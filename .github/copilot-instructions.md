# GitHub Copilot Instructions for sagebox-icon-studio

> Generated by Truely Copilot Extension
> Last updated: 31/12/2025
> Project Type: ðŸ§© VS Code Extension

## Project Description
ExtensiÃ³n para Visual Studio Code que permite gestionar iconos SVG de manera eficiente, incluyendo bÃºsqueda, previsualizaciÃ³n, ediciÃ³n, optimizaciÃ³n y exportaciÃ³n como componentes para frameworks modernos.

## Project Context (Developer Notes)
Sagebox Icon Studio es una extensiÃ³n para Visual Studio Code que centraliza y optimiza el flujo de trabajo con iconos SVG, permitiendo buscar, previsualizar, editar, optimizar y exportar iconos como componentes para frameworks como React, Vue, Svelte y Angular, todo sin salir del editor. Entre sus caracterÃ­sticas clave se incluyen la importaciÃ³n desde Ã¡rboles de archivos, ediciÃ³n avanzada de detalles, optimizaciÃ³n automÃ¡tica y generaciÃ³n de wrappers especÃ­ficos para distintos frameworks. EstÃ¡ diseÃ±ada para desarrolladores y diseÃ±adores que trabajan en sistemas de diseÃ±o o proyectos que requieren una gestiÃ³n eficiente de iconos. La extensiÃ³n opera bajo licencia MIT, es compatible con VS Code 1.85 o superior y prioriza la integraciÃ³n fluida en entornos de desarrollo modernos.

---

**IMPORTANT**: Follow these rules and conventions when generating code for this project.

## ðŸ’» Technology Stack

### Core Technologies
- **Language**: typescript
- **Framework**: vscode-extension
- **Package Manager**: npm

### Technology Rules
- Use TypeScript's type system effectively
- Minimize use of `any` - prefer proper typing
- Use interfaces for object shapes
- Enable strict mode in tsconfig
- Use VS Code Extension API correctly
- Implement proper resource disposal
- Follow extension guidelines
- Use npm as the package manager

## ðŸ—ï¸ Architecture

### Pattern: Layered Architecture

The architecture follows a traditional layered approach.
Each layer depends only on the layer below it.

### Architectural Rules
- Presentation layer handles UI/API
- Business layer contains logic
- Data layer handles persistence
- No layer skipping allowed
- Clear interfaces between layers



### Dependency Rules
- Upper layers depend on lower layers
- No circular dependencies
- Each layer has single responsibility
- Use DTOs for layer communication

## âœ¨ Code Quality

### Clean Code Principles

**SOLID Principles**
- **S**ingle Responsibility: Each class/function has one purpose
- **O**pen/Closed: Open for extension, closed for modification
- **L**iskov Substitution: Subtypes must be substitutable
- **I**nterface Segregation: Many specific interfaces > one general
- **D**ependency Inversion: Depend on abstractions, not concretions

**DRY (Don't Repeat Yourself)**
- Extract repeated code into functions/utilities
- Create reusable components and hooks
- Use constants for repeated values
- Centralize configuration

**KISS (Keep It Simple, Stupid)**
- Prefer simple solutions over clever ones
- Avoid premature optimization
- Write code that's easy to understand
- Refactor complex code

### Naming Conventions

| Element | Convention | Example |
|---------|------------|---------|
| Variables | camelCase | userData |
| Functions | camelCase | getUserById |
| Classes | PascalCase | UserService |
| Constants | SCREAMING_SNAKE_CASE | MAX_RETRIES |
| Files | kebab-case | user-service |
| Folders | kebab-case | user-module |

**Naming Guidelines**
- Use descriptive, meaningful names
- Avoid abbreviations unless well-known
- Name functions with verbs (getUser, calculateTotal)
- Name booleans with is/has/should prefix
- Use domain terminology consistently

### Code Limits

| Metric | Limit | Rationale |
|--------|-------|-----------|
| Function Lines | 40 | Keep functions focused and testable |
| File Lines | 400 | Files should be cohesive |
| Parameters | 4 | Too many suggests refactoring needed |
| Nesting Depth | 3 | Deep nesting hurts readability |

**Limit Guidelines**
- Split large functions into smaller ones
- Extract classes when files grow too large
- Use objects/builders for many parameters
- Use early returns to reduce nesting

## ðŸ§ª Testing

### Testing Framework
- **Unit Tests**: jest

- **Coverage Goal**: 80% (not enforced - configure in jest.config.js to enforce)

### Testing Rules
- Write tests for all business logic
- Follow AAA pattern (Arrange, Act, Assert)
- Mock external dependencies
- Test edge cases and error scenarios
- Name tests descriptively

### Jest Guidelines
- Use `describe` blocks for organization
- Use `beforeEach`/`afterEach` for setup/teardown
- Use `jest.mock()` for module mocking
- Use snapshot testing sparingly
- Prefer `toEqual` over `toMatchObject`

## ðŸ“ File Structure

### Recommended Structure
```
src/
â”œâ”€â”€ extension.ts     # Entry point
â”œâ”€â”€ commands/        # Command handlers
â”œâ”€â”€ providers/       # View providers
â”œâ”€â”€ services/        # Business logic
â”œâ”€â”€ utils/           # Helpers
â””â”€â”€ types/           # Type definitions
```

### File Organization Rules
- Group by feature/domain, not by type
- Keep related files together
- Index files for clean imports
- Consistent naming across project
- README in complex directories

## ðŸ“‹ Development Methodology

### ðŸ”´ðŸŸ¢ðŸ”µ Test-Driven Development (TDD)

TDD is enabled for this project. Follow the Red-Green-Refactor cycle.

**Red-Green-Refactor Cycle**
1. **ðŸ”´ Red**: Write a failing test first
2. **ðŸŸ¢ Green**: Write minimal code to pass
3. **ðŸ”µ Refactor**: Improve without breaking tests

**TDD Rules**
- No production code without a failing test
- Write only enough code to pass the test
- Refactor only when tests pass
- Tests are first-class citizens
- Each test should test one thing

**Test Structure**
- Name tests: `should_ExpectedBehavior_When_Condition`
- Group related tests in describe blocks
- Setup â†’ Execute â†’ Assert â†’ Cleanup
- Mock external dependencies



## Detected Patterns in This Project

> Auto-detected patterns from codebase analysis

### Singleton Pattern
Found 3 singleton instances

## Singleton Pattern
Use singleton pattern for:
- Service instances that should be shared
- Configuration managers
- Database connections

Example:
```typescript
class MyService {
  private static instance: MyService;
  static getInstance(): MyService {
    if (!MyService.instance) {
      MyService.instance = new MyService();
    }
    return MyService.instance;
  }
}
```

### Service Layer
Found 34 service files

## Service Layer
Services contain business logic:
- Orchestrate operations
- Call repositories for data
- Handle transactions
- Naming: `*Service.ts`

### Barrel Exports
Found 11 index files for exports

## Barrel Exports
Use index.ts files to:
- Re-export public APIs from folders
- Simplify imports
- Hide internal implementation

```typescript
// src/services/index.ts
export { UserService } from './UserService';
export { AuthService } from './AuthService';
```

