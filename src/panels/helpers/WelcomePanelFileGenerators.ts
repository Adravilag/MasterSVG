/**
 * WelcomePanelFileGenerators - File generation utilities for WelcomePanel
 *
 * Handles creation of output files (sprite, icons module, types, .msignore).
 */

import * as fs from 'fs';
import * as path from 'path';
import { FrameworkType } from '../../services/types';
import { FrameworkWrapperService } from '../../services/framework';
import {
  MasterSvgConfig,
  OutputStructure,
  FrameworkType as ConfigFrameworkType,
  DEFAULT_CONFIG,
} from '../../config';

/** Options for icons module generation */
export interface IconsModuleOptions {
  outputPath: string;
  webComponentName: string;
  framework: FrameworkType;
  separateStructure?: boolean;
}

/** Options for generating mastersvg.config.json */
export interface ConfigFileOptions {
  sourceDirectories: string[];
  outputDirectory: string;
  outputStructure: OutputStructure;
  outputPaths?: {
    components?: string;
    assets?: string;
    types?: string;
  };
  framework: ConfigFrameworkType;
  typescript?: boolean;
  webComponentName?: string;
  buildFormat: 'icons.js' | 'sprite.svg' | 'css';
  defaultIconSize?: number;
  scanOnStartup?: boolean;
  previewBackground?: 'transparent' | 'light' | 'dark' | 'checkered';
}

/**
 * Generates mastersvg.config.json file in workspace root
 */
export function generateConfigFile(workspacePath: string, options: ConfigFileOptions): void {
  const configPath = path.join(workspacePath, 'mastersvg.config.json');

  // Build output config based on structure type
  const outputConfig: MasterSvgConfig['output'] = options.outputStructure === 'flat'
    ? {
        format: options.buildFormat,
        structure: 'flat',
        directory: options.outputDirectory,
      }
    : {
        format: options.buildFormat,
        structure: 'separated',
        paths: {
          components: options.outputPaths?.components ?? 'src/components/icons',
          assets: options.outputPaths?.assets ?? 'src/assets/icons',
          types: options.outputPaths?.types,
        },
      };

  const config: MasterSvgConfig = {
    $schema: './node_modules/mastersvg/.vscode/mastersvg.schema.json',
    version: '1.0',
    source: {
      directories: options.sourceDirectories,
      ignore: DEFAULT_CONFIG.source.ignore,
    },
    output: outputConfig,
    framework: {
      type: options.framework,
      typescript: options.typescript ?? true,
      component: {
        name: 'Icon',
        webComponentTag: options.webComponentName || 'svg-icon',
      },
    },
    optimization: DEFAULT_CONFIG.optimization,
    icons: {
      ...DEFAULT_CONFIG.icons,
      defaultSize: options.defaultIconSize ?? 24,
    },
    animations: DEFAULT_CONFIG.animations,
    licenses: DEFAULT_CONFIG.licenses,
    editor: {
      ...DEFAULT_CONFIG.editor,
      scanOnStartup: options.scanOnStartup ?? true,
      previewBackground: options.previewBackground ?? 'checkered',
    },
  };

  fs.writeFileSync(configPath, JSON.stringify(config, null, 2), 'utf-8');
}

/**
 * Generates empty sprite.svg file
 */
export function generateEmptySprite(outputPath: string): void {
  const spritePath = path.join(outputPath, 'sprite.svg');
  const content = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Auto-generated by MasterSVG -->
<!-- Add icons using "Add to Icon Collection" or drag SVG files here -->
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display: none;">
  <!-- Icons will be added here as <symbol> elements -->
  <!-- Usage: <svg><use href="sprite.svg#icon-name"></use></svg> -->
</svg>
`;
  fs.writeFileSync(spritePath, content, 'utf-8');
}

/**
 * Generates empty CSS icons file
 */
export function generateEmptyCssIcons(outputPath: string): void {
  const cssPath = path.join(outputPath, 'icons.css');
  const content = `/* Auto-generated by MasterSVG */
/* CSS icon classes will be generated here when you build */
/* Usage: <span class="icon icon-home"></span> */

/* Base icon styles */
.icon {
  --icon-size: 1em;
  display: inline-block;
  width: var(--icon-size);
  height: var(--icon-size);
  vertical-align: middle;
  background-color: currentColor;
  -webkit-mask-size: contain;
  mask-size: contain;
  -webkit-mask-repeat: no-repeat;
  mask-repeat: no-repeat;
  -webkit-mask-position: center;
  mask-position: center;
}

/* Icon classes will be added here as you add icons */
/* Example:
.icon-home {
  -webkit-mask-image: url("data:image/svg+xml,...");
  mask-image: url("data:image/svg+xml,...");
}
*/
`;
  fs.writeFileSync(cssPath, content, 'utf-8');
}

/**
 * Generates empty icons module files (svg-data.ts, index.ts, types.d.ts, wrapper)
 * @param outputPath - Base output directory
 * @param webComponentName - Name for the web component
 * @param framework - Target framework
 * @param separateStructure - If true, generates components/ and assets/ subdirectories
 */
export function generateEmptyIconsModule(
  outputPath: string,
  webComponentName: string,
  framework: FrameworkType,
  separateStructure = false
): void {
  if (separateStructure) {
    generateSeparatedIconsModule({ outputPath, webComponentName, framework, separateStructure });
  } else {
    generateFlatIconsModule(outputPath, webComponentName, framework);
  }
}

/**
 * Generates icons module with flat structure (all files in one directory)
 */
function generateFlatIconsModule(
  outputPath: string,
  webComponentName: string,
  framework: FrameworkType
): void {
  generateEmptySvgDataFile(outputPath);
  generateIndexFile(outputPath, false);

  const wrapperService = FrameworkWrapperService.getInstance();
  wrapperService.generateWrapper(outputPath, framework, webComponentName);

  generateTypesDefinitions(outputPath, webComponentName);
}

/**
 * Generates icons module with separated structure:
 * - outputPath/components/icons/ → Icon.tsx, types.d.ts, index.ts
 * - outputPath/assets/icons/ → svg-data.ts
 */
function generateSeparatedIconsModule(opts: IconsModuleOptions): void {
  const { outputPath, webComponentName, framework } = opts;

  const componentsPath = path.join(outputPath, 'components', 'icons');
  const assetsPath = path.join(outputPath, 'assets', 'icons');

  // Ensure directories exist
  fs.mkdirSync(componentsPath, { recursive: true });
  fs.mkdirSync(assetsPath, { recursive: true });

  // Generate svg-data.ts in assets/icons/
  generateEmptySvgDataFile(assetsPath, true);

  // Generate wrapper component in components/icons/
  const wrapperService = FrameworkWrapperService.getInstance();
  wrapperService.generateWrapper(componentsPath, framework, webComponentName);

  // Generate types in components/icons/
  generateTypesDefinitions(componentsPath, webComponentName);

  // Generate unified index.ts in components/icons/
  generateSeparatedIndexFile(componentsPath, framework);
}

/**
 * Generates empty svg-data.ts file
 */
function generateEmptySvgDataFile(outputPath: string, useTypeScript = false): void {
  const ext = useTypeScript ? 'ts' : 'js';
  const dataPath = path.join(outputPath, `svg-data.${ext}`);
  const typeAnnotation = useTypeScript ? ': Record<string, IconData>' : '';
  const importStatement = useTypeScript
    ? "import type { IconData } from '../../components/icons/types';\n\n"
    : '';

  const content = `${importStatement}// Auto-generated by MasterSVG
// Add icons using "Add to Icon Collection" or drag SVG files here

// Icon exports will be added here
// Example: export const arrowRight = { name: 'arrow-right', body: '...', viewBox: '0 0 24 24' };

// Collection of all icons
export const icons${typeAnnotation} = {
  // Icons will be added here
};
`;
  fs.writeFileSync(dataPath, content, 'utf-8');
}

/**
 * Generates index.js entry point file (flat structure)
 */
function generateIndexFile(outputPath: string, useTypeScript = false): void {
  const ext = useTypeScript ? 'ts' : 'js';
  const indexPath = path.join(outputPath, `index.${ext}`);
  const content = `// Auto-generated by MasterSVG
// Main entry point for the icon library

// Re-export all icons and the icons collection
export * from './svg-data.${ext}';

// Re-export the SvgIcon component (framework-specific)
// Uncomment the appropriate line for your framework:
// export { default as SvgIcon } from './SvgIcon.tsx';  // React
// export { default as SvgIcon } from './SvgIcon.vue';  // Vue
// export { default as SvgIcon } from './SvgIcon.svelte';  // Svelte
`;
  fs.writeFileSync(indexPath, content, 'utf-8');
}

/**
 * Generates index.ts for separated structure (components/icons/)
 */
function generateSeparatedIndexFile(componentsPath: string, framework: FrameworkType): void {
  const indexPath = path.join(componentsPath, 'index.ts');
  const wrapperName = getWrapperFileName(framework);

  const content = `// Auto-generated by MasterSVG
// Main entry point for the icon library

// Export the Icon component
export { default as Icon } from './${wrapperName}';

// Export types
export type { IconData, IconName, IconElement } from './types';

// Re-export icons data from assets
export { icons } from '../../assets/icons/svg-data';
`;
  fs.writeFileSync(indexPath, content, 'utf-8');
}

/**
 * Gets the wrapper file name based on framework
 */
function getWrapperFileName(framework: FrameworkType): string {
  switch (framework) {
    case 'react':
    case 'solid':
    case 'qwik':
      return 'Icon.tsx';
    case 'vue':
      return 'Icon.vue';
    case 'svelte':
      return 'Icon.svelte';
    case 'angular':
      return 'icon.component.ts';
    case 'astro':
      return 'Icon.astro';
    case 'lit':
      return 'Icon.ts';
    default:
      return 'Icon.js';
  }
}

/**
 * Generates types.d.ts TypeScript definitions
 */
function generateTypesDefinitions(outputPath: string, webComponentName: string): void {
  const typesPath = path.join(outputPath, 'types.d.ts');
  const typesContent = `// Auto-generated TypeScript definitions by MasterSVG
// This file provides type safety for your icon library

export interface IconData {
  name: string;
  body: string;
  viewBox: string;
  animation?: {
    type: string;
    duration: number;
    timing: string;
    iteration: string;
    delay?: number;
    direction?: string;
  };
}

// Icon names will be added here as you add icons
export type IconName = string;

// Collection of all icons
export declare const icons: Record<IconName, IconData>;

// Web Component
export declare class IconElement extends HTMLElement {
  name: string;
  size: string;
  color: string;
  animation: string;
}

declare global {
  interface HTMLElementTagNameMap {
    '${webComponentName}': IconElement;
  }
}
`;
  fs.writeFileSync(typesPath, typesContent, 'utf-8');
}

/**
 * Creates .msignore file in workspace root
 */
export function createMsignoreFile(workspacePath: string): void {
  const msignorePath = path.join(workspacePath, '.msignore');

  // Don't overwrite if it already exists
  if (fs.existsSync(msignorePath)) {
    return;
  }

  const template = `# MasterSVG - Ignore File
# This file works similar to .gitignore
# Patterns listed here will be excluded from SVG scanning

# ============================================
# Common directories to ignore
# ============================================

# Dependencies
node_modules/
bower_components/
vendor/

# Build outputs
dist/
build/
out/
.next/
.nuxt/
.output/

# IDE and editor files
.idea/
.vscode/
*.code-workspace

# Version control
.git/
.svn/

# Temporary files
tmp/
temp/
*.tmp
*.bak

# Cache directories
.cache/
.parcel-cache/
.turbo/

# Coverage and test outputs
coverage/
.nyc_output/

# ============================================
# Custom patterns (add your own below)
# ============================================

# Example: Ignore backup SVGs
# **/backup/**
# **/*-old.svg
# **/*-backup.svg
`;
  fs.writeFileSync(msignorePath, template, 'utf-8');
}

/**
 * Ensures output directory exists
 */
export function ensureOutputDirectory(fullPath: string): void {
  if (!fs.existsSync(fullPath)) {
    fs.mkdirSync(fullPath, { recursive: true });
  }
}

/**
 * Ensures .vscode directory exists for workspace settings
 */
export function ensureVscodeDirectory(workspacePath: string): void {
  const vscodeDir = path.join(workspacePath, '.vscode');
  if (!fs.existsSync(vscodeDir)) {
    fs.mkdirSync(vscodeDir, { recursive: true });
  }
}

/**
 * Returns a list of expected output files for the selected build format.
 * The list is intentionally high-level (main files and patterns) to keep the preview concise.
 */
export function getExpectedOutputFiles(
  buildFormat: 'icons.js' | 'sprite.svg' | 'css' | string,
  outputDirectory: string,
  webComponentName?: string,
  framework?: FrameworkType,
  separateStructure = false
): string[] {
  const files: string[] = [];
  const base = outputDirectory || 'public/icons';

  if (buildFormat === 'sprite.svg') {
    files.push(path.posix.join(base, 'sprite.svg'));
    files.push(path.posix.join(base, 'icons.css'));
  } else if (buildFormat === 'css') {
    files.push(path.posix.join(base, 'icons.css'));
    files.push(path.posix.join(base, '*.svg'));
  } else {
    // icons.js / module output
    if (separateStructure) {
      files.push(path.posix.join(base, 'components', 'icons', getWrapperFileName(framework || '')));
      files.push(path.posix.join(base, 'components', 'icons', 'types.d.ts'));
      files.push(path.posix.join(base, 'assets', 'icons', 'svg-data.js'));
      files.push(path.posix.join(base, 'components', 'icons', 'index.ts'));
    } else {
      files.push(path.posix.join(base, 'svg-data.js'));
      files.push(path.posix.join(base, 'index.js'));
      files.push(path.posix.join(base, 'types.d.ts'));
    }
    // web component runtime
    files.push(path.posix.join(base, 'svg-element.js'));
  }

  return files;
}
