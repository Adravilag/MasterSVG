import * as path from 'node:path';
import * as fs from 'node:fs';
import { SvgTransformer } from '../services/SvgTransformer';
import { toVariableName } from './extensionHelpers';
import { getConfig } from './configHelper';
import { ErrorHandler } from './errorHandler';
import { validateSvgContent } from './svgValidation';

/**
 * Animation settings interface
 */
export interface AnimationConfig {
  type: string;
  duration: number;
  timing: string;
  iteration: string;
  delay?: number;
  direction?: string;
}

/**
 * Create an icon entry string with optional animation
 */
function createIconEntry(varName: string, iconName: string, body: string, viewBox: string, animation?: AnimationConfig): string {
  if (animation) {
    const delay = animation.delay || 0;
    const direction = animation.direction || 'normal';
    return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}',
  animation: { type: '${animation.type}', duration: ${animation.duration}, timing: '${animation.timing}', iteration: '${animation.iteration}', delay: ${delay}, direction: '${direction}' }
};`;
  }
  return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}'
};`;
}

/**
 * Update existing icon content
 */
function updateExistingIcon(content: string, varName: string, iconEntry: string): string {
  const regex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};`, 'g');
  return content.replace(regex, iconEntry);
}

/**
 * Add new icon to existing content
 */
function addNewIconToContent(content: string, varName: string, iconEntry: string): string {
  const iconsObjMatch = /export const icons = \{/.exec(content);
  if (iconsObjMatch?.index === undefined) {
    return content + '\n\n' + iconEntry;
  }

  let updatedContent = content.slice(0, iconsObjMatch.index) + iconEntry + '\n\n' + content.slice(iconsObjMatch.index);
  const objContent = /export const icons = \{([^}]*)\}/.exec(updatedContent);
  if (objContent) {
    const existingIcons = objContent[1].trim();
    const newIcons = existingIcons ? `${existingIcons},\n  ${varName}` : `\n  ${varName}\n`;
    updatedContent = updatedContent.replace(/export const icons = \{([^}]*)\}/, `export const icons = {${newIcons}}`);
  }
  return updatedContent;
}

/**
 * Create new icons file content
 */
function createNewIconsFileContent(iconEntry: string, varName: string): string {
  return `// Auto-generated by Icon Manager
// Do not edit manually

${iconEntry}

export const icons = {
  ${varName}
};
`;
}

/**
 * Add an icon to the icons.js library file
 */
export async function addToIconsJs(
  outputPath: string,
  iconName: string,
  svgContent: string,
  transformer: SvgTransformer,
  animation?: AnimationConfig,
  skipWebComponentGeneration: boolean = false
): Promise<void> {
  return ErrorHandler.wrapAsync(async () => {
    // Validate SVG content before adding
    const validation = validateSvgContent(svgContent);
    if (!validation.valid) {
      throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
    }

    const iconsPath = path.join(outputPath, 'icons.js');
    const varName = toVariableName(iconName);
    const body = transformer.extractSvgBody(svgContent);
    const attrs = transformer.extractSvgAttributes(svgContent);
    const iconEntry = createIconEntry(varName, iconName, body, attrs.viewBox || '0 0 24 24', animation);

    if (!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath, { recursive: true });
    }

    if (fs.existsSync(iconsPath)) {
      let content = fs.readFileSync(iconsPath, 'utf-8');
      content = content.includes(`export const ${varName}`)
        ? updateExistingIcon(content, varName, iconEntry)
        : addNewIconToContent(content, varName, iconEntry);
      fs.writeFileSync(iconsPath, content);
    } else {
      fs.writeFileSync(iconsPath, createNewIconsFileContent(iconEntry, varName));
    }

    if (!skipWebComponentGeneration) {
      await generateWebComponent(outputPath);
    }
  }, `adding icon ${iconName} to icons.js`);
}

/**
 * Update animation for an existing icon in icons.js
 */
export async function updateIconAnimation(
  outputPath: string,
  iconName: string,
  animation: AnimationConfig | null
): Promise<boolean> {
  const iconsPath = path.join(outputPath, 'icons.js');
  if (!fs.existsSync(iconsPath)) return false;

  const varName = toVariableName(iconName);
  let content = fs.readFileSync(iconsPath, 'utf-8');
  
  // Pattern to match the complete icon entry (with or without animation)
  const iconPattern = new RegExp(
    String.raw`export const ${varName} = \{[\s\S]*?\};`,
    'g'
  );
  
  const match = iconPattern.exec(content);
  if (!match) return false;
  
  const iconBlock = match[0];
  
  // Extract name, body, and viewBox from the matched block
  const nameMatch = /name:\s*['"]([^'"]+)['"]/.exec(iconBlock);
  const bodyMatch = /body:\s*`([^`]*)`/.exec(iconBlock);
  const viewBoxMatch = /viewBox:\s*['"]([^'"]+)['"]/.exec(iconBlock);
  
  if (!nameMatch || !bodyMatch || !viewBoxMatch) return false;
  
  const name = nameMatch[1];
  const body = bodyMatch[1];
  const viewBox = viewBoxMatch[1];
  
  // Create new entry with or without animation
  const newEntry = createIconEntry(varName, name, body, viewBox, animation || undefined);
  
  // Replace the old entry
  content = content.replace(iconBlock, newEntry);
  
  fs.writeFileSync(iconsPath, content);
  await generateWebComponent(outputPath);
  
  return true;
}

/**
 * Generate the web component for icons with full support for:
 * - Variants (color themes)
 * - Animations (spin, pulse, bounce, shake, fade)
 * - Dynamic imports for optional features
 * 
 * Returns the path and content so caller can write using VS Code API
 */
export async function generateWebComponent(outputPath: string): Promise<{ path: string; content: string }> {
  const config = getConfig();
  const tagName = config.webComponentName;

  const componentPath = path.join(outputPath, 'icon.js');

  const content = `// Auto-generated Web Component by Icon Manager
// Usage: <${tagName} name="icon-name"></${tagName}>
// With variant: <${tagName} name="icon-name" variant="dark-theme"></${tagName}>
// With animation: <${tagName} name="icon-name" animation="spin"></${tagName}>
// With light/dark colors: <${tagName} name="icon-name" light-color="#333" dark-color="#fff"></${tagName}>
// Import this file in your HTML: <script type="module" src="./path/to/icon.js"></script>

import { icons } from './icons.js';

// Optional imports - these files may not exist
let Variants = {};
let defaultVariants = {};

try {
  const VariantsModule = await import('./variants.js');
  Variants = VariantsModule.Variants || {};
  defaultVariants = VariantsModule.defaultVariants || {};
} catch (e) {
  // variants.js not found, continue without Variants
}

// Animation CSS styles using individual transform properties (2024+)
// Benefits: Better performance, easier to combine multiple animations
const animationStyles = \`
  /* Entry animation with @starting-style (2024) */
  @starting-style {
    ${tagName} svg {
      opacity: 0;
      scale: 0.8;
    }
  }
  
  ${tagName} svg {
    transition: opacity 0.3s ease, scale 0.3s ease;
  }

  /* Animations using individual transform properties */
  @keyframes icon-spin { 
    from { rotate: 0deg; } 
    to { rotate: 360deg; } 
  }
  @keyframes icon-spin-reverse { 
    from { rotate: 360deg; } 
    to { rotate: 0deg; } 
  }
  @keyframes icon-pulse { 
    0%, 100% { scale: 1; opacity: 1; } 
    50% { scale: 1.1; opacity: 0.8; } 
  }
  @keyframes icon-pulse-grow { 
    0%, 100% { scale: 1; } 
    50% { scale: 1.3; } 
  }
  @keyframes icon-bounce { 
    0%, 100% { translate: 0 0; } 
    50% { translate: 0 -4px; } 
  }
  @keyframes icon-bounce-in {
    0% { scale: 0; opacity: 0; }
    50% { scale: 1.2; }
    100% { scale: 1; opacity: 1; }
  }
  @keyframes icon-shake { 
    0%, 100% { translate: 0 0; } 
    25% { translate: -2px 0; } 
    75% { translate: 2px 0; } 
  }
  @keyframes icon-fade { 
    0%, 100% { opacity: 1; } 
    50% { opacity: 0.3; } 
  }
  @keyframes icon-float {
    0%, 100% { translate: 0 0; }
    50% { translate: 0 -6px; }
  }
  @keyframes icon-wiggle {
    0%, 100% { rotate: 0deg; }
    25% { rotate: -10deg; }
    75% { rotate: 10deg; }
  }
  @keyframes icon-heartbeat {
    0%, 100% { scale: 1; }
    14% { scale: 1.3; }
    28% { scale: 1; }
    42% { scale: 1.3; }
    70% { scale: 1; }
  }
  
  /* Combined animations - using individual properties allows this! */
  .icon-combo-spin-pulse svg {
    animation: icon-spin 2s linear infinite, icon-pulse 1s ease infinite;
  }
  .icon-combo-bounce-fade svg {
    animation: icon-bounce 0.5s ease infinite, icon-fade 2s ease infinite;
  }
\`;

// Inject animation styles once
if (!document.getElementById('icon-animation-styles')) {
  const styleEl = document.createElement('style');
  styleEl.id = 'icon-animation-styles';
  styleEl.textContent = animationStyles;
  document.head.appendChild(styleEl);
}

class IconElement extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'size', 'color', 'variant', 'animation', 'light-color', 'dark-color'];
  }

  connectedCallback() {
    this.render();
    // Listen for color scheme changes
    this._mediaQuery = window.matchMedia('(prefers-color-scheme: dark)');
    this._mediaQuery.addEventListener('change', () => this.render());
  }
  
  disconnectedCallback() {
    if (this._mediaQuery) {
      this._mediaQuery.removeEventListener('change', () => this.render());
    }
  }

  attributeChangedCallback() {
    this.render();
  }

  // Helper: calculate contrasting color for light/dark auto-detection
  getContrastColor(hex) {
    if (!hex || hex === 'currentColor') return null;
    // Normalize hex
    let h = hex.replace('#', '');
    if (h.length === 3) h = h.split('').map(c => c + c).join('');
    if (h.length !== 6) return null;
    
    const r = parseInt(h.substr(0, 2), 16);
    const g = parseInt(h.substr(2, 2), 16);
    const b = parseInt(h.substr(4, 2), 16);
    
    // Calculate relative luminance
    const luminance = (0.299 * r + 0.587 * g + 0.114 * b) / 255;
    const isLight = luminance > 0.5;
    
    // Invert: light colors get dark contrast, dark colors get light contrast
    const factor = isLight ? 0.2 : 0.8;
    const nr = Math.round(r + (255 - r) * (isLight ? -0.7 : 0.7));
    const ng = Math.round(g + (255 - g) * (isLight ? -0.7 : 0.7));
    const nb = Math.round(b + (255 - b) * (isLight ? -0.7 : 0.7));
    
    const clamp = v => Math.max(0, Math.min(255, v));
    return \`#\${[nr, ng, nb].map(v => clamp(v).toString(16).padStart(2, '0')).join('')}\`;
  }
  
  // Helper: get luminance of a color (0-1)
  getColorLuminance(hex) {
    if (!hex || hex === 'currentColor') return 0.5;
    let h = hex.replace('#', '');
    if (h.length === 3) h = h.split('').map(c => c + c).join('');
    if (h.length !== 6) return 0.5;
    const r = parseInt(h.substr(0, 2), 16);
    const g = parseInt(h.substr(2, 2), 16);
    const b = parseInt(h.substr(4, 2), 16);
    return (0.299 * r + 0.587 * g + 0.114 * b) / 255;
  }

  render() {
    const name = this.getAttribute('name');
    if (!name) return;

    // Convert kebab-case to camelCase for lookup (handles letters and numbers after hyphens)
    const camelName = name.replace(/-([a-z0-9])/gi, (_, c) => c.toUpperCase());
    const icon = icons[camelName];

    if (!icon) {
      console.warn(\`[Icon] Icon "\${name}" not found in icons.js\`);
      this.innerHTML = '';
      return;
    }

    const size = this.getAttribute('size') || '1em';
    
    // Light/Dark color support (CSS light-dark() function - 2024)
    let lightColor = this.getAttribute('light-color');
    let darkColor = this.getAttribute('dark-color');
    let color = this.getAttribute('color') || 'currentColor';
    
    // Auto-generate contrasting color if only one is specified
    if (lightColor && !darkColor) {
      darkColor = this.getContrastColor(lightColor) || lightColor;
    } else if (darkColor && !lightColor) {
      lightColor = this.getContrastColor(darkColor) || darkColor;
    } else if (color !== 'currentColor' && !lightColor && !darkColor) {
      // If just "color" is set, auto-generate light/dark variants
      const contrast = this.getContrastColor(color);
      if (contrast) {
        const luminance = this.getColorLuminance(color);
        lightColor = luminance > 0.5 ? contrast : color;
        darkColor = luminance > 0.5 ? color : contrast;
      }
    }
    
    // If light/dark colors available, use light-dark() CSS function
    if (lightColor && darkColor) {
      color = \`light-dark(\${lightColor}, \${darkColor})\`;
    }
    
    // Use specified variant, or fall back to default Variant for this icon
    const variantName = this.getAttribute('variant') || defaultVariants[icon.name] || null;
    // Use specified animation, or fall back to icon's default animation (stored in icons.js)
    const animName = this.getAttribute('animation') || (icon.animation?.type) || null;
    const animConfig = icon.animation || { duration: 1, timing: 'ease', iteration: 'infinite' };
    
    // Get body with variant colors applied if variant is specified
    let body = icon.body;
    const iconVariants = Variants[icon.name] || {};
    if (variantName && iconVariants[variantName]) {
      const variantColors = iconVariants[variantName];
      // Extract current colors from body and replace with variant colors
      const colorPattern = /(fill|stroke)=["']([^"']+)["']/gi;
      const matches = [...body.matchAll(colorPattern)];
      const uniqueColors = [...new Set(matches.map(m => m[2]).filter(c => c !== 'none' && c !== 'currentColor'))];
      
      for (let i = 0; i < Math.min(uniqueColors.length, variantColors.length); i++) {
        const regex = new RegExp(uniqueColors[i].replace(/[.*+?^\${}()|[\\]\\\\]/g, '\\\\$&'), 'gi');
        body = body.replace(regex, variantColors[i]);
      }
    }

    // Build animation style using individual transform properties
    let animStyle = '';
    if (animName && animName !== 'none') {
      const duration = animConfig.duration || 1;
      const timing = animConfig.timing || 'ease';
      const iteration = animConfig.iteration || 'infinite';
      animStyle = \`animation: icon-\${animName} \${duration}s \${timing} \${iteration};\`;
    }

    this.innerHTML = \`
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        viewBox="\${icon.viewBox}"
        width="\${size}"
        height="\${size}"
        fill="\${color}"
        style="display: inline-block; vertical-align: middle; color-scheme: light dark; \${animStyle}"
      >
        \${body}
      </svg>
    \`;
  }
}

// Register the custom element
if (!customElements.get('${tagName}')) {
  customElements.define('${tagName}', IconElement);
}

export { IconElement };
`;

  return { path: componentPath, content };
}

/**
 * Add an icon to the sprite.svg file
 */
export async function addToSpriteSvg(
  outputPath: string,
  iconName: string,
  svgContent: string,
  transformer: SvgTransformer
): Promise<void> {
  // Validate SVG content before adding
  const validation = validateSvgContent(svgContent);
  if (!validation.valid) {
    throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
  }

  const spritePath = path.join(outputPath, 'sprite.svg');
  const body = transformer.extractSvgBody(svgContent);
  const attrs = transformer.extractSvgAttributes(svgContent);

  const symbolEntry = `  <symbol id="${iconName}" viewBox="${attrs.viewBox || '0 0 24 24'}">
    ${body}
  </symbol>`;

  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath, { recursive: true });
  }

  if (fs.existsSync(spritePath)) {
    let content = fs.readFileSync(spritePath, 'utf-8');
    const existingSymbol = new RegExp(String.raw`<symbol[^>]*id=["']${iconName}["'][\s\S]*?<\/symbol>`, 'g');
    if (existingSymbol.test(content)) {
      content = content.replace(existingSymbol, symbolEntry);
    } else {
      content = content.replace('</svg>', `${symbolEntry}\n</svg>`);
    }
    fs.writeFileSync(spritePath, content);
  } else {
    const content = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
${symbolEntry}
</svg>
`;
    fs.writeFileSync(spritePath, content);
  }
}

/**
 * Remove icons from the icons.js library
 */
export function removeFromIconsJs(outputPath: string, iconNames: string[]): boolean {
  const iconsPath = path.join(outputPath, 'icons.js');
  
  if (!fs.existsSync(iconsPath)) {
    return false;
  }

  let content = fs.readFileSync(iconsPath, 'utf-8');

  for (const name of iconNames) {
    const varName = toVariableName(name);
    const exportRegex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};\s*`, 'g');
    content = content.replace(exportRegex, '');
    
    // Also remove from icons object
    const iconsObjRegex = new RegExp(String.raw`,?\s*${varName}\s*,?`, 'g');
    content = content.replace(iconsObjRegex, (match: string) => {
      // Keep one comma if there are icons before and after
      return match.startsWith(',') && match.endsWith(',') ? ',' : '';
    });
  }

  // Clean up double commas and trailing commas in icons object
  content = content.replace(/,\s*,/g, ',');
  content = content.replace(/\{\s*,/g, '{');
  content = content.replace(/,\s*\}/g, '\n}');

  fs.writeFileSync(iconsPath, content);
  return true;
}

/**
 * Get list of icon names from icons.js
 */
export function getIconNamesFromFile(outputPath: string): string[] {
  const iconsPath = path.join(outputPath, 'icons.js');
  
  if (!fs.existsSync(iconsPath)) {
    return [];
  }

  const content = fs.readFileSync(iconsPath, 'utf-8');
  const names: string[] = [];
  
  const regex = /export const (\w+) = \{[\s\S]*?name:\s*['"]([^'"]+)['"]/g;
  let match;
  
  while ((match = regex.exec(content)) !== null) {
    names.push(match[2]); // The actual icon name
  }
  
  return names;
}
/**
 * Clean sprite.svg by removing symbols with invalid content (like HTML)
 * Returns the number of removed symbols
 */
export function cleanSpriteSvg(outputPath: string): { removed: string[]; kept: number } {
  const spritePath = path.join(outputPath, 'sprite.svg');
  const removed: string[] = [];
  let kept = 0;
  
  if (!fs.existsSync(spritePath)) {
    return { removed, kept };
  }

  let content = fs.readFileSync(spritePath, 'utf-8');
  
  // Find all symbols and check their content
  const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
  const validSymbols: string[] = [];
  let match;

  while ((match = symbolRegex.exec(content)) !== null) {
    const symbolId = match[1];
    const symbolContent = match[2];
    const fullSymbol = match[0];
    
    // Check if content contains HTML indicators
    const hasHtml = /<!DOCTYPE|<html|<head|<body|<meta|<style[^>]*>[\s\S]*?<\/style>[\s\S]*<style/i.test(symbolContent);
    
    if (hasHtml) {
      removed.push(symbolId);
    } else {
      validSymbols.push(fullSymbol);
      kept++;
    }
  }

  if (removed.length > 0) {
    // Rebuild sprite with only valid symbols
    const newContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
  <!--
    SVG Sprite Sheet
    Generated by Icon Manager VS Code Extension
    Total icons: ${kept}
  -->
${validSymbols.join('\n\n')}
</svg>`;
    
    fs.writeFileSync(spritePath, newContent);
  }

  return { removed, kept };
}