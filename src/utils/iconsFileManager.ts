import * as path from 'node:path';
import * as fs from 'node:fs';
import { SvgTransformer } from '../services/SvgTransformer';
import { toVariableName, loadTemplate } from './extensionHelpers';
import { getConfig } from './configHelper';
import { ErrorHandler } from './errorHandler';
import { validateSvgContent } from './svgValidation';
import { extractIconsObjectContent } from './outputFileManager';

/**
 * Animation settings interface
 */
export interface AnimationConfig {
  type: string;
  duration: number;
  timing: string;
  iteration: string;
  delay?: number;
  direction?: string;
}

/**
 * Options for creating an icon entry
 */
export interface IconEntryOptions {
  varName: string;
  iconName: string;
  body: string;
  viewBox: string;
  animation?: AnimationConfig;
}

/**
 * Options for adding an icon to icons.js
 */
export interface AddToIconsJsOptions {
  outputPath: string;
  iconName: string;
  svgContent: string;
  transformer: SvgTransformer;
  animation?: AnimationConfig;
  skipWebComponentGeneration?: boolean;
}

/**
 * Create an icon entry string with optional animation
 */
function createIconEntry(options: IconEntryOptions): string {
  const { varName, iconName, body, viewBox, animation } = options;
  if (animation) {
    const delay = animation.delay || 0;
    const direction = animation.direction || 'normal';
    return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}',
  animation: { type: '${animation.type}', duration: ${animation.duration}, timing: '${animation.timing}', iteration: '${animation.iteration}', delay: ${delay}, direction: '${direction}' }
};`;
  }
  return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}'
};`;
}

/**
 * Update existing icon content
 */
function updateExistingIcon(content: string, varName: string, iconEntry: string): string {
  const regex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};`, 'g');
  return content.replace(regex, iconEntry);
}

/**
 * Add new icon to existing content
 */
function addNewIconToContent(content: string, varName: string, iconEntry: string): string {
  const iconsObjMatch = /export const icons = \{/.exec(content);
  if (iconsObjMatch?.index === undefined) {
    return content + '\n\n' + iconEntry;
  }

  let updatedContent =
    content.slice(0, iconsObjMatch.index) + iconEntry + '\n\n' + content.slice(iconsObjMatch.index);

  // Use proper brace matching to find icons object content
  const objData = extractIconsObjectContent(updatedContent);
  if (objData) {
    const existingIcons = objData.inner.trim();
    const newInner = existingIcons ? `${existingIcons},\n  ${varName}` : `\n  ${varName}\n`;
    updatedContent =
      updatedContent.substring(0, objData.startIndex) +
      newInner +
      updatedContent.substring(objData.endIndex);
  }
  return updatedContent;
}

/**
 * Create new icons file content
 */
function createNewIconsFileContent(iconEntry: string, varName: string): string {
  return `// Auto-generated by MasterSVG
// Do not edit manually

${iconEntry}

export const icons = {
  ${varName}
};
`;
}

/**
 * Add an icon to the icons.js library file
 */
export async function addToIconsJs(options: AddToIconsJsOptions): Promise<void> {
  const {
    outputPath,
    iconName,
    svgContent,
    transformer,
    animation,
    skipWebComponentGeneration = false,
  } = options;

  return ErrorHandler.wrapAsync(async () => {
    console.log('[addToIconsJs] iconName:', iconName);
    console.log('[addToIconsJs] svgContent length:', svgContent.length);

    // Validate SVG content before adding
    const validation = validateSvgContent(svgContent);
    if (!validation.valid) {
      throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
    }

    const iconsPath = path.join(outputPath, 'icons.js');
    const varName = toVariableName(iconName);
    const body = transformer.extractSvgBody(svgContent);
    const attrs = transformer.extractSvgAttributes(svgContent);

    console.log('[addToIconsJs] varName:', varName);
    console.log('[addToIconsJs] body length:', body.length);
    console.log('[addToIconsJs] viewBox:', attrs.viewBox);

    const iconEntry = createIconEntry({
      varName,
      iconName,
      body,
      viewBox: attrs.viewBox || '0 0 24 24',
      animation,
    });

    if (!fs.existsSync(outputPath)) {
      fs.mkdirSync(outputPath, { recursive: true });
    }

    if (fs.existsSync(iconsPath)) {
      let content = fs.readFileSync(iconsPath, 'utf-8');
      const exists = content.includes(`export const ${varName}`);
      console.log('[addToIconsJs] Icon exists in file:', exists);

      content = exists
        ? updateExistingIcon(content, varName, iconEntry)
        : addNewIconToContent(content, varName, iconEntry);
      fs.writeFileSync(iconsPath, content);
      console.log('[addToIconsJs] File written to:', iconsPath);
    } else {
      fs.writeFileSync(iconsPath, createNewIconsFileContent(iconEntry, varName));
      console.log('[addToIconsJs] New file created at:', iconsPath);
    }

    if (!skipWebComponentGeneration) {
      await generateWebComponent(outputPath);
    }
  }, `adding icon ${iconName} to icons.js`);
}

/**
 * Update animation for an existing icon in icons.js
 */
export async function updateIconAnimation(
  outputPath: string,
  iconName: string,
  animation: AnimationConfig | null
): Promise<boolean> {
  const iconsPath = path.join(outputPath, 'icons.js');
  if (!fs.existsSync(iconsPath)) return false;

  const varName = toVariableName(iconName);
  let content = fs.readFileSync(iconsPath, 'utf-8');

  // Pattern to match the complete icon entry (with or without animation)
  const iconPattern = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};`, 'g');

  const match = iconPattern.exec(content);
  if (!match) return false;

  const iconBlock = match[0];

  // Extract name, body, and viewBox from the matched block
  const nameMatch = /name:\s*['"]([^'"]+)['"]/.exec(iconBlock);
  const bodyMatch = /body:\s*`([^`]*)`/.exec(iconBlock);
  const viewBoxMatch = /viewBox:\s*['"]([^'"]+)['"]/.exec(iconBlock);

  if (!nameMatch || !bodyMatch || !viewBoxMatch) return false;

  const name = nameMatch[1];
  const body = bodyMatch[1];
  const viewBox = viewBoxMatch[1];

  // Create new entry with or without animation
  const newEntry = createIconEntry({
    varName,
    iconName: name,
    body,
    viewBox,
    animation: animation || undefined,
  });

  // Replace the old entry
  content = content.replace(iconBlock, newEntry);

  fs.writeFileSync(iconsPath, content);
  await generateWebComponent(outputPath);

  return true;
}

/**
 * Generate the web component for icons with full support for:
 * - Variants (color themes)
 * - Animations (spin, pulse, bounce, shake, fade)
 * - Dynamic imports for optional features
 *
 * Returns the path and content so caller can write using VS Code API
 */
export async function generateWebComponent(
  outputPath: string
): Promise<{ path: string; content: string }> {
  const config = getConfig();
  const tagName = config.webComponentName;
  const componentPath = path.join(outputPath, 'icon.js');

  // Load template and replace placeholders
  const template = loadTemplate('IconWebComponent.js');
  const content = template.replace(/\$\{TAG_NAME\}/g, tagName);

  return { path: componentPath, content };
}

/**
 * Add an icon to the sprite.svg file
 */
export async function addToSpriteSvg(
  outputPath: string,
  iconName: string,
  svgContent: string,
  transformer: SvgTransformer
): Promise<void> {
  // Validate SVG content before adding
  const validation = validateSvgContent(svgContent);
  if (!validation.valid) {
    throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
  }

  const spritePath = path.join(outputPath, 'sprite.svg');
  const body = transformer.extractSvgBody(svgContent);
  const attrs = transformer.extractSvgAttributes(svgContent);

  const symbolEntry = `  <symbol id="${iconName}" viewBox="${attrs.viewBox || '0 0 24 24'}">
    ${body}
  </symbol>`;

  if (!fs.existsSync(outputPath)) {
    fs.mkdirSync(outputPath, { recursive: true });
  }

  if (fs.existsSync(spritePath)) {
    let content = fs.readFileSync(spritePath, 'utf-8');
    const existingSymbol = new RegExp(
      String.raw`<symbol[^>]*id=["']${iconName}["'][\s\S]*?<\/symbol>`,
      'g'
    );
    if (existingSymbol.test(content)) {
      content = content.replace(existingSymbol, symbolEntry);
    } else {
      content = content.replace('</svg>', `${symbolEntry}\n</svg>`);
    }
    fs.writeFileSync(spritePath, content);
  } else {
    const content = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
${symbolEntry}
</svg>
`;
    fs.writeFileSync(spritePath, content);
  }
}

/**
 * Remove icons from the icons.js library
 */
export function removeFromIconsJs(outputPath: string, iconNames: string[]): boolean {
  const iconsPath = path.join(outputPath, 'icons.js');

  if (!fs.existsSync(iconsPath)) {
    return false;
  }

  let content = fs.readFileSync(iconsPath, 'utf-8');

  for (const name of iconNames) {
    const varName = toVariableName(name);
    const exportRegex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};\s*`, 'g');
    content = content.replace(exportRegex, '');

    // Also remove from icons object
    const iconsObjRegex = new RegExp(String.raw`,?\s*${varName}\s*,?`, 'g');
    content = content.replace(iconsObjRegex, (match: string) => {
      // Keep one comma if there are icons before and after
      return match.startsWith(',') && match.endsWith(',') ? ',' : '';
    });
  }

  // Clean up double commas and trailing commas in icons object
  content = content.replace(/,\s*,/g, ',');
  content = content.replace(/\{\s*,/g, '{');
  content = content.replace(/,\s*\}/g, '\n}');

  fs.writeFileSync(iconsPath, content);
  return true;
}

/**
 * Get list of icon names from icons.js
 */
export function getIconNamesFromFile(outputPath: string): string[] {
  const iconsPath = path.join(outputPath, 'icons.js');

  if (!fs.existsSync(iconsPath)) {
    return [];
  }

  const content = fs.readFileSync(iconsPath, 'utf-8');
  const names: string[] = [];

  const regex = /export const (\w+) = \{[\s\S]*?name:\s*['"]([^'"]+)['"]/g;
  let match;

  while ((match = regex.exec(content)) !== null) {
    names.push(match[2]); // The actual icon name
  }

  return names;
}
/**
 * Clean sprite.svg by removing symbols with invalid content (like HTML)
 * Returns the number of removed symbols
 */
export function cleanSpriteSvg(outputPath: string): { removed: string[]; kept: number } {
  const spritePath = path.join(outputPath, 'sprite.svg');
  const removed: string[] = [];
  let kept = 0;

  if (!fs.existsSync(spritePath)) {
    return { removed, kept };
  }

  const content = fs.readFileSync(spritePath, 'utf-8');

  // Find all symbols and check their content
  const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
  const validSymbols: string[] = [];
  let match;

  while ((match = symbolRegex.exec(content)) !== null) {
    const symbolId = match[1];
    const symbolContent = match[2];
    const fullSymbol = match[0];

    // Check if content contains HTML indicators
    const hasHtml =
      /<!DOCTYPE|<html|<head|<body|<meta|<style[^>]*>[\s\S]*?<\/style>[\s\S]*<style/i.test(
        symbolContent
      );

    if (hasHtml) {
      removed.push(symbolId);
    } else {
      validSymbols.push(fullSymbol);
      kept++;
    }
  }

  if (removed.length > 0) {
    // Rebuild sprite with only valid symbols
    const newContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
  <!--
    SVG Sprite Sheet
    Generated by MasterSVG VS Code Extension
    Total icons: ${kept}
  -->
${validSymbols.join('\n\n')}
</svg>`;

    fs.writeFileSync(spritePath, newContent);
  }

  return { removed, kept };
}
