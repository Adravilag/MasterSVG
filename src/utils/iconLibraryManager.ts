/**
 * Icon Library Manager utilities
 * Functions for managing icon collections, imports, and web components
 */

import * as fs from 'fs';
import * as path from 'path';

/**
 * Library icon entry structure
 */
export interface LibraryIcon {
  name: string;
  svg: string;
  body?: string;
  viewBox?: string;
}

/**
 * Icon entry for icons.js file
 */
export interface IconEntry {
  name: string;
  body: string;
  viewBox: string;
}

/**
 * Load icons from library file
 */
export function loadLibraryIcons(libraryPath: string): LibraryIcon[] {
  try {
    if (fs.existsSync(libraryPath)) {
      const content = fs.readFileSync(libraryPath, 'utf-8');
      return JSON.parse(content);
    }
  } catch (e) {
    // File doesn't exist or is invalid
  }
  return [];
}

/**
 * Save icons to library file
 */
export function saveLibraryIcons(libraryPath: string, icons: LibraryIcon[]): void {
  const libraryDir = path.dirname(libraryPath);
  if (!fs.existsSync(libraryDir)) {
    fs.mkdirSync(libraryDir, { recursive: true });
  }
  fs.writeFileSync(libraryPath, JSON.stringify(icons, null, 2));
}

/**
 * Find icon in library by name
 */
export function findIconInLibrary(icons: LibraryIcon[], name: string): number {
  return icons.findIndex(i => i.name === name);
}

/**
 * Add or update icon in library
 */
export function upsertIconInLibrary(
  icons: LibraryIcon[],
  icon: LibraryIcon,
  overwrite: boolean = true
): { icons: LibraryIcon[]; added: boolean; updated: boolean } {
  const existingIndex = findIconInLibrary(icons, icon.name);
  
  if (existingIndex >= 0) {
    if (overwrite) {
      icons[existingIndex] = icon;
      return { icons, added: false, updated: true };
    }
    return { icons, added: false, updated: false };
  }
  
  icons.push(icon);
  return { icons, added: true, updated: false };
}

/**
 * Remove icon from library
 */
export function removeIconFromLibrary(icons: LibraryIcon[], name: string): LibraryIcon[] {
  return icons.filter(i => i.name !== name);
}

/**
 * Get default library path
 */
export function getDefaultLibraryPath(): string {
  const appDataPath = process.env.APPDATA || process.env.HOME || '';
  return path.join(appDataPath, 'icon-manager', 'icons.json');
}

/**
 * Generate icon entry for icons.js file
 */
export function generateIconEntryCode(varName: string, iconName: string, body: string, viewBox: string = '0 0 24 24'): string {
  return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}'
};`;
}

/**
 * Generate new icons.js file content
 */
export function generateNewIconsFileContent(entries: Array<{ varName: string; entry: string }>): string {
  const iconEntries = entries.map(e => e.entry).join('\n\n');
  const iconNames = entries.map(e => e.varName).join(',\n  ');
  
  return `// Auto-generated by Icon Manager
// Do not edit manually

${iconEntries}

export const icons = {
  ${iconNames}
};
`;
}

/**
 * Update existing icons.js content with new icon
 */
export function updateIconsFileContent(content: string, varName: string, iconEntry: string): string {
  // Check if icon already exists
  if (content.includes(`export const ${varName}`)) {
    // Replace existing
    const regex = new RegExp(`export const ${varName} = \\{[\\s\\S]*?\\};`, 'g');
    return content.replace(regex, iconEntry);
  }
  
  // Find the icons object and add before it
  const iconsObjMatch = content.match(/export const icons = \{/);
  if (iconsObjMatch && iconsObjMatch.index !== undefined) {
    let newContent = content.slice(0, iconsObjMatch.index) + iconEntry + '\n\n' + content.slice(iconsObjMatch.index);
    
    // Also add to the icons object
    const objContent = newContent.match(/export const icons = \{([^}]*)\}/);
    if (objContent) {
      const existingIcons = objContent[1].trim();
      const newIcons = existingIcons ? `${existingIcons},\n  ${varName}` : `\n  ${varName}\n`;
      newContent = newContent.replace(/export const icons = \{([^}]*)\}/, `export const icons = {${newIcons}}`);
    }
    return newContent;
  }
  
  // Just append at the end
  return content + '\n\n' + iconEntry;
}

/**
 * Check if icon exists in icons.js content
 */
export function iconExistsInIconsFile(content: string, varName: string): boolean {
  return content.includes(`export const ${varName}`);
}

/**
 * Generate sprite symbol entry
 */
export function generateSpriteSymbol(iconName: string, body: string, viewBox: string = '0 0 24 24'): string {
  return `  <symbol id="${iconName}" viewBox="${viewBox}">\n    ${body}\n  </symbol>`;
}

/**
 * Generate new sprite.svg content
 */
export function generateNewSpriteContent(symbols: string[]): string {
  return `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
${symbols.join('\n')}
</svg>
`;
}

/**
 * Update existing sprite.svg content with new symbol
 */
export function updateSpriteContent(content: string, iconName: string, symbolEntry: string): string {
  // Check if symbol already exists
  const existingSymbol = new RegExp(`<symbol[^>]*id=["']${iconName}["'][\\s\\S]*?<\\/symbol>`, 'g');
  if (existingSymbol.test(content)) {
    // Replace existing
    return content.replace(existingSymbol, symbolEntry);
  }
  
  // Add before closing </svg>
  return content.replace('</svg>', `${symbolEntry}\n</svg>`);
}

/**
 * Check if symbol exists in sprite
 */
export function symbolExistsInSprite(content: string, iconName: string): boolean {
  const pattern = new RegExp(`<symbol[^>]*id=["']${iconName}["']`, 'g');
  return pattern.test(content);
}

/**
 * Generate web component code for HTML usage
 */
export function generateWebComponentCode(tagName: string): string {
  // Build the code using string concatenation to avoid template literal issues with regex
  const header = [
    '// Auto-generated Web Component by Icon Manager',
    '// Usage: <' + tagName + ' name="icon-name"></' + tagName + '>',
    '// With variant: <' + tagName + ' name="icon-name" variant="dark-theme"></' + tagName + '>',
    '// With animation: <' + tagName + ' name="icon-name" animation="spin"></' + tagName + '>',
    '// Import this file in your HTML: <script type="module" src="./path/to/icon.js"></script>',
    '',
    "import { icons } from './icons.js';",
    '',
    '// Optional imports - these files may not exist',
    'let Variants = {};',
    'let defaultVariants = {};',
    'let animations = {};',
    '',
    'try {',
    "  const VariantsModule = await import('./variants.js');",
    '  Variants = VariantsModule.Variants || {};',
    '  defaultVariants = VariantsModule.defaultVariants || {};',
    '} catch (e) {',
    '  // variants.js not found, continue without Variants',
    '}',
    '',
    'try {',
    "  const animModule = await import('./animations.js');",
    '  animations = animModule.animations || {};',
    '} catch (e) {',
    '  // animations.js not found, continue without animations',
    '}',
  ].join('\n');

  const animationStyles = [
    '',
    '// Animation CSS styles',
    'const animationStyles = `',
    '  @keyframes icon-spin { from { transform: rotate(0deg); } to { transform: rotate(360deg); } }',
    '  @keyframes icon-pulse { 0%, 100% { transform: scale(1); opacity: 1; } 50% { transform: scale(1.1); opacity: 0.8; } }',
    '  @keyframes icon-bounce { 0%, 100% { transform: translateY(0); } 50% { transform: translateY(-4px); } }',
    '  @keyframes icon-shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-2px); } 75% { transform: translateX(2px); } }',
    '  @keyframes icon-fade { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }',
    '`;',
    '',
    "// Inject animation styles once",
    "if (!document.getElementById('icon-animation-styles')) {",
    "  const styleEl = document.createElement('style');",
    "  styleEl.id = 'icon-animation-styles';",
    '  styleEl.textContent = animationStyles;',
    '  document.head.appendChild(styleEl);',
    '}',
  ].join('\n');

  const classBody = [
    '',
    'class IconElement extends HTMLElement {',
    '  static get observedAttributes() {',
    "    return ['name', 'size', 'color', 'variant', 'animation'];",
    '  }',
    '',
    '  connectedCallback() {',
    '    this.render();',
    '  }',
    '',
    '  attributeChangedCallback() {',
    '    this.render();',
    '  }',
    '',
    '  render() {',
    "    const name = this.getAttribute('name');",
    '    if (!name) return;',
    '',
    '    // Convert kebab-case to camelCase for lookup',
    '    const camelName = name.replace(/-([a-z0-9])/gi, (_, c) => c.toUpperCase());',
    '    const icon = icons[camelName];',
    '',
    '    if (!icon) {',
    '      console.warn(`[Icon] Icon "${name}" not found in icons.js`);',
    "      this.innerHTML = '';",
    '      return;',
    '    }',
    '',
    "    const size = this.getAttribute('size') || '1em';",
    "    const color = this.getAttribute('color') || 'currentColor';",
    "    const variantName = this.getAttribute('variant') || defaultVariants[icon.name] || null;",
    "    const animName = this.getAttribute('animation') || (animations[icon.name]?.type) || null;",
    '    const animConfig = animations[icon.name] || { duration: 1, timing: "ease", iteration: "infinite" };',
    '',
    '    let body = icon.body;',
    '    const iconVariants = Variants[icon.name] || {};',
    '    if (variantName && iconVariants[variantName]) {',
    '      const variantColors = iconVariants[variantName];',
    "      const colorPattern = /(fill|stroke)=[\"']([^\"']+)[\"']/gi;",
    '      const matches = [...body.matchAll(colorPattern)];',
    "      const uniqueColors = [...new Set(matches.map(m => m[2]).filter(c => c !== 'none' && c !== 'currentColor'))];",
    '',
    '      for (let i = 0; i < Math.min(uniqueColors.length, variantColors.length); i++) {',
    '        body = body.split(uniqueColors[i]).join(variantColors[i]);',
    '      }',
    '    }',
    '',
    "    let animStyle = '';",
    "    if (animName && animName !== 'none') {",
    '      const duration = animConfig.duration || 1;',
    "      const timing = animConfig.timing || 'ease';",
    "      const iteration = animConfig.iteration || 'infinite';",
    '      animStyle = `animation: icon-${animName} ${duration}s ${timing} ${iteration};`;',
    '    }',
    '',
    '    this.innerHTML = `',
    '      <svg ',
    '        xmlns="http://www.w3.org/2000/svg" ',
    '        viewBox="${icon.viewBox}"',
    '        width="${size}"',
    '        height="${size}"',
    '        fill="${color}"',
    '        style="display: inline-block; vertical-align: middle; ${animStyle}"',
    '      >',
    '        ${body}',
    '      </svg>',
    '    `;',
    '  }',
    '}',
  ].join('\n');

  const footer = [
    '',
    '// Register the custom element',
    "if (!customElements.get('" + tagName + "')) {",
    "  customElements.define('" + tagName + "', IconElement);",
    '}',
    '',
    'export { IconElement };',
  ].join('\n');

  return header + animationStyles + classBody + footer;
}

/**
 * Convert component name to web component tag name
 */
export function componentNameToTagName(componentName: string): string {
  // Convert PascalCase/camelCase to kebab-case
  let tagName = componentName
    .replace(/([a-z])([A-Z])/g, '$1-$2')
    .toLowerCase();
  
  // Custom elements MUST have a hyphen - if none, add suffix
  if (!tagName.includes('-')) {
    tagName = `${tagName}-icon`;
  }
  
  return tagName;
}

/**
 * Validate icon name format
 */
export function isValidIconName(name: string): boolean {
  return /^[a-zA-Z][a-zA-Z0-9-]*$/.test(name);
}

/**
 * Validate icon name with error message
 */
export function validateIconName(name: string): string | null {
  if (!name) {
    return 'Icon name is required';
  }
  if (!isValidIconName(name)) {
    return 'Must start with a letter and contain only letters, numbers, and hyphens';
  }
  return null;
}

/**
 * Generate variants.js file content
 */
export function generateVariantsFileContent(variants: Record<string, Record<string, string[]>>): string {
  const variantsJson = JSON.stringify(variants, null, 2);
  return `// Icon color Variants
// Auto-generated by Icon Manager

export const Variants = ${variantsJson};

// Default Variants per icon
export const defaultVariants = {};
`;
}

/**
 * Generate animations.js file content
 */
export function generateAnimationsFileContent(animations: Record<string, { type: string; duration: number; timing: string; iteration: string }>): string {
  const animationsJson = JSON.stringify(animations, null, 2);
  return `// Icon animations
// Auto-generated by Icon Manager

export const animations = ${animationsJson};
`;
}

/**
 * Parse icon names from icons.js content
 */
export function parseIconNamesFromContent(content: string): string[] {
  const results: string[] = [];
  const regex = /name:\s*['"]([^'"]+)['"]/g;
  let match;
  while ((match = regex.exec(content)) !== null) {
    results.push(match[1]);
  }
  return results;
}

/**
 * Parse variable names from icons.js content
 */
export function parseVariableNamesFromContent(content: string): string[] {
  const results: string[] = [];
  const regex = /export const (\w+)\s*=/g;
  let match;
  while ((match = regex.exec(content)) !== null) {
    if (match[1] !== 'icons') {
      results.push(match[1]);
    }
  }
  return results;
}

/**
 * Count icons in icons.js content
 */
export function countIconsInContent(content: string): number {
  const matches = content.match(/name:\s*['"][^'"]+['"]/g);
  return matches ? matches.length : 0;
}

/**
 * Generate import statement for icons
 */
export function generateIconImportStatement(iconNames: string[], importPath: string): string {
  const pascalNames = iconNames.map(name => 
    name.split(/[-_]/).map(part => part.charAt(0).toUpperCase() + part.slice(1)).join('')
  );
  return `import { ${pascalNames.join(', ')} } from '${importPath}';`;
}

/**
 * Check if import exists in content
 */
export function hasImportInContent(content: string, componentName: string): boolean {
  const importRegex = new RegExp(`import.*${componentName}.*from`);
  return importRegex.test(content);
}

/**
 * Find best position to insert import statement
 */
export function findImportInsertLine(lines: string[]): number {
  let insertLine = 0;
  
  for (let i = 0; i < lines.length; i++) {
    const line = lines[i];
    if (line.startsWith('import ')) {
      insertLine = i + 1;
    } else if (line.trim() && !line.startsWith('//') && !line.startsWith('/*') && !line.startsWith('*')) {
      break;
    }
  }
  
  return insertLine;
}

/**
 * Generate script tag for HTML
 */
export function generateScriptTag(relativePath: string): string {
  return `    <script type="module" src="${relativePath}"></script>\n`;
}

/**
 * Calculate relative path from HTML file to icon.js
 */
export function calculateRelativePath(htmlDir: string, iconJsPath: string): string {
  let relativePath = path.relative(htmlDir, iconJsPath).replace(/\\/g, '/');
  
  // Ensure it starts with ./ for relative imports
  if (!relativePath.startsWith('.') && !relativePath.startsWith('/')) {
    relativePath = './' + relativePath;
  }
  
  return relativePath;
}
