/**
 * Icon Build Helpers
 *
 * Helper functions for building and importing icons to the library.
 * Extracted from miscCommands.ts to reduce duplication.
 */
import * as vscode from 'vscode';
import * as path from 'path';
import { SvgTransformer } from '../services/svg/SvgTransformer';
import { addToIconsJs, addToSpriteSvg } from '../utils/iconsFileManager';
import { getConfig, getOutputPathOrWarn, getFullOutputPath } from '../utils/configHelper';
import { getSvgConfig } from './config';
import { WorkspaceIcon } from '../providers/tree/WorkspaceSvgProvider';
import { t } from '../i18n';
import {
  BuildResult as CentralizedBuildResult,
  BuildIconOptions as CentralizedBuildIconOptions,
  DeletePromptOptions as CentralizedDeletePromptOptions,
} from '../services/types/mastersvgTypes';

// Re-export for backwards compatibility
export type BuildResult = CentralizedBuildResult;
export type BuildIconOptions = CentralizedBuildIconOptions<SvgTransformer>;
export type DeletePromptOptions = CentralizedDeletePromptOptions;

/**
 * Build an icon to the configured format (sprite.svg or icons.js).
 * This is the main function for adding icons to the build output.
 */
export async function buildIcon(options: BuildIconOptions): Promise<BuildResult> {
  const { iconName, svgContent, svgTransformer, outputPath: customPath } = options;

  const outputPath = customPath || getOutputPathOrWarn();
  if (!outputPath) {
    return {
      success: false,
      iconName,
      outputPath: '',
      format: 'icons',
      error: 'No output path configured',
    };
  }

  const config = getConfig();
  const isSprite = config.buildFormat === 'sprite.svg';
  const defaultColor = getSvgConfig<string>('defaultSvgColor', (config as any).defaultColor || 'currentColor');
  const needsColorStyle = defaultColor && defaultColor !== 'currentColor';
  const colorStyleHtml = needsColorStyle ? ` style="color: ${defaultColor}"` : '';
  const colorStyleJsx = needsColorStyle ? ` style={{color: '${defaultColor}'}}` : '';

  const classPrefix = getSvgConfig<string>('classPrefix', 'i-');
  const cssMethod = getSvgConfig<string>('cssMethod', 'mask');
  const cssElementTag = getSvgConfig<string>('cssElementTag', 'span');

  try {
    if (isSprite) {
      await addToSpriteSvg(outputPath, iconName, svgContent, svgTransformer);
    } else if (config.buildFormat === 'css') {
      // CSS output: write individual SVG file and update icons.css
      try {
        const fs = require('fs');
        const path = require('path');
        if (!fs.existsSync(outputPath)) fs.mkdirSync(outputPath, { recursive: true });

        const svgFile = path.join(outputPath, `${iconName}.svg`);
        fs.writeFileSync(svgFile, svgContent, 'utf-8');

          const cssPath = path.join(outputPath, 'icons.css');
          let css = '';
          if (fs.existsSync(cssPath)) {
            css = fs.readFileSync(cssPath, 'utf-8');
          }

          const safeName = iconName.replace(/[^a-z0-9_-]/gi, '-').toLowerCase();
          const className = `${classPrefix}${safeName}`;
          // Build rule exactly matching the webview preview format
          const methodProp = cssMethod === 'background' ? 'background-image' : 'mask-image';
          const publicPath = `/${path.basename(outputPath)}/${iconName}.svg`;
          const rule = `.${className} {\n  ${methodProp}: url('${publicPath}');\n  width: 24px;\n  height: 24px;\n  display: inline-block;\n  background-color: currentColor;\n}`;

          if (!css.includes(`.${className} {`)) {
            // Ensure file exists (create with header comment)
            const header = css || '/* Auto-generated by MasterSVG */\n';
            const newCss = header + '\n' + rule + '\n';
            fs.writeFileSync(cssPath, newCss, 'utf-8');
          }
      } catch (e) {
        console.error('[buildIcon] Failed to write CSS icon files:', e);
        throw e;
      }
    } else {
      await addToIconsJs({
        outputPath,
        iconName,
        svgContent,
        transformer: svgTransformer,
      });
    }

    return {
      success: true,
      iconName,
      outputPath,
      format: isSprite ? 'sprite' : 'icons',
    };
  } catch (error: unknown) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    return {
      success: false,
      iconName,
      outputPath,
      format: isSprite ? 'sprite' : 'icons',
      error: errorMessage,
    };
  }
}

/**
 * Show a prompt asking whether to delete the original file.
 * Returns the user's choice or the default value if cancelled.
 */
export async function showDeleteOriginalPrompt(options?: DeletePromptOptions): Promise<boolean> {
  const config = getConfig();
  const isSprite = config.buildFormat === 'sprite.svg';
  const defaultDelete = vscode.workspace
    .getConfiguration('iconStudio')
    .get<boolean>('deleteAfterBuild', false);

  const choice = await vscode.window.showQuickPick(
    [
      {
        label: `$(trash) ${t('editor.deleteOriginalSvg')}`,
        description: t('editor.deleteOriginalSvgDesc'),
        value: true,
      },
      {
        label: `$(file) ${t('editor.keepOriginalSvg')}`,
        description: t('editor.keepOriginalSvgDesc'),
        value: false,
      },
    ],
    {
      placeHolder: t('editor.whatToDoWithOriginal'),
      title:
        options?.title || `${t('editor.addTo')} ${isSprite ? 'Sprite' : t('editor.iconsLibrary')}`,
    }
  );

  return choice?.value ?? options?.defaultValue ?? defaultDelete;
}

/**
 * Attributes that should be preserved when transforming inline SVG to icon component.
 * These are framework directives and common HTML attributes that affect behavior.
 */
const PRESERVED_ATTRIBUTES = [
  // Angular directives
  '*ngIf', '*ngFor', '*ngSwitch', '*ngSwitchCase', '*ngSwitchDefault',
  '[ngClass]', '[ngStyle]', '[class]', '[style]',
  '(click)', '(mouseenter)', '(mouseleave)', '(focus)', '(blur)',
  '@if', '@for', '@switch',
  // Vue directives
  'v-if', 'v-else', 'v-else-if', 'v-show', 'v-for', 'v-bind', 'v-on',
  ':class', ':style', '@click', '@mouseenter', '@mouseleave',
  // React/JSX
  'onClick', 'onMouseEnter', 'onMouseLeave', 'onFocus', 'onBlur',
  // Svelte
  'on:click', 'on:mouseenter', 'on:mouseleave',
  // Common HTML
  'class', 'id', 'style', 'title', 'tabindex', 'role', 'aria-label', 'aria-hidden',
  'data-testid', 'data-cy', 'data-test',
];

/**
 * Extract preserved attributes from original SVG content
 */
export function extractPreservedAttributes(svgContent: string): Record<string, string> {
  const preserved: Record<string, string> = {};

  // Match the opening <svg tag
  const svgTagMatch = svgContent.match(/<svg([^>]*)>/i);
  if (!svgTagMatch) return preserved;

  const attributesStr = svgTagMatch[1];

  // Match attributes - handles both quoted and binding syntax
  // Pattern matches: attr="value", [attr]="value", (attr)="value", *attr="value", @attr="value", :attr="value", v-attr="value"
  const attrRegex = /(\*?[@:(\[]?[\w.-]+[\])]?)=["']([^"']*)["']/g;

  let match;
  while ((match = attrRegex.exec(attributesStr)) !== null) {
    const attrName = match[1];
    const attrValue = match[2];

    // Check if this attribute should be preserved
    const shouldPreserve = PRESERVED_ATTRIBUTES.some(preserved => {
      // Exact match
      if (attrName === preserved) return true;
      // Prefix match for data-* attributes
      if (attrName.startsWith('data-')) return true;
      // Prefix match for aria-* attributes
      if (attrName.startsWith('aria-')) return true;
      // Angular/Vue binding syntax variations
      if (preserved.startsWith('[') && attrName === preserved) return true;
      if (preserved.startsWith('(') && attrName === preserved) return true;
      if (preserved.startsWith('*') && attrName === preserved) return true;
      if (preserved.startsWith('@') && attrName === preserved) return true;
      if (preserved.startsWith(':') && attrName === preserved) return true;
      if (preserved.startsWith('v-') && attrName === preserved) return true;
      return false;
    });

    if (shouldPreserve) {
      preserved[attrName] = attrValue;
    }
  }

  return preserved;
}

/**
 * Format preserved attributes as a string for insertion into HTML
 */
function formatPreservedAttributes(preserved: Record<string, string>): string {
  const entries = Object.entries(preserved);
  if (entries.length === 0) return '';

  return ' ' + entries.map(([key, value]) => `${key}="${value}"`).join(' ');
}

/**
 * Generate a replacement string for a web component or sprite reference.
 * @param iconName - The name of the icon
 * @param languageId - The language ID of the document
 * @param preservedAttrs - Optional attributes to preserve from original SVG
 */
export function generateReplacement(
  iconName: string,
  languageId: string,
  preservedAttrs?: Record<string, string>,
  elementTag?: string
): string {
  const config = getConfig();
  const defaultColor = (config as any).defaultColor || 'currentColor';
  const needsColorStyle = defaultColor && defaultColor !== 'currentColor';
  const colorStyleHtml = needsColorStyle ? ` style="color: ${defaultColor}"` : '';
  const colorStyleJsx = needsColorStyle ? ` style={{color: '${defaultColor}'}}` : '';
  const isSprite = config.buildFormat === 'sprite.svg';
  const componentName = config.webComponentName || 'svg-icon';
  const attrsStr = preservedAttrs ? formatPreservedAttributes(preservedAttrs) : '';

  if (isSprite) {
    // Add color style so sprite <use> icons respect the configured default color
    const style = (languageId === 'javascriptreact' || languageId === 'typescriptreact') ? colorStyleJsx : colorStyleHtml;
    return `<svg${style}${attrsStr} aria-hidden="true"><use href="sprite.svg#${iconName}"></use></svg>`;
  }

  // CSS output: use an inline element (default `span`) with classes
  if (config.buildFormat === 'css') {
    const tag = elementTag || (config as any).cssElementTag || 'span';
    // For JSX languages, convert `class` -> `className`
    const isJsx = ['javascriptreact', 'typescriptreact'].includes(languageId);
    const preserved = preservedAttrs ? { ...preservedAttrs } : {};
    // Merge default class
    const baseClass = 'icon';
    const safeName = iconName.replace(/[^a-z0-9_-]/gi, '-').toLowerCase();
    const specificClass = `ms-icon--${safeName}`;
    const existingClass = preserved.class || preserved.className || '';
    const combinedClass = [baseClass, specificClass, existingClass].filter(Boolean).join(' ');

    if (isJsx) {
      // Build JSX attributes string
      const jsxAttrs = Object.entries(preserved)
        .filter(([k]) => k !== 'class' && k !== 'className')
        .map(([k, v]) => `${k}="${v}"`)
        .join(' ');
      const classAttr = `className=\"${combinedClass}\"`;
        const space = jsxAttrs ? ' ' : '';
      const style = needsColorStyle ? ` style={{color: '${defaultColor}'}}` : '';
      return `<${tag} ${classAttr}${space}${jsxAttrs}${style} aria-hidden=\"true\"></${tag}>`;
    }

    // HTML output
    const htmlAttrs = Object.entries(preserved)
      .filter(([k]) => k !== 'class' && k !== 'className')
      .map(([k, v]) => `${k}="${v}"`)
      .join(' ');
    const space = htmlAttrs ? ' ' : '';
    const style = needsColorStyle ? ` style="color: ${defaultColor}"` : '';
    return `<${tag} class="${combinedClass}"${style}${space}${htmlAttrs} aria-hidden="true"></${tag}>`;
  }

  // For web component, use self-closing in JSX-like languages
  if (['javascriptreact', 'typescriptreact', 'vue', 'svelte', 'astro'].includes(languageId)) {
    return `<${componentName} name="${iconName}"${attrsStr} />`;
  }

  return `<${componentName} name="${iconName}"${attrsStr}></${componentName}>`;
}

/**
 * Check if script import is needed and show warning if missing.
 */
export async function checkScriptImport(
  document: vscode.TextDocument,
  documentUri: string
): Promise<void> {
  const config = getConfig();
  const isSprite = config.buildFormat === 'sprite.svg';

  // Only needed for web component format and HTML files
  if (isSprite) return;

  const ext = path.extname(documentUri).slice(1).toLowerCase();
  if (!['html', 'htm'].includes(ext)) return;

  const fullText = document.getText();
  const hasIconScript = fullText.includes('svg-element.js') || fullText.includes('svg-data.js') ||
                        fullText.includes('icon.js') || fullText.includes('icons.js'); // Legacy support

  if (!hasIconScript) {
    const outputDir = config.outputDirectory || 'icons';
    const addScript = await vscode.window.showWarningMessage(
      `⚠️ ${t('messages.missingScriptImport', { outputDir })}`,
      t('messages.copyToClipboard'),
      t('messages.dismiss')
    );

    if (addScript === t('messages.copyToClipboard')) {
      const scriptTag = `<script type="module" src="./${outputDir}/svg-element.js"></script>`;
      await vscode.env.clipboard.writeText(scriptTag);
      vscode.window.showInformationMessage(t('messages.scriptCopiedToClipboard'));
    }
  }
}

/**
 * Create a WorkspaceIcon from build parameters.
 */
export function createBuiltIcon(
  iconName: string,
  svgContent: string,
  sourcePath?: string
): WorkspaceIcon {
  const outputPath = getFullOutputPath();
  return {
    name: iconName,
    svg: svgContent,
    path: outputPath || sourcePath || '',
    source: 'library',
    isBuilt: true,
  };
}

/**
 * Show success message after build operation.
 */
export function showBuildSuccess(result: BuildResult, extras?: string[]): void {
  const formatName = result.format === 'sprite' ? 'sprite' : t('editor.iconsLibrary');
  const targets = extras ? [formatName, ...extras].join(' & ') : formatName;
  const msg = t('messages.iconImported', { name: result.iconName, targets });
  vscode.window
    .showInformationMessage(msg, 'Open Folder')
    .then(selection => {
      if (selection === 'Open Folder' && result.outputPath) {
        try {
          vscode.commands.executeCommand('revealFileInOS', vscode.Uri.file(result.outputPath));
        } catch (e) {
          // ignore reveal errors
        }
      }
    });
}
