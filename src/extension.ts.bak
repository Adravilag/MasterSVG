"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    var desc = Object.getOwnPropertyDescriptor(m, k);
    if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
      desc = { enumerable: true, get: function() { return m[k]; } };
    }
    Object.defineProperty(o, k2, desc);
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || (function () {
    var ownKeys = function(o) {
        ownKeys = Object.getOwnPropertyNames || function (o) {
            var ar = [];
            for (var k in o) if (Object.prototype.hasOwnProperty.call(o, k)) ar[ar.length] = k;
            return ar;
        };
        return ownKeys(o);
    };
    return function (mod) {
        if (mod && mod.__esModule) return mod;
        var result = {};
        if (mod != null) for (var k = ownKeys(mod), i = 0; i < k.length; i++) if (k[i] !== "default") __createBinding(result, mod, k[i]);
        __setModuleDefault(result, mod);
        return result;
    };
})();
Object.defineProperty(exports, "__esModule", { value: true });
exports.activate = activate;
exports.deactivate = deactivate;
const vscode = __importStar(require("vscode"));
const path = __importStar(require("path"));
const fs = __importStar(require("fs"));
const IconManagerPanel_1 = require("./panels/IconManagerPanel");
const IconCatalogPanel_1 = require("./panels/IconCatalogPanel");
const WorkspaceSvgProvider_1 = require("./providers/WorkspaceSvgProvider");
const SvgTransformer_1 = require("./services/SvgTransformer");
const IconCatalogService_1 = require("./services/IconCatalogService");
const IconCompletionProvider_1 = require("./providers/IconCompletionProvider");
const IconHoverProvider_1 = require("./providers/IconHoverProvider");
const SvgToIconCodeActionProvider_1 = require("./providers/SvgToIconCodeActionProvider");
const IconPreviewProvider_1 = require("./providers/IconPreviewProvider");
const ComponentExporter_1 = require("./services/ComponentExporter");
const SpriteGenerator_1 = require("./services/SpriteGenerator");
const extensionHelpers_1 = require("./utils/extensionHelpers");
const iconPickerHtml_1 = require("./utils/iconPickerHtml");
const webviewHtmlGenerators_1 = require("./utils/webviewHtmlGenerators");
let workspaceSvgProvider;
let diagnosticProvider;
let iconPreviewProvider;
let iconCatalogService;
function activate(context) {
    console.log('Icon Manager extension is now active!');
    // Initialize services
    const svgTransformer = new SvgTransformer_1.SvgTransformer();
    workspaceSvgProvider = new WorkspaceSvgProvider_1.WorkspaceSvgProvider(context);
    iconCatalogService = new IconCatalogService_1.IconCatalogService(context);
    // Register the tree view for workspace SVGs
    vscode.window.registerTreeDataProvider('iconManager.workspaceIcons', workspaceSvgProvider);
    // Register the preview panel in sidebar
    iconPreviewProvider = new IconPreviewProvider_1.IconPreviewProvider(context.extensionUri);
    context.subscriptions.push(vscode.window.registerWebviewViewProvider(IconPreviewProvider_1.IconPreviewProvider.viewType, iconPreviewProvider));
    // Update preview when tree item is selected
    const treeView = vscode.window.createTreeView('iconManager.workspaceIcons', {
        treeDataProvider: workspaceSvgProvider,
        showCollapseAll: true,
        canSelectMany: true
    });
    treeView.onDidChangeSelection(e => {
        if (e.selection.length > 0) {
            const item = e.selection[0];
            if (item.contextValue === 'inlineSvg' || item.contextValue === 'builtIcon' || item.contextValue === 'svgIcon') {
                const svgData = workspaceSvgProvider.getSvgData(item);
                if (svgData) {
                    iconPreviewProvider.updatePreview(svgData.name, svgData.svg, svgData.location, item.contextValue === 'builtIcon');
                }
            }
        }
    });
    context.subscriptions.push(treeView);
    // Command: Open main panel
    const openPanelCmd = vscode.commands.registerCommand('iconManager.openPanel', () => {
        IconManagerPanel_1.IconManagerPanel.createOrShow(context.extensionUri, context);
    });
    // Command: Scan workspace for SVGs
    const scanWorkspaceCmd = vscode.commands.registerCommand('iconManager.scanWorkspace', async (uri) => {
        const folder = uri?.fsPath || vscode.workspace.workspaceFolders?.[0]?.uri.fsPath;
        if (folder) {
            await workspaceSvgProvider.scanFolder(folder);
            await workspaceSvgProvider.scanInlineSvgs();
            // Also scan for usages
            await workspaceSvgProvider.scanIconUsages();
            vscode.window.showInformationMessage('SVG scan complete!');
        }
    });
    // Command: Scan for icon usages
    const scanUsagesCmd = vscode.commands.registerCommand('iconManager.scanUsages', async () => {
        await workspaceSvgProvider.scanIconUsages();
        vscode.window.showInformationMessage('Usage scan complete!');
    });
    // Command: Go to usage location
    const goToUsageCmd = vscode.commands.registerCommand('iconManager.goToUsage', async (item) => {
        if (item.resourceUri) {
            const document = await vscode.workspace.openTextDocument(item.resourceUri);
            const editor = await vscode.window.showTextDocument(document);
            // If it's a usage, highlight the line
            if (item.contextValue === 'iconUsage' && item.location) {
                const line = item.location.line - 1;
                const range = new vscode.Range(line, 0, line, document.lineAt(line).text.length);
                editor.selection = new vscode.Selection(range.start, range.end);
                editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
            }
        }
    });
    // Command: Go to inline SVG
    const goToInlineSvgCmd = vscode.commands.registerCommand('iconManager.goToInlineSvg', async (item) => {
        if (item.location) {
            const document = await vscode.workspace.openTextDocument(vscode.Uri.file(item.location.file));
            const editor = await vscode.window.showTextDocument(document);
            const line = item.location.line - 1;
            const range = new vscode.Range(line, 0, line, document.lineAt(line).text.length);
            editor.selection = new vscode.Selection(range.start, range.end);
            editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
        }
    });
    // Command: Transform inline SVG
    const transformInlineSvgCmd = vscode.commands.registerCommand('iconManager.transformInlineSvg', async (item) => {
        if (item.location && item.svgContent) {
            const document = await vscode.workspace.openTextDocument(vscode.Uri.file(item.location.file));
            const editor = await vscode.window.showTextDocument(document);
            // Find the SVG in the document
            const text = document.getText();
            const svgStart = text.indexOf(item.svgContent);
            if (svgStart === -1) {
                vscode.window.showWarningMessage('Could not find SVG in document');
                return;
            }
            const startPos = document.positionAt(svgStart);
            const endPos = document.positionAt(svgStart + item.svgContent.length);
            const range = new vscode.Range(startPos, endPos);
            // Get transformation options
            const format = await vscode.window.showQuickPick([
                { label: 'Component', description: 'Convert to <Icon name="..."/>' },
                { label: 'Sprite', description: 'Convert to <use href="sprite.svg#..."/>' },
                { label: 'Optimize', description: 'Keep inline but optimize' }
            ], { placeHolder: 'Select transformation type' });
            if (!format)
                return;
            const config = vscode.workspace.getConfiguration('iconManager');
            const outputDir = config.get('outputDirectory', '');
            if (format.label !== 'Optimize' && !outputDir) {
                vscode.window.showWarningMessage('Configure output directory in settings first');
                return;
            }
            let replacement;
            const iconName = item.label;
            if (format.label === 'Component') {
                replacement = (0, extensionHelpers_1.generateIconSnippet)(iconName, (0, extensionHelpers_1.getOutputFormat)());
                // Add the icon to the library
                const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                if (workspaceFolder) {
                    const fullOutputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
                    await addToIconsTs(fullOutputPath, iconName, item.svgContent, svgTransformer);
                }
            }
            else if (format.label === 'Sprite') {
                replacement = `<svg class="icon"><use href="${outputDir}/sprite.svg#${iconName}"></use></svg>`;
                // Add to sprite
                const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                if (workspaceFolder) {
                    const fullOutputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
                    await addToSpriteSvg(fullOutputPath, iconName, item.svgContent, svgTransformer);
                }
            }
            else {
                replacement = svgTransformer.optimize(item.svgContent);
            }
            await editor.edit((editBuilder) => {
                editBuilder.replace(range, replacement);
            });
            // Refresh the tree view
            workspaceSvgProvider.refresh();
            vscode.window.showInformationMessage(`Transformed SVG to ${format.label} format`);
        }
    });
    // Command: Configure icon manager for project
    const configureProjectCmd = vscode.commands.registerCommand('iconManager.configureProject', async () => {
        const config = vscode.workspace.getConfiguration('iconManager');
        // Ask for output directory
        const currentDir = config.get('outputDirectory', '');
        const outputDir = await vscode.window.showInputBox({
            prompt: 'Enter the output directory for generated icons',
            value: currentDir || 'icons',
            placeHolder: 'e.g., src/icons, assets/icons'
        });
        if (outputDir !== undefined) {
            await config.update('outputDirectory', outputDir, vscode.ConfigurationTarget.Workspace);
            // Create the directory if it doesn't exist
            const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
            if (workspaceFolder) {
                const fullPath = path.join(workspaceFolder.uri.fsPath, outputDir);
                if (!fs.existsSync(fullPath)) {
                    fs.mkdirSync(fullPath, { recursive: true });
                }
            }
            vscode.window.showInformationMessage(`Output directory set to: ${outputDir}`);
        }
    });
    // Command: Refresh icons list
    const refreshIconsCmd = vscode.commands.registerCommand('iconManager.refreshIcons', () => {
        workspaceSvgProvider.refresh();
    });
    // Command: Build icons library
    const buildIconsCmd = vscode.commands.registerCommand('iconManager.buildIcons', async () => {
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        if (!outputDir) {
            vscode.window.showWarningMessage('Configure output directory first using "iconManager.configureProject"');
            return;
        }
        // Trigger a scan and generate files
        await workspaceSvgProvider.scanInlineSvgs();
        vscode.window.showInformationMessage('Icons library built successfully!');
    });
    // Command: Transform selected SVG
    const transformSvgCmd = vscode.commands.registerCommand('iconManager.transformSvg', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const selection = editor.selection;
        let svgContent = editor.document.getText(selection);
        if (!svgContent.includes('<svg')) {
            vscode.window.showWarningMessage('Please select an SVG element');
            return;
        }
        const format = await vscode.window.showQuickPick(['react', 'vue', 'svelte', 'web-component'], { placeHolder: 'Select output format' });
        if (!format)
            return;
        const componentName = await vscode.window.showInputBox({
            prompt: 'Enter component name',
            placeHolder: 'e.g., IconHome, ArrowIcon',
            validateInput: (value) => {
                if (!value)
                    return 'Name is required';
                if (!/^[A-Z][a-zA-Z0-9]*$/.test(value)) {
                    return 'Use PascalCase (e.g., IconName)';
                }
                return null;
            }
        });
        if (!componentName)
            return;
        const transformed = svgTransformer.toComponent(svgContent, format, componentName);
        await editor.edit((editBuilder) => {
            editBuilder.replace(selection, transformed);
        });
        vscode.window.showInformationMessage(`SVG transformed to ${format} component`);
    });
    // Command: Optimize SVG
    const optimizeSvgCmd = vscode.commands.registerCommand('iconManager.optimizeSvg', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const selection = editor.selection;
        const svgContent = editor.document.getText(selection);
        if (!svgContent.includes('<svg')) {
            vscode.window.showWarningMessage('Please select an SVG element');
            return;
        }
        const optimized = svgTransformer.optimize(svgContent);
        await editor.edit((editBuilder) => {
            editBuilder.replace(selection, optimized);
        });
        vscode.window.showInformationMessage('SVG optimized!');
    });
    // Command: Insert icon at cursor
    const insertIconCmd = vscode.commands.registerCommand('iconManager.insertIcon', async (item) => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        // Get icon name
        let iconName;
        if (item && typeof item.label === 'string') {
            iconName = item.label;
        }
        else {
            // Show quick pick of available icons
            const icons = await workspaceSvgProvider.getBuiltInIconNames();
            const selected = await vscode.window.showQuickPick(icons, {
                placeHolder: 'Select icon to insert'
            });
            if (!selected)
                return;
            iconName = selected;
        }
        const format = (0, extensionHelpers_1.getOutputFormat)();
        const snippet = (0, extensionHelpers_1.generateIconSnippet)(iconName, format);
        await editor.edit((editBuilder) => {
            editBuilder.insert(editor.selection.active, snippet);
        });
    });
    // Command: Preview icon
    const previewIconCmd = vscode.commands.registerCommand('iconManager.previewIcon', (item) => {
        if (item.svgContent) {
            const svgData = workspaceSvgProvider.getSvgData(item);
            if (svgData) {
                iconPreviewProvider.updatePreview(svgData.name, svgData.svg, svgData.location, item.contextValue === 'builtIcon');
            }
        }
    });
    // Register completion provider for icon suggestions
    const completionDisposable = vscode.languages.registerCompletionItemProvider([
        { language: 'javascript' },
        { language: 'typescript' },
        { language: 'javascriptreact' },
        { language: 'typescriptreact' },
        { language: 'vue' },
        { language: 'svelte' },
        { language: 'html' }
    ], new IconCompletionProvider_1.IconCompletionProvider(workspaceSvgProvider), '<', '"', "'");
    // Register hover provider for icon previews
    const hoverDisposable = vscode.languages.registerHoverProvider([
        { language: 'javascript' },
        { language: 'typescript' },
        { language: 'javascriptreact' },
        { language: 'typescriptreact' },
        { language: 'vue' },
        { language: 'svelte' },
        { language: 'html' }
    ], new IconHoverProvider_1.IconHoverProvider(workspaceSvgProvider));
    // Watch for SVG file changes
    const svgWatcher = vscode.workspace.createFileSystemWatcher('**/*.svg');
    svgWatcher.onDidCreate(() => workspaceSvgProvider.refresh());
    svgWatcher.onDidDelete(() => workspaceSvgProvider.refresh());
    svgWatcher.onDidChange(() => workspaceSvgProvider.refresh());
    // Register code action provider for SVG to Icon conversions
    const codeActionProvider = vscode.languages.registerCodeActionsProvider([
        { language: 'javascript' },
        { language: 'typescript' },
        { language: 'javascriptreact' },
        { language: 'typescriptreact' },
        { language: 'vue' },
        { language: 'svelte' },
        { language: 'html' }
    ], new SvgToIconCodeActionProvider_1.SvgToIconCodeActionProvider(), {
        providedCodeActionKinds: SvgToIconCodeActionProvider_1.SvgToIconCodeActionProvider.providedCodeActionKinds
    });
    // Register diagnostic provider for inline SVGs
    diagnosticProvider = new SvgToIconCodeActionProvider_1.SvgImgDiagnosticProvider();
    // Command: Import SVG file to icon library
    const importSvgToLibraryCmd = vscode.commands.registerCommand('iconManager.importSvgToLibrary', async (item) => {
        let svgPath;
        let svgContent;
        let iconName;
        if (item?.resourceUri) {
            // Called from tree view
            svgPath = item.resourceUri.fsPath;
            svgContent = fs.readFileSync(svgPath, 'utf-8');
            iconName = path.basename(svgPath, '.svg');
        }
        else {
            // Called from command palette - show file picker
            const files = await vscode.window.showOpenDialog({
                canSelectFiles: true,
                canSelectMany: false,
                filters: { 'SVG Files': ['svg'] }
            });
            if (!files || files.length === 0)
                return;
            svgPath = files[0].fsPath;
            svgContent = fs.readFileSync(svgPath, 'utf-8');
            iconName = path.basename(svgPath, '.svg');
        }
        if (!svgContent)
            return;
        // Get the output configuration
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        if (!outputDir) {
            vscode.window.showWarningMessage('Configure output directory first');
            return;
        }
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder)
            return;
        const fullOutputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
        // Add to icons.ts
        await addToIconsTs(fullOutputPath, iconName, svgContent, svgTransformer);
        // Refresh tree
        workspaceSvgProvider.refresh();
        vscode.window.showInformationMessage(`✅ Icon "${iconName}" imported to library!`);
    });
    // Command: Quick check and import inline SVG
    const checkAndImportSvgCmd = vscode.commands.registerCommand('iconManager.checkAndImportSvg', async () => {
        const editor = vscode.window.activeTextEditor;
        if (!editor)
            return;
        const document = editor.document;
        const text = document.getText();
        // Find inline SVGs
        const svgRegex = /<svg[^>]*>[\s\S]*?<\/svg>/gi;
        const matches = [...text.matchAll(svgRegex)];
        if (matches.length === 0) {
            vscode.window.showInformationMessage('No inline SVGs found in this file');
            return;
        }
        // Show quick pick to select SVG
        const items = matches.map((match, index) => {
            const preview = match[0].substring(0, 50) + '...';
            return {
                label: `SVG #${index + 1}`,
                description: preview,
                svgContent: match[0],
                index: match.index
            };
        });
        const selected = await vscode.window.showQuickPick(items, {
            placeHolder: 'Select an SVG to import'
        });
        if (!selected)
            return;
        // Ask for icon name
        const iconName = await vscode.window.showInputBox({
            prompt: 'Enter icon name',
            placeHolder: 'e.g., arrow-right, home-icon',
            validateInput: (value) => {
                if (!value)
                    return 'Name is required';
                if (!/^[a-z][a-z0-9-]*$/.test(value)) {
                    return 'Use kebab-case (e.g., icon-name)';
                }
                return null;
            }
        });
        if (!iconName)
            return;
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        if (!outputDir) {
            vscode.window.showWarningMessage('Configure output directory first');
            return;
        }
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!workspaceFolder)
            return;
        const fullOutputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
        await addToIconsTs(fullOutputPath, iconName, selected.svgContent, svgTransformer);
        // Offer to replace inline SVG with component
        const replace = await vscode.window.showQuickPick(['Yes, replace with component', 'No, keep inline SVG'], { placeHolder: 'Replace inline SVG with component reference?' });
        if (replace === 'Yes, replace with component') {
            const startPos = document.positionAt(selected.index);
            const endPos = document.positionAt(selected.index + selected.svgContent.length);
            const range = new vscode.Range(startPos, endPos);
            const snippet = (0, extensionHelpers_1.generateIconSnippet)(iconName, (0, extensionHelpers_1.getOutputFormat)());
            await editor.edit((editBuilder) => {
                editBuilder.replace(range, snippet);
            });
        }
        workspaceSvgProvider.refresh();
        vscode.window.showInformationMessage(`✅ Icon "${iconName}" imported!`);
    });
    // Command: Delete selected icons
    const deleteIconsCmd = vscode.commands.registerCommand('iconManager.deleteIcons', async (item, selectedItems) => {
        const itemsToDelete = selectedItems && selectedItems.length > 0 ? selectedItems : [item];
        const names = itemsToDelete.map(i => typeof i.label === 'string' ? i.label : '').filter(Boolean);
        if (names.length === 0) {
            vscode.window.showWarningMessage('No icons selected for deletion');
            return;
        }
        const confirm = await vscode.window.showWarningMessage(`Delete ${names.length} icon(s): ${names.join(', ')}?`, { modal: true }, 'Delete');
        if (confirm !== 'Delete')
            return;
        // Delete from icons.ts
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!outputDir || !workspaceFolder)
            return;
        const iconsPath = path.join(workspaceFolder.uri.fsPath, outputDir, 'icons.js');
        if (fs.existsSync(iconsPath)) {
            let content = fs.readFileSync(iconsPath, 'utf-8');
            for (const name of names) {
                const varName = (0, extensionHelpers_1.toVariableName)(name);
                // Remove the export const
                const exportRegex = new RegExp(`export const ${varName} = \\{[\\s\\S]*?\\};\\s*`, 'g');
                content = content.replace(exportRegex, '');
                // Remove from icons object
                const objRegex = new RegExp(`,?\\s*${varName}\\s*,?`, 'g');
                content = content.replace(objRegex, (match) => {
                    // If it was the only comma, remove it
                    return match.includes(',') && !match.startsWith(',') ? ',' : '';
                });
            }
            fs.writeFileSync(iconsPath, content);
        }
        workspaceSvgProvider.refresh();
        vscode.window.showInformationMessage(`Deleted ${names.length} icon(s)`);
    });
    // Command: Open color editor for an icon
    const colorEditorCmd = vscode.commands.registerCommand('iconManager.editColors', async (item) => {
        let svgContent;
        let iconName;
        let filePath;
        let lineNumber;
        if (item?.svgContent) {
            svgContent = item.svgContent;
            iconName = typeof item.label === 'string' ? item.label : 'icon';
            if (item.location) {
                filePath = item.location.file;
                lineNumber = item.location.line;
            }
        }
        else {
            // Try to get from current selection
            const editor = vscode.window.activeTextEditor;
            if (!editor) {
                vscode.window.showWarningMessage('Select an SVG or use from tree view');
                return;
            }
            const selection = editor.selection;
            svgContent = editor.document.getText(selection);
            if (!svgContent.includes('<svg')) {
                vscode.window.showWarningMessage('Please select an SVG element');
                return;
            }
            iconName = 'selected-svg';
            filePath = editor.document.uri.fsPath;
            lineNumber = selection.start.line + 1;
        }
        if (!svgContent)
            return;
        // Load saved styles for this icon from global state
        const savedStyles = context.globalState.get(`iconStyles.${iconName}`) || [];
        // Create webview panel for color editing
        const panel = vscode.window.createWebviewPanel('iconColorEditor', `Colors: ${iconName}`, vscode.ViewColumn.One, {
            enableScripts: true,
            retainContextWhenHidden: true
        });
        panel.webview.html = (0, webviewHtmlGenerators_1.getColorEditorHtml)(iconName, svgContent, filePath, lineNumber, savedStyles);
        // Handle messages from the webview
        panel.webview.onDidReceiveMessage(async (message) => {
            switch (message.command) {
                case 'copyModifiedSvg':
                    await vscode.env.clipboard.writeText(message.svg);
                    vscode.window.showInformationMessage('SVG copied to clipboard!');
                    break;
                case 'exportSvg':
                    const saveUri = await vscode.window.showSaveDialog({
                        defaultUri: vscode.Uri.file(`${message.iconName}.svg`),
                        filters: { 'SVG Files': ['svg'] }
                    });
                    if (saveUri) {
                        fs.writeFileSync(saveUri.fsPath, message.svg);
                        vscode.window.showInformationMessage(`SVG exported to ${saveUri.fsPath}`);
                    }
                    break;
                case 'saveSvg':
                    if (message.filePath && message.lineNumber !== undefined) {
                        try {
                            const document = await vscode.workspace.openTextDocument(message.filePath);
                            const editor = await vscode.window.showTextDocument(document);
                            const line = message.lineNumber - 1;
                            const lineText = document.lineAt(line).text;
                            // Find SVG in that line or nearby
                            const text = document.getText();
                            const svgRegex = /<svg[^>]*>[\s\S]*?<\/svg>/gi;
                            let match;
                            let bestMatch = null;
                            let bestDistance = Infinity;
                            while ((match = svgRegex.exec(text)) !== null) {
                                const matchLine = document.positionAt(match.index).line;
                                const distance = Math.abs(matchLine - line);
                                if (distance < bestDistance) {
                                    bestDistance = distance;
                                    bestMatch = match;
                                }
                            }
                            if (bestMatch) {
                                const startPos = document.positionAt(bestMatch.index);
                                const endPos = document.positionAt(bestMatch.index + bestMatch[0].length);
                                const range = new vscode.Range(startPos, endPos);
                                await editor.edit((editBuilder) => {
                                    editBuilder.replace(range, message.svg);
                                });
                                vscode.window.showInformationMessage('SVG updated in source file!');
                                workspaceSvgProvider.refresh();
                            }
                            else {
                                vscode.window.showWarningMessage('Could not find SVG in source file');
                            }
                        }
                        catch (error) {
                            vscode.window.showErrorMessage(`Error saving SVG: ${error}`);
                        }
                    }
                    break;
                case 'saveStyles':
                    // Save styles to global state
                    await context.globalState.update(`iconStyles.${message.iconName}`, message.styles);
                    break;
                case 'showInfo':
                    vscode.window.showInformationMessage(message.message);
                    break;
            }
        }, undefined, context.subscriptions);
    });
    // Command: Show icon details panel
    const showDetailsCmd = vscode.commands.registerCommand('iconManager.showDetails', async (item) => {
        if (!item?.svgContent) {
            vscode.window.showWarningMessage('Select an icon from the tree view');
            return;
        }
        const iconName = typeof item.label === 'string' ? item.label : 'icon';
        const location = item.location;
        const isBuilt = item.contextValue === 'builtIcon';
        const panel = vscode.window.createWebviewPanel('iconDetails', `Details: ${iconName}`, vscode.ViewColumn.One, { enableScripts: true });
        panel.webview.html = (0, webviewHtmlGenerators_1.getIconDetailsHtml)(iconName, item.svgContent, location, isBuilt);
        panel.webview.onDidReceiveMessage(async (message) => {
            switch (message.command) {
                case 'copyName':
                    await vscode.env.clipboard.writeText(message.name);
                    vscode.window.showInformationMessage('Name copied!');
                    break;
                case 'copySvg':
                    await vscode.env.clipboard.writeText(message.svg);
                    vscode.window.showInformationMessage('SVG copied!');
                    break;
                case 'exportSvg':
                    const saveUri = await vscode.window.showSaveDialog({
                        defaultUri: vscode.Uri.file(`${message.iconName}.svg`),
                        filters: { 'SVG Files': ['svg'] }
                    });
                    if (saveUri) {
                        fs.writeFileSync(saveUri.fsPath, message.svg);
                        vscode.window.showInformationMessage(`Exported to ${saveUri.fsPath}`);
                    }
                    break;
                case 'goToLocation':
                    if (message.file && message.line) {
                        const document = await vscode.workspace.openTextDocument(message.file);
                        const editor = await vscode.window.showTextDocument(document);
                        const line = message.line - 1;
                        const range = new vscode.Range(line, 0, line, document.lineAt(line).text.length);
                        editor.selection = new vscode.Selection(range.start, range.end);
                        editor.revealRange(range, vscode.TextEditorRevealType.InCenter);
                    }
                    break;
                case 'openColorEditor':
                    vscode.commands.executeCommand('iconManager.editColors', item);
                    break;
            }
        }, undefined, context.subscriptions);
    });
    // Command: Open icon catalog
    const openCatalogCmd = vscode.commands.registerCommand('iconManager.openCatalog', () => {
        IconCatalogPanel_1.IconCatalogPanel.createOrShow(context.extensionUri, context, iconCatalogService);
    });
    // Command: Generate licenses file
    const generateLicensesCmd = vscode.commands.registerCommand('iconManager.generateLicenses', async () => {
        const licenses = iconCatalogService.generateLicenseFile();
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!outputDir || !workspaceFolder) {
            vscode.window.showWarningMessage('Configure output directory first');
            return;
        }
        const licensePath = path.join(workspaceFolder.uri.fsPath, outputDir, 'ICON_LICENSES.md');
        fs.writeFileSync(licensePath, licenses);
        vscode.window.showInformationMessage(`License file generated at ${licensePath}`);
    });
    // Command: Export as component (React, Vue, Svelte)
    const exportComponentCmd = vscode.commands.registerCommand('iconManager.exportComponent', async (item) => {
        if (!item?.svgContent) {
            vscode.window.showWarningMessage('Select an icon to export');
            return;
        }
        const format = await vscode.window.showQuickPick([
            { label: 'React', value: 'react' },
            { label: 'Vue', value: 'vue' },
            { label: 'Svelte', value: 'svelte' },
            { label: 'Angular', value: 'angular' },
            { label: 'Web Component', value: 'webcomponent' }
        ], { placeHolder: 'Select component format' });
        if (!format)
            return;
        const iconName = typeof item.label === 'string' ? item.label : 'icon';
        const exporter = (0, ComponentExporter_1.getComponentExporter)(format.value);
        const componentCode = exporter.export(iconName, item.svgContent);
        // Show in new document
        const doc = await vscode.workspace.openTextDocument({
            content: componentCode,
            language: format.value === 'vue' ? 'vue' :
                format.value === 'svelte' ? 'svelte' :
                    format.value === 'angular' ? 'typescript' : 'typescriptreact'
        });
        await vscode.window.showTextDocument(doc);
    });
    // Command: Generate sprite sheet
    const generateSpriteCmd = vscode.commands.registerCommand('iconManager.generateSprite', async () => {
        const icons = workspaceSvgProvider.getAllBuiltIcons();
        if (icons.length === 0) {
            vscode.window.showWarningMessage('No icons found in library');
            return;
        }
        const formatChoice = await vscode.window.showQuickPick([
            { label: 'SVG Sprite', value: 'svg' },
            { label: 'CSS Sprite', value: 'css' },
            { label: 'Both', value: 'both' }
        ], { placeHolder: 'Select sprite format' });
        if (!formatChoice)
            return;
        const config = vscode.workspace.getConfiguration('iconManager');
        const outputDir = config.get('outputDirectory', '');
        const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
        if (!outputDir || !workspaceFolder) {
            vscode.window.showWarningMessage('Configure output directory first');
            return;
        }
        const spriteIcons = icons.map(icon => ({
            name: icon.name,
            svg: icon.svg,
            viewBox: icon.viewBox || '0 0 24 24'
        }));
        const generator = (0, SpriteGenerator_1.getSpriteGenerator)(formatChoice.value === 'css' ? 'css' : 'svg');
        const outputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
        if (formatChoice.value === 'svg' || formatChoice.value === 'both') {
            const svgGenerator = (0, SpriteGenerator_1.getSpriteGenerator)('svg');
            const svgSprite = svgGenerator.generate(spriteIcons);
            fs.writeFileSync(path.join(outputPath, 'sprite.svg'), svgSprite);
        }
        if (formatChoice.value === 'css' || formatChoice.value === 'both') {
            const cssGenerator = (0, SpriteGenerator_1.getSpriteGenerator)('css');
            const cssSprite = cssGenerator.generate(spriteIcons);
            fs.writeFileSync(path.join(outputPath, 'icons.css'), cssSprite);
        }
        vscode.window.showInformationMessage(`Sprite generated in ${outputPath}`);
    });
    // Command: Search Iconify and add to collection
    const addSvgToCollectionCmd = vscode.commands.registerCommand('iconManager.addSvgToCollection', async () => {
        const query = await vscode.window.showInputBox({
            prompt: 'Search for icons (e.g., "arrow", "home", "user")',
            placeHolder: 'Enter search term'
        });
        if (!query)
            return;
        // Search Iconify
        const results = await searchIconify(query);
        if (results.length === 0) {
            vscode.window.showInformationMessage(`No icons found for "${query}"`);
            return;
        }
        // Show the results in a webview panel with previews
        showIconPickerPanel(context, results, query, svgTransformer, workspaceSvgProvider);
    });
    context.subscriptions.push(openPanelCmd, scanWorkspaceCmd, scanUsagesCmd, goToUsageCmd, goToInlineSvgCmd, transformInlineSvgCmd, configureProjectCmd, refreshIconsCmd, buildIconsCmd, transformSvgCmd, optimizeSvgCmd, insertIconCmd, previewIconCmd, completionDisposable, hoverDisposable, svgWatcher, codeActionProvider, importSvgToLibraryCmd, checkAndImportSvgCmd, diagnosticProvider, deleteIconsCmd, colorEditorCmd, showDetailsCmd, openCatalogCmd, generateLicensesCmd, exportComponentCmd, generateSpriteCmd, addSvgToCollectionCmd);
}
function deactivate() {
    // Cleanup
}
// ============================================================================
// Helper Functions
// ============================================================================
/**
 * Add import statement if needed (for JS/TS files)
 */
async function addImportIfNeeded(editor, componentName, importPath) {
    const document = editor.document;
    const text = document.getText();
    const languageId = document.languageId;
    // For HTML files, add script tag instead of import
    if (languageId === 'html') {
        await addScriptTagIfNeeded(editor, componentName);
        return;
    }
    // Check if import already exists
    const importRegex = new RegExp(`import.*${componentName}.*from`);
    if (importRegex.test(text))
        return;
    // Find the best position to add import
    const lines = text.split('\n');
    let insertLine = 0;
    for (let i = 0; i < lines.length; i++) {
        const line = lines[i];
        if (line.startsWith('import ')) {
            insertLine = i + 1;
        }
        else if (line.trim() && !line.startsWith('//') && !line.startsWith('/*') && !line.startsWith('*')) {
            break;
        }
    }
    const importStatement = `import { ${componentName} } from '${importPath}';\n`;
    const position = new vscode.Position(insertLine, 0);
    await editor.edit((editBuilder) => {
        editBuilder.insert(position, importStatement);
    });
}
/**
 * Add script tag for Web Component in HTML files
 */
async function addScriptTagIfNeeded(editor, componentName) {
    const document = editor.document;
    const text = document.getText();
    // Check if script already exists
    if (text.includes('icon.js') || text.includes('icons.js'))
        return;
    // Get output directory to create relative path
    const config = vscode.workspace.getConfiguration('iconManager');
    const outputDir = config.get('outputDirectory', 'icons');
    // Calculate relative path from HTML file to icon.js
    const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
    if (!workspaceFolder)
        return;
    const htmlDir = path.dirname(document.uri.fsPath);
    const iconJsPath = path.join(workspaceFolder.uri.fsPath, outputDir, 'icon.js');
    let relativePath = path.relative(htmlDir, iconJsPath).replace(/\\/g, '/');
    // Ensure it starts with ./ for relative imports
    if (!relativePath.startsWith('.') && !relativePath.startsWith('/')) {
        relativePath = './' + relativePath;
    }
    // Find </head> or <body> to insert before
    const headCloseMatch = text.match(/<\/head>/i);
    const bodyOpenMatch = text.match(/<body[^>]*>/i);
    let insertPosition;
    let scriptTag;
    if (headCloseMatch && headCloseMatch.index !== undefined) {
        // Insert before </head>
        const pos = document.positionAt(headCloseMatch.index);
        insertPosition = pos;
        scriptTag = `    <script type="module" src="${relativePath}"></script>\n`;
    }
    else if (bodyOpenMatch && bodyOpenMatch.index !== undefined) {
        // Insert after <body>
        const pos = document.positionAt(bodyOpenMatch.index + bodyOpenMatch[0].length);
        insertPosition = new vscode.Position(pos.line + 1, 0);
        scriptTag = `    <script type="module" src="${relativePath}"></script>\n`;
    }
    else {
        // No good place found, skip
        return;
    }
    await editor.edit((editBuilder) => {
        editBuilder.insert(insertPosition, scriptTag);
    });
}
/**
 * Add icon to icons.ts file
 */
async function addToIconsTs(outputPath, iconName, svgContent, transformer) {
    const iconsPath = path.join(outputPath, 'icons.js');
    const varName = (0, extensionHelpers_1.toVariableName)(iconName);
    const body = transformer.extractSvgBody(svgContent);
    const attrs = transformer.extractSvgAttributes(svgContent);
    const iconEntry = `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${attrs.viewBox || '0 0 24 24'}'
};`;
    if (fs.existsSync(iconsPath)) {
        // Read existing file
        let content = fs.readFileSync(iconsPath, 'utf-8');
        // Check if icon already exists
        if (content.includes(`export const ${varName}`)) {
            // Replace existing
            const regex = new RegExp(`export const ${varName} = \\{[\\s\\S]*?\\};`, 'g');
            content = content.replace(regex, iconEntry);
        }
        else {
            // Find the icons object and add before it
            const iconsObjMatch = content.match(/export const icons = \{/);
            if (iconsObjMatch && iconsObjMatch.index !== undefined) {
                content = content.slice(0, iconsObjMatch.index) + iconEntry + '\n\n' + content.slice(iconsObjMatch.index);
                // Also add to the icons object
                const objContent = content.match(/export const icons = \{([^}]*)\}/);
                if (objContent) {
                    const existingIcons = objContent[1].trim();
                    const newIcons = existingIcons ? `${existingIcons},\n  ${varName}` : `\n  ${varName}\n`;
                    content = content.replace(/export const icons = \{([^}]*)\}/, `export const icons = {${newIcons}}`);
                }
            }
            else {
                // Just append at the end
                content += '\n\n' + iconEntry;
            }
        }
        fs.writeFileSync(iconsPath, content);
    }
    else {
        // Create new file
        const content = `// Auto-generated by Icon Manager
// Do not edit manually

${iconEntry}

export const icons = {
  ${varName}
};
`;
        fs.writeFileSync(iconsPath, content);
    }
    // Also generate the Web Component file (icon.js)
    await generateWebComponent(outputPath);
}
/**
 * Generate the Web Component for HTML usage
 */
async function generateWebComponent(outputPath) {
    const config = vscode.workspace.getConfiguration('iconManager');
    const componentName = config.get('componentName', 'Icon');
    // Convert PascalCase/camelCase to kebab-case for custom element name
    let tagName = componentName
        .replace(/([a-z])([A-Z])/g, '$1-$2')
        .toLowerCase();
    // Custom elements MUST have a hyphen - if none, add prefix
    if (!tagName.includes('-')) {
        tagName = `${tagName}-icon`;
    }
    const componentPath = path.join(outputPath, 'icon.js');
    const content = `// Auto-generated Web Component by Icon Manager
// Usage: <${tagName} name="icon-name"></${tagName}>

import { icons } from './icons.js';

class IconElement extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'size', 'color', 'animation'];
  }

  constructor() {
    super();
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback() {
    this.render();
  }

  render() {
    const name = this.getAttribute('name');
    const size = this.getAttribute('size') || '24';
    const color = this.getAttribute('color') || 'currentColor';
    const animName = this.getAttribute('animation');

    const icon = icons[name];
    if (!icon) {
      this.innerHTML = '';
      return;
    }

    // Process body - replace currentColor with the specified color
    let body = icon.body;
    if (color !== 'currentColor') {
      body = body.replace(/currentColor/g, color);
    }

    // Get animation configuration
    const animConfig = this.getAnimationConfig(animName);

    // Build animation style
    let animStyle = '';
    if (animName && animName !== 'none') {
      const duration = animConfig.duration || 1;
      const timing = animConfig.timing || 'ease';
      const iteration = animConfig.iteration || 'infinite';
      animStyle = \`animation: icon-\${animName} \${duration}s \${timing} \${iteration};\`;
    }

    this.innerHTML = \`
      <svg 
        xmlns="http://www.w3.org/2000/svg" 
        viewBox="\${icon.viewBox}"
        width="\${size}"
        height="\${size}"
        fill="\${color}"
        style="display: inline-block; vertical-align: middle; \${animStyle}"
      >
        \${body}
      </svg>
    \`;
  }

  getAnimationConfig(name) {
    const animations = {
      spin: { duration: 1, timing: 'linear', iteration: 'infinite' },
      pulse: { duration: 1, timing: 'ease-in-out', iteration: 'infinite' },
      bounce: { duration: 0.5, timing: 'ease', iteration: 'infinite' },
      shake: { duration: 0.5, timing: 'ease-in-out', iteration: 'infinite' }
    };
    return animations[name] || {};
  }
}

// Register the custom element
if (!customElements.get('${tagName}')) {
  customElements.define('${tagName}', IconElement);
}

export { IconElement };
`;
    fs.writeFileSync(componentPath, content);
}
/**
 * Add icon to sprite.svg file
 */
async function addToSpriteSvg(outputPath, iconName, svgContent, transformer) {
    const spritePath = path.join(outputPath, 'sprite.svg');
    const body = transformer.extractSvgBody(svgContent);
    const attrs = transformer.extractSvgAttributes(svgContent);
    const symbolEntry = `  <symbol id="${iconName}" viewBox="${attrs.viewBox || '0 0 24 24'}">
    ${body}
  </symbol>`;
    if (fs.existsSync(spritePath)) {
        let content = fs.readFileSync(spritePath, 'utf-8');
        // Check if symbol already exists
        const existingSymbol = new RegExp(`<symbol[^>]*id=["']${iconName}["'][\\s\\S]*?<\\/symbol>`, 'g');
        if (existingSymbol.test(content)) {
            // Replace existing
            content = content.replace(existingSymbol, symbolEntry);
        }
        else {
            // Add before closing </svg>
            content = content.replace('</svg>', `${symbolEntry}\n</svg>`);
        }
        fs.writeFileSync(spritePath, content);
    }
    else {
        // Create new sprite file
        const content = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
${symbolEntry}
</svg>
`;
        fs.writeFileSync(spritePath, content);
    }
}
/**
 * Search icons from Iconify API
 */
async function searchIconify(query) {
    const https = await Promise.resolve().then(() => __importStar(require('https')));
    return new Promise((resolve, reject) => {
        const url = `https://api.iconify.design/search?query=${encodeURIComponent(query)}&limit=50`;
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                try {
                    const result = JSON.parse(data);
                    const icons = [];
                    if (result.icons && Array.isArray(result.icons)) {
                        for (const iconId of result.icons) {
                            const [prefix, name] = iconId.split(':');
                            if (prefix && name) {
                                icons.push({ prefix, name });
                            }
                        }
                    }
                    resolve(icons);
                }
                catch (e) {
                    reject(e);
                }
            });
        }).on('error', reject);
    });
}
/**
 * Fetch SVG from Iconify
 */
async function fetchIconSvg(prefix, name, color) {
    const https = await Promise.resolve().then(() => __importStar(require('https')));
    return new Promise((resolve, reject) => {
        // Use color parameter if provided (for monochrome icons)
        let url = `https://api.iconify.design/${prefix}/${name}.svg`;
        if (color) {
            url += `?color=${encodeURIComponent(color)}`;
        }
        https.get(url, (res) => {
            let data = '';
            res.on('data', chunk => data += chunk);
            res.on('end', () => {
                if (res.statusCode === 200 && data.includes('<svg')) {
                    resolve(data);
                }
                else {
                    resolve(null);
                }
            });
        }).on('error', () => resolve(null));
    });
}
/**
 * Show icon picker panel with previews
 */
function showIconPickerPanel(context, icons, query, svgTransformer, workspaceSvgProvider) {
    const panel = vscode.window.createWebviewPanel('iconPicker', `Icons: ${query}`, vscode.ViewColumn.One, {
        enableScripts: true,
        retainContextWhenHidden: true
    });
    panel.webview.html = (0, iconPickerHtml_1.getIconPickerHtml)(icons, query);
    // Handle messages from the webview
    panel.webview.onDidReceiveMessage(async (message) => {
        if (message.command === 'addIcon') {
            const { prefix, name, color } = message;
            try {
                // Pass color to fetch (only applies to monochrome icons)
                const svg = await fetchIconSvg(prefix, name, color !== '#ffffff' ? color : undefined);
                if (!svg) {
                    vscode.window.showErrorMessage('Failed to fetch icon SVG');
                    return;
                }
                const config = vscode.workspace.getConfiguration('iconManager');
                const outputDir = config.get('outputDirectory', '');
                if (!outputDir) {
                    vscode.window.showWarningMessage('Configure output directory first');
                    return;
                }
                const workspaceFolder = vscode.workspace.workspaceFolders?.[0];
                if (!workspaceFolder)
                    return;
                const fullOutputPath = path.join(workspaceFolder.uri.fsPath, outputDir);
                const iconName = `${prefix}-${name}`;
                await addToIconsTs(fullOutputPath, iconName, svg, svgTransformer);
                workspaceSvgProvider.refresh();
                vscode.window.showInformationMessage(`✅ Icon "${iconName}" added to your library!`);
                // Update panel to show icon was added
                panel.webview.postMessage({ command: 'iconAdded', prefix, name });
            }
            catch (error) {
                vscode.window.showErrorMessage(`Error adding icon: ${error}`);
            }
        }
    }, undefined, context.subscriptions);
}
//# sourceMappingURL=extension.js.map