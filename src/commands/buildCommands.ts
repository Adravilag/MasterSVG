/**
 * Build Commands
 * Commands for building icons library, sprites, and batch operations
 */
import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import type { IconAnimation } from '../types/icons';
import { SvgTransformer } from '../services/SvgTransformer';
import { getSpriteGenerator, SpriteIcon } from '../services/SpriteGenerator';
import { addToIconsJs, addToSpriteSvg, generateWebComponent } from '../utils/iconsFileManager';
import { getConfig, getFullOutputPath, getOutputPathOrWarn, updateIconsJsContext } from '../utils/configHelper';
import { buildIconsFileContent } from '../utils/outputFileManager';

// Interfaces for providers
export interface WorkspaceSvgProviderLike {
  refresh(): void;
  scanInlineSvgs(): Promise<void>;
  getAllIcons(): Promise<Array<{
    name: string;
    svg?: string;
    path?: string;
    animation?: IconAnimation;
  }>>;
  getImgReferences(): Array<{
    name: string;
    svg?: string;
    path?: string;
    filePath?: string;
    line?: number;
    exists?: boolean;
  }>;
}

export interface BuiltIconsProviderLike {
  refresh(): void;
}

export interface SvgFilesProviderLike {
  refresh(): void;
  ensureReady(): Promise<void>;
  getSvgFilesMap(): Map<string, { name: string; svg?: string; path?: string }>;
}

/**
 * Write file using VS Code API to avoid conflicts with open editors
 */
async function writeFileWithVSCode(filePath: string, content: string): Promise<void> {
  const uri = vscode.Uri.file(filePath);
  const encoder = new TextEncoder();
  await vscode.workspace.fs.writeFile(uri, encoder.encode(content));
}

/**
 * Count unique colors in SVG (to detect rasterized images)
 */
function countSvgColors(svg: string): number {
  const colorRegex = /#(?:[0-9a-fA-F]{3,4}){1,2}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)|(?:fill|stroke|stop-color|flood-color|lighting-color)\s*[:=]\s*["']?([a-zA-Z]+)["']?/gi;
  const colors = new Set<string>();
  let match;
  while ((match = colorRegex.exec(svg)) !== null) {
    colors.add(match[0].toLowerCase());
  }
  return colors.size;
}

/**
 * Generate TypeScript types file content
 */
function generateTypesFileContent(iconNames: string[]): string {
  const sortedNames = [...iconNames].sort();
  return `// Auto-generated by Icon Manager
// Do not edit manually

export type IconName = ${sortedNames.map(n => `'${n}'`).join(' | ')};

export const iconNames = [
${sortedNames.map(n => `  '${n}'`).join(',\n')}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
}

/**
 * Registers all build-related commands
 */
export function registerBuildCommands(
  context: vscode.ExtensionContext,
  providers: {
    workspaceSvgProvider: WorkspaceSvgProviderLike;
    builtIconsProvider: BuiltIconsProviderLike;
    svgFilesProvider: SvgFilesProviderLike;
  },
  svgTransformer: SvgTransformer
): vscode.Disposable[] {
  const disposables: vscode.Disposable[] = [];

  // Command: Build All References - transforms all img references to web components
  disposables.push(
    vscode.commands.registerCommand('iconManager.buildAllReferences', async () => {
      const config = getConfig();
      const componentName = config.webComponentName || 'bz-icon';
      const buildFormat = config.buildFormat || 'icons.js';
      
      const imgRefs = providers.workspaceSvgProvider.getImgReferences();
      
      if (!imgRefs || imgRefs.length === 0) {
        vscode.window.showInformationMessage('No IMG references found to transform');
        return;
      }
      
      const validRefs = imgRefs.filter(ref => ref.exists !== false);
      
      if (validRefs.length === 0) {
        vscode.window.showWarningMessage('All IMG references point to missing files');
        return;
      }
      
      const confirm = await vscode.window.showInformationMessage(
        `Transform ${validRefs.length} IMG reference${validRefs.length > 1 ? 's' : ''} to <${componentName}>?`,
        'Yes', 'No'
      );
      
      if (confirm !== 'Yes') return;
      
      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Building references...',
        cancellable: false
      }, async (progress) => {
        let transformed = 0;
        let failed = 0;
        
        const refsByFile = new Map<string, typeof validRefs>();
        for (const ref of validRefs) {
          if (!ref.filePath) continue;
          const list = refsByFile.get(ref.filePath) || [];
          list.push(ref);
          refsByFile.set(ref.filePath, list);
        }
        
        for (const [filePath, refs] of Array.from(refsByFile.entries())) {
          progress.report({ message: `Processing ${path.basename(filePath)}...` });
          
          try {
            const document = await vscode.workspace.openTextDocument(vscode.Uri.file(filePath));
            const edit = new vscode.WorkspaceEdit();
            
            const sortedRefs = [...refs].sort((a, b) => (b.line || 0) - (a.line || 0));
            
            for (const ref of sortedRefs) {
              if (ref.line === undefined || !ref.svg || !ref.path) continue;
              
              const line = document.lineAt(ref.line);
              const lineText = line.text;
              
              const imgRegex = new RegExp(`<img\\s+[^>]*src=["'][^"']*${ref.name.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\.svg["'][^>]*>`, 'gi');
              const match = imgRegex.exec(lineText);
              
              if (match) {
                const startPos = new vscode.Position(ref.line, match.index);
                const endPos = new vscode.Position(ref.line, match.index + match[0].length);
                const range = new vscode.Range(startPos, endPos);
                
                const iconName = ref.name;
                const outputPath = getFullOutputPath();
                
                if (outputPath) {
                  const transformer = new SvgTransformer();
                  if (buildFormat === 'sprite.svg') {
                    await addToSpriteSvg(outputPath, iconName, ref.svg, transformer);
                  } else {
                    await addToIconsJs(outputPath, iconName, ref.svg, transformer);
                  }
                }
                
                const replacement = `<${componentName} name="${iconName}"></${componentName}>`;
                edit.replace(document.uri, range, replacement);
                transformed++;
              }
            }
            
            await vscode.workspace.applyEdit(edit);
            await document.save();
          } catch (err) {
            console.error('[IconWrap] Error transforming references in', filePath, err);
            failed++;
          }
        }
        
        providers.workspaceSvgProvider.refresh();
        providers.builtIconsProvider.refresh();
        
        if (failed > 0) {
          vscode.window.showWarningMessage(`Transformed ${transformed} references. ${failed} file(s) had errors.`);
        } else {
          vscode.window.showInformationMessage(`Successfully transformed ${transformed} IMG reference${transformed > 1 ? 's' : ''} to <${componentName}>`);
        }
      });
    })
  );

  // Command: Build All SVG Files to library
  disposables.push(
    vscode.commands.registerCommand('iconManager.buildAllFiles', async () => {
      const config = getConfig();
      const buildFormat = config.buildFormat || 'icons.js';
      
      await providers.svgFilesProvider.ensureReady();
      
      const svgFilesMap = providers.svgFilesProvider.getSvgFilesMap();
      const allSvgFiles = Array.from(svgFilesMap.values()).filter(icon => icon.path);
      
      if (allSvgFiles.length === 0) {
        vscode.window.showInformationMessage('No SVG files found in workspace');
        return;
      }
      
      const confirm = await vscode.window.showInformationMessage(
        `Build ${allSvgFiles.length} SVG file${allSvgFiles.length > 1 ? 's' : ''} to ${buildFormat}?`,
        'Yes', 'No'
      );
      
      if (confirm !== 'Yes') return;
      
      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Building SVG files...',
        cancellable: false
      }, async (progress) => {
        let built = 0;
        let failed = 0;
        const outputPath = getFullOutputPath();
        
        if (!outputPath) {
          vscode.window.showErrorMessage('Output path not configured');
          return;
        }
        
        const transformer = new SvgTransformer();
        const isIconsJs = buildFormat !== 'sprite.svg';
        
        for (const icon of allSvgFiles) {
          progress.report({ message: `Building ${icon.name}...` });
          
          try {
            let svgContent = icon.svg;
            if (!svgContent && icon.path) {
              svgContent = fs.readFileSync(icon.path, 'utf-8');
            }
            
            if (!svgContent || !icon.name) {
              failed++;
              continue;
            }
            
            if (isIconsJs) {
              await addToIconsJs(outputPath, icon.name, svgContent, transformer, undefined, true);
            } else {
              await addToSpriteSvg(outputPath, icon.name, svgContent, transformer);
            }
            built++;
          } catch (err) {
            console.error('[IconWrap] Error building', icon.name, err);
            failed++;
          }
        }
        
        if (isIconsJs && built > 0) {
          progress.report({ message: 'Generating web component...' });
          await generateWebComponent(outputPath);
        }
        
        const deleteOption = await vscode.window.showInformationMessage(
          `Built ${built} icon${built > 1 ? 's' : ''}. Delete original SVG files?`,
          'Delete All', 'Keep All'
        );
        
        if (deleteOption === 'Delete All') {
          let deleted = 0;
          for (const icon of allSvgFiles) {
            if (icon.path) {
              try {
                await vscode.workspace.fs.delete(vscode.Uri.file(icon.path));
                deleted++;
              } catch (err) {
                console.error('[IconWrap] Error deleting', icon.path, err);
              }
            }
          }
          vscode.window.showInformationMessage(`Deleted ${deleted} original SVG file${deleted > 1 ? 's' : ''}`);
        }
        
        providers.svgFilesProvider.refresh();
        providers.builtIconsProvider.refresh();
        
        if (failed > 0 && deleteOption !== 'Delete All') {
          vscode.window.showWarningMessage(`Built ${built} icons. ${failed} file(s) had errors.`);
        }
      });
    })
  );

  // Command: Build icons library
  disposables.push(
    vscode.commands.registerCommand('iconManager.buildIcons', async () => {
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;

      await vscode.window.withProgress({
        location: vscode.ProgressLocation.Notification,
        title: 'Building icons library...',
        cancellable: false
      }, async (progress) => {
        progress.report({ message: 'Scanning icons...' });
        await providers.workspaceSvgProvider.scanInlineSvgs();
        const icons = await providers.workspaceSvgProvider.getAllIcons();
        
        if (icons.length === 0) {
          vscode.window.showWarningMessage('No icons found to build');
          return;
        }

        progress.report({ message: 'Generating output...' });
        const config = getConfig();
        const webComponentName = config.webComponentName;
        const buildFormat = config.buildFormat || 'icons.ts';

        const MAX_COLORS_FOR_BUILD = 50;

        const iconList: Array<{ name: string; svg: string; animation?: IconAnimation }> = [];
        const processedNames = new Set<string>();
        const skippedIcons: string[] = [];

        for (const icon of icons) {
          if (processedNames.has(icon.name)) continue;

          let svgContent = icon.svg;
          
          if (!svgContent && icon.path && fs.existsSync(icon.path) && icon.path.toLowerCase().endsWith('.svg')) {
            try {
              svgContent = fs.readFileSync(icon.path, 'utf-8');
            } catch (e) {
              console.error(`Failed to read SVG for ${icon.name}`, e);
            }
          }

          if (!svgContent) continue;
          
          const colorCount = countSvgColors(svgContent);
          if (colorCount > MAX_COLORS_FOR_BUILD) {
            skippedIcons.push(`${icon.name} (${colorCount} colors)`);
            continue;
          }
          
          processedNames.add(icon.name);
          iconList.push({ 
            name: icon.name, 
            svg: svgContent,
            animation: icon.animation
          });
        }

        if (buildFormat === 'sprite.svg') {
          const generator = getSpriteGenerator();
          const spriteIcons: SpriteIcon[] = iconList.map(icon => ({
            id: icon.name,
            name: icon.name,
            svg: icon.svg,
            viewBox: undefined
          }));
          
          const result = generator.generate(spriteIcons, { 
            outputPath, 
            generateHelper: true, 
            helperFormat: 'vanilla',
            webComponentName,
            generateTypes: true
          });

          if (result.sprite) {
            await writeFileWithVSCode(path.join(outputPath, 'sprite.svg'), result.sprite);
          }
          if (result.helperComponent) {
            await writeFileWithVSCode(path.join(outputPath, 'icons.js'), result.helperComponent);
          }
          if (result.typeDefinitions) {
            await writeFileWithVSCode(path.join(outputPath, 'icons.d.ts'), result.typeDefinitions);
          }
        } else {
          const iconsContent = buildIconsFileContent(iconList, svgTransformer);
          await writeFileWithVSCode(path.join(outputPath, 'icons.js'), iconsContent);
          
          const webComponent = await generateWebComponent(outputPath);
          await writeFileWithVSCode(webComponent.path, webComponent.content);
          
          const iconNames = iconList.map(i => i.name);
          const typesContent = generateTypesFileContent(iconNames);
          await writeFileWithVSCode(path.join(outputPath, 'icons.d.ts'), typesContent);
        }

        if (skippedIcons.length > 0) {
          vscode.window.showWarningMessage(
            `Skipped ${skippedIcons.length} rasterized SVG(s) with too many colors: ${skippedIcons.slice(0, 3).join(', ')}${skippedIcons.length > 3 ? '...' : ''}`
          );
        }

        providers.workspaceSvgProvider.refresh();
      });
      
      // Update context for icons.js existence
      updateIconsJsContext();
      
      const config = getConfig();
      const formatName = config.buildFormat === 'sprite.svg' ? 'sprite.svg' : 'icons.js';
      vscode.window.showInformationMessage(`Icons library built as ${formatName} in ${outputPath}`);
    })
  );

  return disposables;
}
