import * as vscode from 'vscode';
import * as path from 'node:path';
import * as fs from 'node:fs';
import { promises as fsPromises } from 'node:fs';
import { WorkspaceIcon } from '../../types/icons';
import { reloadIgnorePatterns, shouldIgnorePath } from '../../utils/IgnorePatterns';
import {
  ScannerConfig,
  DEFAULT_SCANNER_CONFIG,
  ProgressCallback,
  ScanResult,
  ScanError,
} from '../../types/scanner';
import { ConcurrentProcessor } from '../../utils/ConcurrentProcessor';

/**
 * Result of scanning a single file for inline SVGs
 * Uses WorkspaceIcon directly for type compatibility with local processing
 */
interface FileScanResult {
  inlineSvgs: Map<string, WorkspaceIcon>;
  imgReferences: WorkspaceIcon[];
  error?: ScanError;
}

/**
 * Scanner for inline SVGs and IMG references in code files
 * Optimized for large projects with concurrent file reading
 */
export class InlineSvgScanner {
  /**
   * File patterns to include in search
   */
  static readonly INCLUDE_PATTERN = '**/*.{tsx,jsx,vue,svelte,astro,html,ts,js}';

  /**
   * File patterns to exclude from search
   */
  static readonly EXCLUDE_PATTERN = '**/node_modules/**';

  /**
   * Generated icon files to skip
   */
  static readonly SKIP_FILES = new Set(['icon.js', 'icons.js', 'icon.ts', 'icons.ts']);

  /**
   * Current scanner configuration
   */
  private static config: ScannerConfig = DEFAULT_SCANNER_CONFIG;

  /**
   * Pre-compiled regex patterns for better performance
   */
  private static readonly SVG_REGEX = /<svg\s[^>]*>[\s\S]*?<\/svg>/gi;
  private static readonly IMG_SVG_REGEX = /<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/gi;
  private static readonly GENERATED_MARKER = 'Auto-generated by MasterSVG';

  /**
   * Configure scanner options
   */
  static configure(config: Partial<ScannerConfig>): void {
    this.config = { ...DEFAULT_SCANNER_CONFIG, ...config };
  }

  /**
   * Reset configuration to defaults
   */
  static resetConfig(): void {
    this.config = DEFAULT_SCANNER_CONFIG;
  }

  /**
   * Scan all code files for inline <svg> elements and <img src="...svg"> references
   * Optimized with concurrent file processing and direct file reading
   */
  static async scanInlineSvgs(
    inlineSvgs: Map<string, WorkspaceIcon>,
    svgReferences: Map<string, WorkspaceIcon[]>,
    builtIcons: Set<string>,
    onProgress?: ProgressCallback
  ): Promise<
    ScanResult<{
      inlineSvgs: Map<string, WorkspaceIcon>;
      svgReferences: Map<string, WorkspaceIcon[]>;
    }>
  > {
    const startTime = Date.now();
    const errors: ScanError[] = [];
    let truncated = false;

    inlineSvgs.clear();
    svgReferences.clear();

    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return {
        items: { inlineSvgs, svgReferences },
        filesScanned: 0,
        itemsFound: 0,
        duration: Date.now() - startTime,
        truncated: false,
        errors: [],
      };
    }

    // Reload ignore patterns before scanning
    reloadIgnorePatterns();

    onProgress?.({ phase: 'preparing', processed: 0 });

    // Search for files containing potential SVGs
    const files = await vscode.workspace.findFiles(
      this.INCLUDE_PATTERN,
      this.EXCLUDE_PATTERN,
      this.config.maxFiles
    );

    if (files.length >= this.config.maxFiles) {
      truncated = true;
    }

    // Filter files that should be ignored (quick filter before processing)
    const filesToProcess = files.filter(file => {
      if (shouldIgnorePath(file.fsPath)) return false;
      const fileName = path.basename(file.fsPath);
      if (this.SKIP_FILES.has(fileName)) return false;
      return true;
    });

    onProgress?.({
      phase: 'scanning',
      processed: 0,
      total: filesToProcess.length,
      percentage: 0,
    });

    const workspaceRoot = workspaceFolders[0].uri.fsPath;

    // Process files concurrently with batching for memory efficiency
    const results = await ConcurrentProcessor.processBatches<vscode.Uri, FileScanResult | null>({
      items: filesToProcess,
      processor: async file => this.processFileOptimized(file, workspaceRoot, builtIcons),
      batchSize: this.config.batchSize,
      concurrency: this.config.concurrencyLimit,
      onBatchComplete: (batchIndex: number, _totalBatches: number) => {
        const processed = Math.min(batchIndex * this.config.batchSize, filesToProcess.length);
        onProgress?.({
          phase: 'processing',
          processed,
          total: filesToProcess.length,
          percentage: Math.round((processed / filesToProcess.length) * 100),
        });
      },
    });

    // Merge results
    for (const result of results) {
      if (!result) continue;

      if (result.error) {
        errors.push(result.error);
      }

      // Merge inline SVGs
      for (const [key, value] of result.inlineSvgs) {
        inlineSvgs.set(key, value);
      }

      // Merge IMG references
      if (result.imgReferences.length > 0) {
        const filePath = result.imgReferences[0].filePath!;
        svgReferences.set(filePath, result.imgReferences);
      }
    }

    onProgress?.({
      phase: 'complete',
      processed: filesToProcess.length,
      total: filesToProcess.length,
      percentage: 100,
    });

    return {
      items: { inlineSvgs, svgReferences },
      filesScanned: filesToProcess.length,
      itemsFound: inlineSvgs.size + svgReferences.size,
      duration: Date.now() - startTime,
      truncated,
      errors,
    };
  }

  /**
   * Process a single file optimized - uses direct file reading instead of VS Code document API
   */
  private static async processFileOptimized(
    file: vscode.Uri,
    workspaceRoot: string,
    builtIcons: Set<string>
  ): Promise<FileScanResult | null> {
    const result: FileScanResult = {
      inlineSvgs: new Map(),
      imgReferences: [],
    };

    try {
      // Read file directly for better performance
      const text = await fsPromises.readFile(file.fsPath, 'utf-8');

      // Skip files that look like generated icon files (quick check)
      if (text.includes(this.GENERATED_MARKER)) {
        return null;
      }

      // Find all <svg...>...</svg> patterns (inline SVGs)
      this.extractInlineSvgsOptimized(text, file, result.inlineSvgs, builtIcons);

      // Find all <img src="...svg"> references
      this.extractImgReferencesOptimized(text, file, result.imgReferences, workspaceRoot);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      result.error = {
        filePath: file.fsPath,
        message: errorMessage,
        code: (error as NodeJS.ErrnoException).code,
      };
    }

    return result;
  }

  /**
   * Extract inline SVGs from text content (optimized - no document API)
   */
  private static extractInlineSvgsOptimized(
    text: string,
    file: vscode.Uri,
    inlineSvgs: Map<string, WorkspaceIcon>,
    builtIcons: Set<string>
  ): void {
    // Reset regex lastIndex for reuse
    this.SVG_REGEX.lastIndex = 0;

    let match;
    while ((match = this.SVG_REGEX.exec(text)) !== null) {
      const svgContent = match[0];

      // Skip template literals like ${icon.body}
      if (svgContent.includes('${')) {
        continue;
      }

      // Skip sprite references (<use href="#icon-..."> or <use xlink:href="#...">)
      // These are references to icons in sprite.svg, not actual inline SVGs
      if (/<use\s+[^>]*(href|xlink:href)=["']#/i.test(svgContent)) {
        continue;
      }

      // Skip dynamic Angular SVGs with bindings or control flow
      // [attr.width], [attr.height], @switch, @case, @if, @for, etc.
      if (/\[attr\.|\[ngClass\]|\[ngStyle\]|@switch|@case|@if|@for|@default/.test(svgContent)) {
        continue;
      }

      // Calculate line number efficiently
      const textBeforeMatch = text.substring(0, match.index);
      const lineNumber = (textBeforeMatch.match(/\n/g) || []).length;
      const lastNewlineIndex = textBeforeMatch.lastIndexOf('\n');
      const columnNumber = match.index - lastNewlineIndex - 1;

      // Calculate end position
      const fullMatchText = text.substring(0, match.index + match[0].length);
      const endLineNumber = (fullMatchText.match(/\n/g) || []).length;
      const lastNewlineInMatch = fullMatchText.lastIndexOf('\n');
      const endColumnNumber = match.index + match[0].length - lastNewlineInMatch - 1;

      // Try to extract a name from id, class, aria-label, or nearby context
      const iconName = this.extractSvgNameFromText(svgContent, text, lineNumber);

      // Make name unique by adding file and index
      const fileBaseName = path.basename(file.fsPath, path.extname(file.fsPath));
      const uniqueKey = `${fileBaseName}:${iconName}:${lineNumber}`;

      inlineSvgs.set(uniqueKey, {
        name: iconName,
        path: file.fsPath,
        source: 'inline',
        category: 'icons',
        svg: svgContent,
        filePath: file.fsPath,
        line: lineNumber,
        column: columnNumber,
        endLine: endLineNumber,
        endColumn: endColumnNumber,
        isBuilt: builtIcons.has(iconName),
      });
    }
  }

  /**
   * Extract SVG name from content and surrounding text (optimized - no document API)
   */
  private static extractSvgNameFromText(
    svgContent: string,
    fullText: string,
    lineNumber: number
  ): string {
    // Try to extract from id attribute
    const idMatch = svgContent.match(/id=["']([^"']+)["']/);
    if (idMatch) return this.cleanName(idMatch[1]);

    // Try to extract from aria-label
    const ariaMatch = svgContent.match(/aria-label=["']([^"']+)["']/);
    if (ariaMatch) return this.cleanName(ariaMatch[1]);

    // Try to extract from data-icon, data-name, or data-testid
    const dataMatch = svgContent.match(/data-(?:icon|name|testid)=["']([^"']+)["']/i);
    if (dataMatch) return this.cleanName(dataMatch[1]);

    // Try to extract from <title> element inside SVG
    const titleMatch = svgContent.match(/<title>([^<]+)<\/title>/i);
    if (titleMatch) return this.cleanName(titleMatch[1]);

    // Try to extract from class name that looks like icon name
    const classMatch = svgContent.match(/class=["']([^"']*icon[^"']*)["']/i);
    if (classMatch) {
      const iconClass = classMatch[1].split(/\s+/).find(c => c.includes('icon'));
      if (iconClass) {
        const cleaned = iconClass.replace(/icon-?/i, '');
        if (cleaned) return this.cleanName(cleaned);
      }
    }

    const lines = fullText.split('\n');

    // Try to look at the line above for variable assignment or component name
    if (lineNumber > 0 && lineNumber <= lines.length) {
      const prevLine = lines[lineNumber - 1];

      // Check for variable assignment: const CheckIcon = ...
      const varMatch = prevLine.match(/(?:const|let|var)\s+(\w+Icon|\w+Svg)\s*=/i);
      if (varMatch) return this.cleanName(varMatch[1].replace(/Icon$|Svg$/i, ''));

      // Check for HTML comment: <!-- check icon -->
      const commentMatch = prevLine.match(/<!--\s*([^-]+?)\s*(?:icon)?\s*-->/i);
      if (commentMatch) return this.cleanName(commentMatch[1]);
    }

    // Try to find parent component name (React/Vue style): <CheckIcon>, <IconCheck>
    const svgStartIndex = fullText.lastIndexOf('<svg', fullText.indexOf(svgContent));
    if (svgStartIndex > 0) {
      const textBefore = fullText.substring(Math.max(0, svgStartIndex - 200), svgStartIndex);
      // Look for component opening tag: <CheckIcon or <Icon.Check
      const componentMatch = textBefore.match(/<([A-Z][a-zA-Z]*(?:Icon|Svg)|Icon\.([A-Z][a-zA-Z]*))[^>]*>\s*$/i);
      if (componentMatch) {
        const name = componentMatch[2] || componentMatch[1];
        return this.cleanName(name.replace(/Icon$|Svg$/i, ''));
      }
    }

    // Try to infer from path d attribute (common shapes)
    const pathMatch = svgContent.match(/d=["']([^"']+)["']/);
    if (pathMatch) {
      const pathName = this.inferNameFromPath(pathMatch[1]);
      if (pathName) return pathName;
    }

    // Default to svg-{line}
    return `svg-${lineNumber + 1}`;
  }

  /**
   * Clean a string to be a valid icon name
   */
  private static cleanName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '')
      .substring(0, 50) || 'icon';
  }

  /**
   * Try to infer icon name from SVG path data
   */
  private static inferNameFromPath(pathData: string): string | null {
    const normalized = pathData.toLowerCase();

    // Common checkmark patterns
    if (/m\s*5.*l\s*4\s*4.*l.*7|m.*l.*4\s*4.*19\s*7/i.test(pathData)) {
      return 'check';
    }

    // X/close patterns (two crossing lines)
    if (/m\s*6.*18.*m\s*6.*6.*18/i.test(pathData) || /m.*6\s*6.*18\s*18.*m.*6\s*18.*18\s*6/i.test(pathData)) {
      return 'close';
    }

    // Arrow patterns
    if (normalized.includes('arrow') || /m.*12.*l.*-?[48].*-?[48]/i.test(pathData)) {
      if (pathData.includes('-4') && !pathData.includes('4 4')) return 'arrow-left';
      if (pathData.includes('4 4') || pathData.includes('4,4')) return 'arrow-right';
    }

    // Plus pattern
    if (/m\s*12\s*5.*v\s*14.*m\s*5\s*12.*h\s*14/i.test(pathData)) {
      return 'plus';
    }

    // Minus pattern
    if (/m\s*5\s*12.*h\s*14/i.test(pathData) && !/v/i.test(pathData)) {
      return 'minus';
    }

    // Adjustments/sliders pattern (horizontal lines with circles - Heroicons adjustments)
    // Pattern: M10.5 6h9.75M10.5 6a1.5... multiple horizontal lines at y=6, 12, 18
    if (/M\d+\.?\d*\s*6.*M\d+\.?\d*\s*6a.*M.*12.*M.*18|h\d+.*m.*h\d+.*m.*h\d+/i.test(pathData)) {
      return 'adjustments';
    }

    // Menu/hamburger pattern (3 horizontal lines)
    if (/M3.*h18.*M3.*12.*h18.*M3.*h18|m\s*4\s*6.*h\s*16.*m.*h\s*16.*m.*h\s*16/i.test(pathData)) {
      return 'menu';
    }

    // Search/magnifier pattern (circle + line)
    if (/M21\s*21.*l.*-5.*-5|circle.*line|m.*10.*a.*8.*8/i.test(pathData)) {
      return 'search';
    }

    // Home pattern
    if (/M3\s*12.*l.*9.*-9.*9.*9|m.*10.*20.*v.*-6.*h.*4.*v.*6/i.test(pathData)) {
      return 'home';
    }

    // User/person pattern (circle head + body path)
    if (/M15\.75\s*6.*a.*3\.75|M17\.982.*15\.75.*a.*9/i.test(pathData)) {
      return 'user';
    }

    // Cog/settings pattern (gear with circle in center)
    if (/M9\.594.*3\.94|M10\.343.*3\.94|cog|gear/i.test(pathData)) {
      return 'settings';
    }

    // Heart pattern
    if (/M21\s*8\.25.*c.*0.*-3.*-2\.25|M11\.645.*20\.91/i.test(pathData)) {
      return 'heart';
    }

    // Star pattern
    if (/M11\.48.*3\.499|M12\s*2.*l.*3\.09.*6\.26/i.test(pathData)) {
      return 'star';
    }

    // Trash/delete pattern
    if (/M14\.74\s*9.*l.*-0\.346.*9|M19\s*7.*l.*-0\.867/i.test(pathData)) {
      return 'trash';
    }

    // Edit/pencil pattern
    if (/M16\.862.*4\.487|m.*16\.862.*4\.487|M11\s*5.*H6.*a.*2/i.test(pathData)) {
      return 'edit';
    }

    return null;
  }

  /**
   * Extract IMG references from text content (optimized)
   */
  private static extractImgReferencesOptimized(
    text: string,
    file: vscode.Uri,
    imgReferences: WorkspaceIcon[],
    workspaceRoot: string
  ): void {
    // Reset regex lastIndex for reuse
    this.IMG_SVG_REGEX.lastIndex = 0;

    let match;
    while ((match = this.IMG_SVG_REGEX.exec(text)) !== null) {
      const svgPath = match[1];

      // Calculate line number
      const textBeforeMatch = text.substring(0, match.index);
      const lineNumber = (textBeforeMatch.match(/\n/g) || []).length;
      const lastNewlineIndex = textBeforeMatch.lastIndexOf('\n');
      const columnNumber = match.index - lastNewlineIndex - 1;

      // Extract icon name from path
      const iconName = path.basename(svgPath, '.svg');

      // Try to resolve the actual SVG file path
      let resolvedPath = svgPath;
      let svgContent: string | undefined;

      if (svgPath.startsWith('./') || svgPath.startsWith('../')) {
        const fileDir = path.dirname(file.fsPath);
        resolvedPath = path.resolve(fileDir, svgPath);

        if (!fs.existsSync(resolvedPath)) {
          const cleanPath = svgPath.replace(/^\.\//, '');
          const rootPath = path.join(workspaceRoot, cleanPath);
          if (fs.existsSync(rootPath)) {
            resolvedPath = rootPath;
          }
        }
      } else if (!path.isAbsolute(svgPath)) {
        resolvedPath = path.join(workspaceRoot, svgPath);
      }

      // Read actual SVG content if file exists
      const fileExists = fs.existsSync(resolvedPath);
      if (fileExists) {
        try {
          svgContent = fs.readFileSync(resolvedPath, 'utf-8');
        } catch {
          // Silent fail - content will be undefined
        }
      }

      imgReferences.push({
        name: iconName,
        path: resolvedPath,
        source: 'inline',
        category: 'img-ref',
        svg: svgContent,
        filePath: file.fsPath,
        line: lineNumber,
        column: columnNumber,
        exists: fileExists,
      });
    }
  }

  /**
   * Extract SVG name from content and context
   * @deprecated Use extractSvgNameFromText instead
   */
  static extractSvgName(svgContent: string, document: vscode.TextDocument, line: number): string {
    return this.extractSvgNameFromText(svgContent, document.getText(), line);
  }

  /**
   * Get current scanner configuration
   */
  static getConfig(): Readonly<ScannerConfig> {
    return { ...this.config };
  }

  /**
   * Legacy method for backward compatibility - wraps to new implementation
   * @deprecated Use extractInlineSvgsOptimized instead
   */
  static extractInlineSvgs(
    document: vscode.TextDocument,
    text: string,
    file: vscode.Uri,
    inlineSvgs: Map<string, WorkspaceIcon>,
    builtIcons: Set<string>
  ): void {
    this.extractInlineSvgsOptimized(text, file, inlineSvgs, builtIcons);
  }

  /**
   * Legacy method for backward compatibility - wraps to new implementation
   * @deprecated Use extractImgReferencesOptimized instead
   */
  static extractImgReferences(
    document: vscode.TextDocument,
    text: string,
    file: vscode.Uri,
    svgReferences: Map<string, WorkspaceIcon[]>,
    workspaceRoot: string
  ): void {
    const imgReferences: WorkspaceIcon[] = [];
    this.extractImgReferencesOptimized(text, file, imgReferences, workspaceRoot);
    if (imgReferences.length > 0) {
      svgReferences.set(file.fsPath, imgReferences);
    }
  }
}
