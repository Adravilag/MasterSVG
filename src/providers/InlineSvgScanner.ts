import * as vscode from 'vscode';
import * as path from 'path';
import * as fs from 'fs';
import { WorkspaceIcon } from '../types/icons';
import { reloadIgnorePatterns, shouldIgnorePath } from './IgnorePatterns';

/**
 * Scanner for inline SVGs and IMG references in code files
 */
export class InlineSvgScanner {
  /**
   * File patterns to include in search
   */
  static readonly INCLUDE_PATTERN = '**/*.{tsx,jsx,vue,svelte,astro,html,ts,js}';

  /**
   * File patterns to exclude from search
   */
  static readonly EXCLUDE_PATTERN = '**/node_modules/**';

  /**
   * Generated icon files to skip
   */
  static readonly SKIP_FILES = ['icon.js', 'icons.js', 'icon.ts', 'icons.ts'];

  /**
   * Scan all code files for inline <svg> elements and <img src="...svg"> references
   */
  static async scanInlineSvgs(
    inlineSvgs: Map<string, WorkspaceIcon>,
    svgReferences: Map<string, WorkspaceIcon[]>,
    builtIcons: Set<string>
  ): Promise<void> {
    inlineSvgs.clear();
    svgReferences.clear();
    console.log('[Icon Studio] Scanning for inline SVGs and SVG references...');

    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders) return;

    // Reload ignore patterns before scanning
    reloadIgnorePatterns();

    // Search for files containing <svg
    const files = await vscode.workspace.findFiles(
      this.INCLUDE_PATTERN,
      this.EXCLUDE_PATTERN
    );

    for (const file of files) {
      try {
        // Check if file should be ignored
        if (shouldIgnorePath(file.fsPath)) {
          console.log('[Icon Studio] Ignoring file (svgignore):', file.fsPath);
          continue;
        }

        const fileName = path.basename(file.fsPath);
        
        // Skip generated icon files to avoid circular detection
        if (this.SKIP_FILES.includes(fileName)) {
          continue;
        }

        const document = await vscode.workspace.openTextDocument(file);
        const text = document.getText();
        
        // Skip files that look like generated icon files
        if (text.includes('Auto-generated by Icon Studio')) {
          continue;
        }
        
        // Find all <svg...>...</svg> patterns (inline SVGs)
        this.extractInlineSvgs(document, text, file, inlineSvgs, builtIcons);

        // Find all <img src="...svg"> references
        this.extractImgReferences(document, text, file, svgReferences, workspaceFolders[0].uri.fsPath);
      } catch (error) {
        console.error(`Error scanning file ${file.fsPath}:`, error);
      }
    }

    console.log('[Icon Studio] Found inline SVGs:', inlineSvgs.size);
    console.log('[Icon Studio] Found files with SVG references:', svgReferences.size);
  }

  /**
   * Extract inline SVGs from document
   */
  static extractInlineSvgs(
    document: vscode.TextDocument,
    text: string,
    file: vscode.Uri,
    inlineSvgs: Map<string, WorkspaceIcon>,
    builtIcons: Set<string>
  ): void {
    const svgRegex = /<svg\s[^>]*>[\s\S]*?<\/svg>/gi;
    let match;

    while ((match = svgRegex.exec(text)) !== null) {
      const svgContent = match[0];
      
      // Skip template literals like ${icon.body}
      if (svgContent.includes('${')) {
        continue;
      }
      
      const startPos = document.positionAt(match.index);
      const endPos = document.positionAt(match.index + match[0].length);
      
      // Try to extract a name from id, class, aria-label, or nearby context
      const iconName = this.extractSvgName(svgContent, document, startPos.line);
      
      // Make name unique by adding file and index
      const fileBaseName = path.basename(file.fsPath, path.extname(file.fsPath));
      const uniqueKey = `${fileBaseName}:${iconName}:${startPos.line}`;
      
      inlineSvgs.set(uniqueKey, {
        name: iconName,
        path: file.fsPath,
        source: 'inline',
        category: 'icons',
        svg: svgContent,
        filePath: file.fsPath,
        line: startPos.line,
        column: startPos.character,
        endLine: endPos.line,
        endColumn: endPos.character,
        isBuilt: builtIcons.has(iconName)
      });
    }
  }

  /**
   * Extract IMG references from document
   */
  static extractImgReferences(
    document: vscode.TextDocument,
    text: string,
    file: vscode.Uri,
    svgReferences: Map<string, WorkspaceIcon[]>,
    workspaceRoot: string
  ): void {
    const imgSvgRegex = /<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/gi;
    const fileReferences: WorkspaceIcon[] = [];
    let match;
    
    while ((match = imgSvgRegex.exec(text)) !== null) {
      const svgPath = match[1];
      const startPos = document.positionAt(match.index);
      
      // Extract icon name from path
      const iconName = path.basename(svgPath, '.svg');
      
      // Try to resolve the actual SVG file path
      let resolvedPath = svgPath;
      let svgContent: string | undefined;
      
      if (svgPath.startsWith('./') || svgPath.startsWith('../')) {
        // First try relative to the file
        const fileDir = path.dirname(file.fsPath);
        resolvedPath = path.resolve(fileDir, svgPath);
        
        // If not found, try relative to workspace root
        if (!fs.existsSync(resolvedPath)) {
          const cleanPath = svgPath.replace(/^\.\//, '');
          const rootPath = path.join(workspaceRoot, cleanPath);
          if (fs.existsSync(rootPath)) {
            resolvedPath = rootPath;
          }
        }
      } else if (!path.isAbsolute(svgPath)) {
        // Path without ./ prefix - try from workspace root
        resolvedPath = path.join(workspaceRoot, svgPath);
      }
      
      // Read actual SVG content if file exists
      if (fs.existsSync(resolvedPath)) {
        try {
          svgContent = fs.readFileSync(resolvedPath, 'utf-8');
        } catch (err) {
          console.error('[Icon Studio] Error reading SVG file:', resolvedPath, err);
        }
      }
      
      const fileExists = fs.existsSync(resolvedPath);
      fileReferences.push({
        name: iconName,
        path: resolvedPath,
        source: 'inline',
        category: 'img-ref',
        svg: svgContent,
        filePath: file.fsPath,
        line: startPos.line,
        column: startPos.character,
        exists: fileExists
      });
    }
    
    if (fileReferences.length > 0) {
      svgReferences.set(file.fsPath, fileReferences);
    }
  }

  /**
   * Extract SVG name from content and context
   */
  static extractSvgName(svgContent: string, document: vscode.TextDocument, line: number): string {
    // Try to extract from id attribute
    const idMatch = svgContent.match(/id=["']([^"']+)["']/);
    if (idMatch) return idMatch[1];

    // Try to extract from aria-label
    const ariaMatch = svgContent.match(/aria-label=["']([^"']+)["']/);
    if (ariaMatch) return ariaMatch[1].toLowerCase().replace(/\s+/g, '-');

    // Try to extract from class name that looks like icon name
    const classMatch = svgContent.match(/class=["']([^"']*icon[^"']*)["']/i);
    if (classMatch) {
      const iconClass = classMatch[1].split(/\s+/).find(c => c.includes('icon'));
      if (iconClass) return iconClass.replace(/icon-?/i, '') || 'icon';
    }

    // Try to look at the line above for variable assignment or component name
    if (line > 0) {
      const prevLine = document.lineAt(line - 1).text;
      const varMatch = prevLine.match(/(?:const|let|var)\s+(\w+Icon|\w+Svg)\s*=/i);
      if (varMatch) return varMatch[1].replace(/Icon$|Svg$/i, '').toLowerCase();
    }

    // Default to svg-{line}
    return `svg-${line + 1}`;
  }
}

