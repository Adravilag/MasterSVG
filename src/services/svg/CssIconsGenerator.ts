/**
 * CssIconsGenerator - Generates CSS-based icon systems
 *
 * Produces a CSS file where each icon is a class using CSS mask-image
 * with data URIs. Monocolor icons inherit `currentColor` via mask,
 * while multicolor icons use background-image.
 *
 * This is the most lightweight output format:
 * - Zero JS runtime required
 * - Icons inherit font color and size from parent
 * - Compatible with any framework
 * - Works with CSS purging/tree-shaking tools
 */

import * as path from 'path';
import * as fs from 'fs';

// ═══════════════════════════════════════════════════════════
// TYPES
// ═══════════════════════════════════════════════════════════

export interface CssIcon {
  /** Icon identifier (used as CSS class suffix) */
  name: string;
  /** Full SVG content */
  svg: string;
  /** Optional viewBox override */
  viewBox?: string;
}

export interface CssIconsOptions {
  /** Output directory path */
  outputPath: string;
  /** CSS class prefix (default: 'icon') */
  prefix?: string;
  /** Output filename without extension (default: 'icons') */
  filename?: string;
  /** Generate TypeScript definitions (default: true) */
  generateTypes?: boolean;
  /** Include CSS custom properties for customization (default: true) */
  includeCustomProperties?: boolean;
  /** Default icon size (default: '1em') */
  defaultSize?: string;
  /** Generate minified CSS (default: false) */
  minify?: boolean;
}

export interface CssIconsResult {
  /** Generated CSS content */
  css: string;
  /** Icon class names generated */
  classNames: string[];
  /** TypeScript definitions if requested */
  typeDefinitions?: string;
  /** Stats about the generation */
  stats: CssIconsStats;
}

export interface CssIconsStats {
  /** Total number of icons processed */
  totalIcons: number;
  /** Number of monocolor icons (using mask-image) */
  monoColorIcons: number;
  /** Number of multicolor icons (using background-image) */
  multiColorIcons: number;
  /** Total CSS size in bytes */
  totalSize: number;
}

// ═══════════════════════════════════════════════════════════
// GENERATOR
// ═══════════════════════════════════════════════════════════

export class CssIconsGenerator {
  /**
   * Generate CSS icon system from multiple SVG icons
   */
  generate(icons: CssIcon[], options: CssIconsOptions): CssIconsResult {
    const prefix = options.prefix || 'icon';
    const defaultSize = options.defaultSize || '1em';
    const includeCustomProps = options.includeCustomProperties !== false;

    const classNames: string[] = [];
    const rules: string[] = [];
    let monoColorCount = 0;
    let multiColorCount = 0;

    // Base class with shared styles
    const baseClass = this.generateBaseClass(prefix, defaultSize, includeCustomProps);
    rules.push(baseClass);

    for (const icon of icons) {
      const className = this.sanitizeClassName(icon.name);
      classNames.push(`${prefix}-${className}`);

      const isMultiColor = this.isMultiColorSvg(icon.svg);
      const dataUri = this.svgToDataUri(icon.svg);

      if (isMultiColor) {
        rules.push(this.generateMultiColorRule(prefix, className, dataUri));
        multiColorCount++;
      } else {
        rules.push(this.generateMonoColorRule(prefix, className, dataUri));
        monoColorCount++;
      }
    }

    const css = options.minify
      ? this.minifyCss(rules.join('\n\n'))
      : rules.join('\n\n') + '\n';

    const result: CssIconsResult = {
      css,
      classNames,
      stats: {
        totalIcons: icons.length,
        monoColorIcons: monoColorCount,
        multiColorIcons: multiColorCount,
        totalSize: css.length,
      },
    };

    if (options.generateTypes !== false) {
      result.typeDefinitions = this.generateTypeDefinitions(classNames, prefix);
    }

    return result;
  }

  /**
   * Generate CSS and save to files
   */
  async generateAndSave(icons: CssIcon[], options: CssIconsOptions): Promise<CssIconsResult> {
    const result = this.generate(icons, options);

    const outputDir = options.outputPath;
    const filename = options.filename || 'icons';

    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Save CSS
    const cssPath = path.join(outputDir, `${filename}.css`);
    fs.writeFileSync(cssPath, result.css, 'utf-8');

    // Save TypeScript definitions
    if (result.typeDefinitions) {
      const typesPath = path.join(outputDir, `${filename}.css.d.ts`);
      fs.writeFileSync(typesPath, result.typeDefinitions, 'utf-8');
    }

    return result;
  }

  /**
   * Generate the base CSS class with shared icon styles
   */
  private generateBaseClass(prefix: string, defaultSize: string, includeCustomProps: boolean): string {
    if (includeCustomProps) {
      return `/* Auto-generated by MasterSVG - CSS Icons */
/* Do not edit manually */

:root {
  --${prefix}-size: ${defaultSize};
  --${prefix}-color: currentColor;
}

.${prefix} {
  display: inline-block;
  width: var(--${prefix}-size);
  height: var(--${prefix}-size);
  vertical-align: middle;
  content: '';
}`;
    }

    return `/* Auto-generated by MasterSVG - CSS Icons */
/* Do not edit manually */

.${prefix} {
  display: inline-block;
  width: ${defaultSize};
  height: ${defaultSize};
  vertical-align: middle;
  content: '';
}`;
  }

  /**
   * Generate CSS rule for a monocolor icon (uses mask-image for currentColor inheritance)
   */
  private generateMonoColorRule(prefix: string, className: string, dataUri: string): string {
    return `.${prefix}-${className} {
  background-color: currentColor;
  mask-image: url("${dataUri}");
  mask-size: 100% 100%;
  mask-repeat: no-repeat;
  -webkit-mask-image: url("${dataUri}");
  -webkit-mask-size: 100% 100%;
  -webkit-mask-repeat: no-repeat;
}`;
  }

  /**
   * Generate CSS rule for a multicolor icon (uses background-image to preserve colors)
   */
  private generateMultiColorRule(prefix: string, className: string, dataUri: string): string {
    return `.${prefix}-${className} {
  background-image: url("${dataUri}");
  background-size: 100% 100%;
  background-repeat: no-repeat;
  background-color: transparent;
}`;
  }

  /**
   * Check if an SVG contains multiple colors (fill/stroke with different values)
   */
  isMultiColorSvg(svg: string): boolean {
    // Remove the outer <svg> attributes to focus on content
    const innerMatch = svg.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    const content = innerMatch ? innerMatch[1] : svg;

    // Collect unique fill colors (excluding 'none', 'currentColor', and inherited)
    const fillColors = new Set<string>();
    const strokeColors = new Set<string>();

    const fillRegex = /fill\s*[:=]\s*["']?([^"';}\s]+)/gi;
    const strokeRegex = /stroke\s*[:=]\s*["']?([^"';}\s]+)/gi;

    let match: RegExpExecArray | null;

    while ((match = fillRegex.exec(content)) !== null) {
      const color = match[1].toLowerCase().trim();
      if (color !== 'none' && color !== 'currentcolor' && color !== 'inherit') {
        fillColors.add(color);
      }
    }

    while ((match = strokeRegex.exec(content)) !== null) {
      const color = match[1].toLowerCase().trim();
      if (color !== 'none' && color !== 'currentcolor' && color !== 'inherit') {
        strokeColors.add(color);
      }
    }

    // Also check style blocks for color declarations
    const styleRegex = /<style[^>]*>([\s\S]*?)<\/style>/gi;
    while ((match = styleRegex.exec(content)) !== null) {
      const styleContent = match[1];
      const colorRegex = /(?:fill|stroke)\s*:\s*([^;}\s]+)/gi;
      let colorMatch: RegExpExecArray | null;
      while ((colorMatch = colorRegex.exec(styleContent)) !== null) {
        const color = colorMatch[1].toLowerCase().trim();
        if (color !== 'none' && color !== 'currentcolor' && color !== 'inherit') {
          fillColors.add(color);
        }
      }
    }

    const allColors = new Set([...fillColors, ...strokeColors]);
    return allColors.size > 1;
  }

  /**
   * Convert SVG string to an optimized data URI
   */
  svgToDataUri(svg: string): string {
    // Ensure the SVG has xmlns
    let cleanSvg = svg.trim();
    if (!cleanSvg.includes('xmlns=')) {
      cleanSvg = cleanSvg.replace('<svg', '<svg xmlns="http://www.w3.org/2000/svg"');
    }

    // Mini-optimize: remove unnecessary whitespace
    cleanSvg = cleanSvg
      .replace(/\s+/g, ' ')
      .replace(/> </g, '><')
      .replace(/\s*\/>/g, '/>')
      .trim();

    // Encode for data URI (using encodeURIComponent is smaller than base64 for SVGs)
    const encoded = cleanSvg
      .replace(/"/g, "'")
      .replace(/%/g, '%25')
      .replace(/#/g, '%23')
      .replace(/{/g, '%7B')
      .replace(/}/g, '%7D')
      .replace(/</g, '%3C')
      .replace(/>/g, '%3E');

    return `data:image/svg+xml,${encoded}`;
  }

  /**
   * Generate TypeScript type definitions for CSS icon classes
   */
  private generateTypeDefinitions(classNames: string[], prefix: string): string {
    const sortedNames = [...classNames].sort();
    const iconNames = sortedNames.map(cn => cn.replace(`${prefix}-`, ''));

    return `// Auto-generated by MasterSVG - CSS Icons
// Do not edit manually

export type IconName = ${iconNames.map(n => `'${n}'`).join(' | ')};

export const iconNames = [
${iconNames.map(n => `  '${n}'`).join(',\n')}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Get the CSS class name for an icon
 */
export function getIconClass(name: IconName): string {
  return '${prefix}-' + name;
}

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
  }

  /**
   * Minify CSS by removing whitespace and comments
   */
  private minifyCss(css: string): string {
    return css
      .replace(/\/\*[\s\S]*?\*\//g, '')  // Remove comments
      .replace(/\s*\n\s*/g, '')          // Remove newlines
      .replace(/\s*{\s*/g, '{')          // Compact braces
      .replace(/\s*}\s*/g, '}')
      .replace(/\s*:\s*/g, ':')
      .replace(/\s*;\s*/g, ';')
      .replace(/;}/g, '}')               // Remove last semicolons
      .trim();
  }

  /**
   * Sanitize icon name for use as CSS class
   */
  private sanitizeClassName(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }
}

// ═══════════════════════════════════════════════════════════
// SINGLETON
// ═══════════════════════════════════════════════════════════

let generatorInstance: CssIconsGenerator | undefined;

export function getCssIconsGenerator(): CssIconsGenerator {
  if (!generatorInstance) {
    generatorInstance = new CssIconsGenerator();
  }
  return generatorInstance;
}
