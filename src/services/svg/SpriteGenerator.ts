import * as path from 'path';
import * as fs from 'fs';
import {
  SpriteIcon as CentralizedSpriteIcon,
  SpriteOptions as CentralizedSpriteOptions,
  SpriteResult as CentralizedSpriteResult,
  SpriteStats,
} from '../types/mastersvgTypes';

// Re-export centralized types for backwards compatibility
export type SpriteIcon = CentralizedSpriteIcon;
export type SpriteOptions = CentralizedSpriteOptions;
export type SpriteResult = CentralizedSpriteResult;

export class SpriteGenerator {
  /**
   * Generate a sprite sheet from multiple SVG icons
   */
  generate(icons: SpriteIcon[], options: SpriteOptions): SpriteResult {
    const iconIds: string[] = [];
    const symbols: string[] = [];
    let totalSize = 0;

    for (const icon of icons) {
      const { id, symbol, size } = this.createSymbol(icon, options);
      iconIds.push(id);
      symbols.push(symbol);
      totalSize += size;
    }

    const sprite = this.wrapInSprite(symbols, options);

    const result: SpriteResult = {
      sprite,
      iconIds,
      stats: {
        totalIcons: icons.length,
        totalSize,
        averageSize: Math.round(totalSize / icons.length),
      },
    };

    // Generate TypeScript definitions
    if (options.generateTypes) {
      result.typeDefinitions = this.generateTypeDefinitions(iconIds);
    }

    // Generate helper component
    if (options.generateHelper && options.helperFormat) {
      result.helperComponent = this.generateHelper(iconIds, options);
    }

    return result;
  }

  /**
   * Generate sprite and save to files
   */
  async generateAndSave(icons: SpriteIcon[], options: SpriteOptions): Promise<SpriteResult> {
    const result = this.generate(icons, options);

    const outputDir = options.outputPath;
    const filename = options.filename || 'sprite';

    // Ensure directory exists
    if (!fs.existsSync(outputDir)) {
      fs.mkdirSync(outputDir, { recursive: true });
    }

    // Save sprite
    const spritePath = path.join(outputDir, `${filename}.svg`);
    fs.writeFileSync(spritePath, result.sprite, 'utf-8');

    // Save type definitions (use unified name `types.d.ts`)
    if (result.typeDefinitions) {
      const typesPath = path.join(outputDir, `types.d.ts`);
      fs.writeFileSync(typesPath, result.typeDefinitions, 'utf-8');
    }

    // Save helper component
    if (result.helperComponent && options.helperFormat) {
      const ext = this.getHelperExtension(options.helperFormat);
      const helperPath = path.join(outputDir, `Icon.${ext}`);
      fs.writeFileSync(helperPath, result.helperComponent, 'utf-8');
    }

    return result;
  }

  /**
   * Create a <symbol> from an SVG
   */
  private createSymbol(
    icon: SpriteIcon,
    options: SpriteOptions
  ): { id: string; symbol: string; size: number } {
    const id = this.sanitizeId(icon.id || icon.name);
    const svg = icon.svg;

    // Extract viewBox from SVG if not provided
    let viewBox = icon.viewBox;
    if (!viewBox) {
      const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/i);
      viewBox = viewBoxMatch ? viewBoxMatch[1] : '0 0 24 24';
    }

    // Extract inner content
    const innerMatch = svg.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    let inner = innerMatch ? innerMatch[1].trim() : svg;

    // Remove styles if requested
    if (options.removeStyles) {
      inner = inner.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, '');
    }

    // Build symbol
    let symbol = `  <symbol id="${id}" viewBox="${viewBox}">\n`;

    if (options.includeTitle) {
      symbol += `    <title>${icon.name}</title>\n`;
    }

    if (options.includeDesc) {
      symbol += `    <desc>Icon: ${icon.name}</desc>\n`;
    }

    symbol += `    ${inner}\n`;
    symbol += `  </symbol>`;

    return {
      id,
      symbol,
      size: symbol.length,
    };
  }

  /**
   * Wrap symbols in SVG sprite container
   */
  private wrapInSprite(symbols: string[], _options: SpriteOptions): string {
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
  <!--
    SVG Sprite Sheet
    Generated by MasterSVG VS Code Extension
    Total icons: ${symbols.length}
  -->
${symbols.join('\n\n')}
</svg>`;
  }

  /**
   * Generate TypeScript type definitions
   */
  private generateTypeDefinitions(iconIds: string[]): string {
    const unionType = iconIds.map(id => `'${id}'`).join(' | ');

    return `// Auto-generated by MasterSVG
// Do not edit manually

export type IconName = ${unionType};

export const iconNames = [
${iconIds.map(id => `  '${id}'`).join(',\n')}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
  }

  /**
   * Generate helper component
   */
  private generateHelper(iconIds: string[], options: SpriteOptions): string {
    switch (options.helperFormat) {
      case 'react':
        return this.generateReactHelper(iconIds, options);
      case 'vue':
        return this.generateVueHelper(iconIds, options);
      case 'svelte':
        return this.generateSvelteHelper(iconIds, options);
      case 'vanilla':
        return this.generateVanillaHelper(iconIds, options);
      default:
        return '';
    }
  }

  private generateReactHelper(iconIds: string[], options: SpriteOptions): string {
    const spritePath = options.filename || 'sprite';

    return `import React from 'react';

export type IconName = ${iconIds.map(id => `'${id}'`).join(' | ')};

interface IconProps extends React.SVGProps<SVGSVGElement> {
  name: IconName;
  size?: number | string;
  color?: string;
  title?: string;
}

/**
 * Icon component using SVG sprite
 *
 * @example
 * <Icon name="arrow-left" size={24} color="currentColor" />
 */
export const Icon = React.forwardRef<SVGSVGElement, IconProps>(
  ({ name, size = 24, color = 'currentColor', title, className, ...props }, ref) => {
    return (
      <svg
        ref={ref}
        width={size}
        height={size}
        fill="none"
        stroke={color}
        className={className}
        aria-hidden={!title}
        role={title ? 'img' : undefined}
        {...props}
      >
        {title && <title>{title}</title>}
        <use href={\`/${spritePath}.svg#\${name}\`} />
      </svg>
    );
  }
);

Icon.displayName = 'Icon';

export const iconNames: IconName[] = [
${iconIds.map(id => `  '${id}'`).join(',\n')}
];

export default Icon;
`;
  }

  private generateVueHelper(iconIds: string[], options: SpriteOptions): string {
    const spritePath = options.filename || 'sprite';

    return `<script setup lang="ts">
export type IconName = ${iconIds.map(id => `'${id}'`).join(' | ')};

interface Props {
  name: IconName;
  size?: number | string;
  color?: string;
  title?: string;
}

const props = withDefaults(defineProps<Props>(), {
  size: 24,
  color: 'currentColor'
});
</script>

<template>
  <svg
    :width="size"
    :height="size"
    fill="none"
    :stroke="color"
    :aria-hidden="!title"
    :role="title ? 'img' : undefined"
  >
    <title v-if="title">{{ title }}</title>
    <use :href="\`/${spritePath}.svg#\${name}\`" />
  </svg>
</template>

<script lang="ts">
export const iconNames: IconName[] = [
${iconIds.map(id => `  '${id}'`).join(',\n')}
];
</script>
`;
  }

  private generateSvelteHelper(iconIds: string[], options: SpriteOptions): string {
    const spritePath = options.filename || 'sprite';

    return `<script lang="ts">
  export type IconName = ${iconIds.map(id => `'${id}'`).join(' | ')};

  export let name: IconName;
  export let size: number | string = 24;
  export let color: string = 'currentColor';
  export let title: string | undefined = undefined;

  export const iconNames: IconName[] = [
${iconIds.map(id => `    '${id}'`).join(',\n')}
  ];
</script>

<svg
  width={size}
  height={size}
  fill="none"
  stroke={color}
  aria-hidden={!title}
  role={title ? 'img' : undefined}
  {...$$restProps}
>
  {#if title}
    <title>{title}</title>
  {/if}
  <use href="/${spritePath}.svg#{name}" />
</svg>
`;
  }

  private generateVanillaHelper(iconIds: string[], options: SpriteOptions): string {
    const spritePath = options.filename || 'sprite';
    const componentName = options.webComponentName || 'mastersvg-icon';

    return `/**
 * Icon Web Component
 * Auto-generated by MasterSVG
 */

const ICON_NAMES = [
${iconIds.map(id => `  '${id}'`).join(',\n')}
];

// Path to the sprite file (relative to this file)
const SPRITE_URL = new URL('./${spritePath}.svg', import.meta.url).href;

class IconComponent extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'size', 'color', 'stroke-width'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  render() {
    const name = this.getAttribute('name');
    if (!name) return;


    const size = this.getAttribute('size') || '24';
    const color = this.getAttribute('color') || 'currentColor';
    const strokeWidth = this.getAttribute('stroke-width') || '2';

    this.shadowRoot.innerHTML = \`
      <style>
        :host {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          vertical-align: middle;
        }
        svg {
          width: \${size}px;
          height: \${size}px;
          color: \${color};
        }
      </style>
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="\${strokeWidth}"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="\${SPRITE_URL}#\${name}"></use>
      </svg>
    \`;
  }
}

if (!customElements.get('${componentName}')) {
  customElements.define('${componentName}', IconComponent);
}

export { IconComponent, ICON_NAMES };
`;
  }

  private getHelperExtension(format: string): string {
    switch (format) {
      case 'react':
        return 'tsx';
      case 'vue':
        return 'vue';
      case 'svelte':
        return 'svelte';
      case 'vanilla':
        return 'js';
      default:
        return 'js';
    }
  }

  private sanitizeId(name: string): string {
    return name
      .toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-|-$/g, '');
  }
}

// Singleton
let generatorInstance: SpriteGenerator | undefined;

export function getSpriteGenerator(): SpriteGenerator {
  if (!generatorInstance) {
    generatorInstance = new SpriteGenerator();
  }
  return generatorInstance;
}
