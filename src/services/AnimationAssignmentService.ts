import * as vscode from 'vscode';
import * as fs from 'node:fs';
import * as path from 'node:path';
import { getSvgConfig } from '../utils/config';

/**
 * Animation assignment data for an icon
 */
export interface IconAnimation {
  type: string;
  duration?: number;
  timing?: string;
  iteration?: string;
  delay?: number;
  direction?: string;
}

/**
 * Structure of the animations.js file
 */
export interface AnimationsData {
  animations: Record<string, IconAnimation>;
}

/**
 * Service for managing icon animation assignments
 * Handles persistence of which animation is assigned to each icon
 */
class AnimationAssignmentService {
  private _animationsCache: Record<string, IconAnimation> | null = null;

  /**
   * Reset the cache
   */
  resetCache(): void {
    this._animationsCache = null;
  }

  /**
   * Safely parse a JS object literal string into an object
   * Converts JS syntax to JSON (single quotes to double, unquoted keys to quoted)
   */
  private _parseJsObjectLiteral(jsObjectStr: string): Record<string, IconAnimation> {
    try {
      // Convert JS object literal to valid JSON:
      // 1. Replace single quotes with double quotes for string values
      // 2. Add quotes around unquoted keys
      const jsonStr = jsObjectStr
        .replace(/'/g, '"') // Single to double quotes
        .replace(/(\w+)\s*:/g, '"$1":') // Quote unquoted keys
        .replace(/,\s*}/g, '}') // Remove trailing commas
        .replace(/,\s*]/g, ']'); // Remove trailing commas in arrays

      return JSON.parse(jsonStr);
    } catch {
      // If parsing fails, return empty object
      return {};
    }
  }

  /**
   * Get the path to the animations.js file
   */
  private _getAnimationsFilePath(): string | undefined {
    const outputDir = getSvgConfig<string>('outputDirectory', 'icons');
    const workspaceFolders = vscode.workspace.workspaceFolders;
    if (!workspaceFolders || !outputDir) return undefined;

    return path.join(workspaceFolders[0].uri.fsPath, outputDir, 'animations.js');
  }

  /**
   * Read all animations from file (or cache)
   */
  private _readAnimationsFromFile(): Record<string, IconAnimation> {
    if (this._animationsCache !== null) {
      return { ...this._animationsCache };
    }

    try {
      const filePath = this._getAnimationsFilePath();
      if (!filePath) {
        this._animationsCache = {};
        return {};
      }

      if (!fs.existsSync(filePath)) {
        this._animationsCache = {};
        return {};
      }

      const content = fs.readFileSync(filePath, 'utf-8');

      // Parse the JS module format: export const animations = { ... }
      const regex = /export\s+const\s+animations\s*=\s*(\{[\s\S]*\});?\s*$/;
      const match = regex.exec(content);
      if (match) {
        // Safely parse by converting JS object literal to JSON
        const parsed = this._parseJsObjectLiteral(match[1]);
        this._animationsCache = parsed || {};
        return { ...this._animationsCache };
      }

      this._animationsCache = {};
      return {};
    } catch {
      // Silent fail - return empty animations if file can't be read
      this._animationsCache = {};
      return {};
    }
  }

  /**
   * Write animations to file
   */
  private _writeAnimationsToFile(animations: Record<string, IconAnimation>): boolean {
    try {
      const filePath = this._getAnimationsFilePath();
      if (!filePath) return false;

      // Ensure directory exists
      const dir = path.dirname(filePath);
      if (!fs.existsSync(dir)) {
        fs.mkdirSync(dir, { recursive: true });
      }

      // Generate JS module content
      const content = this._generateAnimationsContent(animations);
      fs.writeFileSync(filePath, content, 'utf-8');

      // Update cache
      this._animationsCache = { ...animations };

      return true;
    } catch {
      // Silent fail - return false if file can't be written
      return false;
    }
  }

  /**
   * Generate the animations.js file content
   */
  private _generateAnimationsContent(animations: Record<string, IconAnimation>): string {
    const lines: string[] = [
      '/**',
      ' * Icon Animation Assignments',
      ' * Auto-generated by MasterSVG',
      ' * ',
      ' * This file defines which animation is assigned to each icon.',
      ' * Format: { iconName: { type, duration?, timing?, iteration?, delay?, direction? } }',
      ' */',
      '',
      'export const animations = {',
    ];

    const iconNames = Object.keys(animations).sort((a, b) => a.localeCompare(b));

    const iconEntries = iconNames.map((iconName, i) => {
      const anim = animations[iconName];
      const comma = i < iconNames.length - 1 ? ',' : '';

      // Build animation object string
      const props: string[] = [`type: '${anim.type}'`];
      if (anim.duration !== undefined) props.push(`duration: ${anim.duration}`);
      if (anim.timing) props.push(`timing: '${anim.timing}'`);
      if (anim.iteration) props.push(`iteration: '${anim.iteration}'`);
      if (anim.delay !== undefined) props.push(`delay: ${anim.delay}`);
      if (anim.direction) props.push(`direction: '${anim.direction}'`);

      return `  '${iconName}': { ${props.join(', ')} }${comma}`;
    });

    return [...lines, ...iconEntries, '};', ''].join('\n');
  }

  /**
   * Get animation for a specific icon
   */
  getAnimation(iconName: string): IconAnimation | undefined {
    const animations = this._readAnimationsFromFile();
    return animations[iconName];
  }

  /**
   * Get all animations
   */
  getAllAnimations(): Record<string, IconAnimation> {
    return this._readAnimationsFromFile();
  }

  /**
   * Set animation for an icon
   */
  setAnimation(iconName: string, animation: IconAnimation): boolean {
    const animations = this._readAnimationsFromFile();

    if (animation.type === 'none' || !animation.type) {
      // Remove animation if set to 'none'
      delete animations[iconName];
    } else {
      animations[iconName] = animation;
    }

    return this._writeAnimationsToFile(animations);
  }

  /**
   * Remove animation from an icon
   */
  removeAnimation(iconName: string): boolean {
    const animations = this._readAnimationsFromFile();

    if (animations[iconName]) {
      delete animations[iconName];
      return this._writeAnimationsToFile(animations);
    }

    return true;
  }

  /**
   * Check if an icon has an animation assigned
   */
  hasAnimation(iconName: string): boolean {
    const animations = this._readAnimationsFromFile();
    return iconName in animations && animations[iconName].type !== 'none';
  }
}

// Singleton instance
let animationServiceInstance: AnimationAssignmentService | null = null;

/**
 * Get the AnimationAssignmentService singleton instance
 */
export function getAnimationService(): AnimationAssignmentService {
  animationServiceInstance ??= new AnimationAssignmentService();
  return animationServiceInstance;
}
