/**
 * Helper for writing variants file content
 */
import * as fs from 'node:fs';
import * as path from 'node:path';
import type { VariantsDataFile, AnimationPresetConfig, ColorMappingRecord } from '../types';

/**
 * Ensure directory exists for file path
 */
export function ensureDirectoryExists(filePath: string): void {
  const dir = path.dirname(filePath);
  if (!fs.existsSync(dir)) {
    fs.mkdirSync(dir, { recursive: true });
  }
}

/**
 * Generate file content for colorMappings and Variants exports
 */
export function generateVariantsFileContent(
  allVariants: Record<string, Record<string, string[]>>,
  colorMappings: Record<string, ColorMappingRecord>
): string {
  let content = '// Auto-generated by MasterSVG\n';
  content += '// Variants for icons - edit freely or use the Icon Editor\n\n';

  // Export color mappings
  content += '// Color mappings per icon: { originalColor: newColor }\n';
  content += 'export const colorMappings = {\n';
  content += formatObjectEntries(colorMappings, formatColorMappingEntry);
  content += '};\n\n';

  // Export variants
  content += 'export const Variants = {\n';
  content += formatObjectEntries(allVariants, formatVariantEntry);
  content += '};\n';

  return content;
}

/**
 * Format VariantsData for full file output (including animations)
 */
export function formatVariantsData(data: VariantsDataFile): string {
  const lines: string[] = ['export const Variants = {'];

  // Variants
  if (data.variants && Object.keys(data.variants).length > 0) {
    lines.push('  variants: {');
    for (const [iconName, variants] of Object.entries(data.variants)) {
      lines.push(`    "${iconName}": {`);
      for (const [variantName, colors] of Object.entries(variants)) {
        const colorStr = colors.map(c => `"${c}"`).join(', ');
        lines.push(`      "${variantName}": [${colorStr}],`);
      }
      lines.push('    },');
    }
    lines.push('  },');
  }

  // Defaults
  if (data.defaults && Object.keys(data.defaults).length > 0) {
    lines.push('  defaults: {');
    for (const [iconName, defaultVariant] of Object.entries(data.defaults)) {
      lines.push(`    "${iconName}": "${defaultVariant}",`);
    }
    lines.push('  },');
  }

  // Color mappings
  if (data.colorMappings && Object.keys(data.colorMappings).length > 0) {
    lines.push('  colorMappings: {');
    for (const [iconName, mapping] of Object.entries(data.colorMappings)) {
      lines.push(`    "${iconName}": {`);
      for (const [original, replacement] of Object.entries(mapping)) {
        lines.push(`      "${original}": "${replacement}",`);
      }
      lines.push('    },');
    }
    lines.push('  },');
  }

  // Animations
  if (data.animations && Object.keys(data.animations).length > 0) {
    lines.push('  animations: {');
    for (const [iconName, presets] of Object.entries(data.animations)) {
      lines.push(`    "${iconName}": [`);
      for (const preset of presets as AnimationPresetConfig[]) {
        lines.push(...formatAnimationPreset(preset));
      }
      lines.push('    ],');
    }
    lines.push('  },');
  }

  lines.push('};');
  return lines.join('\n');
}

// Internal helpers

function formatObjectEntries<T>(
  obj: Record<string, T>,
  formatter: (key: string, value: T, isLast: boolean) => string
): string {
  const entries = Object.entries(obj);
  return entries.map(([key, value], idx) =>
    formatter(key, value, idx === entries.length - 1)
  ).join('');
}

function formatColorMappingEntry(
  iconName: string,
  mappings: Record<string, string>,
  isLastIcon: boolean
): string {
  let result = `  '${iconName}': {\n`;
  const colorEntries = Object.entries(mappings);
  colorEntries.forEach(([origColor, newColor], idx) => {
    result += `    '${origColor}': '${newColor}'`;
    result += idx < colorEntries.length - 1 ? ',\n' : '\n';
  });
  result += `  }`;
  result += isLastIcon ? '\n' : ',\n';
  return result;
}

function formatVariantEntry(
  iconName: string,
  variants: Record<string, string[]>,
  isLastIcon: boolean
): string {
  let result = `  '${iconName}': {\n`;
  const variantEntries = Object.entries(variants);
  variantEntries.forEach(([variantName, colors], idx) => {
    const colorsStr = colors.map(c => `'${c}'`).join(', ');
    result += `    '${variantName}': [${colorsStr}]`;
    result += idx < variantEntries.length - 1 ? ',\n' : '\n';
  });
  result += `  }`;
  result += isLastIcon ? '\n' : ',\n';
  return result;
}

function formatAnimationPreset(preset: AnimationPresetConfig): string[] {
  const lines: string[] = ['      {'];
  lines.push(`        name: "${preset.name}",`);
  lines.push(`        type: "${preset.type}",`);
  if (preset.duration !== undefined) lines.push(`        duration: ${preset.duration},`);
  if (preset.timing) lines.push(`        timing: "${preset.timing}",`);
  if (preset.iteration) lines.push(`        iteration: "${preset.iteration}",`);
  if (preset.delay !== undefined) lines.push(`        delay: ${preset.delay},`);
  if (preset.direction) lines.push(`        direction: "${preset.direction}",`);
  lines.push('      },');
  return lines;
}

/**
 * Write content to file
 */
export function writeFile(filePath: string, content: string): void {
  ensureDirectoryExists(filePath);
  fs.writeFileSync(filePath, content, 'utf-8');
}
