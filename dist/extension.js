"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// src/utils/config.ts
function getSvgConfig(key, defaultValue) {
  const config = vscode.workspace.getConfiguration("sageboxIconStudio");
  return config.get(key, defaultValue);
}
function getFullSvgConfig() {
  return vscode.workspace.getConfiguration("sageboxIconStudio");
}
function isFullyConfigured() {
  const config = vscode.workspace.getConfiguration("sageboxIconStudio");
  const svgFolders = config.get("svgFolders", []);
  const outputDirectory = config.get("outputDirectory", "");
  const buildFormat = config.get("buildFormat", "");
  const webComponentName = config.get("webComponentName", "");
  const isStep1Complete = svgFolders.length > 0 && svgFolders[0].length > 0;
  const isStep2Complete = !!outputDirectory;
  const isStep3Complete = !!buildFormat;
  const isStep4Complete = webComponentName.includes("-");
  return isStep1Complete && isStep2Complete && isStep3Complete && isStep4Complete;
}
var vscode;
var init_config = __esm({
  "src/utils/config.ts"() {
    "use strict";
    vscode = __toESM(require("vscode"));
  }
});

// l10n/en.json
var en_default;
var init_en = __esm({
  "l10n/en.json"() {
    en_default = {
      extension: {
        name: "Icon Studio",
        description: "SVG Icon Studio for VS Code",
        appTitle: "Icon Studio"
      },
      welcome: {
        title: "Welcome to Icon Studio",
        subtitle: "Your SVG icon management solution",
        getStarted: "Get Started",
        configuration: "Configuration",
        language: "Language",
        languageDescription: "Select your preferred language",
        sourceDirectory: "Source Directory",
        sourceDirectoryDescription: "Folder where your SVG icons are located",
        sourceDirectoryPlaceholder: "e.g., src/assets/svg or icons",
        outputDirectory: "Output Directory",
        outputDirectoryDescription: "Folder where built icons will be saved",
        outputDirectoryPlaceholder: "e.g., src/icons or assets/icons",
        scanDirectories: "Scan Directories",
        scanDirectoriesDescription: "Folders to scan for SVG files",
        addDirectory: "Add Directory",
        removeDirectory: "Remove",
        save: "Save Configuration",
        saving: "Saving...",
        saved: "Configuration saved!",
        features: "Features",
        featuresDescription: "Discover what Icon Studio can do for you",
        documentation: "Documentation",
        quickStart: "Quick Start",
        quickStartDescription: "Learn how to use Icon Studio in minutes",
        browse: "Browse...",
        selectFolder: "Select Folder",
        jsModule: "JS Module",
        noRuntime: "No runtime",
        import: "Import",
        use: "Use",
        reference: "Reference",
        tag: "Tag",
        webComponentName: "Web Component Name",
        webComponentDesc: "Custom element tag name for your icons",
        licenseConsentTitle: "Third-Party Licenses",
        licenseConsentDesc: "Icons from Iconify have their own licenses that may require attribution.",
        licenseConsentCheckbox: "I understand that Iconify icons are third-party content with their own licenses, and I agree to auto-generate license attribution files when building.",
        licenseConsentInfo: "When enabled, a LICENSES.md file will be automatically generated in your output folder with proper attribution for all Iconify icons used in your project.",
        configureOutputFirst: "Configure output directory first",
        setupComplete: "Setup complete!",
        filesCreated: "Files created in {path}",
        spriteCreated: "Sprite created in {path}",
        errorCreatingFiles: "Error creating files",
        previewResult: "Result",
        workflowSource: "Source",
        workflowBuild: "Build",
        workflowOutput: "Output",
        comingSoon: "Coming Soon",
        selectFormat: "Select format...",
        selectFormatFirst: "Select an output format to see the preview",
        buildFirstMessage: "Build icons first to see preview",
        advancedOptions: "Advanced Options",
        svgoOptimize: "SVGO Optimization",
        scanOnStartup: "Scan on Startup",
        defaultIconSize: "Default Icon Size",
        previewBackground: "Preview Background",
        allSettings: "All Settings..."
      },
      features: {
        iconManagement: "Icon Management",
        iconManagementDescription: "Organize, preview, and manage your SVG icons",
        buildSystem: "Build System",
        buildSystemDescription: "Export icons to JS modules or SVG sprites",
        iconEditor: "Icon Editor",
        iconEditorDescription: "Edit colors, animations, and variants",
        codeIntegration: "Code Integration",
        codeIntegrationDescription: "Autocomplete and hover previews in your code",
        iconify: "Iconify Integration",
        iconifyDescription: "Access thousands of icons from Iconify"
      },
      treeView: {
        files: "Files",
        code: "Code",
        built: "Built",
        preview: "Preview",
        noIcons: "No icons found",
        scanWorkspace: "Scan workspace for SVG files",
        configureFirst: "Configure Icon Studio",
        noBuiltIcons: "No built icons - Run Build command",
        inlineSvgs: "Inline SVGs",
        imgReferences: "IMG References"
      },
      commands: {
        build: "Build Icons",
        buildAll: "Build All Icons",
        buildSelected: "Build Selected",
        refresh: "Refresh",
        refreshAll: "Refresh All",
        delete: "Delete",
        deleteSelected: "Delete Selected",
        rename: "Rename",
        duplicate: "Duplicate",
        copyName: "Copy Name",
        copySvg: "Copy SVG",
        copyComponent: "Copy as Component",
        openEditor: "Open in Editor",
        openFile: "Open File",
        revealInExplorer: "Reveal in Explorer",
        addToSprite: "Add to Sprite",
        removeFromSprite: "Remove from Sprite",
        removeFromBuilt: "Remove from Built",
        optimize: "Optimize SVG",
        transform: "Transform",
        exportAs: "Export As...",
        scanWorkspace: "Scan Workspace",
        goToUsage: "Go to Usage",
        goToReference: "Go to Reference",
        showDetails: "Show Details",
        goToSvg: "Go to SVG",
        openSetup: "Open Setup",
        transformSvg: "Transform SVG Reference",
        importIcon: "Import Icon"
      },
      editor: {
        title: "Icon Editor",
        edit: "Edit",
        color: "Color",
        animation: "Animation",
        code: "Code",
        variants: "Variants",
        colors: "Colors",
        selectCustomToEdit: "Select custom to edit",
        original: "Original",
        custom: "Custom",
        readOnly: "Read-only",
        globalFilters: "Global Filters",
        hueRotate: "Hue Rotate",
        saturation: "Saturation",
        brightness: "Brightness",
        reset: "Reset",
        apply: "Apply",
        addVariant: "Add Variant",
        deleteVariant: "Delete Variant",
        variantName: "Variant Name",
        preview: "Preview",
        addToIcons: "Add to icons.js",
        renamePrompt: "Enter new name for the icon",
        nameCannotBeEmpty: "Name cannot be empty",
        enterDifferentName: "Enter a different name",
        nameValidation: "Name can only contain letters, numbers, dashes and underscores",
        enterVariantName: "Enter variant name",
        variantPlaceholder: "e.g. Dark theme, Primary colors...",
        editVariantName: "Edit variant name",
        deleteOriginalSvg: "Delete original SVG",
        deleteOriginalSvgDesc: "Remove the source file after build",
        keepOriginalSvg: "Keep original SVG",
        keepOriginalSvgDesc: "Preserve the source file",
        whatToDoWithOriginal: "What to do with the original file?",
        addTo: "Add to",
        iconsLibrary: "Icons Library",
        selectSvgToImport: "Select an SVG to import",
        enterIconName: "Enter icon name"
      },
      animation: {
        title: "Animation",
        type: "Type",
        duration: "Duration",
        timing: "Timing Function",
        iteration: "Iteration",
        delay: "Delay",
        direction: "Direction",
        none: "None",
        spin: "Spin",
        pulse: "Pulse",
        bounce: "Bounce",
        shake: "Shake",
        flip: "Flip",
        swing: "Swing",
        rubberBand: "Rubber Band",
        tada: "Tada",
        heartbeat: "Heartbeat",
        flash: "Flash"
      },
      details: {
        title: "Icon Details",
        name: "Name",
        path: "Path",
        size: "Size",
        viewBox: "ViewBox",
        colors: "Colors Found",
        source: "Source",
        status: "Status",
        built: "Built",
        notBuilt: "Not Built",
        inSprite: "In Sprite",
        notInSprite: "Not in Sprite"
      },
      sprite: {
        title: "SVG Sprite",
        generate: "Generate Sprite",
        regenerate: "Regenerate Sprite",
        preview: "Preview Sprite",
        iconsCount: "{count} icons",
        noIcons: "No icons in sprite",
        addSelected: "Add Selected to Sprite"
      },
      messages: {
        iconAdded: "Icon '{name}' added to icons.js",
        iconAddedToSprite: "'{name}' added to sprite.svg",
        iconAddedToIconsJs: "'{name}' added to icons.js",
        iconAddedWithAnimation: "'{name}' added to icons.js with animation",
        animationSaved: "Animation '{animation}' assigned to '{name}'",
        animationRemoved: "Animation removed from '{name}'",
        iconRemoved: "Icon '{name}' removed",
        iconRenamed: "Icon renamed from '{oldName}' to '{newName}'",
        renamedTo: "Renamed to '{name}'",
        iconDuplicated: "Icon duplicated as '{name}'",
        iconOptimized: "Icon optimized successfully",
        iconAlreadyOptimized: "SVG is already optimized",
        optimizedApplied: "Optimized SVG applied",
        optimizedSaved: "Optimized SVG applied and saved",
        optimizedReduced: "Optimized: {original} \u2192 {optimized} ({percent}% reduction)",
        buildSuccess: "Icons built successfully",
        buildFailed: "Build failed: {error}",
        failedToAddIcon: "Failed to add icon: {error}",
        failedToImportIcon: "Failed to import icon: {error}",
        failedToBuildIcon: "Failed to build icon: {error}",
        failedToOptimize: "Failed to optimize SVG: {error}",
        configSaved: "Configuration saved",
        configError: "Error saving configuration: {error}",
        configureOutputFirst: "Configure output directory first",
        noWorkspace: "No workspace folder open",
        noActiveEditor: "No active editor",
        noIconData: "No icon data available. Please reopen the editor.",
        noIconSelected: "No icon selected",
        noFiltersToApply: "No filters to apply",
        filtersApplied: "Filters applied to colors",
        selectIcon: "Please select an icon",
        selectIcons: "Please select one or more icons",
        confirmDelete: "Are you sure you want to delete {count} icon(s)?",
        yes: "Yes",
        no: "No",
        cancel: "Cancel",
        ok: "OK",
        error: "Error",
        warning: "Warning",
        info: "Information",
        success: "Success",
        copiedToClipboard: "Copied to clipboard!",
        copiedNameToClipboard: "Copied '{name}' to clipboard",
        svgCopiedToClipboard: "SVG copied to clipboard",
        animatedSvgCopied: "Animated SVG copied to clipboard",
        codeInsertedAtCursor: "Code inserted at cursor",
        noActiveEditorCodeCopied: "No active editor. Code copied to clipboard.",
        scanComplete: "Scan complete: {count} icons found",
        noIconsFound: "No icons found in workspace",
        noInlineSvgsFound: "No inline SVGs found in this file",
        noIconsFoundForQuery: "No icons found for '{query}'",
        svgFileNotFound: "SVG file not found: {path}",
        noBuiltIconsFound: "No built icons found. Build some icons first.",
        couldNotReadSvg: "Could not read SVG content",
        couldNotUpdateSprite: "Could not update sprite.svg",
        couldNotFindIconsJs: "Could not find icons.js to update",
        variantGenerated: "Variant '{name}' generated",
        variantSaved: "Variant '{name}' saved",
        variantUpdated: "Variant '{name}' updated",
        variantSetAsDefault: "'{name}' is now the default variant for {icon}",
        variantDefaultCleared: "Default variant cleared for {icon}",
        scriptCopiedToClipboard: "Script tag copied to clipboard!",
        missingScriptImport: 'Missing script import! Add <script type="module" src="./{outputDir}/icon.js"></script> to your HTML <head>',
        copyToClipboard: "Copy to Clipboard",
        dismiss: "Dismiss",
        iconImported: "Icon '{name}' imported to {targets}!",
        iconBuilt: "Icon '{name}' built to {format}!",
        iconTransformed: "Icon '{name}' transformed to <{component}>!",
        extractInlineSvg: 'Extract inline SVG as "{name}"',
        addedFillColor: "Added fill color: {color}",
        updatedFile: "Updated {path}",
        errorRenaming: "Error renaming: {error}",
        couldNotFindImgRef: "Could not find IMG reference in document. The file might have changed.",
        couldNotFindSvgInDoc: "Could not find SVG in document. The file might have changed.",
        transformedToFormat: "Transformed SVG to {format} format",
        pleaseSelectSvg: "Please select an SVG element",
        svgTransformedToComponent: "SVG transformed to {format} component",
        svgOptimized: "SVG optimized!",
        noIconsInLibrary: "No icons found in library",
        spriteGenerated: "Sprite generated in {path}",
        spriteNotFound: "sprite.svg not found",
        noIconsInSprite: "No icons found in sprite.svg",
        iconCopied: "Copied: {name}",
        failedToExportComponent: "Failed to export component: {error}",
        iconRenamedTo: "Icon renamed to: {name}",
        confirmDeleteIcon: 'Delete "{name}" from sprite?',
        confirmDeleteIconFromFile: 'Delete "{name}" from icons file?',
        iconDeleted: "Icon deleted: {name}",
        spriteClean: "Sprite is clean - no invalid content found.",
        spriteCleanedCount: "Cleaned sprite: removed {removed} invalid entries. {kept} icons remaining.",
        svgCopiedToClipboard: "SVG copied to clipboard",
        noIconsFile: "No icons file found",
        iconsFileNotFound: "Icons file not found",
        noIconsInFile: "No icons found in the file",
        noFileSelected: "No file selected",
        fileNotFound: "File not found: {path}",
        confirmDeleteFile: "Delete '{name}'? This action cannot be undone.",
        fileDeleted: "Deleted: {name}",
        failedToDeleteFile: "Failed to delete file: {error}",
        svgScanComplete: "SVG scan complete!",
        usageScanComplete: "Usage scan complete!",
        noSvgPathAvailable: "No SVG file path available",
        cannotFindRefLocation: "Cannot find the reference location",
        refreshIcons: "Please refresh the icons list",
        removedReference: 'Removed reference to "{name}"',
        errorRemovingReference: "Error removing reference: {error}",
        noSvgFilesFound: "No SVG files found in workspace",
        savedIconTo: "Saved icon to {name}",
        updatedPath: 'Updated path from "{oldPath}" to "{newPath}"',
        errorUpdatingPath: "Error updating path: {error}",
        failedToFetchIcon: "Failed to fetch icon SVG",
        failedToFetchIconError: "Failed to fetch icon: {error}",
        iconAddedToFormat: 'Icon "{name}" added to {format}!',
        failedToAddIcon: "Failed to add icon: {error}",
        iconImportedToFormat: 'Icon "{name}" imported to {format}!',
        updatedFile: "Updated {path}",
        copiedNameToClipboard: 'Copied "{name}" to clipboard',
        svgAlreadyOptimized: "SVG is already optimized",
        optimizedSvgApplied: "Optimized SVG applied",
        addedFillColor: "Added fill color: {color}",
        variantSaved: 'Variant "{name}" saved',
        variantSetAsDefault: '"{name}" is now the default variant for {iconName}',
        defaultVariantCleared: "Default variant cleared for {iconName}",
        outputDirectorySet: "Output directory set to: {path}",
        svgFoldersUpdated: "SVG folders updated",
        componentNameSet: "Component name set to: {name}",
        outputFormatSet: "Output format set to: {format}",
        noIconsSelectedForDeletion: "No icons selected for deletion",
        confirmDeleteIcons: "Delete {count} icon(s): {names}?",
        deleteButton: "Delete",
        failedToDelete: "Failed to delete {name}: {error}",
        deletedCount: "Deleted {count} icon(s)",
        selectIconsToRemoveFromBuilt: "Select icon(s) to remove from built",
        couldNotDetermineIconNames: "Could not determine icon names",
        outputDirectoryNotConfigured: "Output directory not configured",
        removeIconFromBuilt: 'Remove "{name}" from built icons library?',
        removeIconsFromBuilt: "Remove {count} icons from built icons library?",
        removeButton: "Remove",
        removedIconFromBuilt: 'Removed "{name}" from built icons',
        removedIconsFromBuilt: "Removed {count} icons from built icons",
        failedToRemoveFromBuilt: "Failed to remove icon(s) from built icons",
        selectIconToRename: "Select an icon to rename",
        fileAlreadyExists: 'A file named "{name}" already exists',
        renamedWithReferences: 'Renamed "{oldName}" to "{newName}" and updated {count} file(s) with references',
        iconNotFoundInBuildFiles: 'Could not find icon "{name}" in build files',
        renamedFilesUpdated: 'Renamed "{oldName}" to "{newName}" ({count} file(s) updated)',
        errorRenamingIcon: "Error renaming icon: {error}",
        pleaseSelectValidSvgFile: "Please select a valid SVG file",
        selectIconFromTreeOrEditor: "Select an icon from the tree view or select SVG code in the editor",
        couldNotFindSvgData: "Could not find SVG data for {name}",
        cannotEditRasterized: 'Cannot edit "{name}": This SVG has {colors} unique colors (likely a rasterized image). Color editing is disabled for SVGs with more than {maxColors} colors.',
        selectIconToExport: "Select an icon to export",
        addedSvgFolder: "Added SVG folder: {path}",
        selectFolderInsideWorkspace: "Please select a folder inside the workspace",
        svgFoldersUpdatedList: "SVG folders updated: {folders}",
        svgFoldersUpdatedNone: "SVG folders updated: (none - will scan all)",
        removedSvgFolder: "Removed SVG folder: {folder}",
        noImgReferencesFound: "No IMG references found to transform",
        allImgReferencesMissing: "All IMG references point to missing files",
        confirmTransformReferences: "Transform {count} IMG reference(s) to <{component}>?",
        transformedWithErrors: "Transformed {transformed} references. {failed} file(s) had errors.",
        transformedSuccessfully: "Successfully transformed {count} IMG reference(s) to <{component}>",
        confirmBuildSvgFiles: "Build {count} SVG file(s) to {format}?",
        outputPathNotConfigured: "Output path not configured",
        confirmDeleteOriginals: "Built {count} icon(s). Delete original SVG files?",
        deleteAll: "Delete All",
        keepAll: "Keep All",
        deletedOriginals: "Deleted {count} original SVG file(s)",
        builtWithErrors: "Built {built} icons. {failed} file(s) had errors.",
        noIconsFoundToBuild: "No icons found to build",
        skippedRasterizedIcons: "Skipped {count} rasterized SVG(s) with too many colors: {names}",
        iconsLibraryBuilt: "Icons library built as {format} in {path}",
        yesButton: "Yes",
        noButton: "No",
        clickToConfigureOutput: "Click to configure output directory and settings",
        svgCanBeConverted: 'SVG "{name}" can be converted to Icon component',
        transformToFormat: 'Transform to {format}: "{name}"',
        importIconName: 'Import icon: "{name}"',
        searchIconify: "Search in Iconify...",
        browseWorkspaceIcons: "Browse workspace icons...",
        noIconsInWorkspace: "No icons found in workspace. Try searching Iconify.",
        iconSelected: 'Icon "{name}" selected',
        iconAlreadyExists: 'Icon "{name}" already exists'
      },
      settings: {
        title: "Settings",
        general: "General",
        appearance: "Appearance",
        build: "Build",
        advanced: "Advanced",
        language: "Language",
        languageAuto: "Auto (System)",
        theme: "Icon Theme",
        previewSize: "Preview Size",
        showLabels: "Show Labels",
        outputFormat: "Output Format",
        optimizeOnBuild: "Optimize on Build",
        includeAnimation: "Include Animation Data",
        generateTypes: "Generate TypeScript Types"
      },
      ui: {
        progress: {
          buildingReferences: "Building references...",
          buildingSvgFiles: "Building SVG files...",
          buildingIconsLibrary: "Building icons library...",
          scanningIcons: "Scanning icons...",
          generatingOutput: "Generating output...",
          generatingWebComponent: "Generating web component...",
          processing: "Processing {name}...",
          building: "Building {name}..."
        },
        placeholders: {
          iconName: "icon-name",
          selectSettingToConfigure: "Select a setting to configure",
          outputDirectoryExample: "e.g., src/icons, assets/icons",
          svgFoldersExample: "src/icons, assets/svg",
          selectOutputFormat: "Select output format",
          configureSvgFolders: "Configure SVG folders to scan",
          svgFoldersExampleLong: "e.g., src/icons, assets/svg, public/images",
          enterSearchTerm: "Enter search term (e.g., arrow, home, user)",
          selectBuiltIcon: "Select a built icon",
          howToFindReplacement: "How do you want to find the replacement SVG?",
          whereToSaveSvg: "Where do you want to save the new SVG?",
          svgPathExample: "./path/to/icon.svg",
          selectSpriteFormat: "Select sprite format",
          selectComponentFormat: "Select component format",
          componentNameExample: "e.g., IconHome, ArrowIcon",
          selectIconToInsert: "Select icon to insert",
          variantNameExample: "e.g. Dark theme, Primary colors..."
        },
        prompts: {
          enterOutputDirectory: "Enter the output directory for generated icons",
          enterSvgFolders: "Enter SVG folders to scan (comma separated)",
          enterSvgFoldersRelative: "Enter SVG folders to scan (comma separated, relative to workspace)",
          enterComponentName: "Enter the component name",
          enterWebComponentName: "Enter the web component name",
          enterNewIconName: "Enter new icon name",
          enterIconName: "Enter a name for this icon",
          enterVariantName: "Enter variant name",
          searchIconify: "Search Iconify for an icon",
          searchIconifyFull: 'Search for icons (e.g., "arrow", "home", "user")',
          enterNewSvgPath: "Enter the new SVG path"
        },
        titles: {
          svgFoldersConfiguration: "SVG Folders Configuration",
          selectSvgFile: "Select SVG file",
          selectFolderToSave: "Select folder to save the SVG",
          iconEditor: "Icon Editor",
          duplicateIcon: "Duplicate Icon Name"
        },
        labels: {
          browseForFolder: "Browse for folder...",
          enterPathManually: "Enter path manually...",
          currentFolders: "Current folders:",
          removeFolder: "Remove: {folder}",
          selectSvgFolder: "Select SVG Folder",
          scanWorkspace: "Scan Workspace",
          goToUsage: "Go to Usage",
          goToReference: "Go to Reference",
          showDetails: "Show Details",
          goToSvg: "Go to SVG",
          openSetup: "Open Setup",
          importIcon: "Import Icon",
          fromWorkspace: "From workspace SVG files",
          fromIconify: "From Iconify (search online)",
          saveToWorkspace: "Save to workspace folder",
          replaceInPlace: "Replace in place (update path only)",
          outputDirectory: "Output Directory",
          svgFolders: "SVG Folders",
          componentName: "Component Name",
          outputFormat: "Output Format",
          webComponentName: "Web Component Name",
          svgSprite: "SVG Sprite",
          webComponentJs: "Web Component (JS)",
          both: "Both",
          searchInIconify: "Search in Iconify",
          useReferencedSvg: "Use referenced SVG file",
          useInlineSvg: "Use this inline SVG",
          extractAndBuild: "Extract and build as icon",
          browseBuiltIcons: "Browse built icons",
          browseForSvgFile: "Browse for SVG file",
          searchWorkspaceSvg: "Search workspace for SVG",
          enterNewPathManually: "Enter new path manually",
          saveNextToFile: "Save next to referenced file",
          chooseFolder: "Choose folder",
          clickToRemove: "Click to remove this folder",
          selectFolderFromWorkspace: "Select a folder from the workspace",
          typeRelativePath: "Type a relative path",
          findBuildIconify: "Find and build an icon from Iconify library",
          selectExistingSvg: "Select an existing SVG file",
          selectIconFromLibrary: "Select an icon already in your library",
          renameIcon: "Rename icon",
          enterNewName: "Enter a different name",
          replaceIcon: "Replace existing",
          overwriteExisting: "Overwrite the existing icon",
          cancel: "Cancel"
        },
        details: {
          outputDirectoryDesc: "Directory where icons.ts or sprite.svg will be generated",
          svgFoldersDesc: "Folders to scan for SVG files",
          componentNameDesc: "Name of the Icon component (e.g. Icon)",
          outputFormatDesc: "Default output format (jsx, vue, svelte, etc.)",
          webComponentNameDesc: "Name for the custom element (e.g. bezier-icon)"
        },
        validation: {
          nameCannotBeEmpty: "Name cannot be empty",
          invalidNameFormat: "Invalid name format"
        },
        colors: {
          white: "White",
          black: "Black",
          blue: "Blue",
          green: "Green",
          orange: "Orange",
          red: "Red",
          purple: "Purple",
          pink: "Pink"
        }
      },
      webview: {
        animation: {
          animationType: "Animation Type",
          categoryBasic: "Basic",
          categoryAttention: "Attention",
          categoryEntrance: "Entrance",
          categoryDraw: "Draw",
          drawHint: "Draw animations work best with stroke-based SVGs. The icon should have visible strokes.",
          settings: "Settings",
          duration: "Duration",
          delay: "Delay",
          timing: "Timing",
          iteration: "Iteration",
          direction: "Direction",
          timingLinear: "Linear",
          timingEase: "Ease",
          timingEaseIn: "Ease In",
          timingEaseOut: "Ease Out",
          timingEaseInOut: "Ease In-Out",
          iterationOnce: "Once",
          iterationTwice: "Twice",
          iteration3Times: "3 Times",
          iterationInfinite: "Infinite",
          directionNormal: "Normal",
          directionReverse: "Reverse",
          directionAlternate: "Alternate",
          directionAltReverse: "Alt Reverse",
          export: "Export",
          saveAnimation: "Assign",
          saveAnimationTooltip: "Save animation assignment for this icon",
          copyWithAnimation: "Copy with Animation",
          exportHint: "SVG will include CSS animation"
        },
        color: {
          colors: "Colors",
          globalFilters: "Global Filters",
          hueRotate: "Hue Rotate",
          saturation: "Saturation",
          brightness: "Brightness",
          reset: "Reset",
          resetFilters: "Reset all filters",
          variants: "Variants",
          saveVariant: "Save current colors as variant"
        },
        code: {
          svgSource: "SVG Source",
          animationCss: "Animation CSS",
          usageExample: "Usage Example",
          copy: "Copy",
          copySvg: "Copy SVG to clipboard",
          copyAnimation: "Copy animation CSS",
          copyUsage: "Copy usage code"
        },
        tabs: {
          title: "Icon Studio",
          searchPlaceholder: "Search icons...",
          workspace: "Workspace",
          library: "Library",
          online: "Online"
        },
        editor: {
          editorBadge: "Editor",
          optimizedBadge: "Optimized",
          renameIcon: "Rename Icon",
          zoomOut: "Zoom Out",
          zoomIn: "Zoom In",
          resetZoom: "Reset Zoom",
          restartAnimation: "Restart Animation",
          buildIcons: "Build Icons",
          copySvg: "Copy SVG",
          optimizeSvg: "Optimize SVG (SVGO)",
          applyOnBuild: "Apply on Build",
          discardOptimization: "Discard optimization",
          tabColor: "Color",
          tabAnimation: "Animation",
          tabCode: "Code"
        },
        details: {
          built: "Built",
          draft: "Draft",
          zoomOut: "Zoom Out",
          zoomIn: "Zoom In",
          resetZoom: "Reset Zoom",
          copyIconName: "Copy icon name",
          copySvgCode: "Copy SVG code",
          openInEditor: "Open in Editor",
          goToSource: "Go to source",
          colors: "Colors",
          colorsWarning: "This SVG has {count} unique colors. Color preview disabled for rasterized SVGs.",
          usesCurrentColor: "Uses currentColor",
          inheritsFromCss: "inherits from CSS",
          noColorsDetected: "No colors detected",
          properties: "Properties",
          viewBox: "viewBox",
          dimensions: "Dimensions",
          fileSize: "File Size",
          elements: "Elements",
          elementsBreakdown: "Elements",
          features: "Features",
          sourceLocation: "Source Location",
          animation: "Animation",
          variants: "Variants",
          variantsDisabled: "Variants disabled for SVGs with too many colors",
          saveVariant: "Save current colors as variant",
          usages: "Usages",
          searchingUsages: "Searching for usages...",
          original: "original",
          currentlyDefault: "Currently default",
          setAsDefault: "Set as default",
          clickToApply: "Click to apply",
          activeDefault: "active default",
          delete: "Delete",
          license: "License",
          collection: "Collection",
          author: "Author",
          licenseType: "License",
          unknownAuthor: "Unknown",
          unknownLicense: "Unknown",
          licenseUnknown: "License information not available",
          download: "Download"
        },
        spritePreview: {
          icons: "icons",
          openFile: "Open File",
          refresh: "Refresh",
          copyName: "Copy Name",
          copySvg: "Copy SVG",
          editIcon: "Edit Icon",
          showDetails: "Show Details",
          exportComponent: "Export Component",
          rename: "Rename",
          delete: "Delete"
        },
        js: {
          svgWillIncludeAnimation: "SVG will include CSS animation",
          svgCodeCopied: "SVG code copied to clipboard",
          animationCssCopied: "Animation CSS copied to clipboard",
          usageCodeCopied: "Usage code copied to clipboard",
          optimizeSvgo: "Optimize SVG (SVGO)",
          optimal: "Optimal",
          alreadyOptimized: "Already optimized",
          selectAnimationToEnable: "Select an animation to enable",
          originalColor: "Original: {color}",
          addFillColor: "Add fill color",
          noIconsFound: "No icons found. Scan your workspace to detect SVG files.",
          noIconsMatch: "No icons match your search.",
          noUsagesFound: "No usages found in workspace",
          original: "Original:",
          optimized: "Optimized:",
          saved: "Saved:",
          alreadyOptimal: "Already optimal",
          searchingUsages: "Searching for usages...",
          noColorsDetected: "No colors detected",
          browseIconify: "Browse icons from Iconify",
          comingSoon: "Coming soon...",
          scanWorkspaceBtn: "Scan Workspace"
        }
      }
    };
  }
});

// l10n/es.json
var es_default;
var init_es = __esm({
  "l10n/es.json"() {
    es_default = {
      extension: {
        name: "Icon Studio",
        description: "Gestor de iconos SVG para VS Code",
        appTitle: "Icon Studio"
      },
      welcome: {
        title: "Bienvenido a Icon Studio",
        subtitle: "Tu soluci\xF3n para gestionar iconos SVG",
        getStarted: "Comenzar",
        configuration: "Configuraci\xF3n",
        language: "Idioma",
        languageDescription: "Selecciona tu idioma preferido",
        sourceDirectory: "Directorio de Origen",
        sourceDirectoryDescription: "Carpeta donde est\xE1n ubicados tus iconos SVG",
        sourceDirectoryPlaceholder: "ej., src/assets/svg o icons",
        outputDirectory: "Directorio de Salida",
        outputDirectoryDescription: "Carpeta donde se guardar\xE1n los iconos compilados",
        outputDirectoryPlaceholder: "ej., src/icons o assets/icons",
        scanDirectories: "Directorios a Escanear",
        scanDirectoriesDescription: "Carpetas donde buscar archivos SVG",
        addDirectory: "A\xF1adir Directorio",
        removeDirectory: "Eliminar",
        save: "Guardar Configuraci\xF3n",
        saving: "Guardando...",
        saved: "\xA1Configuraci\xF3n guardada!",
        features: "Caracter\xEDsticas",
        featuresDescription: "Descubre lo que Icon Studio puede hacer por ti",
        documentation: "Documentaci\xF3n",
        quickStart: "Inicio R\xE1pido",
        quickStartDescription: "Aprende a usar Icon Studio en minutos",
        browse: "Explorar...",
        selectFolder: "Seleccionar Carpeta",
        jsModule: "M\xF3dulo JS",
        noRuntime: "Sin runtime",
        import: "Importar",
        use: "Usar",
        reference: "Referencia",
        tag: "Etiqueta",
        webComponentName: "Nombre del Web Component",
        webComponentDesc: "Nombre de la etiqueta personalizada para tus iconos",
        licenseConsentTitle: "Licencias de Terceros",
        licenseConsentDesc: "Los iconos de Iconify tienen sus propias licencias que pueden requerir atribuci\xF3n.",
        licenseConsentCheckbox: "Entiendo que los iconos de Iconify son contenido de terceros con sus propias licencias, y acepto auto-generar archivos de atribuci\xF3n de licencias al compilar.",
        licenseConsentInfo: "Cuando est\xE1 habilitado, se generar\xE1 autom\xE1ticamente un archivo LICENSES.md en tu carpeta de salida con la atribuci\xF3n correcta para todos los iconos de Iconify usados en tu proyecto.",
        configureOutputFirst: "Configura el directorio de salida primero",
        setupComplete: "\xA1Configuraci\xF3n completa!",
        filesCreated: "Archivos creados en {path}",
        spriteCreated: "Sprite creado en {path}",
        errorCreatingFiles: "Error al crear archivos",
        previewResult: "Resultado",
        workflowSource: "Origen",
        workflowBuild: "Compilar",
        workflowOutput: "Salida",
        comingSoon: "Pr\xF3ximamente",
        selectFormat: "Seleccionar formato...",
        selectFormatFirst: "Selecciona un formato de salida para ver la previsualizaci\xF3n",
        buildFirstMessage: "Construye los iconos primero para ver la vista previa",
        advancedOptions: "Opciones Avanzadas",
        svgoOptimize: "Optimizaci\xF3n SVGO",
        scanOnStartup: "Escanear al Iniciar",
        defaultIconSize: "Tama\xF1o por Defecto",
        previewBackground: "Fondo de Vista Previa",
        allSettings: "Todas las Configuraciones..."
      },
      features: {
        iconManagement: "Gesti\xF3n de Iconos",
        iconManagementDescription: "Organiza, previsualiza y gestiona tus iconos SVG",
        buildSystem: "Sistema de Compilaci\xF3n",
        buildSystemDescription: "Exporta iconos a m\xF3dulos JS o sprites SVG",
        iconEditor: "Editor de Iconos",
        iconEditorDescription: "Edita colores, animaciones y variantes",
        codeIntegration: "Integraci\xF3n con C\xF3digo",
        codeIntegrationDescription: "Autocompletado y previsualizaciones en tu c\xF3digo",
        iconify: "Integraci\xF3n Iconify",
        iconifyDescription: "Accede a miles de iconos de Iconify"
      },
      treeView: {
        files: "Archivos",
        code: "C\xF3digo",
        built: "Compilados",
        preview: "Vista Previa",
        noIcons: "No se encontraron iconos",
        scanWorkspace: "Escanear workspace en busca de archivos SVG",
        configureFirst: "Configurar Icon Studio",
        noBuiltIcons: "Sin iconos compilados - Ejecuta el comando Build",
        inlineSvgs: "SVGs en l\xEDnea",
        imgReferences: "Referencias IMG"
      },
      commands: {
        build: "Compilar Iconos",
        buildAll: "Compilar Todos",
        buildSelected: "Compilar Seleccionados",
        refresh: "Actualizar",
        refreshAll: "Actualizar Todo",
        delete: "Eliminar",
        deleteSelected: "Eliminar Seleccionados",
        rename: "Renombrar",
        duplicate: "Duplicar",
        copyName: "Copiar Nombre",
        copySvg: "Copiar SVG",
        copyComponent: "Copiar como Componente",
        openEditor: "Abrir en Editor",
        openFile: "Abrir Archivo",
        revealInExplorer: "Mostrar en Explorador",
        addToSprite: "A\xF1adir al Sprite",
        removeFromSprite: "Quitar del Sprite",
        removeFromBuilt: "Quitar de Compilados",
        optimize: "Optimizar SVG",
        transform: "Transformar",
        exportAs: "Exportar Como...",
        scanWorkspace: "Escanear Espacio de Trabajo",
        goToUsage: "Ir al Uso",
        goToReference: "Ir a Referencia",
        showDetails: "Mostrar Detalles",
        goToSvg: "Ir al SVG",
        openSetup: "Abrir Configuraci\xF3n",
        transformSvg: "Transformar Referencia SVG",
        importIcon: "Importar Icono"
      },
      editor: {
        title: "Editor de Iconos",
        edit: "Editar",
        color: "Color",
        animation: "Animaci\xF3n",
        code: "C\xF3digo",
        variants: "Variantes",
        colors: "Colores",
        selectCustomToEdit: "Selecciona custom para editar",
        original: "Original",
        custom: "Personalizado",
        readOnly: "Solo lectura",
        globalFilters: "Filtros Globales",
        hueRotate: "Rotaci\xF3n de Tono",
        saturation: "Saturaci\xF3n",
        brightness: "Brillo",
        reset: "Restablecer",
        apply: "Aplicar",
        addVariant: "A\xF1adir Variante",
        deleteVariant: "Eliminar Variante",
        variantName: "Nombre de Variante",
        preview: "Vista Previa",
        addToIcons: "A\xF1adir a icons.js",
        renamePrompt: "Introduce el nuevo nombre para el icono",
        nameCannotBeEmpty: "El nombre no puede estar vac\xEDo",
        enterDifferentName: "Introduce un nombre diferente",
        nameValidation: "El nombre solo puede contener letras, n\xFAmeros, guiones y guiones bajos",
        enterVariantName: "Introduce el nombre de la variante",
        variantPlaceholder: "ej. Tema oscuro, Colores primarios...",
        editVariantName: "Editar nombre de variante",
        deleteOriginalSvg: "Eliminar SVG original",
        deleteOriginalSvgDesc: "Eliminar el archivo fuente despu\xE9s de construir",
        keepOriginalSvg: "Mantener SVG original",
        keepOriginalSvgDesc: "Preservar el archivo fuente",
        whatToDoWithOriginal: "\xBFQu\xE9 hacer con el archivo original?",
        addTo: "A\xF1adir a",
        iconsLibrary: "Librer\xEDa de Iconos",
        selectSvgToImport: "Selecciona un SVG para importar",
        enterIconName: "Introduce el nombre del icono"
      },
      animation: {
        title: "Animaci\xF3n",
        type: "Tipo",
        duration: "Duraci\xF3n",
        timing: "Funci\xF3n de Tiempo",
        iteration: "Iteraci\xF3n",
        delay: "Retraso",
        direction: "Direcci\xF3n",
        none: "Ninguna",
        spin: "Girar",
        pulse: "Pulso",
        bounce: "Rebotar",
        shake: "Temblar",
        flip: "Voltear",
        swing: "Balancear",
        rubberBand: "El\xE1stico",
        tada: "Tada",
        heartbeat: "Latido",
        flash: "Destello"
      },
      details: {
        title: "Detalles del Icono",
        name: "Nombre",
        path: "Ruta",
        size: "Tama\xF1o",
        viewBox: "ViewBox",
        colors: "Colores Encontrados",
        source: "Origen",
        status: "Estado",
        built: "Compilado",
        notBuilt: "No Compilado",
        inSprite: "En Sprite",
        notInSprite: "No est\xE1 en Sprite"
      },
      sprite: {
        title: "Sprite SVG",
        generate: "Generar Sprite",
        regenerate: "Regenerar Sprite",
        preview: "Vista Previa del Sprite",
        iconsCount: "{count} iconos",
        noIcons: "No hay iconos en el sprite",
        addSelected: "A\xF1adir Seleccionados al Sprite"
      },
      messages: {
        iconAdded: "Icono '{name}' a\xF1adido a icons.js",
        iconAddedToSprite: "'{name}' a\xF1adido a sprite.svg",
        iconAddedToIconsJs: "'{name}' a\xF1adido a icons.js",
        iconAddedWithAnimation: "'{name}' a\xF1adido a icons.js con animaci\xF3n",
        animationSaved: "Animaci\xF3n '{animation}' asignada a '{name}'",
        animationRemoved: "Animaci\xF3n eliminada de '{name}'",
        iconRemoved: "Icono '{name}' eliminado",
        iconRenamed: "Icono renombrado de '{oldName}' a '{newName}'",
        renamedTo: "Renombrado a '{name}'",
        iconDuplicated: "Icono duplicado como '{name}'",
        iconOptimized: "Icono optimizado correctamente",
        iconAlreadyOptimized: "El SVG ya est\xE1 optimizado",
        optimizedApplied: "SVG optimizado aplicado",
        optimizedSaved: "SVG optimizado aplicado y guardado",
        optimizedReduced: "Optimizado: {original} \u2192 {optimized} ({percent}% reducci\xF3n)",
        buildSuccess: "Iconos compilados correctamente",
        buildFailed: "Error en compilaci\xF3n: {error}",
        failedToAddIcon: "Error al a\xF1adir icono: {error}",
        failedToImportIcon: "Error al importar icono: {error}",
        failedToBuildIcon: "Error al compilar icono: {error}",
        failedToOptimize: "Error al optimizar SVG: {error}",
        configSaved: "Configuraci\xF3n guardada",
        configError: "Error al guardar configuraci\xF3n: {error}",
        configureOutputFirst: "Configura el directorio de salida primero",
        noWorkspace: "No hay carpeta de workspace abierta",
        noActiveEditor: "No hay editor activo",
        noIconData: "No hay datos del icono. Por favor, reabre el editor.",
        noIconSelected: "Ning\xFAn icono seleccionado",
        noFiltersToApply: "No hay filtros que aplicar",
        filtersApplied: "Filtros aplicados a los colores",
        selectIcon: "Por favor, selecciona un icono",
        selectIcons: "Por favor, selecciona uno o m\xE1s iconos",
        confirmDelete: "\xBFEst\xE1s seguro de que quieres eliminar {count} icono(s)?",
        yes: "S\xED",
        no: "No",
        cancel: "Cancelar",
        ok: "Aceptar",
        error: "Error",
        warning: "Advertencia",
        info: "Informaci\xF3n",
        success: "\xC9xito",
        copiedToClipboard: "\xA1Copiado al portapapeles!",
        copiedNameToClipboard: "'{name}' copiado al portapapeles",
        svgCopiedToClipboard: "SVG copiado al portapapeles",
        animatedSvgCopied: "SVG animado copiado al portapapeles",
        codeInsertedAtCursor: "C\xF3digo insertado en el cursor",
        noActiveEditorCodeCopied: "No hay editor activo. C\xF3digo copiado al portapapeles.",
        scanComplete: "Escaneo completo: {count} iconos encontrados",
        noIconsFound: "No se encontraron iconos en el workspace",
        noInlineSvgsFound: "No se encontraron SVGs inline en este archivo",
        noIconsFoundForQuery: "No se encontraron iconos para '{query}'",
        svgFileNotFound: "Archivo SVG no encontrado: {path}",
        noBuiltIconsFound: "No hay iconos compilados. Compila algunos iconos primero.",
        couldNotReadSvg: "No se pudo leer el contenido SVG",
        couldNotUpdateSprite: "No se pudo actualizar sprite.svg",
        couldNotFindIconsJs: "No se encontr\xF3 icons.js para actualizar",
        variantGenerated: "Variante '{name}' generada",
        variantSaved: "Variante '{name}' guardada",
        variantUpdated: "Variante '{name}' actualizada",
        variantSetAsDefault: "'{name}' es ahora la variante predeterminada para {icon}",
        variantDefaultCleared: "Variante predeterminada eliminada para {icon}",
        scriptCopiedToClipboard: "\xA1Etiqueta script copiada al portapapeles!",
        missingScriptImport: '\xA1Falta importar el script! A\xF1ade <script type="module" src="./{outputDir}/icon.js"></script> a tu <head> HTML',
        copyToClipboard: "Copiar al Portapapeles",
        dismiss: "Descartar",
        iconImported: "\xA1Icono '{name}' importado a {targets}!",
        iconBuilt: "\xA1Icono '{name}' compilado a {format}!",
        iconTransformed: "\xA1Icono '{name}' transformado a <{component}>!",
        extractInlineSvg: 'Extraer SVG inline como "{name}"',
        addedFillColor: "Color de relleno a\xF1adido: {color}",
        updatedFile: "Actualizado {path}",
        errorRenaming: "Error al renombrar: {error}",
        couldNotFindImgRef: "No se encontr\xF3 la referencia IMG en el documento. El archivo puede haber cambiado.",
        couldNotFindSvgInDoc: "No se encontr\xF3 el SVG en el documento. El archivo puede haber cambiado.",
        transformedToFormat: "SVG transformado a formato {format}",
        pleaseSelectSvg: "Por favor, selecciona un elemento SVG",
        svgTransformedToComponent: "SVG transformado a componente {format}",
        svgOptimized: "\xA1SVG optimizado!",
        noIconsInLibrary: "No se encontraron iconos en la librer\xEDa",
        spriteGenerated: "Sprite generado en {path}",
        spriteNotFound: "sprite.svg no encontrado",
        noIconsInSprite: "No se encontraron iconos en sprite.svg",
        iconCopied: "Copiado: {name}",
        failedToExportComponent: "Error al exportar componente: {error}",
        iconRenamedTo: "Icono renombrado a: {name}",
        confirmDeleteIcon: '\xBFEliminar "{name}" del sprite?',
        confirmDeleteIconFromFile: '\xBFEliminar "{name}" del archivo de iconos?',
        iconDeleted: "Icono eliminado: {name}",
        spriteClean: "El sprite est\xE1 limpio - no se encontr\xF3 contenido inv\xE1lido.",
        spriteCleanedCount: "Sprite limpiado: {removed} entradas inv\xE1lidas eliminadas. {kept} iconos restantes.",
        svgCopiedToClipboard: "SVG copiado al portapapeles",
        noIconsFile: "No se encontr\xF3 archivo de iconos",
        iconsFileNotFound: "Archivo de iconos no encontrado",
        noIconsInFile: "No se encontraron iconos en el archivo",
        noFileSelected: "Ning\xFAn archivo seleccionado",
        fileNotFound: "Archivo no encontrado: {path}",
        confirmDeleteFile: "\xBFEliminar '{name}'? Esta acci\xF3n no se puede deshacer.",
        fileDeleted: "Eliminado: {name}",
        failedToDeleteFile: "Error al eliminar archivo: {error}",
        svgScanComplete: "\xA1Escaneo de SVG completado!",
        usageScanComplete: "\xA1Escaneo de uso completado!",
        noSvgPathAvailable: "No hay ruta de archivo SVG disponible",
        cannotFindRefLocation: "No se puede encontrar la ubicaci\xF3n de referencia",
        refreshIcons: "Por favor, actualiza la lista de iconos",
        removedReference: 'Referencia eliminada a "{name}"',
        errorRemovingReference: "Error al eliminar referencia: {error}",
        noSvgFilesFound: "No se encontraron archivos SVG en el workspace",
        savedIconTo: "Icono guardado en {name}",
        updatedPath: 'Ruta actualizada de "{oldPath}" a "{newPath}"',
        errorUpdatingPath: "Error al actualizar ruta: {error}",
        failedToFetchIcon: "Error al obtener SVG del icono",
        failedToFetchIconError: "Error al obtener icono: {error}",
        iconAddedToFormat: '\xA1Icono "{name}" a\xF1adido a {format}!',
        failedToAddIcon: "Error al a\xF1adir icono: {error}",
        iconImportedToFormat: '\xA1Icono "{name}" importado a {format}!',
        updatedFile: "Actualizado {path}",
        copiedNameToClipboard: '"{name}" copiado al portapapeles',
        svgAlreadyOptimized: "El SVG ya est\xE1 optimizado",
        optimizedSvgApplied: "SVG optimizado aplicado",
        addedFillColor: "Color de relleno a\xF1adido: {color}",
        variantSaved: 'Variante "{name}" guardada',
        variantSetAsDefault: '"{name}" es ahora la variante predeterminada para {iconName}',
        defaultVariantCleared: "Variante predeterminada eliminada para {iconName}",
        outputDirectorySet: "Directorio de salida configurado en: {path}",
        svgFoldersUpdated: "Carpetas SVG actualizadas",
        componentNameSet: "Nombre de componente configurado en: {name}",
        outputFormatSet: "Formato de salida configurado en: {format}",
        noIconsSelectedForDeletion: "No hay iconos seleccionados para eliminar",
        confirmDeleteIcons: "\xBFEliminar {count} icono(s): {names}?",
        deleteButton: "Eliminar",
        failedToDelete: "Error al eliminar {name}: {error}",
        deletedCount: "{count} icono(s) eliminado(s)",
        selectIconsToRemoveFromBuilt: "Selecciona icono(s) para quitar de compilados",
        couldNotDetermineIconNames: "No se pudieron determinar los nombres de iconos",
        outputDirectoryNotConfigured: "Directorio de salida no configurado",
        removeIconFromBuilt: '\xBFQuitar "{name}" de la librer\xEDa de iconos compilados?',
        removeIconsFromBuilt: "\xBFQuitar {count} iconos de la librer\xEDa de iconos compilados?",
        removeButton: "Quitar",
        removedIconFromBuilt: '"{name}" eliminado de iconos compilados',
        removedIconsFromBuilt: "{count} iconos eliminados de iconos compilados",
        failedToRemoveFromBuilt: "Error al quitar icono(s) de iconos compilados",
        selectIconToRename: "Selecciona un icono para renombrar",
        fileAlreadyExists: 'Ya existe un archivo llamado "{name}"',
        renamedWithReferences: '"{oldName}" renombrado a "{newName}" y actualizadas {count} referencia(s)',
        iconNotFoundInBuildFiles: 'No se encontr\xF3 el icono "{name}" en los archivos compilados',
        renamedFilesUpdated: '"{oldName}" renombrado a "{newName}" ({count} archivo(s) actualizado(s))',
        errorRenamingIcon: "Error al renombrar icono: {error}",
        pleaseSelectValidSvgFile: "Por favor, selecciona un archivo SVG v\xE1lido",
        selectIconFromTreeOrEditor: "Selecciona un icono del \xE1rbol o selecciona c\xF3digo SVG en el editor",
        couldNotFindSvgData: "No se encontraron datos SVG para {name}",
        cannotEditRasterized: 'No se puede editar "{name}": Este SVG tiene {colors} colores \xFAnicos (probablemente una imagen rasterizada). La edici\xF3n de color est\xE1 deshabilitada para SVGs con m\xE1s de {maxColors} colores.',
        selectIconToExport: "Selecciona un icono para exportar",
        addedSvgFolder: "Carpeta SVG a\xF1adida: {path}",
        selectFolderInsideWorkspace: "Por favor, selecciona una carpeta dentro del workspace",
        svgFoldersUpdatedList: "Carpetas SVG actualizadas: {folders}",
        svgFoldersUpdatedNone: "Carpetas SVG actualizadas: (ninguna - se escanear\xE1n todas)",
        removedSvgFolder: "Carpeta SVG eliminada: {folder}",
        noImgReferencesFound: "No se encontraron referencias IMG para transformar",
        allImgReferencesMissing: "Todas las referencias IMG apuntan a archivos inexistentes",
        confirmTransformReferences: "\xBFTransformar {count} referencia(s) IMG a <{component}>?",
        transformedWithErrors: "{transformed} referencias transformadas. {failed} archivo(s) con errores.",
        transformedSuccessfully: "{count} referencia(s) IMG transformada(s) exitosamente a <{component}>",
        confirmBuildSvgFiles: "\xBFCompilar {count} archivo(s) SVG a {format}?",
        outputPathNotConfigured: "Ruta de salida no configurada",
        confirmDeleteOriginals: "{count} icono(s) compilado(s). \xBFEliminar archivos SVG originales?",
        deleteAll: "Eliminar Todos",
        keepAll: "Mantener Todos",
        deletedOriginals: "{count} archivo(s) SVG original(es) eliminado(s)",
        builtWithErrors: "{built} iconos compilados. {failed} archivo(s) con errores.",
        noIconsFoundToBuild: "No se encontraron iconos para compilar",
        skippedRasterizedIcons: "{count} SVG(s) rasterizado(s) omitido(s) por tener demasiados colores: {names}",
        iconsLibraryBuilt: "Librer\xEDa de iconos compilada como {format} en {path}",
        yesButton: "S\xED",
        noButton: "No",
        clickToConfigureOutput: "Clic para configurar el directorio de salida y ajustes",
        svgCanBeConverted: 'SVG "{name}" puede convertirse a componente de Icono',
        transformToFormat: 'Transformar a {format}: "{name}"',
        importIconName: 'Importar icono: "{name}"',
        searchIconify: "Buscar en Iconify...",
        browseWorkspaceIcons: "Explorar iconos del workspace...",
        noIconsInWorkspace: "No se encontraron iconos en el workspace. Intenta buscar en Iconify.",
        iconSelected: 'Icono "{name}" seleccionado',
        iconAlreadyExists: 'El icono "{name}" ya existe'
      },
      settings: {
        title: "Configuraci\xF3n",
        general: "General",
        appearance: "Apariencia",
        build: "Compilaci\xF3n",
        advanced: "Avanzado",
        language: "Idioma",
        languageAuto: "Auto (Sistema)",
        theme: "Tema de Iconos",
        previewSize: "Tama\xF1o de Vista Previa",
        showLabels: "Mostrar Etiquetas",
        outputFormat: "Formato de Salida",
        optimizeOnBuild: "Optimizar al Compilar",
        includeAnimation: "Incluir Datos de Animaci\xF3n",
        generateTypes: "Generar Tipos TypeScript"
      },
      ui: {
        progress: {
          buildingReferences: "Compilando referencias...",
          buildingSvgFiles: "Compilando archivos SVG...",
          buildingIconsLibrary: "Compilando librer\xEDa de iconos...",
          scanningIcons: "Escaneando iconos...",
          generatingOutput: "Generando salida...",
          generatingWebComponent: "Generando web component...",
          processing: "Procesando {name}...",
          building: "Compilando {name}..."
        },
        placeholders: {
          iconName: "nombre-icono",
          selectSettingToConfigure: "Selecciona una opci\xF3n para configurar",
          outputDirectoryExample: "ej., src/icons, assets/icons",
          svgFoldersExample: "src/icons, assets/svg",
          selectOutputFormat: "Selecciona formato de salida",
          configureSvgFolders: "Configurar carpetas SVG a escanear",
          svgFoldersExampleLong: "ej., src/icons, assets/svg, public/images",
          enterSearchTerm: "Introduce t\xE9rmino de b\xFAsqueda (ej., arrow, home, user)",
          selectBuiltIcon: "Selecciona un icono compilado",
          howToFindReplacement: "\xBFC\xF3mo quieres encontrar el SVG de reemplazo?",
          whereToSaveSvg: "\xBFD\xF3nde quieres guardar el nuevo SVG?",
          svgPathExample: "./ruta/al/icono.svg",
          selectSpriteFormat: "Selecciona formato de sprite",
          selectComponentFormat: "Selecciona formato de componente",
          componentNameExample: "ej., IconHome, ArrowIcon",
          selectIconToInsert: "Selecciona icono a insertar",
          variantNameExample: "ej. Tema oscuro, Colores primarios..."
        },
        prompts: {
          enterOutputDirectory: "Introduce el directorio de salida para iconos generados",
          enterSvgFolders: "Introduce carpetas SVG a escanear (separadas por coma)",
          enterSvgFoldersRelative: "Introduce carpetas SVG a escanear (separadas por coma, relativas al workspace)",
          enterComponentName: "Introduce el nombre del componente",
          enterWebComponentName: "Introduce el nombre del web component",
          enterNewIconName: "Introduce nuevo nombre de icono",
          enterIconName: "Introduce un nombre para este icono",
          enterVariantName: "Introduce nombre de variante",
          searchIconify: "Buscar un icono en Iconify",
          searchIconifyFull: 'Buscar iconos (ej., "arrow", "home", "user")',
          enterNewSvgPath: "Introduce la nueva ruta del SVG"
        },
        titles: {
          svgFoldersConfiguration: "Configuraci\xF3n de Carpetas SVG",
          selectSvgFile: "Seleccionar archivo SVG",
          selectFolderToSave: "Seleccionar carpeta para guardar el SVG",
          iconEditor: "Editor de Iconos",
          duplicateIcon: "Icono Duplicado"
        },
        labels: {
          browseForFolder: "Explorar carpeta...",
          enterPathManually: "Introducir ruta manualmente...",
          currentFolders: "Carpetas actuales:",
          removeFolder: "Eliminar: {folder}",
          selectSvgFolder: "Seleccionar Carpeta SVG",
          scanWorkspace: "Escanear Workspace",
          goToUsage: "Ir al Uso",
          goToReference: "Ir a Referencia",
          showDetails: "Mostrar Detalles",
          goToSvg: "Ir al SVG",
          openSetup: "Abrir Configuraci\xF3n",
          importIcon: "Importar Icono",
          fromWorkspace: "Desde archivos SVG del workspace",
          fromIconify: "Desde Iconify (buscar online)",
          saveToWorkspace: "Guardar en carpeta del workspace",
          replaceInPlace: "Reemplazar en sitio (solo actualizar ruta)",
          renameIcon: "Renombrar icono",
          enterNewName: "Introduce un nuevo nombre para el icono",
          replaceIcon: "Reemplazar icono",
          overwriteExisting: "Sobrescribir icono existente",
          cancel: "Cancelar",
          outputDirectory: "Directorio de Salida",
          svgFolders: "Carpetas SVG",
          componentName: "Nombre del Componente",
          outputFormat: "Formato de Salida",
          webComponentName: "Nombre del Web Component",
          svgSprite: "SVG Sprite",
          webComponentJs: "Web Component (JS)",
          both: "Ambos",
          searchInIconify: "Buscar en Iconify",
          useReferencedSvg: "Usar archivo SVG referenciado",
          useInlineSvg: "Usar este SVG inline",
          extractAndBuild: "Extraer y construir como icono",
          browseBuiltIcons: "Explorar iconos construidos",
          browseForSvgFile: "Buscar archivo SVG",
          searchWorkspaceSvg: "Buscar SVG en workspace",
          enterNewPathManually: "Introducir nueva ruta manualmente",
          saveNextToFile: "Guardar junto al archivo referenciado",
          chooseFolder: "Elegir carpeta",
          clickToRemove: "Clic para eliminar esta carpeta",
          selectFolderFromWorkspace: "Seleccionar una carpeta del workspace",
          typeRelativePath: "Escribir una ruta relativa",
          findBuildIconify: "Buscar y construir un icono desde Iconify",
          selectExistingSvg: "Seleccionar un archivo SVG existente",
          selectIconFromLibrary: "Seleccionar un icono ya en tu biblioteca"
        },
        details: {
          outputDirectoryDesc: "Directorio donde se generar\xE1 icons.ts o sprite.svg",
          svgFoldersDesc: "Carpetas para escanear archivos SVG",
          componentNameDesc: "Nombre del componente Icon (ej. Icon)",
          outputFormatDesc: "Formato de salida por defecto (jsx, vue, svelte, etc.)",
          webComponentNameDesc: "Nombre del elemento personalizado (ej. bezier-icon)"
        },
        validation: {
          nameCannotBeEmpty: "El nombre no puede estar vac\xEDo",
          invalidNameFormat: "Formato de nombre inv\xE1lido"
        },
        colors: {
          white: "Blanco",
          black: "Negro",
          blue: "Azul",
          green: "Verde",
          orange: "Naranja",
          red: "Rojo",
          purple: "Morado",
          pink: "Rosa"
        }
      },
      webview: {
        animation: {
          animationType: "Tipo de Animaci\xF3n",
          categoryBasic: "B\xE1sico",
          categoryAttention: "Atenci\xF3n",
          categoryEntrance: "Entrada",
          categoryDraw: "Dibujo",
          drawHint: "Las animaciones de dibujo funcionan mejor con SVGs basados en trazos. El icono debe tener trazos visibles.",
          settings: "Configuraci\xF3n",
          duration: "Duraci\xF3n",
          delay: "Retardo",
          timing: "Temporizaci\xF3n",
          iteration: "Iteraci\xF3n",
          direction: "Direcci\xF3n",
          timingLinear: "Lineal",
          timingEase: "Suave",
          timingEaseIn: "Entrada Suave",
          timingEaseOut: "Salida Suave",
          timingEaseInOut: "Entrada-Salida Suave",
          iterationOnce: "Una vez",
          iterationTwice: "Dos veces",
          iteration3Times: "3 veces",
          iterationInfinite: "Infinito",
          directionNormal: "Normal",
          directionReverse: "Invertido",
          directionAlternate: "Alternado",
          directionAltReverse: "Alt Invertido",
          export: "Exportar",
          saveAnimation: "Asignar",
          saveAnimationTooltip: "Guardar asignaci\xF3n de animaci\xF3n para este icono",
          copyWithAnimation: "Copiar con Animaci\xF3n",
          exportHint: "El SVG incluir\xE1 animaci\xF3n CSS"
        },
        color: {
          colors: "Colores",
          globalFilters: "Filtros Globales",
          hueRotate: "Rotar Tono",
          saturation: "Saturaci\xF3n",
          brightness: "Brillo",
          reset: "Restablecer",
          resetFilters: "Restablecer todos los filtros",
          variants: "Variantes",
          saveVariant: "Guardar colores actuales como variante"
        },
        code: {
          svgSource: "C\xF3digo SVG",
          animationCss: "CSS de Animaci\xF3n",
          usageExample: "Ejemplo de Uso",
          copy: "Copiar",
          copySvg: "Copiar SVG al portapapeles",
          copyAnimation: "Copiar CSS de animaci\xF3n",
          copyUsage: "Copiar c\xF3digo de uso"
        },
        tabs: {
          title: "Gestor de Iconos",
          searchPlaceholder: "Buscar iconos...",
          workspace: "Espacio de Trabajo",
          library: "Biblioteca",
          online: "En L\xEDnea"
        },
        editor: {
          editorBadge: "Editor",
          optimizedBadge: "Optimizado",
          renameIcon: "Renombrar icono",
          zoomOut: "Alejar",
          zoomIn: "Acercar",
          resetZoom: "Restablecer zoom",
          restartAnimation: "Reiniciar animaci\xF3n",
          buildIcons: "Compilar iconos",
          copySvg: "Copiar SVG",
          optimizeSvg: "Optimizar SVG (SVGO)",
          applyOnBuild: "Aplicar al compilar",
          discardOptimization: "Descartar optimizaci\xF3n",
          tabColor: "Color",
          tabAnimation: "Animaci\xF3n",
          tabCode: "C\xF3digo"
        },
        details: {
          built: "Compilado",
          draft: "Borrador",
          zoomOut: "Alejar",
          zoomIn: "Acercar",
          resetZoom: "Restablecer zoom",
          copyIconName: "Copiar nombre del icono",
          copySvgCode: "Copiar c\xF3digo SVG",
          openInEditor: "Abrir en Editor",
          goToSource: "Ir al origen",
          colors: "Colores",
          colorsWarning: "Este SVG tiene {count} colores \xFAnicos. Vista previa de colores deshabilitada para SVGs rasterizados.",
          usesCurrentColor: "Usa currentColor",
          inheritsFromCss: "hereda de CSS",
          noColorsDetected: "No se detectaron colores",
          properties: "Propiedades",
          viewBox: "viewBox",
          dimensions: "Dimensiones",
          fileSize: "Tama\xF1o de archivo",
          elements: "Elementos",
          elementsBreakdown: "Elementos",
          features: "Caracter\xEDsticas",
          sourceLocation: "Ubicaci\xF3n del origen",
          animation: "Animaci\xF3n",
          variants: "Variantes",
          variantsDisabled: "Variantes deshabilitadas para SVGs con demasiados colores",
          saveVariant: "Guardar colores actuales como variante",
          usages: "Usos",
          searchingUsages: "Buscando usos...",
          original: "original",
          currentlyDefault: "Actualmente predeterminado",
          setAsDefault: "Establecer como predeterminado",
          clickToApply: "Clic para aplicar",
          activeDefault: "predeterminado activo",
          delete: "Eliminar",
          license: "Licencia",
          collection: "Colecci\xF3n",
          author: "Autor",
          licenseType: "Licencia",
          unknownAuthor: "Desconocido",
          unknownLicense: "Desconocida",
          licenseUnknown: "Informaci\xF3n de licencia no disponible",
          download: "Descargar"
        },
        spritePreview: {
          icons: "iconos",
          openFile: "Abrir Archivo",
          refresh: "Actualizar",
          copyName: "Copiar Nombre",
          copySvg: "Copiar SVG",
          editIcon: "Editar Icono",
          showDetails: "Ver Detalles",
          exportComponent: "Exportar Componente",
          rename: "Renombrar",
          delete: "Eliminar"
        },
        js: {
          svgWillIncludeAnimation: "SVG incluir\xE1 animaci\xF3n CSS",
          svgCodeCopied: "C\xF3digo SVG copiado al portapapeles",
          animationCssCopied: "CSS de animaci\xF3n copiado al portapapeles",
          usageCodeCopied: "C\xF3digo de uso copiado al portapapeles",
          optimizeSvgo: "Optimizar SVG (SVGO)",
          optimal: "\xD3ptimo",
          alreadyOptimized: "Ya optimizado",
          selectAnimationToEnable: "Selecciona una animaci\xF3n para activar",
          originalColor: "Original: {color}",
          addFillColor: "A\xF1adir color de relleno",
          noIconsFound: "No se encontraron iconos. Escanea tu espacio de trabajo para detectar archivos SVG.",
          noIconsMatch: "Ning\xFAn icono coincide con tu b\xFAsqueda.",
          noUsagesFound: "No se encontraron usos en el espacio de trabajo",
          original: "Original:",
          optimized: "Optimizado:",
          saved: "Ahorrado:",
          alreadyOptimal: "Ya \xF3ptimo",
          searchingUsages: "Buscando usos...",
          noColorsDetected: "No se detectaron colores",
          browseIconify: "Explorar iconos de Iconify",
          comingSoon: "Pr\xF3ximamente...",
          scanWorkspaceBtn: "Escanear espacio de trabajo"
        }
      }
    };
  }
});

// l10n/zh.json
var zh_default;
var init_zh = __esm({
  "l10n/zh.json"() {
    zh_default = {
      extension: {
        name: "Icon Studio",
        description: "VS Code \u7684 SVG \u56FE\u6807\u7BA1\u7406\u5668",
        appTitle: "Icon Studio"
      },
      welcome: {
        title: "\u6B22\u8FCE\u4F7F\u7528 Icon Studio",
        subtitle: "\u60A8\u7684 SVG \u56FE\u6807\u7BA1\u7406\u89E3\u51B3\u65B9\u6848",
        getStarted: "\u5F00\u59CB\u4F7F\u7528",
        configuration: "\u914D\u7F6E",
        language: "\u8BED\u8A00",
        languageDescription: "\u9009\u62E9\u60A8\u7684\u9996\u9009\u8BED\u8A00",
        sourceDirectory: "\u6E90\u76EE\u5F55",
        sourceDirectoryDescription: "SVG \u56FE\u6807\u6240\u5728\u7684\u6587\u4EF6\u5939",
        sourceDirectoryPlaceholder: "\u4F8B\u5982\uFF1Asrc/assets/svg \u6216 icons",
        outputDirectory: "\u8F93\u51FA\u76EE\u5F55",
        outputDirectoryDescription: "\u6784\u5EFA\u56FE\u6807\u5C06\u4FDD\u5B58\u7684\u6587\u4EF6\u5939",
        outputDirectoryPlaceholder: "\u4F8B\u5982\uFF1Asrc/icons \u6216 assets/icons",
        scanDirectories: "\u626B\u63CF\u76EE\u5F55",
        scanDirectoriesDescription: "\u8981\u626B\u63CF SVG \u6587\u4EF6\u7684\u6587\u4EF6\u5939",
        addDirectory: "\u6DFB\u52A0\u76EE\u5F55",
        removeDirectory: "\u5220\u9664",
        save: "\u4FDD\u5B58\u914D\u7F6E",
        saving: "\u4FDD\u5B58\u4E2D...",
        saved: "\u914D\u7F6E\u5DF2\u4FDD\u5B58\uFF01",
        features: "\u529F\u80FD",
        featuresDescription: "\u4E86\u89E3 Icon Studio \u80FD\u4E3A\u60A8\u505A\u4EC0\u4E48",
        documentation: "\u6587\u6863",
        quickStart: "\u5FEB\u901F\u5165\u95E8",
        quickStartDescription: "\u51E0\u5206\u949F\u5B66\u4F1A\u4F7F\u7528 Icon Studio",
        browse: "\u6D4F\u89C8...",
        selectFolder: "\u9009\u62E9\u6587\u4EF6\u5939",
        jsModule: "JS \u6A21\u5757",
        noRuntime: "\u65E0\u8FD0\u884C\u65F6",
        import: "\u5BFC\u5165",
        use: "\u4F7F\u7528",
        reference: "\u5F15\u7528",
        tag: "\u6807\u7B7E",
        webComponentName: "Web\u7EC4\u4EF6\u540D\u79F0",
        webComponentDesc: "\u56FE\u6807\u7684\u81EA\u5B9A\u4E49\u5143\u7D20\u6807\u7B7E\u540D",
        licenseConsentTitle: "\u7B2C\u4E09\u65B9\u8BB8\u53EF\u8BC1",
        licenseConsentDesc: "Iconify\u56FE\u6807\u6709\u81EA\u5DF1\u7684\u8BB8\u53EF\u8BC1\uFF0C\u53EF\u80FD\u9700\u8981\u7F72\u540D\u3002",
        licenseConsentCheckbox: "\u6211\u4E86\u89E3Iconify\u56FE\u6807\u662F\u5177\u6709\u81EA\u5DF1\u8BB8\u53EF\u8BC1\u7684\u7B2C\u4E09\u65B9\u5185\u5BB9\uFF0C\u5E76\u540C\u610F\u5728\u6784\u5EFA\u65F6\u81EA\u52A8\u751F\u6210\u8BB8\u53EF\u8BC1\u7F72\u540D\u6587\u4EF6\u3002",
        licenseConsentInfo: "\u542F\u7528\u540E\uFF0C\u5C06\u5728\u8F93\u51FA\u6587\u4EF6\u5939\u4E2D\u81EA\u52A8\u751F\u6210LICENSES.md\u6587\u4EF6\uFF0C\u5176\u4E2D\u5305\u542B\u9879\u76EE\u4E2D\u4F7F\u7528\u7684\u6240\u6709Iconify\u56FE\u6807\u7684\u6B63\u786E\u7F72\u540D\u3002",
        configureOutputFirst: "\u8BF7\u5148\u914D\u7F6E\u8F93\u51FA\u76EE\u5F55",
        setupComplete: "\u8BBE\u7F6E\u5B8C\u6210\uFF01",
        filesCreated: "\u6587\u4EF6\u5DF2\u521B\u5EFA\u5728 {path}",
        spriteCreated: "\u7CBE\u7075\u56FE\u5DF2\u521B\u5EFA\u5728 {path}",
        errorCreatingFiles: "\u521B\u5EFA\u6587\u4EF6\u65F6\u51FA\u9519",
        previewResult: "\u7ED3\u679C",
        workflowSource: "\u6E90\u6587\u4EF6",
        workflowBuild: "\u6784\u5EFA",
        workflowOutput: "\u8F93\u51FA",
        comingSoon: "\u5373\u5C06\u63A8\u51FA",
        selectFormat: "\u9009\u62E9\u683C\u5F0F...",
        selectFormatFirst: "\u9009\u62E9\u8F93\u51FA\u683C\u5F0F\u4EE5\u67E5\u770B\u9884\u89C8",
        buildFirstMessage: "\u8BF7\u5148\u6784\u5EFA\u56FE\u6807\u4EE5\u67E5\u770B\u9884\u89C8",
        advancedOptions: "\u9AD8\u7EA7\u9009\u9879",
        svgoOptimize: "SVGO \u4F18\u5316",
        scanOnStartup: "\u542F\u52A8\u65F6\u626B\u63CF",
        defaultIconSize: "\u9ED8\u8BA4\u56FE\u6807\u5927\u5C0F",
        previewBackground: "\u9884\u89C8\u80CC\u666F",
        allSettings: "\u6240\u6709\u8BBE\u7F6E..."
      },
      features: {
        iconManagement: "\u56FE\u6807\u7BA1\u7406",
        iconManagementDescription: "\u7EC4\u7EC7\u3001\u9884\u89C8\u548C\u7BA1\u7406\u60A8\u7684 SVG \u56FE\u6807",
        buildSystem: "\u6784\u5EFA\u7CFB\u7EDF",
        buildSystemDescription: "\u5C06\u56FE\u6807\u5BFC\u51FA\u4E3A JS \u6A21\u5757\u6216 SVG \u7CBE\u7075\u56FE",
        iconEditor: "\u56FE\u6807\u7F16\u8F91\u5668",
        iconEditorDescription: "\u7F16\u8F91\u989C\u8272\u3001\u52A8\u753B\u548C\u53D8\u4F53",
        codeIntegration: "\u4EE3\u7801\u96C6\u6210",
        codeIntegrationDescription: "\u4EE3\u7801\u4E2D\u7684\u81EA\u52A8\u5B8C\u6210\u548C\u60AC\u505C\u9884\u89C8",
        iconify: "Iconify \u96C6\u6210",
        iconifyDescription: "\u8BBF\u95EE Iconify \u7684\u6570\u5343\u4E2A\u56FE\u6807"
      },
      treeView: {
        files: "\u6587\u4EF6",
        code: "\u4EE3\u7801",
        built: "\u5DF2\u6784\u5EFA",
        preview: "\u9884\u89C8",
        noIcons: "\u672A\u627E\u5230\u56FE\u6807",
        scanWorkspace: "\u626B\u63CF\u5DE5\u4F5C\u533A\u4E2D\u7684 SVG \u6587\u4EF6",
        configureFirst: "\u914D\u7F6E\u56FE\u6807\u7BA1\u7406\u5668",
        noBuiltIcons: "\u6CA1\u6709\u5DF2\u6784\u5EFA\u7684\u56FE\u6807 - \u8FD0\u884C\u6784\u5EFA\u547D\u4EE4",
        inlineSvgs: "\u5185\u8054 SVG",
        imgReferences: "IMG \u5F15\u7528"
      },
      commands: {
        build: "\u6784\u5EFA\u56FE\u6807",
        buildAll: "\u6784\u5EFA\u5168\u90E8",
        buildSelected: "\u6784\u5EFA\u9009\u4E2D\u9879",
        refresh: "\u5237\u65B0",
        refreshAll: "\u5237\u65B0\u5168\u90E8",
        delete: "\u5220\u9664",
        deleteSelected: "\u5220\u9664\u9009\u4E2D\u9879",
        rename: "\u91CD\u547D\u540D",
        duplicate: "\u590D\u5236",
        copyName: "\u590D\u5236\u540D\u79F0",
        copySvg: "\u590D\u5236 SVG",
        copyComponent: "\u590D\u5236\u4E3A\u7EC4\u4EF6",
        openEditor: "\u5728\u7F16\u8F91\u5668\u4E2D\u6253\u5F00",
        openFile: "\u6253\u5F00\u6587\u4EF6",
        revealInExplorer: "\u5728\u8D44\u6E90\u7BA1\u7406\u5668\u4E2D\u663E\u793A",
        addToSprite: "\u6DFB\u52A0\u5230\u7CBE\u7075\u56FE",
        removeFromSprite: "\u4ECE\u7CBE\u7075\u56FE\u4E2D\u79FB\u9664",
        removeFromBuilt: "\u4ECE\u5DF2\u6784\u5EFA\u4E2D\u79FB\u9664",
        optimize: "\u4F18\u5316 SVG",
        transform: "\u53D8\u6362",
        exportAs: "\u5BFC\u51FA\u4E3A...",
        scanWorkspace: "\u626B\u63CF\u5DE5\u4F5C\u533A",
        goToUsage: "\u8DF3\u8F6C\u5230\u4F7F\u7528\u5904",
        goToReference: "\u8DF3\u8F6C\u5230\u5F15\u7528",
        showDetails: "\u663E\u793A\u8BE6\u60C5",
        goToSvg: "\u8DF3\u8F6C\u5230 SVG",
        openSetup: "\u6253\u5F00\u8BBE\u7F6E",
        transformSvg: "\u8F6C\u6362 SVG \u5F15\u7528",
        importIcon: "\u5BFC\u5165\u56FE\u6807"
      },
      editor: {
        title: "\u56FE\u6807\u7F16\u8F91\u5668",
        edit: "\u7F16\u8F91",
        color: "\u989C\u8272",
        animation: "\u52A8\u753B",
        code: "\u4EE3\u7801",
        variants: "\u53D8\u4F53",
        colors: "\u989C\u8272",
        selectCustomToEdit: "\u9009\u62E9\u81EA\u5B9A\u4E49\u8FDB\u884C\u7F16\u8F91",
        original: "\u539F\u59CB",
        custom: "\u81EA\u5B9A\u4E49",
        readOnly: "\u53EA\u8BFB",
        globalFilters: "\u5168\u5C40\u6EE4\u955C",
        hueRotate: "\u8272\u76F8\u65CB\u8F6C",
        saturation: "\u9971\u548C\u5EA6",
        brightness: "\u4EAE\u5EA6",
        reset: "\u91CD\u7F6E",
        apply: "\u5E94\u7528",
        addVariant: "\u6DFB\u52A0\u53D8\u4F53",
        deleteVariant: "\u5220\u9664\u53D8\u4F53",
        variantName: "\u53D8\u4F53\u540D\u79F0",
        preview: "\u9884\u89C8",
        addToIcons: "\u6DFB\u52A0\u5230 icons.js",
        renamePrompt: "\u8F93\u5165\u56FE\u6807\u7684\u65B0\u540D\u79F0",
        nameCannotBeEmpty: "\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
        enterDifferentName: "\u8BF7\u8F93\u5165\u4E0D\u540C\u7684\u540D\u79F0",
        nameValidation: "\u540D\u79F0\u53EA\u80FD\u5305\u542B\u5B57\u6BCD\u3001\u6570\u5B57\u3001\u77ED\u6A2A\u7EBF\u548C\u4E0B\u5212\u7EBF",
        enterVariantName: "\u8F93\u5165\u53D8\u4F53\u540D\u79F0",
        variantPlaceholder: "\u4F8B\u5982\uFF1A\u6DF1\u8272\u4E3B\u9898\u3001\u4E3B\u8272\u8C03...",
        editVariantName: "\u7F16\u8F91\u53D8\u4F53\u540D\u79F0",
        deleteOriginalSvg: "\u5220\u9664\u539F\u59CB SVG",
        deleteOriginalSvgDesc: "\u6784\u5EFA\u540E\u5220\u9664\u6E90\u6587\u4EF6",
        keepOriginalSvg: "\u4FDD\u7559\u539F\u59CB SVG",
        keepOriginalSvgDesc: "\u4FDD\u7559\u6E90\u6587\u4EF6",
        whatToDoWithOriginal: "\u5982\u4F55\u5904\u7406\u539F\u59CB\u6587\u4EF6\uFF1F",
        addTo: "\u6DFB\u52A0\u5230",
        iconsLibrary: "\u56FE\u6807\u5E93",
        selectSvgToImport: "\u9009\u62E9\u8981\u5BFC\u5165\u7684 SVG",
        enterIconName: "\u8F93\u5165\u56FE\u6807\u540D\u79F0"
      },
      animation: {
        title: "\u52A8\u753B",
        type: "\u7C7B\u578B",
        duration: "\u6301\u7EED\u65F6\u95F4",
        timing: "\u65F6\u95F4\u51FD\u6570",
        iteration: "\u8FED\u4EE3\u6B21\u6570",
        delay: "\u5EF6\u8FDF",
        direction: "\u65B9\u5411",
        none: "\u65E0",
        spin: "\u65CB\u8F6C",
        pulse: "\u8109\u51B2",
        bounce: "\u5F39\u8DF3",
        shake: "\u6296\u52A8",
        flip: "\u7FFB\u8F6C",
        swing: "\u6446\u52A8",
        rubberBand: "\u6A61\u76AE\u7B4B",
        tada: "\u60CA\u559C",
        heartbeat: "\u5FC3\u8DF3",
        flash: "\u95EA\u70C1"
      },
      details: {
        title: "\u56FE\u6807\u8BE6\u60C5",
        name: "\u540D\u79F0",
        path: "\u8DEF\u5F84",
        size: "\u5927\u5C0F",
        viewBox: "\u89C6\u56FE\u6846",
        colors: "\u53D1\u73B0\u7684\u989C\u8272",
        source: "\u6765\u6E90",
        status: "\u72B6\u6001",
        built: "\u5DF2\u6784\u5EFA",
        notBuilt: "\u672A\u6784\u5EFA",
        inSprite: "\u5728\u7CBE\u7075\u56FE\u4E2D",
        notInSprite: "\u4E0D\u5728\u7CBE\u7075\u56FE\u4E2D"
      },
      sprite: {
        title: "SVG \u7CBE\u7075\u56FE",
        generate: "\u751F\u6210\u7CBE\u7075\u56FE",
        regenerate: "\u91CD\u65B0\u751F\u6210\u7CBE\u7075\u56FE",
        preview: "\u9884\u89C8\u7CBE\u7075\u56FE",
        iconsCount: "{count} \u4E2A\u56FE\u6807",
        noIcons: "\u7CBE\u7075\u56FE\u4E2D\u6CA1\u6709\u56FE\u6807",
        addSelected: "\u5C06\u9009\u4E2D\u9879\u6DFB\u52A0\u5230\u7CBE\u7075\u56FE"
      },
      messages: {
        iconAdded: "\u56FE\u6807 '{name}' \u5DF2\u6DFB\u52A0\u5230 icons.js",
        iconAddedToSprite: "'{name}' \u5DF2\u6DFB\u52A0\u5230 sprite.svg",
        iconAddedToIconsJs: "'{name}' \u5DF2\u6DFB\u52A0\u5230 icons.js",
        iconAddedWithAnimation: "'{name}' \u5DF2\u6DFB\u52A0\u5230 icons.js\uFF08\u542B\u52A8\u753B\uFF09",
        animationSaved: "\u52A8\u753B '{animation}' \u5DF2\u5206\u914D\u7ED9 '{name}'",
        animationRemoved: "\u52A8\u753B\u5DF2\u4ECE '{name}' \u79FB\u9664",
        iconRemoved: "\u56FE\u6807 '{name}' \u5DF2\u5220\u9664",
        iconRenamed: "\u56FE\u6807\u5DF2\u4ECE '{oldName}' \u91CD\u547D\u540D\u4E3A '{newName}'",
        renamedTo: "\u5DF2\u91CD\u547D\u540D\u4E3A '{name}'",
        iconDuplicated: "\u56FE\u6807\u5DF2\u590D\u5236\u4E3A '{name}'",
        iconOptimized: "\u56FE\u6807\u4F18\u5316\u6210\u529F",
        iconAlreadyOptimized: "SVG \u5DF2\u7ECF\u662F\u6700\u4F18\u5316\u7684",
        optimizedApplied: "\u4F18\u5316\u540E\u7684 SVG \u5DF2\u5E94\u7528",
        optimizedSaved: "\u4F18\u5316\u540E\u7684 SVG \u5DF2\u5E94\u7528\u5E76\u4FDD\u5B58",
        optimizedReduced: "\u5DF2\u4F18\u5316\uFF1A{original} \u2192 {optimized}\uFF08\u51CF\u5C11 {percent}%\uFF09",
        buildSuccess: "\u56FE\u6807\u6784\u5EFA\u6210\u529F",
        buildFailed: "\u6784\u5EFA\u5931\u8D25\uFF1A{error}",
        failedToAddIcon: "\u6DFB\u52A0\u56FE\u6807\u5931\u8D25\uFF1A{error}",
        failedToImportIcon: "\u5BFC\u5165\u56FE\u6807\u5931\u8D25\uFF1A{error}",
        failedToBuildIcon: "\u6784\u5EFA\u56FE\u6807\u5931\u8D25\uFF1A{error}",
        failedToOptimize: "\u4F18\u5316 SVG \u5931\u8D25\uFF1A{error}",
        configSaved: "\u914D\u7F6E\u5DF2\u4FDD\u5B58",
        configError: "\u4FDD\u5B58\u914D\u7F6E\u65F6\u51FA\u9519\uFF1A{error}",
        configureOutputFirst: "\u8BF7\u5148\u914D\u7F6E\u8F93\u51FA\u76EE\u5F55",
        noWorkspace: "\u6CA1\u6709\u6253\u5F00\u7684\u5DE5\u4F5C\u533A\u6587\u4EF6\u5939",
        noActiveEditor: "\u6CA1\u6709\u6D3B\u52A8\u7684\u7F16\u8F91\u5668",
        noIconData: "\u6CA1\u6709\u56FE\u6807\u6570\u636E\u3002\u8BF7\u91CD\u65B0\u6253\u5F00\u7F16\u8F91\u5668\u3002",
        noIconSelected: "\u672A\u9009\u62E9\u56FE\u6807",
        noFiltersToApply: "\u6CA1\u6709\u8981\u5E94\u7528\u7684\u8FC7\u6EE4\u5668",
        filtersApplied: "\u8FC7\u6EE4\u5668\u5DF2\u5E94\u7528\u5230\u989C\u8272",
        selectIcon: "\u8BF7\u9009\u62E9\u4E00\u4E2A\u56FE\u6807",
        selectIcons: "\u8BF7\u9009\u62E9\u4E00\u4E2A\u6216\u591A\u4E2A\u56FE\u6807",
        confirmDelete: "\u786E\u5B9A\u8981\u5220\u9664 {count} \u4E2A\u56FE\u6807\u5417\uFF1F",
        yes: "\u662F",
        no: "\u5426",
        cancel: "\u53D6\u6D88",
        ok: "\u786E\u5B9A",
        error: "\u9519\u8BEF",
        warning: "\u8B66\u544A",
        info: "\u4FE1\u606F",
        success: "\u6210\u529F",
        copiedToClipboard: "\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01",
        copiedNameToClipboard: "'{name}' \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
        svgCopiedToClipboard: "SVG \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
        animatedSvgCopied: "\u52A8\u753B SVG \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
        codeInsertedAtCursor: "\u4EE3\u7801\u5DF2\u63D2\u5165\u5149\u6807\u4F4D\u7F6E",
        noActiveEditorCodeCopied: "\u6CA1\u6709\u6D3B\u52A8\u7684\u7F16\u8F91\u5668\u3002\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\u3002",
        scanComplete: "\u626B\u63CF\u5B8C\u6210\uFF1A\u627E\u5230 {count} \u4E2A\u56FE\u6807",
        noIconsFound: "\u5728\u5DE5\u4F5C\u533A\u4E2D\u672A\u627E\u5230\u56FE\u6807",
        noInlineSvgsFound: "\u6B64\u6587\u4EF6\u4E2D\u672A\u627E\u5230\u5185\u8054 SVG",
        noIconsFoundForQuery: "\u672A\u627E\u5230 '{query}' \u76F8\u5173\u7684\u56FE\u6807",
        svgFileNotFound: "SVG \u6587\u4EF6\u672A\u627E\u5230\uFF1A{path}",
        noBuiltIconsFound: "\u6CA1\u6709\u5DF2\u6784\u5EFA\u7684\u56FE\u6807\u3002\u8BF7\u5148\u6784\u5EFA\u4E00\u4E9B\u56FE\u6807\u3002",
        couldNotReadSvg: "\u65E0\u6CD5\u8BFB\u53D6 SVG \u5185\u5BB9",
        couldNotUpdateSprite: "\u65E0\u6CD5\u66F4\u65B0 sprite.svg",
        couldNotFindIconsJs: "\u627E\u4E0D\u5230 icons.js \u8FDB\u884C\u66F4\u65B0",
        variantGenerated: "\u53D8\u4F53 '{name}' \u5DF2\u751F\u6210",
        variantSaved: "\u53D8\u4F53 '{name}' \u5DF2\u4FDD\u5B58",
        variantUpdated: "\u53D8\u4F53 '{name}' \u5DF2\u66F4\u65B0",
        variantSetAsDefault: "'{name}' \u73B0\u5728\u662F {icon} \u7684\u9ED8\u8BA4\u53D8\u4F53",
        variantDefaultCleared: "{icon} \u7684\u9ED8\u8BA4\u53D8\u4F53\u5DF2\u6E05\u9664",
        scriptCopiedToClipboard: "\u811A\u672C\u6807\u7B7E\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F\uFF01",
        missingScriptImport: '\u7F3A\u5C11\u811A\u672C\u5BFC\u5165\uFF01\u8BF7\u5728 HTML <head> \u4E2D\u6DFB\u52A0 <script type="module" src="./{outputDir}/icon.js"></script>',
        copyToClipboard: "\u590D\u5236\u5230\u526A\u8D34\u677F",
        dismiss: "\u5173\u95ED",
        iconImported: "\u56FE\u6807 '{name}' \u5DF2\u5BFC\u5165\u5230 {targets}\uFF01",
        iconBuilt: "\u56FE\u6807 '{name}' \u5DF2\u6784\u5EFA\u5230 {format}\uFF01",
        iconTransformed: "\u56FE\u6807 '{name}' \u5DF2\u8F6C\u6362\u4E3A <{component}>\uFF01",
        extractInlineSvg: '\u63D0\u53D6\u5185\u8054 SVG \u4E3A "{name}"',
        addedFillColor: "\u5DF2\u6DFB\u52A0\u586B\u5145\u989C\u8272\uFF1A{color}",
        updatedFile: "\u5DF2\u66F4\u65B0 {path}",
        errorRenaming: "\u91CD\u547D\u540D\u9519\u8BEF\uFF1A{error}",
        couldNotFindImgRef: "\u5728\u6587\u6863\u4E2D\u627E\u4E0D\u5230 IMG \u5F15\u7528\u3002\u6587\u4EF6\u53EF\u80FD\u5DF2\u66F4\u6539\u3002",
        couldNotFindSvgInDoc: "\u5728\u6587\u6863\u4E2D\u627E\u4E0D\u5230 SVG\u3002\u6587\u4EF6\u53EF\u80FD\u5DF2\u66F4\u6539\u3002",
        transformedToFormat: "SVG \u5DF2\u8F6C\u6362\u4E3A {format} \u683C\u5F0F",
        pleaseSelectSvg: "\u8BF7\u9009\u62E9\u4E00\u4E2A SVG \u5143\u7D20",
        svgTransformedToComponent: "SVG \u5DF2\u8F6C\u6362\u4E3A {format} \u7EC4\u4EF6",
        svgOptimized: "SVG \u5DF2\u4F18\u5316\uFF01",
        noIconsInLibrary: "\u5E93\u4E2D\u672A\u627E\u5230\u56FE\u6807",
        spriteGenerated: "Sprite \u5DF2\u751F\u6210\u5728 {path}",
        spriteNotFound: "\u672A\u627E\u5230 sprite.svg",
        noIconsInSprite: "sprite.svg \u4E2D\u672A\u627E\u5230\u56FE\u6807",
        iconCopied: "\u5DF2\u590D\u5236\uFF1A{name}",
        failedToExportComponent: "\u5BFC\u51FA\u7EC4\u4EF6\u5931\u8D25\uFF1A{error}",
        iconRenamedTo: "\u56FE\u6807\u5DF2\u91CD\u547D\u540D\u4E3A\uFF1A{name}",
        confirmDeleteIcon: '\u4ECE\u7CBE\u7075\u56FE\u4E2D\u5220\u9664 "{name}"\uFF1F',
        confirmDeleteIconFromFile: '\u4ECE\u56FE\u6807\u6587\u4EF6\u4E2D\u5220\u9664 "{name}"\uFF1F',
        iconDeleted: "\u56FE\u6807\u5DF2\u5220\u9664\uFF1A{name}",
        spriteClean: "Sprite \u662F\u5E72\u51C0\u7684 - \u672A\u627E\u5230\u65E0\u6548\u5185\u5BB9\u3002",
        spriteCleanedCount: "\u7CBE\u7075\u56FE\u5DF2\u6E05\u7406\uFF1A\u79FB\u9664\u4E86 {removed} \u4E2A\u65E0\u6548\u6761\u76EE\u3002\u5269\u4F59 {kept} \u4E2A\u56FE\u6807\u3002",
        svgCopiedToClipboard: "SVG \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
        noIconsFile: "\u672A\u627E\u5230\u56FE\u6807\u6587\u4EF6",
        iconsFileNotFound: "\u56FE\u6807\u6587\u4EF6\u672A\u627E\u5230",
        noIconsInFile: "\u6587\u4EF6\u4E2D\u672A\u627E\u5230\u56FE\u6807",
        noFileSelected: "\u672A\u9009\u62E9\u6587\u4EF6",
        fileNotFound: "\u6587\u4EF6\u672A\u627E\u5230\uFF1A{path}",
        confirmDeleteFile: "\u5220\u9664 '{name}'\uFF1F\u6B64\u64CD\u4F5C\u65E0\u6CD5\u64A4\u9500\u3002",
        fileDeleted: "\u5DF2\u5220\u9664\uFF1A{name}",
        failedToDeleteFile: "\u5220\u9664\u6587\u4EF6\u5931\u8D25\uFF1A{error}",
        svgScanComplete: "SVG \u626B\u63CF\u5B8C\u6210\uFF01",
        usageScanComplete: "\u4F7F\u7528\u626B\u63CF\u5B8C\u6210\uFF01",
        noSvgPathAvailable: "\u6CA1\u6709\u53EF\u7528\u7684 SVG \u6587\u4EF6\u8DEF\u5F84",
        cannotFindRefLocation: "\u627E\u4E0D\u5230\u5F15\u7528\u4F4D\u7F6E",
        refreshIcons: "\u8BF7\u5237\u65B0\u56FE\u6807\u5217\u8868",
        removedReference: '\u5DF2\u79FB\u9664\u5BF9 "{name}" \u7684\u5F15\u7528',
        errorRemovingReference: "\u79FB\u9664\u5F15\u7528\u65F6\u51FA\u9519\uFF1A{error}",
        noSvgFilesFound: "\u5DE5\u4F5C\u533A\u4E2D\u672A\u627E\u5230 SVG \u6587\u4EF6",
        savedIconTo: "\u56FE\u6807\u5DF2\u4FDD\u5B58\u5230 {name}",
        updatedPath: '\u8DEF\u5F84\u5DF2\u4ECE "{oldPath}" \u66F4\u65B0\u4E3A "{newPath}"',
        errorUpdatingPath: "\u66F4\u65B0\u8DEF\u5F84\u65F6\u51FA\u9519\uFF1A{error}",
        failedToFetchIcon: "\u83B7\u53D6\u56FE\u6807 SVG \u5931\u8D25",
        failedToFetchIconError: "\u83B7\u53D6\u56FE\u6807\u5931\u8D25\uFF1A{error}",
        iconAddedToFormat: '\u56FE\u6807 "{name}" \u5DF2\u6DFB\u52A0\u5230 {format}\uFF01',
        failedToAddIcon: "\u6DFB\u52A0\u56FE\u6807\u5931\u8D25\uFF1A{error}",
        iconImportedToFormat: '\u56FE\u6807 "{name}" \u5DF2\u5BFC\u5165\u5230 {format}\uFF01',
        updatedFile: "\u5DF2\u66F4\u65B0 {path}",
        copiedNameToClipboard: '"{name}" \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F',
        svgAlreadyOptimized: "SVG \u5DF2\u7ECF\u662F\u6700\u4F18\u5316\u7684",
        optimizedSvgApplied: "\u5DF2\u5E94\u7528\u4F18\u5316\u7684 SVG",
        addedFillColor: "\u5DF2\u6DFB\u52A0\u586B\u5145\u989C\u8272\uFF1A{color}",
        variantSaved: '\u53D8\u4F53 "{name}" \u5DF2\u4FDD\u5B58',
        variantSetAsDefault: '"{name}" \u73B0\u5728\u662F {iconName} \u7684\u9ED8\u8BA4\u53D8\u4F53',
        defaultVariantCleared: "\u5DF2\u6E05\u9664 {iconName} \u7684\u9ED8\u8BA4\u53D8\u4F53",
        outputDirectorySet: "\u8F93\u51FA\u76EE\u5F55\u5DF2\u8BBE\u7F6E\u4E3A\uFF1A{path}",
        svgFoldersUpdated: "SVG \u6587\u4EF6\u5939\u5DF2\u66F4\u65B0",
        componentNameSet: "\u7EC4\u4EF6\u540D\u79F0\u5DF2\u8BBE\u7F6E\u4E3A\uFF1A{name}",
        outputFormatSet: "\u8F93\u51FA\u683C\u5F0F\u5DF2\u8BBE\u7F6E\u4E3A\uFF1A{format}",
        noIconsSelectedForDeletion: "\u672A\u9009\u62E9\u8981\u5220\u9664\u7684\u56FE\u6807",
        confirmDeleteIcons: "\u5220\u9664 {count} \u4E2A\u56FE\u6807\uFF1A{names}\uFF1F",
        deleteButton: "\u5220\u9664",
        failedToDelete: "\u5220\u9664 {name} \u5931\u8D25\uFF1A{error}",
        deletedCount: "\u5DF2\u5220\u9664 {count} \u4E2A\u56FE\u6807",
        selectIconsToRemoveFromBuilt: "\u9009\u62E9\u8981\u4ECE\u5DF2\u6784\u5EFA\u4E2D\u79FB\u9664\u7684\u56FE\u6807",
        couldNotDetermineIconNames: "\u65E0\u6CD5\u786E\u5B9A\u56FE\u6807\u540D\u79F0",
        outputDirectoryNotConfigured: "\u8F93\u51FA\u76EE\u5F55\u672A\u914D\u7F6E",
        removeIconFromBuilt: '\u4ECE\u5DF2\u6784\u5EFA\u56FE\u6807\u5E93\u4E2D\u79FB\u9664 "{name}"\uFF1F',
        removeIconsFromBuilt: "\u4ECE\u5DF2\u6784\u5EFA\u56FE\u6807\u5E93\u4E2D\u79FB\u9664 {count} \u4E2A\u56FE\u6807\uFF1F",
        removeButton: "\u79FB\u9664",
        removedIconFromBuilt: '"{name}" \u5DF2\u4ECE\u5DF2\u6784\u5EFA\u56FE\u6807\u4E2D\u79FB\u9664',
        removedIconsFromBuilt: "{count} \u4E2A\u56FE\u6807\u5DF2\u4ECE\u5DF2\u6784\u5EFA\u4E2D\u79FB\u9664",
        failedToRemoveFromBuilt: "\u4ECE\u5DF2\u6784\u5EFA\u56FE\u6807\u4E2D\u79FB\u9664\u5931\u8D25",
        selectIconToRename: "\u9009\u62E9\u8981\u91CD\u547D\u540D\u7684\u56FE\u6807",
        fileAlreadyExists: '\u540D\u4E3A "{name}" \u7684\u6587\u4EF6\u5DF2\u5B58\u5728',
        renamedWithReferences: '"{oldName}" \u5DF2\u91CD\u547D\u540D\u4E3A "{newName}" \u5E76\u66F4\u65B0\u4E86 {count} \u4E2A\u5F15\u7528',
        iconNotFoundInBuildFiles: '\u5728\u6784\u5EFA\u6587\u4EF6\u4E2D\u627E\u4E0D\u5230\u56FE\u6807 "{name}"',
        renamedFilesUpdated: '"{oldName}" \u5DF2\u91CD\u547D\u540D\u4E3A "{newName}"\uFF08\u66F4\u65B0\u4E86 {count} \u4E2A\u6587\u4EF6\uFF09',
        errorRenamingIcon: "\u91CD\u547D\u540D\u56FE\u6807\u9519\u8BEF\uFF1A{error}",
        pleaseSelectValidSvgFile: "\u8BF7\u9009\u62E9\u4E00\u4E2A\u6709\u6548\u7684 SVG \u6587\u4EF6",
        selectIconFromTreeOrEditor: "\u4ECE\u6811\u89C6\u56FE\u9009\u62E9\u56FE\u6807\u6216\u5728\u7F16\u8F91\u5668\u4E2D\u9009\u62E9 SVG \u4EE3\u7801",
        couldNotFindSvgData: "\u627E\u4E0D\u5230 {name} \u7684 SVG \u6570\u636E",
        cannotEditRasterized: '\u65E0\u6CD5\u7F16\u8F91 "{name}"\uFF1A\u6B64 SVG \u6709 {colors} \u79CD\u72EC\u7279\u989C\u8272\uFF08\u53EF\u80FD\u662F\u5149\u6805\u5316\u56FE\u50CF\uFF09\u3002\u8D85\u8FC7 {maxColors} \u79CD\u989C\u8272\u7684 SVG \u65E0\u6CD5\u8FDB\u884C\u989C\u8272\u7F16\u8F91\u3002',
        selectIconToExport: "\u9009\u62E9\u8981\u5BFC\u51FA\u7684\u56FE\u6807",
        addedSvgFolder: "SVG \u6587\u4EF6\u5939\u5DF2\u6DFB\u52A0\uFF1A{path}",
        selectFolderInsideWorkspace: "\u8BF7\u9009\u62E9\u5DE5\u4F5C\u533A\u5185\u7684\u6587\u4EF6\u5939",
        svgFoldersUpdatedList: "SVG \u6587\u4EF6\u5939\u5DF2\u66F4\u65B0\uFF1A{folders}",
        svgFoldersUpdatedNone: "SVG \u6587\u4EF6\u5939\u5DF2\u66F4\u65B0\uFF1A\uFF08\u65E0 - \u5C06\u626B\u63CF\u6240\u6709\uFF09",
        removedSvgFolder: "SVG \u6587\u4EF6\u5939\u5DF2\u79FB\u9664\uFF1A{folder}",
        noImgReferencesFound: "\u672A\u627E\u5230\u8981\u8F6C\u6362\u7684 IMG \u5F15\u7528",
        allImgReferencesMissing: "\u6240\u6709 IMG \u5F15\u7528\u90FD\u6307\u5411\u4E22\u5931\u7684\u6587\u4EF6",
        confirmTransformReferences: "\u5C06 {count} \u4E2A IMG \u5F15\u7528\u8F6C\u6362\u4E3A <{component}>\uFF1F",
        transformedWithErrors: "\u5DF2\u8F6C\u6362 {transformed} \u4E2A\u5F15\u7528\u3002{failed} \u4E2A\u6587\u4EF6\u51FA\u9519\u3002",
        transformedSuccessfully: "\u6210\u529F\u5C06 {count} \u4E2A IMG \u5F15\u7528\u8F6C\u6362\u4E3A <{component}>",
        confirmBuildSvgFiles: "\u5C06 {count} \u4E2A SVG \u6587\u4EF6\u6784\u5EFA\u5230 {format}\uFF1F",
        outputPathNotConfigured: "\u8F93\u51FA\u8DEF\u5F84\u672A\u914D\u7F6E",
        confirmDeleteOriginals: "\u5DF2\u6784\u5EFA {count} \u4E2A\u56FE\u6807\u3002\u5220\u9664\u539F\u59CB SVG \u6587\u4EF6\uFF1F",
        deleteAll: "\u5168\u90E8\u5220\u9664",
        keepAll: "\u5168\u90E8\u4FDD\u7559",
        deletedOriginals: "\u5DF2\u5220\u9664 {count} \u4E2A\u539F\u59CB SVG \u6587\u4EF6",
        builtWithErrors: "\u5DF2\u6784\u5EFA {built} \u4E2A\u56FE\u6807\u3002{failed} \u4E2A\u6587\u4EF6\u51FA\u9519\u3002",
        noIconsFoundToBuild: "\u672A\u627E\u5230\u8981\u6784\u5EFA\u7684\u56FE\u6807",
        skippedRasterizedIcons: "\u8DF3\u8FC7\u4E86 {count} \u4E2A\u989C\u8272\u8FC7\u591A\u7684\u5149\u6805\u5316 SVG\uFF1A{names}",
        iconsLibraryBuilt: "\u56FE\u6807\u5E93\u5DF2\u6784\u5EFA\u4E3A {format}\uFF0C\u4F4D\u4E8E {path}",
        yesButton: "\u662F",
        noButton: "\u5426",
        clickToConfigureOutput: "\u70B9\u51FB\u914D\u7F6E\u8F93\u51FA\u76EE\u5F55\u548C\u8BBE\u7F6E",
        svgCanBeConverted: 'SVG "{name}" \u53EF\u4EE5\u8F6C\u6362\u4E3A\u56FE\u6807\u7EC4\u4EF6',
        transformToFormat: '\u8F6C\u6362\u4E3A {format}: "{name}"',
        importIconName: '\u5BFC\u5165\u56FE\u6807: "{name}"',
        searchIconify: "\u5728 Iconify \u4E2D\u641C\u7D22...",
        browseWorkspaceIcons: "\u6D4F\u89C8\u5DE5\u4F5C\u533A\u56FE\u6807...",
        noIconsInWorkspace: "\u5DE5\u4F5C\u533A\u4E2D\u672A\u627E\u5230\u56FE\u6807\u3002\u8BF7\u5C1D\u8BD5\u5728 Iconify \u4E2D\u641C\u7D22\u3002",
        iconSelected: '\u56FE\u6807 "{name}" \u5DF2\u9009\u4E2D',
        iconAlreadyExists: '\u56FE\u6807 "{name}" \u5DF2\u5B58\u5728'
      },
      settings: {
        title: "\u8BBE\u7F6E",
        general: "\u5E38\u89C4",
        appearance: "\u5916\u89C2",
        build: "\u6784\u5EFA",
        advanced: "\u9AD8\u7EA7",
        language: "\u8BED\u8A00",
        languageAuto: "\u81EA\u52A8\uFF08\u7CFB\u7EDF\uFF09",
        theme: "\u56FE\u6807\u4E3B\u9898",
        previewSize: "\u9884\u89C8\u5927\u5C0F",
        showLabels: "\u663E\u793A\u6807\u7B7E",
        outputFormat: "\u8F93\u51FA\u683C\u5F0F",
        optimizeOnBuild: "\u6784\u5EFA\u65F6\u4F18\u5316",
        includeAnimation: "\u5305\u542B\u52A8\u753B\u6570\u636E",
        generateTypes: "\u751F\u6210 TypeScript \u7C7B\u578B"
      },
      ui: {
        progress: {
          buildingReferences: "\u6B63\u5728\u6784\u5EFA\u5F15\u7528...",
          buildingSvgFiles: "\u6B63\u5728\u6784\u5EFA SVG \u6587\u4EF6...",
          buildingIconsLibrary: "\u6B63\u5728\u6784\u5EFA\u56FE\u6807\u5E93...",
          scanningIcons: "\u6B63\u5728\u626B\u63CF\u56FE\u6807...",
          generatingOutput: "\u6B63\u5728\u751F\u6210\u8F93\u51FA...",
          generatingWebComponent: "\u6B63\u5728\u751F\u6210 Web \u7EC4\u4EF6...",
          processing: "\u6B63\u5728\u5904\u7406 {name}...",
          building: "\u6B63\u5728\u6784\u5EFA {name}..."
        },
        placeholders: {
          iconName: "\u56FE\u6807\u540D\u79F0",
          selectSettingToConfigure: "\u9009\u62E9\u8981\u914D\u7F6E\u7684\u8BBE\u7F6E",
          outputDirectoryExample: "\u4F8B\u5982 src/icons, assets/icons",
          svgFoldersExample: "src/icons, assets/svg",
          selectOutputFormat: "\u9009\u62E9\u8F93\u51FA\u683C\u5F0F",
          configureSvgFolders: "\u914D\u7F6E\u8981\u626B\u63CF\u7684 SVG \u6587\u4EF6\u5939",
          svgFoldersExampleLong: "\u4F8B\u5982 src/icons, assets/svg, public/images",
          enterSearchTerm: "\u8F93\u5165\u641C\u7D22\u8BCD\uFF08\u4F8B\u5982 arrow, home, user\uFF09",
          selectBuiltIcon: "\u9009\u62E9\u5DF2\u6784\u5EFA\u7684\u56FE\u6807",
          howToFindReplacement: "\u60A8\u60F3\u5982\u4F55\u67E5\u627E\u66FF\u6362 SVG\uFF1F",
          whereToSaveSvg: "\u60A8\u60F3\u5C06\u65B0 SVG \u4FDD\u5B58\u5728\u54EA\u91CC\uFF1F",
          svgPathExample: "./\u8DEF\u5F84/\u5230/\u56FE\u6807.svg",
          selectSpriteFormat: "\u9009\u62E9 Sprite \u683C\u5F0F",
          selectComponentFormat: "\u9009\u62E9\u7EC4\u4EF6\u683C\u5F0F",
          componentNameExample: "\u4F8B\u5982 IconHome, ArrowIcon",
          selectIconToInsert: "\u9009\u62E9\u8981\u63D2\u5165\u7684\u56FE\u6807",
          variantNameExample: "\u4F8B\u5982 \u6DF1\u8272\u4E3B\u9898\u3001\u4E3B\u8981\u989C\u8272..."
        },
        prompts: {
          enterOutputDirectory: "\u8F93\u5165\u751F\u6210\u56FE\u6807\u7684\u8F93\u51FA\u76EE\u5F55",
          enterSvgFolders: "\u8F93\u5165\u8981\u626B\u63CF\u7684 SVG \u6587\u4EF6\u5939\uFF08\u7528\u9017\u53F7\u5206\u9694\uFF09",
          enterSvgFoldersRelative: "\u8F93\u5165\u8981\u626B\u63CF\u7684 SVG \u6587\u4EF6\u5939\uFF08\u7528\u9017\u53F7\u5206\u9694\uFF0C\u76F8\u5BF9\u4E8E workspace\uFF09",
          enterComponentName: "\u8F93\u5165\u7EC4\u4EF6\u540D\u79F0",
          enterWebComponentName: "\u8F93\u5165 Web \u7EC4\u4EF6\u540D\u79F0",
          enterNewIconName: "\u8F93\u5165\u65B0\u56FE\u6807\u540D\u79F0",
          enterIconName: "\u4E3A\u6B64\u56FE\u6807\u8F93\u5165\u540D\u79F0",
          enterVariantName: "\u8F93\u5165\u53D8\u4F53\u540D\u79F0",
          searchIconify: "\u5728 Iconify \u641C\u7D22\u56FE\u6807",
          searchIconifyFull: '\u641C\u7D22\u56FE\u6807\uFF08\u4F8B\u5982 "arrow", "home", "user"\uFF09',
          enterNewSvgPath: "\u8F93\u5165\u65B0 SVG \u8DEF\u5F84"
        },
        titles: {
          svgFoldersConfiguration: "SVG \u6587\u4EF6\u5939\u914D\u7F6E",
          selectSvgFile: "\u9009\u62E9 SVG \u6587\u4EF6",
          selectFolderToSave: "\u9009\u62E9\u4FDD\u5B58 SVG \u7684\u6587\u4EF6\u5939",
          iconEditor: "\u56FE\u6807\u7F16\u8F91\u5668",
          duplicateIcon: "\u56FE\u6807\u91CD\u590D"
        },
        labels: {
          browseForFolder: "\u6D4F\u89C8\u6587\u4EF6\u5939...",
          enterPathManually: "\u624B\u52A8\u8F93\u5165\u8DEF\u5F84...",
          currentFolders: "\u5F53\u524D\u6587\u4EF6\u5939\uFF1A",
          removeFolder: "\u79FB\u9664\uFF1A{folder}",
          selectSvgFolder: "\u9009\u62E9 SVG \u6587\u4EF6\u5939",
          scanWorkspace: "\u626B\u63CF Workspace",
          goToUsage: "\u8DF3\u8F6C\u5230\u4F7F\u7528\u4F4D\u7F6E",
          goToReference: "\u8DF3\u8F6C\u5230\u5F15\u7528",
          showDetails: "\u663E\u793A\u8BE6\u60C5",
          goToSvg: "\u8DF3\u8F6C\u5230 SVG",
          openSetup: "\u6253\u5F00\u8BBE\u7F6E",
          importIcon: "\u5BFC\u5165\u56FE\u6807",
          fromWorkspace: "\u4ECE workspace SVG \u6587\u4EF6",
          fromIconify: "\u4ECE Iconify\uFF08\u5728\u7EBF\u641C\u7D22\uFF09",
          saveToWorkspace: "\u4FDD\u5B58\u5230 workspace \u6587\u4EF6\u5939",
          replaceInPlace: "\u539F\u5730\u66FF\u6362\uFF08\u4EC5\u66F4\u65B0\u8DEF\u5F84\uFF09",
          renameIcon: "\u91CD\u547D\u540D\u56FE\u6807",
          enterNewName: "\u4E3A\u56FE\u6807\u8F93\u5165\u65B0\u540D\u79F0",
          replaceIcon: "\u66FF\u6362\u56FE\u6807",
          overwriteExisting: "\u8986\u76D6\u73B0\u6709\u56FE\u6807",
          cancel: "\u53D6\u6D88",
          outputDirectory: "\u8F93\u51FA\u76EE\u5F55",
          svgFolders: "SVG \u6587\u4EF6\u5939",
          componentName: "\u7EC4\u4EF6\u540D\u79F0",
          outputFormat: "\u8F93\u51FA\u683C\u5F0F",
          webComponentName: "Web \u7EC4\u4EF6\u540D\u79F0",
          svgSprite: "SVG Sprite",
          webComponentJs: "Web \u7EC4\u4EF6 (JS)",
          both: "\u4E24\u8005\u90FD",
          searchInIconify: "\u5728 Iconify \u4E2D\u641C\u7D22",
          useReferencedSvg: "\u4F7F\u7528\u5F15\u7528\u7684 SVG \u6587\u4EF6",
          useInlineSvg: "\u4F7F\u7528\u6B64\u5185\u8054 SVG",
          extractAndBuild: "\u63D0\u53D6\u5E76\u6784\u5EFA\u4E3A\u56FE\u6807",
          browseBuiltIcons: "\u6D4F\u89C8\u5DF2\u6784\u5EFA\u56FE\u6807",
          browseForSvgFile: "\u6D4F\u89C8 SVG \u6587\u4EF6",
          searchWorkspaceSvg: "\u5728 workspace \u4E2D\u641C\u7D22 SVG",
          enterNewPathManually: "\u624B\u52A8\u8F93\u5165\u65B0\u8DEF\u5F84",
          saveNextToFile: "\u4FDD\u5B58\u5728\u5F15\u7528\u6587\u4EF6\u65C1\u8FB9",
          chooseFolder: "\u9009\u62E9\u6587\u4EF6\u5939",
          clickToRemove: "\u70B9\u51FB\u79FB\u9664\u6B64\u6587\u4EF6\u5939",
          selectFolderFromWorkspace: "\u4ECE workspace \u9009\u62E9\u6587\u4EF6\u5939",
          typeRelativePath: "\u8F93\u5165\u76F8\u5BF9\u8DEF\u5F84",
          findBuildIconify: "\u4ECE Iconify \u67E5\u627E\u5E76\u6784\u5EFA\u56FE\u6807",
          selectExistingSvg: "\u9009\u62E9\u73B0\u6709 SVG \u6587\u4EF6",
          selectIconFromLibrary: "\u9009\u62E9\u5E93\u4E2D\u7684\u56FE\u6807"
        },
        details: {
          outputDirectoryDesc: "\u751F\u6210 icons.ts \u6216 sprite.svg \u7684\u76EE\u5F55",
          svgFoldersDesc: "\u8981\u626B\u63CF SVG \u6587\u4EF6\u7684\u6587\u4EF6\u5939",
          componentNameDesc: "Icon \u7EC4\u4EF6\u7684\u540D\u79F0\uFF08\u4F8B\u5982 Icon\uFF09",
          outputFormatDesc: "\u9ED8\u8BA4\u8F93\u51FA\u683C\u5F0F\uFF08jsx\u3001vue\u3001svelte \u7B49\uFF09",
          webComponentNameDesc: "\u81EA\u5B9A\u4E49\u5143\u7D20\u7684\u540D\u79F0\uFF08\u4F8B\u5982 bezier-icon\uFF09"
        },
        validation: {
          nameCannotBeEmpty: "\u540D\u79F0\u4E0D\u80FD\u4E3A\u7A7A",
          invalidNameFormat: "\u540D\u79F0\u683C\u5F0F\u65E0\u6548"
        },
        colors: {
          white: "\u767D\u8272",
          black: "\u9ED1\u8272",
          blue: "\u84DD\u8272",
          green: "\u7EFF\u8272",
          orange: "\u6A59\u8272",
          red: "\u7EA2\u8272",
          purple: "\u7D2B\u8272",
          pink: "\u7C89\u8272"
        }
      },
      webview: {
        animation: {
          animationType: "\u52A8\u753B\u7C7B\u578B",
          categoryBasic: "\u57FA\u7840",
          categoryAttention: "\u6CE8\u610F",
          categoryEntrance: "\u8FDB\u5165",
          categoryDraw: "\u7ED8\u5236",
          drawHint: "\u7ED8\u5236\u52A8\u753B\u6700\u9002\u5408\u57FA\u4E8E\u63CF\u8FB9\u7684 SVG\u3002\u56FE\u6807\u5E94\u8BE5\u6709\u53EF\u89C1\u7684\u63CF\u8FB9\u3002",
          settings: "\u8BBE\u7F6E",
          duration: "\u6301\u7EED\u65F6\u95F4",
          delay: "\u5EF6\u8FDF",
          timing: "\u65F6\u5E8F",
          iteration: "\u8FED\u4EE3",
          direction: "\u65B9\u5411",
          timingLinear: "\u7EBF\u6027",
          timingEase: "\u7F13\u52A8",
          timingEaseIn: "\u7F13\u5165",
          timingEaseOut: "\u7F13\u51FA",
          timingEaseInOut: "\u7F13\u5165\u7F13\u51FA",
          iterationOnce: "\u4E00\u6B21",
          iterationTwice: "\u4E24\u6B21",
          iteration3Times: "3 \u6B21",
          iterationInfinite: "\u65E0\u9650",
          directionNormal: "\u6B63\u5E38",
          directionReverse: "\u53CD\u5411",
          directionAlternate: "\u4EA4\u66FF",
          directionAltReverse: "\u4EA4\u66FF\u53CD\u5411",
          export: "\u5BFC\u51FA",
          saveAnimation: "\u5206\u914D",
          saveAnimationTooltip: "\u4FDD\u5B58\u6B64\u56FE\u6807\u7684\u52A8\u753B\u5206\u914D",
          copyWithAnimation: "\u590D\u5236\u5E26\u52A8\u753B",
          exportHint: "SVG \u5C06\u5305\u542B CSS \u52A8\u753B"
        },
        color: {
          colors: "\u989C\u8272",
          globalFilters: "\u5168\u5C40\u6EE4\u955C",
          hueRotate: "\u8272\u76F8\u65CB\u8F6C",
          saturation: "\u9971\u548C\u5EA6",
          brightness: "\u4EAE\u5EA6",
          reset: "\u91CD\u7F6E",
          resetFilters: "\u91CD\u7F6E\u6240\u6709\u6EE4\u955C",
          variants: "\u53D8\u4F53",
          saveVariant: "\u5C06\u5F53\u524D\u989C\u8272\u4FDD\u5B58\u4E3A\u53D8\u4F53"
        },
        code: {
          svgSource: "SVG \u6E90\u7801",
          animationCss: "\u52A8\u753B CSS",
          usageExample: "\u4F7F\u7528\u793A\u4F8B",
          copy: "\u590D\u5236",
          copySvg: "\u590D\u5236SVG\u5230\u526A\u8D34\u677F",
          copyAnimation: "\u590D\u5236\u52A8\u753BCSS",
          copyUsage: "\u590D\u5236\u4F7F\u7528\u4EE3\u7801"
        },
        tabs: {
          title: "\u56FE\u6807\u7BA1\u7406\u5668",
          searchPlaceholder: "\u641C\u7D22\u56FE\u6807...",
          workspace: "\u5DE5\u4F5C\u533A",
          library: "\u5E93",
          online: "\u5728\u7EBF"
        },
        editor: {
          editorBadge: "\u7F16\u8F91\u5668",
          optimizedBadge: "\u5DF2\u4F18\u5316",
          renameIcon: "\u91CD\u547D\u540D\u56FE\u6807",
          zoomOut: "\u7F29\u5C0F",
          zoomIn: "\u653E\u5927",
          resetZoom: "\u91CD\u7F6E\u7F29\u653E",
          restartAnimation: "\u91CD\u65B0\u64AD\u653E\u52A8\u753B",
          buildIcons: "\u6784\u5EFA\u56FE\u6807",
          copySvg: "\u590D\u5236SVG",
          optimizeSvg: "\u4F18\u5316SVG (SVGO)",
          applyOnBuild: "\u6784\u5EFA\u65F6\u5E94\u7528",
          discardOptimization: "\u653E\u5F03\u4F18\u5316",
          tabColor: "\u989C\u8272",
          tabAnimation: "\u52A8\u753B",
          tabCode: "\u4EE3\u7801"
        },
        details: {
          built: "\u5DF2\u6784\u5EFA",
          draft: "\u8349\u7A3F",
          zoomOut: "\u7F29\u5C0F",
          zoomIn: "\u653E\u5927",
          resetZoom: "\u91CD\u7F6E\u7F29\u653E",
          copyIconName: "\u590D\u5236\u56FE\u6807\u540D\u79F0",
          copySvgCode: "\u590D\u5236SVG\u4EE3\u7801",
          openInEditor: "\u5728\u7F16\u8F91\u5668\u4E2D\u6253\u5F00",
          goToSource: "\u8F6C\u5230\u6E90\u6587\u4EF6",
          colors: "\u989C\u8272",
          colorsWarning: "\u6B64SVG\u6709{count}\u79CD\u72EC\u7279\u989C\u8272\u3002\u5DF2\u7981\u7528\u5149\u6805\u5316SVG\u7684\u989C\u8272\u9884\u89C8\u3002",
          usesCurrentColor: "\u4F7F\u7528currentColor",
          inheritsFromCss: "\u4ECECSSX\u7EE7\u627F",
          noColorsDetected: "\u672A\u68C0\u6D4B\u5230\u989C\u8272",
          properties: "\u5C5E\u6027",
          viewBox: "viewBox",
          dimensions: "\u5C3A\u5BF8",
          fileSize: "\u6587\u4EF6\u5927\u5C0F",
          elements: "\u5143\u7D20",
          elementsBreakdown: "\u5143\u7D20",
          features: "\u7279\u6027",
          sourceLocation: "\u6E90\u4F4D\u7F6E",
          animation: "\u52A8\u753B",
          variants: "\u53D8\u4F53",
          variantsDisabled: "\u989C\u8272\u8FC7\u591A\u7684SVG\u5DF2\u7981\u7528\u53D8\u4F53",
          saveVariant: "\u5C06\u5F53\u524D\u989C\u8272\u4FDD\u5B58\u4E3A\u53D8\u4F53",
          usages: "\u4F7F\u7528",
          searchingUsages: "\u6B63\u5728\u641C\u7D22\u4F7F\u7528...",
          original: "\u539F\u59CB",
          currentlyDefault: "\u5F53\u524D\u9ED8\u8BA4",
          setAsDefault: "\u8BBE\u4E3A\u9ED8\u8BA4",
          clickToApply: "\u70B9\u51FB\u5E94\u7528",
          activeDefault: "\u6D3B\u52A8\u9ED8\u8BA4",
          delete: "\u5220\u9664",
          license: "\u8BB8\u53EF\u8BC1",
          collection: "\u96C6\u5408",
          author: "\u4F5C\u8005",
          licenseType: "\u8BB8\u53EF\u8BC1",
          unknownAuthor: "\u672A\u77E5",
          unknownLicense: "\u672A\u77E5",
          licenseUnknown: "\u8BB8\u53EF\u8BC1\u4FE1\u606F\u4E0D\u53EF\u7528",
          download: "\u4E0B\u8F7D"
        },
        spritePreview: {
          icons: "\u56FE\u6807",
          openFile: "\u6253\u5F00\u6587\u4EF6",
          refresh: "\u5237\u65B0",
          copyName: "\u590D\u5236\u540D\u79F0",
          copySvg: "\u590D\u5236SVG",
          editIcon: "\u7F16\u8F91\u56FE\u6807",
          showDetails: "\u663E\u793A\u8BE6\u60C5",
          exportComponent: "\u5BFC\u51FA\u7EC4\u4EF6",
          rename: "\u91CD\u547D\u540D",
          delete: "\u5220\u9664"
        },
        js: {
          svgWillIncludeAnimation: "SVG \u5C06\u5305\u542B CSS \u52A8\u753B",
          svgCodeCopied: "SVG \u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
          animationCssCopied: "\u52A8\u753B CSS \u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
          usageCodeCopied: "\u4F7F\u7528\u4EE3\u7801\u5DF2\u590D\u5236\u5230\u526A\u8D34\u677F",
          optimizeSvgo: "\u4F18\u5316 SVG (SVGO)",
          optimal: "\u6700\u4F18",
          alreadyOptimized: "\u5DF2\u4F18\u5316",
          selectAnimationToEnable: "\u9009\u62E9\u52A8\u753B\u4EE5\u542F\u7528",
          originalColor: "\u539F\u59CB: {color}",
          addFillColor: "\u6DFB\u52A0\u586B\u5145\u989C\u8272",
          noIconsFound: "\u672A\u627E\u5230\u56FE\u6807\u3002\u626B\u63CF\u5DE5\u4F5C\u533A\u4EE5\u68C0\u6D4B SVG \u6587\u4EF6\u3002",
          noIconsMatch: "\u6CA1\u6709\u56FE\u6807\u5339\u914D\u60A8\u7684\u641C\u7D22\u3002",
          noUsagesFound: "\u5728\u5DE5\u4F5C\u533A\u4E2D\u672A\u627E\u5230\u4F7F\u7528",
          original: "\u539F\u59CB:",
          optimized: "\u5DF2\u4F18\u5316:",
          saved: "\u8282\u7701:",
          alreadyOptimal: "\u5DF2\u662F\u6700\u4F18",
          searchingUsages: "\u6B63\u5728\u641C\u7D22\u4F7F\u7528...",
          noColorsDetected: "\u672A\u68C0\u6D4B\u5230\u989C\u8272",
          browseIconify: "\u6D4F\u89C8 Iconify \u56FE\u6807",
          comingSoon: "\u5373\u5C06\u63A8\u51FA...",
          scanWorkspaceBtn: "\u626B\u63CF\u5DE5\u4F5C\u533A"
        }
      }
    };
  }
});

// l10n/ru.json
var ru_default;
var init_ru = __esm({
  "l10n/ru.json"() {
    ru_default = {
      extension: {
        name: "Icon Studio",
        description: "\u041C\u0435\u043D\u0435\u0434\u0436\u0435\u0440 SVG \u0438\u043A\u043E\u043D\u043E\u043A \u0434\u043B\u044F VS Code",
        appTitle: "Icon Studio"
      },
      welcome: {
        title: "\u0414\u043E\u0431\u0440\u043E \u043F\u043E\u0436\u0430\u043B\u043E\u0432\u0430\u0442\u044C \u0432 Icon Studio",
        subtitle: "\u0412\u0430\u0448\u0435 \u0440\u0435\u0448\u0435\u043D\u0438\u0435 \u0434\u043B\u044F \u0443\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u044F SVG \u0438\u043A\u043E\u043D\u043A\u0430\u043C\u0438",
        getStarted: "\u041D\u0430\u0447\u0430\u0442\u044C",
        configuration: "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F",
        language: "\u042F\u0437\u044B\u043A",
        languageDescription: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0440\u0435\u0434\u043F\u043E\u0447\u0438\u0442\u0430\u0435\u043C\u044B\u0439 \u044F\u0437\u044B\u043A",
        sourceDirectory: "\u0418\u0441\u0445\u043E\u0434\u043D\u044B\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433",
        sourceDirectoryDescription: "\u041F\u0430\u043F\u043A\u0430 \u0441 \u0432\u0430\u0448\u0438\u043C\u0438 SVG \u0438\u043A\u043E\u043D\u043A\u0430\u043C\u0438",
        sourceDirectoryPlaceholder: "\u043D\u0430\u043F\u0440., src/assets/svg \u0438\u043B\u0438 icons",
        outputDirectory: "\u0412\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433",
        outputDirectoryDescription: "\u041F\u0430\u043F\u043A\u0430 \u0434\u043B\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A",
        outputDirectoryPlaceholder: "\u043D\u0430\u043F\u0440., src/icons \u0438\u043B\u0438 assets/icons",
        scanDirectories: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433\u0438 \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F",
        scanDirectoriesDescription: "\u041F\u0430\u043F\u043A\u0438 \u0434\u043B\u044F \u043F\u043E\u0438\u0441\u043A\u0430 SVG \u0444\u0430\u0439\u043B\u043E\u0432",
        addDirectory: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u043A\u0430\u0442\u0430\u043B\u043E\u0433",
        removeDirectory: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
        save: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044E",
        saving: "\u0421\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u0435...",
        saved: "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430!",
        features: "\u0412\u043E\u0437\u043C\u043E\u0436\u043D\u043E\u0441\u0442\u0438",
        featuresDescription: "\u0423\u0437\u043D\u0430\u0439\u0442\u0435, \u0447\u0442\u043E Icon Studio \u043C\u043E\u0436\u0435\u0442 \u0441\u0434\u0435\u043B\u0430\u0442\u044C \u0434\u043B\u044F \u0432\u0430\u0441",
        documentation: "\u0414\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0430\u0446\u0438\u044F",
        quickStart: "\u0411\u044B\u0441\u0442\u0440\u044B\u0439 \u0441\u0442\u0430\u0440\u0442",
        quickStartDescription: "\u041D\u0430\u0443\u0447\u0438\u0442\u0435\u0441\u044C \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C Icon Studio \u0437\u0430 \u043C\u0438\u043D\u0443\u0442\u044B",
        browse: "\u041E\u0431\u0437\u043E\u0440...",
        selectFolder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443",
        jsModule: "JS \u041C\u043E\u0434\u0443\u043B\u044C",
        noRuntime: "\u0411\u0435\u0437 runtime",
        import: "\u0418\u043C\u043F\u043E\u0440\u0442",
        use: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0435",
        reference: "\u0421\u0441\u044B\u043B\u043A\u0430",
        tag: "\u0422\u0435\u0433",
        webComponentName: "\u0418\u043C\u044F Web-\u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
        webComponentDesc: "\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0433\u043E \u0442\u0435\u0433\u0430 \u0434\u043B\u044F \u0438\u043A\u043E\u043D\u043E\u043A",
        licenseConsentTitle: "\u041B\u0438\u0446\u0435\u043D\u0437\u0438\u0438 \u0442\u0440\u0435\u0442\u044C\u0438\u0445 \u0441\u0442\u043E\u0440\u043E\u043D",
        licenseConsentDesc: "\u0418\u043A\u043E\u043D\u043A\u0438 Iconify \u0438\u043C\u0435\u044E\u0442 \u0441\u043E\u0431\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u0435 \u043B\u0438\u0446\u0435\u043D\u0437\u0438\u0438, \u043A\u043E\u0442\u043E\u0440\u044B\u0435 \u043C\u043E\u0433\u0443\u0442 \u0442\u0440\u0435\u0431\u043E\u0432\u0430\u0442\u044C \u0443\u043A\u0430\u0437\u0430\u043D\u0438\u044F \u0430\u0432\u0442\u043E\u0440\u0441\u0442\u0432\u0430.",
        licenseConsentCheckbox: "\u042F \u043F\u043E\u043D\u0438\u043C\u0430\u044E, \u0447\u0442\u043E \u0438\u043A\u043E\u043D\u043A\u0438 Iconify \u044F\u0432\u043B\u044F\u044E\u0442\u0441\u044F \u043A\u043E\u043D\u0442\u0435\u043D\u0442\u043E\u043C \u0442\u0440\u0435\u0442\u044C\u0438\u0445 \u0441\u0442\u043E\u0440\u043E\u043D \u0441 \u0441\u043E\u0431\u0441\u0442\u0432\u0435\u043D\u043D\u044B\u043C\u0438 \u043B\u0438\u0446\u0435\u043D\u0437\u0438\u044F\u043C\u0438, \u0438 \u0441\u043E\u0433\u043B\u0430\u0441\u0435\u043D \u043D\u0430 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0443\u044E \u0433\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044E \u0444\u0430\u0439\u043B\u043E\u0432 \u0430\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u0438 \u043F\u0440\u0438 \u0441\u0431\u043E\u0440\u043A\u0435.",
        licenseConsentInfo: "\u041F\u0440\u0438 \u0432\u043A\u043B\u044E\u0447\u0435\u043D\u0438\u0438 \u0444\u0430\u0439\u043B LICENSES.md \u0431\u0443\u0434\u0435\u0442 \u0430\u0432\u0442\u043E\u043C\u0430\u0442\u0438\u0447\u0435\u0441\u043A\u0438 \u0441\u043E\u0437\u0434\u0430\u043D \u0432 \u0432\u0430\u0448\u0435\u0439 \u0432\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043F\u0430\u043F\u043A\u0435 \u0441 \u043F\u0440\u0430\u0432\u0438\u043B\u044C\u043D\u043E\u0439 \u0430\u0442\u0440\u0438\u0431\u0443\u0446\u0438\u0435\u0439 \u0434\u043B\u044F \u0432\u0441\u0435\u0445 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u043C\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A Iconify.",
        configureOutputFirst: "\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u0442\u0435 \u0432\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433",
        setupComplete: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u0430!",
        filesCreated: "\u0424\u0430\u0439\u043B\u044B \u0441\u043E\u0437\u0434\u0430\u043D\u044B \u0432 {path}",
        spriteCreated: "\u0421\u043F\u0440\u0430\u0439\u0442 \u0441\u043E\u0437\u0434\u0430\u043D \u0432 {path}",
        errorCreatingFiles: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0437\u0434\u0430\u043D\u0438\u044F \u0444\u0430\u0439\u043B\u043E\u0432",
        previewResult: "\u0420\u0435\u0437\u0443\u043B\u044C\u0442\u0430\u0442",
        workflowSource: "\u0418\u0441\u0442\u043E\u0447\u043D\u0438\u043A",
        workflowBuild: "\u0421\u0431\u043E\u0440\u043A\u0430",
        workflowOutput: "\u0412\u044B\u0432\u043E\u0434",
        comingSoon: "\u0421\u043A\u043E\u0440\u043E",
        selectFormat: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0444\u043E\u0440\u043C\u0430\u0442...",
        selectFormatFirst: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430 \u0434\u043B\u044F \u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430 \u043F\u0440\u0435\u0432\u044C\u044E",
        buildFirstMessage: "\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0441\u043E\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0438, \u0447\u0442\u043E\u0431\u044B \u0443\u0432\u0438\u0434\u0435\u0442\u044C \u043F\u0440\u0435\u0432\u044C\u044E",
        advancedOptions: "\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u043D\u044B\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
        svgoOptimize: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0430\u0446\u0438\u044F SVGO",
        scanOnStartup: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0440\u0438 \u0437\u0430\u043F\u0443\u0441\u043A\u0435",
        defaultIconSize: "\u0420\u0430\u0437\u043C\u0435\u0440 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
        previewBackground: "\u0424\u043E\u043D \u043F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440\u0430",
        allSettings: "\u0412\u0441\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438..."
      },
      features: {
        iconManagement: "\u0423\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435 \u0438\u043A\u043E\u043D\u043A\u0430\u043C\u0438",
        iconManagementDescription: "\u041E\u0440\u0433\u0430\u043D\u0438\u0437\u0443\u0439\u0442\u0435, \u043F\u0440\u043E\u0441\u043C\u0430\u0442\u0440\u0438\u0432\u0430\u0439\u0442\u0435 \u0438 \u0443\u043F\u0440\u0430\u0432\u043B\u044F\u0439\u0442\u0435 SVG \u0438\u043A\u043E\u043D\u043A\u0430\u043C\u0438",
        buildSystem: "\u0421\u0438\u0441\u0442\u0435\u043C\u0430 \u0441\u0431\u043E\u0440\u043A\u0438",
        buildSystemDescription: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0438 \u0432 JS \u043C\u043E\u0434\u0443\u043B\u0438 \u0438\u043B\u0438 SVG \u0441\u043F\u0440\u0430\u0439\u0442\u044B",
        iconEditor: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0438\u043A\u043E\u043D\u043E\u043A",
        iconEditorDescription: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u0443\u0439\u0442\u0435 \u0446\u0432\u0435\u0442\u0430, \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438 \u0438 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u044B",
        codeIntegration: "\u0418\u043D\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u044F \u0441 \u043A\u043E\u0434\u043E\u043C",
        codeIntegrationDescription: "\u0410\u0432\u0442\u043E\u0434\u043E\u043F\u043E\u043B\u043D\u0435\u043D\u0438\u0435 \u0438 \u043F\u0440\u0435\u0432\u044C\u044E \u043F\u0440\u0438 \u043D\u0430\u0432\u0435\u0434\u0435\u043D\u0438\u0438 \u0432 \u043A\u043E\u0434\u0435",
        iconify: "\u0418\u043D\u0442\u0435\u0433\u0440\u0430\u0446\u0438\u044F \u0441 Iconify",
        iconifyDescription: "\u0414\u043E\u0441\u0442\u0443\u043F \u043A \u0442\u044B\u0441\u044F\u0447\u0430\u043C \u0438\u043A\u043E\u043D\u043E\u043A \u0438\u0437 Iconify"
      },
      treeView: {
        files: "\u0424\u0430\u0439\u043B\u044B",
        code: "\u041A\u043E\u0434",
        built: "\u0421\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0435",
        preview: "\u041F\u0440\u0435\u0432\u044C\u044E",
        noIcons: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B",
        scanWorkspace: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0440\u0430\u0431\u043E\u0447\u0443\u044E \u043E\u0431\u043B\u0430\u0441\u0442\u044C \u043D\u0430 \u043D\u0430\u043B\u0438\u0447\u0438\u0435 SVG \u0444\u0430\u0439\u043B\u043E\u0432",
        configureFirst: "\u041D\u0430\u0441\u0442\u0440\u043E\u0438\u0442\u044C Icon Studio",
        noBuiltIcons: "\u041D\u0435\u0442 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A - \u0412\u044B\u043F\u043E\u043B\u043D\u0438\u0442\u0435 \u043A\u043E\u043C\u0430\u043D\u0434\u0443 Build",
        inlineSvgs: "\u0412\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u044B\u0435 SVG",
        imgReferences: "IMG \u0441\u0441\u044B\u043B\u043A\u0438"
      },
      commands: {
        build: "\u0421\u043E\u0431\u0440\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0438",
        buildAll: "\u0421\u043E\u0431\u0440\u0430\u0442\u044C \u0432\u0441\u0435",
        buildSelected: "\u0421\u043E\u0431\u0440\u0430\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435",
        refresh: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C",
        refreshAll: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u0432\u0441\u0435",
        delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
        deleteSelected: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435",
        rename: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C",
        duplicate: "\u0414\u0443\u0431\u043B\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
        copyName: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043C\u044F",
        copySvg: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG",
        copyComponent: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u043A \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442",
        openEditor: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0432 \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0435",
        openFile: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0444\u0430\u0439\u043B",
        revealInExplorer: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0432 \u043F\u0440\u043E\u0432\u043E\u0434\u043D\u0438\u043A\u0435",
        addToSprite: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432 \u0441\u043F\u0440\u0430\u0439\u0442",
        removeFromSprite: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0437 \u0441\u043F\u0440\u0430\u0439\u0442\u0430",
        removeFromBuilt: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0437 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445",
        optimize: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG",
        transform: "\u0422\u0440\u0430\u043D\u0441\u0444\u043E\u0440\u043C\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
        exportAs: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u0430\u043A...",
        scanWorkspace: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0440\u0430\u0431\u043E\u0447\u0435\u0435 \u043F\u0440\u043E\u0441\u0442\u0440\u0430\u043D\u0441\u0442\u0432\u043E",
        goToUsage: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044E",
        goToReference: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0441\u0441\u044B\u043B\u043A\u0435",
        showDetails: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438",
        goToSvg: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A SVG",
        openSetup: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0443",
        transformSvg: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C \u0441\u0441\u044B\u043B\u043A\u0443 SVG",
        importIcon: "\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443"
      },
      editor: {
        title: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0438\u043A\u043E\u043D\u043E\u043A",
        edit: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
        color: "\u0426\u0432\u0435\u0442",
        animation: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F",
        code: "\u041A\u043E\u0434",
        variants: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442\u044B",
        colors: "\u0426\u0432\u0435\u0442\u0430",
        selectCustomToEdit: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 custom \u0434\u043B\u044F \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F",
        original: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B",
        custom: "\u041F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u0438\u0439",
        readOnly: "\u0422\u043E\u043B\u044C\u043A\u043E \u0447\u0442\u0435\u043D\u0438\u0435",
        globalFilters: "\u0413\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u0442\u0440\u044B",
        hueRotate: "\u041F\u043E\u0432\u043E\u0440\u043E\u0442 \u043E\u0442\u0442\u0435\u043D\u043A\u0430",
        saturation: "\u041D\u0430\u0441\u044B\u0449\u0435\u043D\u043D\u043E\u0441\u0442\u044C",
        brightness: "\u042F\u0440\u043A\u043E\u0441\u0442\u044C",
        reset: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C",
        apply: "\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C",
        addVariant: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432\u0430\u0440\u0438\u0430\u043D\u0442",
        deleteVariant: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0430\u0440\u0438\u0430\u043D\u0442",
        variantName: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0430",
        preview: "\u041F\u0440\u0435\u0432\u044C\u044E",
        addToIcons: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432 icons.js",
        renamePrompt: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u043E\u0432\u043E\u0435 \u0438\u043C\u044F \u0434\u043B\u044F \u0438\u043A\u043E\u043D\u043A\u0438",
        nameCannotBeEmpty: "\u0418\u043C\u044F \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0443\u0441\u0442\u044B\u043C",
        enterDifferentName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0434\u0440\u0443\u0433\u043E\u0435 \u0438\u043C\u044F",
        nameValidation: "\u0418\u043C\u044F \u043C\u043E\u0436\u0435\u0442 \u0441\u043E\u0434\u0435\u0440\u0436\u0430\u0442\u044C \u0442\u043E\u043B\u044C\u043A\u043E \u0431\u0443\u043A\u0432\u044B, \u0446\u0438\u0444\u0440\u044B, \u0434\u0435\u0444\u0438\u0441\u044B \u0438 \u043F\u043E\u0434\u0447\u0451\u0440\u043A\u0438\u0432\u0430\u043D\u0438\u044F",
        enterVariantName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0430",
        variantPlaceholder: "\u043D\u0430\u043F\u0440. \u0422\u0451\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430, \u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435 \u0446\u0432\u0435\u0442\u0430...",
        editVariantName: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0430",
        deleteOriginalSvg: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0439 SVG",
        deleteOriginalSvgDesc: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0439 \u0444\u0430\u0439\u043B \u043F\u043E\u0441\u043B\u0435 \u0441\u0431\u043E\u0440\u043A\u0438",
        keepOriginalSvg: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u0439 SVG",
        keepOriginalSvgDesc: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0439 \u0444\u0430\u0439\u043B",
        whatToDoWithOriginal: "\u0427\u0442\u043E \u0434\u0435\u043B\u0430\u0442\u044C \u0441 \u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B\u044C\u043D\u044B\u043C \u0444\u0430\u0439\u043B\u043E\u043C?",
        addTo: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432",
        iconsLibrary: "\u0411\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0443 \u0438\u043A\u043E\u043D\u043E\u043A",
        selectSvgToImport: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 SVG \u0434\u043B\u044F \u0438\u043C\u043F\u043E\u0440\u0442\u0430",
        enterIconName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0438\u043A\u043E\u043D\u043A\u0438"
      },
      animation: {
        title: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F",
        type: "\u0422\u0438\u043F",
        duration: "\u0414\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
        timing: "\u0424\u0443\u043D\u043A\u0446\u0438\u044F \u0432\u0440\u0435\u043C\u0435\u043D\u0438",
        iteration: "\u0418\u0442\u0435\u0440\u0430\u0446\u0438\u044F",
        delay: "\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430",
        direction: "\u041D\u0430\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435",
        none: "\u041D\u0435\u0442",
        spin: "\u0412\u0440\u0430\u0449\u0435\u043D\u0438\u0435",
        pulse: "\u041F\u0443\u043B\u044C\u0441\u0430\u0446\u0438\u044F",
        bounce: "\u041E\u0442\u0441\u043A\u043E\u043A",
        shake: "\u0422\u0440\u044F\u0441\u043A\u0430",
        flip: "\u041F\u0435\u0440\u0435\u0432\u043E\u0440\u043E\u0442",
        swing: "\u041A\u0430\u0447\u0430\u043D\u0438\u0435",
        rubberBand: "\u0420\u0435\u0437\u0438\u043D\u043A\u0430",
        tada: "\u0422\u0430\u0434\u0430",
        heartbeat: "\u0421\u0435\u0440\u0434\u0446\u0435\u0431\u0438\u0435\u043D\u0438\u0435",
        flash: "\u0412\u0441\u043F\u044B\u0448\u043A\u0430"
      },
      details: {
        title: "\u0414\u0435\u0442\u0430\u043B\u0438 \u0438\u043A\u043E\u043D\u043A\u0438",
        name: "\u041D\u0430\u0437\u0432\u0430\u043D\u0438\u0435",
        path: "\u041F\u0443\u0442\u044C",
        size: "\u0420\u0430\u0437\u043C\u0435\u0440",
        viewBox: "ViewBox",
        colors: "\u041D\u0430\u0439\u0434\u0435\u043D\u043D\u044B\u0435 \u0446\u0432\u0435\u0442\u0430",
        source: "\u0418\u0441\u0442\u043E\u0447\u043D\u0438\u043A",
        status: "\u0421\u0442\u0430\u0442\u0443\u0441",
        built: "\u0421\u043E\u0431\u0440\u0430\u043D\u0430",
        notBuilt: "\u041D\u0435 \u0441\u043E\u0431\u0440\u0430\u043D\u0430",
        inSprite: "\u0412 \u0441\u043F\u0440\u0430\u0439\u0442\u0435",
        notInSprite: "\u041D\u0435 \u0432 \u0441\u043F\u0440\u0430\u0439\u0442\u0435"
      },
      sprite: {
        title: "SVG \u0421\u043F\u0440\u0430\u0439\u0442",
        generate: "\u0421\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u043F\u0440\u0430\u0439\u0442",
        regenerate: "\u041F\u0435\u0440\u0435\u0441\u043E\u0437\u0434\u0430\u0442\u044C \u0441\u043F\u0440\u0430\u0439\u0442",
        preview: "\u041F\u0440\u0435\u0432\u044C\u044E \u0441\u043F\u0440\u0430\u0439\u0442\u0430",
        iconsCount: "{count} \u0438\u043A\u043E\u043D\u043E\u043A",
        noIcons: "\u041D\u0435\u0442 \u0438\u043A\u043E\u043D\u043E\u043A \u0432 \u0441\u043F\u0440\u0430\u0439\u0442\u0435",
        addSelected: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0432\u044B\u0431\u0440\u0430\u043D\u043D\u044B\u0435 \u0432 \u0441\u043F\u0440\u0430\u0439\u0442"
      },
      messages: {
        iconAdded: "\u0418\u043A\u043E\u043D\u043A\u0430 '{name}' \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 icons.js",
        iconAddedToSprite: "'{name}' \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 sprite.svg",
        iconAddedToIconsJs: "'{name}' \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 icons.js",
        iconAddedWithAnimation: "'{name}' \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 icons.js (\u0441 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0435\u0439)",
        animationSaved: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F '{animation}' \u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u0430 '{name}'",
        animationRemoved: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F \u0443\u0434\u0430\u043B\u0435\u043D\u0430 \u0438\u0437 '{name}'",
        iconRemoved: "\u0418\u043A\u043E\u043D\u043A\u0430 '{name}' \u0443\u0434\u0430\u043B\u0435\u043D\u0430",
        iconRenamed: "\u0418\u043A\u043E\u043D\u043A\u0430 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0430 \u0441 '{oldName}' \u043D\u0430 '{newName}'",
        renamedTo: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u043E \u0432 '{name}'",
        iconDuplicated: "\u0418\u043A\u043E\u043D\u043A\u0430 \u0434\u0443\u0431\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u043A\u0430\u043A '{name}'",
        iconOptimized: "\u0418\u043A\u043E\u043D\u043A\u0430 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u0430",
        iconAlreadyOptimized: "SVG \u0443\u0436\u0435 \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D",
        optimizedApplied: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 SVG \u043F\u0440\u0438\u043C\u0435\u043D\u0451\u043D",
        optimizedSaved: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 SVG \u043F\u0440\u0438\u043C\u0435\u043D\u0451\u043D \u0438 \u0441\u043E\u0445\u0440\u0430\u043D\u0451\u043D",
        optimizedReduced: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E: {original} \u2192 {optimized} (\u0443\u043C\u0435\u043D\u044C\u0448\u0435\u043D\u043E \u043D\u0430 {percent}%)",
        buildSuccess: "\u0418\u043A\u043E\u043D\u043A\u0438 \u0443\u0441\u043F\u0435\u0448\u043D\u043E \u0441\u043E\u0431\u0440\u0430\u043D\u044B",
        buildFailed: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u0431\u043E\u0440\u043A\u0438: {error}",
        failedToAddIcon: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: {error}",
        failedToImportIcon: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: {error}",
        failedToBuildIcon: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0441\u043E\u0431\u0440\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: {error}",
        failedToOptimize: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG: {error}",
        configSaved: "\u041A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430",
        configError: "\u041E\u0448\u0438\u0431\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F \u043A\u043E\u043D\u0444\u0438\u0433\u0443\u0440\u0430\u0446\u0438\u0438: {error}",
        configureOutputFirst: "\u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u0442\u0435 \u0434\u0438\u0440\u0435\u043A\u0442\u043E\u0440\u0438\u044E \u0432\u044B\u0432\u043E\u0434\u0430",
        noWorkspace: "\u041F\u0430\u043F\u043A\u0430 \u0440\u0430\u0431\u043E\u0447\u0435\u0439 \u043E\u0431\u043B\u0430\u0441\u0442\u0438 \u043D\u0435 \u043E\u0442\u043A\u0440\u044B\u0442\u0430",
        noActiveEditor: "\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0430",
        noIconData: "\u041D\u0435\u0442 \u0434\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043A\u0438. \u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043E\u0442\u043A\u0440\u043E\u0439\u0442\u0435 \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0437\u0430\u043D\u043E\u0432\u043E.",
        noIconSelected: "\u0418\u043A\u043E\u043D\u043A\u0430 \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D\u0430",
        noFiltersToApply: "\u041D\u0435\u0442 \u0444\u0438\u043B\u044C\u0442\u0440\u043E\u0432 \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F",
        filtersApplied: "\u0424\u0438\u043B\u044C\u0442\u0440\u044B \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u044B \u043A \u0446\u0432\u0435\u0442\u0430\u043C",
        selectIcon: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443",
        selectIcons: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043E\u0434\u043D\u0443 \u0438\u043B\u0438 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0438\u043A\u043E\u043D\u043E\u043A",
        confirmDelete: "\u0412\u044B \u0443\u0432\u0435\u0440\u0435\u043D\u044B, \u0447\u0442\u043E \u0445\u043E\u0442\u0438\u0442\u0435 \u0443\u0434\u0430\u043B\u0438\u0442\u044C {count} \u0438\u043A\u043E\u043D\u043E\u043A?",
        yes: "\u0414\u0430",
        no: "\u041D\u0435\u0442",
        cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
        ok: "\u041E\u041A",
        error: "\u041E\u0448\u0438\u0431\u043A\u0430",
        warning: "\u041F\u0440\u0435\u0434\u0443\u043F\u0440\u0435\u0436\u0434\u0435\u043D\u0438\u0435",
        info: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F",
        success: "\u0423\u0441\u043F\u0435\u0445",
        copiedToClipboard: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430!",
        copiedNameToClipboard: "'{name}' \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
        svgCopiedToClipboard: "SVG \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
        animatedSvgCopied: "\u0410\u043D\u0438\u043C\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 SVG \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
        codeInsertedAtCursor: "\u041A\u043E\u0434 \u0432\u0441\u0442\u0430\u0432\u043B\u0435\u043D \u0432 \u043F\u043E\u0437\u0438\u0446\u0438\u044E \u043A\u0443\u0440\u0441\u043E\u0440\u0430",
        noActiveEditorCodeCopied: "\u041D\u0435\u0442 \u0430\u043A\u0442\u0438\u0432\u043D\u043E\u0433\u043E \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0430. \u041A\u043E\u0434 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430.",
        scanComplete: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E: \u043D\u0430\u0439\u0434\u0435\u043D\u043E {count} \u0438\u043A\u043E\u043D\u043E\u043A",
        noIconsFound: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u0440\u0430\u0431\u043E\u0447\u0435\u0439 \u043E\u0431\u043B\u0430\u0441\u0442\u0438",
        noInlineSvgsFound: "\u0412\u0441\u0442\u0440\u043E\u0435\u043D\u043D\u044B\u0435 SVG \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u044D\u0442\u043E\u043C \u0444\u0430\u0439\u043B\u0435",
        noIconsFoundForQuery: "\u0418\u043A\u043E\u043D\u043A\u0438 \u0434\u043B\u044F '{query}' \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B",
        svgFileNotFound: "SVG \u0444\u0430\u0439\u043B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D: {path}",
        noBuiltIconsFound: "\u041D\u0435\u0442 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A. \u0421\u043D\u0430\u0447\u0430\u043B\u0430 \u0441\u043E\u0431\u0435\u0440\u0438\u0442\u0435 \u043D\u0435\u0441\u043A\u043E\u043B\u044C\u043A\u043E \u0438\u043A\u043E\u043D\u043E\u043A.",
        couldNotReadSvg: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u0440\u043E\u0447\u0438\u0442\u0430\u0442\u044C \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 SVG",
        couldNotUpdateSprite: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C sprite.svg",
        couldNotFindIconsJs: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 icons.js \u0434\u043B\u044F \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u044F",
        variantGenerated: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442 '{name}' \u0441\u043E\u0437\u0434\u0430\u043D",
        variantSaved: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442 '{name}' \u0441\u043E\u0445\u0440\u0430\u043D\u0451\u043D",
        variantUpdated: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442 '{name}' \u043E\u0431\u043D\u043E\u0432\u043B\u0451\u043D",
        variantSetAsDefault: "'{name}' \u0442\u0435\u043F\u0435\u0440\u044C \u0432\u0430\u0440\u0438\u0430\u043D\u0442 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0434\u043B\u044F {icon}",
        variantDefaultCleared: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0434\u043B\u044F {icon} \u043E\u0447\u0438\u0449\u0435\u043D",
        scriptCopiedToClipboard: "\u0422\u0435\u0433 script \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430!",
        missingScriptImport: '\u041E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u0435\u0442 \u0438\u043C\u043F\u043E\u0440\u0442 \u0441\u043A\u0440\u0438\u043F\u0442\u0430! \u0414\u043E\u0431\u0430\u0432\u044C\u0442\u0435 <script type="module" src="./{outputDir}/icon.js"></script> \u0432 \u0432\u0430\u0448 HTML <head>',
        copyToClipboard: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0432 \u0431\u0443\u0444\u0435\u0440",
        dismiss: "\u041E\u0442\u043A\u043B\u043E\u043D\u0438\u0442\u044C",
        iconImported: "\u0418\u043A\u043E\u043D\u043A\u0430 '{name}' \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 {targets}!",
        iconBuilt: "\u0418\u043A\u043E\u043D\u043A\u0430 '{name}' \u0441\u043A\u043E\u043C\u043F\u0438\u043B\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 {format}!",
        iconTransformed: "\u0418\u043A\u043E\u043D\u043A\u0430 '{name}' \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0430 \u0432 <{component}>!",
        extractInlineSvg: '\u0418\u0437\u0432\u043B\u0435\u0447\u044C \u0438\u043D\u043B\u0430\u0439\u043D SVG \u043A\u0430\u043A "{name}"',
        addedFillColor: "\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D \u0446\u0432\u0435\u0442 \u0437\u0430\u043B\u0438\u0432\u043A\u0438: {color}",
        updatedFile: "\u041E\u0431\u043D\u043E\u0432\u043B\u0451\u043D {path}",
        errorRenaming: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F: {error}",
        couldNotFindImgRef: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 \u0441\u0441\u044B\u043B\u043A\u0443 IMG \u0432 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0435. \u0424\u0430\u0439\u043B \u043C\u043E\u0433 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C\u0441\u044F.",
        couldNotFindSvgInDoc: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 SVG \u0432 \u0434\u043E\u043A\u0443\u043C\u0435\u043D\u0442\u0435. \u0424\u0430\u0439\u043B \u043C\u043E\u0433 \u0438\u0437\u043C\u0435\u043D\u0438\u0442\u044C\u0441\u044F.",
        transformedToFormat: "SVG \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D \u0432 \u0444\u043E\u0440\u043C\u0430\u0442 {format}",
        pleaseSelectSvg: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u044D\u043B\u0435\u043C\u0435\u043D\u0442 SVG",
        svgTransformedToComponent: "SVG \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D \u0432 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 {format}",
        svgOptimized: "SVG \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D!",
        noIconsInLibrary: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0435",
        spriteGenerated: "\u0421\u043F\u0440\u0430\u0439\u0442 \u0441\u043E\u0437\u0434\u0430\u043D \u0432 {path}",
        spriteNotFound: "sprite.svg \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        noIconsInSprite: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 sprite.svg",
        iconCopied: "\u0421\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E: {name}",
        failedToExportComponent: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442: {error}",
        iconRenamedTo: "\u0418\u043A\u043E\u043D\u043A\u0430 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0430 \u0432: {name}",
        confirmDeleteIcon: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C "{name}" \u0438\u0437 \u0441\u043F\u0440\u0430\u0439\u0442\u0430?',
        confirmDeleteIconFromFile: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C "{name}" \u0438\u0437 \u0444\u0430\u0439\u043B\u0430 \u0438\u043A\u043E\u043D\u043E\u043A?',
        iconDeleted: "\u0418\u043A\u043E\u043D\u043A\u0430 \u0443\u0434\u0430\u043B\u0435\u043D\u0430: {name}",
        spriteClean: "\u0421\u043F\u0440\u0430\u0439\u0442 \u0447\u0438\u0441\u0442 - \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u043E\u0435 \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u043C\u043E\u0435 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u043E.",
        spriteCleanedCount: "\u0421\u043F\u0440\u0430\u0439\u0442 \u043E\u0447\u0438\u0449\u0435\u043D: \u0443\u0434\u0430\u043B\u0435\u043D\u043E {removed} \u043D\u0435\u0434\u043E\u043F\u0443\u0441\u0442\u0438\u043C\u044B\u0445 \u0437\u0430\u043F\u0438\u0441\u0435\u0439. \u041E\u0441\u0442\u0430\u043B\u043E\u0441\u044C {kept} \u0438\u043A\u043E\u043D\u043E\u043A.",
        svgCopiedToClipboard: "SVG \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
        noIconsFile: "\u0424\u0430\u0439\u043B \u0438\u043A\u043E\u043D\u043E\u043A \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        iconsFileNotFound: "\u0424\u0430\u0439\u043B \u0438\u043A\u043E\u043D\u043E\u043A \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D",
        noIconsInFile: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u0444\u0430\u0439\u043B\u0435",
        noFileSelected: "\u0424\u0430\u0439\u043B \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D",
        fileNotFound: "\u0424\u0430\u0439\u043B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D: {path}",
        confirmDeleteFile: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C '{name}'? \u042D\u0442\u043E \u0434\u0435\u0439\u0441\u0442\u0432\u0438\u0435 \u043D\u0435\u043B\u044C\u0437\u044F \u043E\u0442\u043C\u0435\u043D\u0438\u0442\u044C.",
        fileDeleted: "\u0423\u0434\u0430\u043B\u0435\u043D\u043E: {name}",
        failedToDeleteFile: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0444\u0430\u0439\u043B: {error}",
        svgScanComplete: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 SVG \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
        usageScanComplete: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0437\u0430\u0432\u0435\u0440\u0448\u0435\u043D\u043E!",
        noSvgPathAvailable: "\u041F\u0443\u0442\u044C \u043A SVG \u0444\u0430\u0439\u043B\u0443 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u0435\u043D",
        cannotFindRefLocation: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 \u0440\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0441\u0441\u044B\u043B\u043A\u0438",
        refreshIcons: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u0435 \u0441\u043F\u0438\u0441\u043E\u043A \u0438\u043A\u043E\u043D\u043E\u043A",
        removedReference: '\u0421\u0441\u044B\u043B\u043A\u0430 \u043D\u0430 "{name}" \u0443\u0434\u0430\u043B\u0435\u043D\u0430',
        errorRemovingReference: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u0438 \u0441\u0441\u044B\u043B\u043A\u0438: {error}",
        noSvgFilesFound: "SVG \u0444\u0430\u0439\u043B\u044B \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u0440\u0430\u0431\u043E\u0447\u0435\u0439 \u043E\u0431\u043B\u0430\u0441\u0442\u0438",
        savedIconTo: "\u0418\u043A\u043E\u043D\u043A\u0430 \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0430 \u0432 {name}",
        updatedPath: '\u041F\u0443\u0442\u044C \u043E\u0431\u043D\u043E\u0432\u043B\u0451\u043D \u0441 "{oldPath}" \u043D\u0430 "{newPath}"',
        errorUpdatingPath: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0440\u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u0438\u0438 \u043F\u0443\u0442\u0438: {error}",
        failedToFetchIcon: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C SVG \u0438\u043A\u043E\u043D\u043A\u0438",
        failedToFetchIconError: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043F\u043E\u043B\u0443\u0447\u0438\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: {error}",
        iconAddedToFormat: '\u0418\u043A\u043E\u043D\u043A\u0430 "{name}" \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430 \u0432 {format}!',
        failedToAddIcon: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0434\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: {error}",
        iconImportedToFormat: '\u0418\u043A\u043E\u043D\u043A\u0430 "{name}" \u0438\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 {format}!',
        updatedFile: "\u041E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E {path}",
        copiedNameToClipboard: '"{name}" \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u043E \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430',
        svgAlreadyOptimized: "SVG \u0443\u0436\u0435 \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D",
        optimizedSvgApplied: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0439 SVG \u043F\u0440\u0438\u043C\u0435\u043D\u0451\u043D",
        addedFillColor: "\u0414\u043E\u0431\u0430\u0432\u043B\u0435\u043D \u0446\u0432\u0435\u0442 \u0437\u0430\u043B\u0438\u0432\u043A\u0438: {color}",
        variantSaved: '\u0412\u0430\u0440\u0438\u0430\u043D\u0442 "{name}" \u0441\u043E\u0445\u0440\u0430\u043D\u0451\u043D',
        variantSetAsDefault: '"{name}" \u0442\u0435\u043F\u0435\u0440\u044C \u0432\u0430\u0440\u0438\u0430\u043D\u0442 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0434\u043B\u044F {iconName}',
        defaultVariantCleared: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u043E\u0447\u0438\u0449\u0435\u043D \u0434\u043B\u044F {iconName}",
        outputDirectorySet: "\u0412\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D \u0432: {path}",
        svgFoldersUpdated: "\u041F\u0430\u043F\u043A\u0438 SVG \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B",
        componentNameSet: "\u0418\u043C\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D\u043E \u0432: {name}",
        outputFormatSet: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430 \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u043B\u0435\u043D \u0432: {format}",
        noIconsSelectedForDeletion: "\u0418\u043A\u043E\u043D\u043A\u0438 \u0434\u043B\u044F \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u043D\u0435 \u0432\u044B\u0431\u0440\u0430\u043D\u044B",
        confirmDeleteIcons: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C {count} \u0438\u043A\u043E\u043D\u043E\u043A: {names}?",
        deleteButton: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
        failedToDelete: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u0434\u0430\u043B\u0438\u0442\u044C {name}: {error}",
        deletedCount: "\u0423\u0434\u0430\u043B\u0435\u043D\u043E {count} \u0438\u043A\u043E\u043D\u043E\u043A",
        selectIconsToRemoveFromBuilt: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0438 \u0434\u043B\u044F \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u0438\u0437 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445",
        couldNotDetermineIconNames: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043E\u043F\u0440\u0435\u0434\u0435\u043B\u0438\u0442\u044C \u0438\u043C\u0435\u043D\u0430 \u0438\u043A\u043E\u043D\u043E\u043A",
        outputDirectoryNotConfigured: "\u0412\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433 \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D",
        removeIconFromBuilt: '\u0423\u0434\u0430\u043B\u0438\u0442\u044C "{name}" \u0438\u0437 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A?',
        removeIconsFromBuilt: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C {count} \u0438\u043A\u043E\u043D\u043E\u043A \u0438\u0437 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445?",
        removeButton: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
        removedIconFromBuilt: '"{name}" \u0443\u0434\u0430\u043B\u0435\u043D\u0430 \u0438\u0437 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A',
        removedIconsFromBuilt: "{count} \u0438\u043A\u043E\u043D\u043E\u043A \u0443\u0434\u0430\u043B\u0435\u043D\u043E \u0438\u0437 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445",
        failedToRemoveFromBuilt: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u0443\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0438 \u0438\u0437 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445",
        selectIconToRename: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443 \u0434\u043B\u044F \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F",
        fileAlreadyExists: '\u0424\u0430\u0439\u043B \u0441 \u0438\u043C\u0435\u043D\u0435\u043C "{name}" \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442',
        renamedWithReferences: '"{oldName}" \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0430 \u0432 "{newName}" \u0438 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E {count} \u0441\u0441\u044B\u043B\u043E\u043A',
        iconNotFoundInBuildFiles: '\u0418\u043A\u043E\u043D\u043A\u0430 "{name}" \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u0430 \u0432 \u0444\u0430\u0439\u043B\u0430\u0445 \u0441\u0431\u043E\u0440\u043A\u0438',
        renamedFilesUpdated: '"{oldName}" \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0430 \u0432 "{newName}" ({count} \u0444\u0430\u0439\u043B\u043E\u0432 \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u043E)',
        errorRenamingIcon: "\u041E\u0448\u0438\u0431\u043A\u0430 \u043F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u043D\u0438\u044F \u0438\u043A\u043E\u043D\u043A\u0438: {error}",
        pleaseSelectValidSvgFile: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043A\u043E\u0440\u0440\u0435\u043A\u0442\u043D\u044B\u0439 SVG \u0444\u0430\u0439\u043B",
        selectIconFromTreeOrEditor: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443 \u0438\u0437 \u0434\u0435\u0440\u0435\u0432\u0430 \u0438\u043B\u0438 \u0432\u044B\u0434\u0435\u043B\u0438\u0442\u0435 SVG \u043A\u043E\u0434 \u0432 \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0435",
        couldNotFindSvgData: "\u041D\u0435 \u0443\u0434\u0430\u043B\u043E\u0441\u044C \u043D\u0430\u0439\u0442\u0438 \u0434\u0430\u043D\u043D\u044B\u0435 SVG \u0434\u043B\u044F {name}",
        cannotEditRasterized: '\u041D\u0435\u0432\u043E\u0437\u043C\u043E\u0436\u043D\u043E \u0440\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C "{name}": \u042D\u0442\u043E\u0442 SVG \u0441\u043E\u0434\u0435\u0440\u0436\u0438\u0442 {colors} \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0445 \u0446\u0432\u0435\u0442\u043E\u0432 (\u0432\u0435\u0440\u043E\u044F\u0442\u043D\u043E, \u0440\u0430\u0441\u0442\u0440\u043E\u0432\u043E\u0435 \u0438\u0437\u043E\u0431\u0440\u0430\u0436\u0435\u043D\u0438\u0435). \u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u043E \u0434\u043B\u044F SVG \u0441 \u0431\u043E\u043B\u0435\u0435 \u0447\u0435\u043C {maxColors} \u0446\u0432\u0435\u0442\u0430\u043C\u0438.',
        selectIconToExport: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443 \u0434\u043B\u044F \u044D\u043A\u0441\u043F\u043E\u0440\u0442\u0430",
        addedSvgFolder: "\u041F\u0430\u043F\u043A\u0430 SVG \u0434\u043E\u0431\u0430\u0432\u043B\u0435\u043D\u0430: {path}",
        selectFolderInsideWorkspace: "\u041F\u043E\u0436\u0430\u043B\u0443\u0439\u0441\u0442\u0430, \u0432\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0443 \u0432\u043D\u0443\u0442\u0440\u0438 \u0440\u0430\u0431\u043E\u0447\u0435\u0439 \u043E\u0431\u043B\u0430\u0441\u0442\u0438",
        svgFoldersUpdatedList: "\u041F\u0430\u043F\u043A\u0438 SVG \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B: {folders}",
        svgFoldersUpdatedNone: "\u041F\u0430\u043F\u043A\u0438 SVG \u043E\u0431\u043D\u043E\u0432\u043B\u0435\u043D\u044B: (\u043D\u0435\u0442 - \u0431\u0443\u0434\u0443\u0442 \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C\u0441\u044F \u0432\u0441\u0435)",
        removedSvgFolder: "\u041F\u0430\u043F\u043A\u0430 SVG \u0443\u0434\u0430\u043B\u0435\u043D\u0430: {folder}",
        noImgReferencesFound: "\u0421\u0441\u044B\u043B\u043A\u0438 IMG \u0434\u043B\u044F \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B",
        allImgReferencesMissing: "\u0412\u0441\u0435 \u0441\u0441\u044B\u043B\u043A\u0438 IMG \u0443\u043A\u0430\u0437\u044B\u0432\u0430\u044E\u0442 \u043D\u0430 \u043E\u0442\u0441\u0443\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0435 \u0444\u0430\u0439\u043B\u044B",
        confirmTransformReferences: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C {count} \u0441\u0441\u044B\u043B\u043E\u043A IMG \u0432 <{component}>?",
        transformedWithErrors: "\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u043E {transformed} \u0441\u0441\u044B\u043B\u043E\u043A. {failed} \u0444\u0430\u0439\u043B\u043E\u0432 \u0441 \u043E\u0448\u0438\u0431\u043A\u0430\u043C\u0438.",
        transformedSuccessfully: "\u0423\u0441\u043F\u0435\u0448\u043D\u043E \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D\u043E {count} \u0441\u0441\u044B\u043B\u043E\u043A IMG \u0432 <{component}>",
        confirmBuildSvgFiles: "\u0421\u043E\u0431\u0440\u0430\u0442\u044C {count} SVG \u0444\u0430\u0439\u043B\u043E\u0432 \u0432 {format}?",
        outputPathNotConfigured: "\u041F\u0443\u0442\u044C \u0432\u044B\u0432\u043E\u0434\u0430 \u043D\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0435\u043D",
        confirmDeleteOriginals: "\u0421\u043E\u0431\u0440\u0430\u043D\u043E {count} \u0438\u043A\u043E\u043D\u043E\u043A. \u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0435 SVG \u0444\u0430\u0439\u043B\u044B?",
        deleteAll: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C \u0432\u0441\u0435",
        keepAll: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0432\u0441\u0435",
        deletedOriginals: "\u0423\u0434\u0430\u043B\u0435\u043D\u043E {count} \u0438\u0441\u0445\u043E\u0434\u043D\u044B\u0445 SVG \u0444\u0430\u0439\u043B\u043E\u0432",
        builtWithErrors: "\u0421\u043E\u0431\u0440\u0430\u043D\u043E {built} \u0438\u043A\u043E\u043D\u043E\u043A. {failed} \u0444\u0430\u0439\u043B\u043E\u0432 \u0441 \u043E\u0448\u0438\u0431\u043A\u0430\u043C\u0438.",
        noIconsFoundToBuild: "\u0418\u043A\u043E\u043D\u043A\u0438 \u0434\u043B\u044F \u0441\u0431\u043E\u0440\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B",
        skippedRasterizedIcons: "\u041F\u0440\u043E\u043F\u0443\u0449\u0435\u043D\u043E {count} \u0440\u0430\u0441\u0442\u0440\u043E\u0432\u044B\u0445 SVG \u0441 \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u0438\u043C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E\u043C \u0446\u0432\u0435\u0442\u043E\u0432: {names}",
        iconsLibraryBuilt: "\u0411\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0430 \u0438\u043A\u043E\u043D\u043E\u043A \u0441\u043E\u0431\u0440\u0430\u043D\u0430 \u043A\u0430\u043A {format} \u0432 {path}",
        yesButton: "\u0414\u0430",
        noButton: "\u041D\u0435\u0442",
        clickToConfigureOutput: "\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438 \u043A\u0430\u0442\u0430\u043B\u043E\u0433\u0430 \u0432\u044B\u0432\u043E\u0434\u0430 \u0438 \u043F\u0430\u0440\u0430\u043C\u0435\u0442\u0440\u043E\u0432",
        svgCanBeConverted: 'SVG "{name}" \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u043D \u0432 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 \u0438\u043A\u043E\u043D\u043A\u0438',
        transformToFormat: '\u041F\u0440\u0435\u043E\u0431\u0440\u0430\u0437\u043E\u0432\u0430\u0442\u044C \u0432 {format}: "{name}"',
        importIconName: '\u0418\u043C\u043F\u043E\u0440\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443: "{name}"',
        searchIconify: "\u0418\u0441\u043A\u0430\u0442\u044C \u0432 Iconify...",
        browseWorkspaceIcons: "\u041E\u0431\u0437\u043E\u0440 \u0438\u043A\u043E\u043D\u043E\u043A workspace...",
        noIconsInWorkspace: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 workspace. \u041F\u043E\u043F\u0440\u043E\u0431\u0443\u0439\u0442\u0435 \u0438\u0441\u043A\u0430\u0442\u044C \u0432 Iconify.",
        iconSelected: '\u0418\u043A\u043E\u043D\u043A\u0430 "{name}" \u0432\u044B\u0431\u0440\u0430\u043D\u0430',
        iconAlreadyExists: '\u0418\u043A\u043E\u043D\u043A\u0430 "{name}" \u0443\u0436\u0435 \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u0435\u0442'
      },
      settings: {
        title: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
        general: "\u041E\u0431\u0449\u0438\u0435",
        appearance: "\u0412\u043D\u0435\u0448\u043D\u0438\u0439 \u0432\u0438\u0434",
        build: "\u0421\u0431\u043E\u0440\u043A\u0430",
        advanced: "\u0420\u0430\u0441\u0448\u0438\u0440\u0435\u043D\u043D\u044B\u0435",
        language: "\u042F\u0437\u044B\u043A",
        languageAuto: "\u0410\u0432\u0442\u043E (\u0421\u0438\u0441\u0442\u0435\u043C\u0430)",
        theme: "\u0422\u0435\u043C\u0430 \u0438\u043A\u043E\u043D\u043E\u043A",
        previewSize: "\u0420\u0430\u0437\u043C\u0435\u0440 \u043F\u0440\u0435\u0432\u044C\u044E",
        showLabels: "\u041F\u043E\u043A\u0430\u0437\u044B\u0432\u0430\u0442\u044C \u043C\u0435\u0442\u043A\u0438",
        outputFormat: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430",
        optimizeOnBuild: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043F\u0440\u0438 \u0441\u0431\u043E\u0440\u043A\u0435",
        includeAnimation: "\u0412\u043A\u043B\u044E\u0447\u0438\u0442\u044C \u0434\u0430\u043D\u043D\u044B\u0435 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438",
        generateTypes: "\u0413\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u0442\u044C TypeScript \u0442\u0438\u043F\u044B"
      },
      ui: {
        progress: {
          buildingReferences: "\u0421\u0431\u043E\u0440\u043A\u0430 \u0441\u0441\u044B\u043B\u043E\u043A...",
          buildingSvgFiles: "\u0421\u0431\u043E\u0440\u043A\u0430 SVG \u0444\u0430\u0439\u043B\u043E\u0432...",
          buildingIconsLibrary: "\u0421\u0431\u043E\u0440\u043A\u0430 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438 \u0438\u043A\u043E\u043D\u043E\u043A...",
          scanningIcons: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u0435 \u0438\u043A\u043E\u043D\u043E\u043A...",
          generatingOutput: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F \u0432\u044B\u0432\u043E\u0434\u0430...",
          generatingWebComponent: "\u0413\u0435\u043D\u0435\u0440\u0430\u0446\u0438\u044F web-\u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430...",
          processing: "\u041E\u0431\u0440\u0430\u0431\u043E\u0442\u043A\u0430 {name}...",
          building: "\u0421\u0431\u043E\u0440\u043A\u0430 {name}..."
        },
        placeholders: {
          iconName: "\u0438\u043C\u044F-\u0438\u043A\u043E\u043D\u043A\u0438",
          selectSettingToConfigure: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0443 \u0434\u043B\u044F \u0438\u0437\u043C\u0435\u043D\u0435\u043D\u0438\u044F",
          outputDirectoryExample: "\u043D\u0430\u043F\u0440., src/icons, assets/icons",
          svgFoldersExample: "src/icons, assets/svg",
          selectOutputFormat: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430",
          configureSvgFolders: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u043F\u0430\u043F\u043E\u043A SVG \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F",
          svgFoldersExampleLong: "\u043D\u0430\u043F\u0440., src/icons, assets/svg, public/images",
          enterSearchTerm: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u043E\u0438\u0441\u043A\u043E\u0432\u044B\u0439 \u0437\u0430\u043F\u0440\u043E\u0441 (\u043D\u0430\u043F\u0440., arrow, home, user)",
          selectBuiltIcon: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u0443\u044E \u0438\u043A\u043E\u043D\u043A\u0443",
          howToFindReplacement: "\u041A\u0430\u043A \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u043D\u0430\u0439\u0442\u0438 \u0437\u0430\u043C\u0435\u043D\u0443 SVG?",
          whereToSaveSvg: "\u0413\u0434\u0435 \u0432\u044B \u0445\u043E\u0442\u0438\u0442\u0435 \u0441\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043D\u043E\u0432\u044B\u0439 SVG?",
          svgPathExample: "./\u043F\u0443\u0442\u044C/\u043A/\u0438\u043A\u043E\u043D\u043A\u0435.svg",
          selectSpriteFormat: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u0441\u043F\u0440\u0430\u0439\u0442\u0430",
          selectComponentFormat: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0444\u043E\u0440\u043C\u0430\u0442 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          componentNameExample: "\u043D\u0430\u043F\u0440., IconHome, ArrowIcon",
          selectIconToInsert: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0438\u043A\u043E\u043D\u043A\u0443 \u0434\u043B\u044F \u0432\u0441\u0442\u0430\u0432\u043A\u0438",
          variantNameExample: "\u043D\u0430\u043F\u0440. \u0422\u0451\u043C\u043D\u0430\u044F \u0442\u0435\u043C\u0430, \u041E\u0441\u043D\u043E\u0432\u043D\u044B\u0435 \u0446\u0432\u0435\u0442\u0430..."
        },
        prompts: {
          enterOutputDirectory: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0432\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433 \u0434\u043B\u044F \u0441\u0433\u0435\u043D\u0435\u0440\u0438\u0440\u043E\u0432\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A",
          enterSvgFolders: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0438 SVG \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F (\u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E)",
          enterSvgFoldersRelative: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0438 SVG \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F (\u0447\u0435\u0440\u0435\u0437 \u0437\u0430\u043F\u044F\u0442\u0443\u044E, \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u043E workspace)",
          enterComponentName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043C\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          enterWebComponentName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043C\u044F web-\u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          enterNewIconName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u043E\u0432\u043E\u0435 \u0438\u043C\u044F \u0438\u043A\u043E\u043D\u043A\u0438",
          enterIconName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u0438\u043C\u044F \u0434\u043B\u044F \u044D\u0442\u043E\u0439 \u0438\u043A\u043E\u043D\u043A\u0438",
          enterVariantName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u0430\u0437\u0432\u0430\u043D\u0438\u0435 \u0432\u0430\u0440\u0438\u0430\u043D\u0442\u0430",
          searchIconify: "\u0418\u0441\u043A\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443 \u0432 Iconify",
          searchIconifyFull: '\u0418\u0441\u043A\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0438 (\u043D\u0430\u043F\u0440., "arrow", "home", "user")',
          enterNewSvgPath: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u043E\u0432\u044B\u0439 \u043F\u0443\u0442\u044C \u043A SVG"
        },
        titles: {
          svgFoldersConfiguration: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0430 \u043F\u0430\u043F\u043E\u043A SVG",
          selectSvgFile: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 SVG \u0444\u0430\u0439\u043B",
          selectFolderToSave: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u043F\u0430\u043F\u043A\u0443 \u0434\u043B\u044F \u0441\u043E\u0445\u0440\u0430\u043D\u0435\u043D\u0438\u044F SVG",
          iconEditor: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440 \u0438\u043A\u043E\u043D\u043E\u043A",
          duplicateIcon: "\u0414\u0443\u0431\u043B\u0438\u043A\u0430\u0442 \u0438\u043A\u043E\u043D\u043A\u0438"
        },
        labels: {
          browseForFolder: "\u041E\u0431\u0437\u043E\u0440 \u043F\u0430\u043F\u043A\u0438...",
          enterPathManually: "\u0412\u0432\u0435\u0441\u0442\u0438 \u043F\u0443\u0442\u044C \u0432\u0440\u0443\u0447\u043D\u0443\u044E...",
          currentFolders: "\u0422\u0435\u043A\u0443\u0449\u0438\u0435 \u043F\u0430\u043F\u043A\u0438:",
          removeFolder: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C: {folder}",
          selectSvgFolder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443 SVG",
          scanWorkspace: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C Workspace",
          goToUsage: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044E",
          goToReference: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0441\u0441\u044B\u043B\u043A\u0435",
          showDetails: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438",
          goToSvg: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A SVG",
          openSetup: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u043D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0443",
          importIcon: "\u0418\u043C\u043F\u043E\u0440\u0442 \u0438\u043A\u043E\u043D\u043A\u0438",
          fromWorkspace: "\u0418\u0437 SVG \u0444\u0430\u0439\u043B\u043E\u0432 workspace",
          fromIconify: "\u0418\u0437 Iconify (\u043F\u043E\u0438\u0441\u043A \u043E\u043D\u043B\u0430\u0439\u043D)",
          saveToWorkspace: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0432 \u043F\u0430\u043F\u043A\u0443 workspace",
          replaceInPlace: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u043D\u0430 \u043C\u0435\u0441\u0442\u0435 (\u0442\u043E\u043B\u044C\u043A\u043E \u043E\u0431\u043D\u043E\u0432\u0438\u0442\u044C \u043F\u0443\u0442\u044C)",
          renameIcon: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443",
          enterNewName: "\u0412\u0432\u0435\u0434\u0438\u0442\u0435 \u043D\u043E\u0432\u043E\u0435 \u0438\u043C\u044F \u0434\u043B\u044F \u0438\u043A\u043E\u043D\u043A\u0438",
          replaceIcon: "\u0417\u0430\u043C\u0435\u043D\u0438\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443",
          overwriteExisting: "\u041F\u0435\u0440\u0435\u0437\u0430\u043F\u0438\u0441\u0430\u0442\u044C \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0443\u044E \u0438\u043A\u043E\u043D\u043A\u0443",
          cancel: "\u041E\u0442\u043C\u0435\u043D\u0430",
          outputDirectory: "\u0412\u044B\u0445\u043E\u0434\u043D\u043E\u0439 \u043A\u0430\u0442\u0430\u043B\u043E\u0433",
          svgFolders: "\u041F\u0430\u043F\u043A\u0438 SVG",
          componentName: "\u0418\u043C\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          outputFormat: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430",
          webComponentName: "\u0418\u043C\u044F Web-\u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          svgSprite: "SVG \u0421\u043F\u0440\u0430\u0439\u0442",
          webComponentJs: "Web-\u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442 (JS)",
          both: "\u041E\u0431\u0430",
          searchInIconify: "\u0418\u0441\u043A\u0430\u0442\u044C \u0432 Iconify",
          useReferencedSvg: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u044B\u0439 SVG \u0444\u0430\u0439\u043B",
          useInlineSvg: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u044C \u044D\u0442\u043E\u0442 \u0438\u043D\u043B\u0430\u0439\u043D SVG",
          extractAndBuild: "\u0418\u0437\u0432\u043B\u0435\u0447\u044C \u0438 \u0441\u043E\u0431\u0440\u0430\u0442\u044C \u043A\u0430\u043A \u0438\u043A\u043E\u043D\u043A\u0443",
          browseBuiltIcons: "\u041F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u0441\u043E\u0431\u0440\u0430\u043D\u043D\u044B\u0445 \u0438\u043A\u043E\u043D\u043E\u043A",
          browseForSvgFile: "\u041D\u0430\u0439\u0442\u0438 \u0444\u0430\u0439\u043B SVG",
          searchWorkspaceSvg: "\u0418\u0441\u043A\u0430\u0442\u044C SVG \u0432 workspace",
          enterNewPathManually: "\u0412\u0432\u0435\u0441\u0442\u0438 \u043D\u043E\u0432\u044B\u0439 \u043F\u0443\u0442\u044C \u0432\u0440\u0443\u0447\u043D\u0443\u044E",
          saveNextToFile: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0440\u044F\u0434\u043E\u043C \u0441 \u0443\u043A\u0430\u0437\u0430\u043D\u043D\u044B\u043C \u0444\u0430\u0439\u043B\u043E\u043C",
          chooseFolder: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443",
          clickToRemove: "\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u0443\u0434\u0430\u043B\u0435\u043D\u0438\u044F \u044D\u0442\u043E\u0439 \u043F\u0430\u043F\u043A\u0438",
          selectFolderFromWorkspace: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u043F\u0430\u043F\u043A\u0443 \u0438\u0437 workspace",
          typeRelativePath: "\u0412\u0432\u0435\u0441\u0442\u0438 \u043E\u0442\u043D\u043E\u0441\u0438\u0442\u0435\u043B\u044C\u043D\u044B\u0439 \u043F\u0443\u0442\u044C",
          findBuildIconify: "\u041D\u0430\u0439\u0442\u0438 \u0438 \u0441\u043E\u0431\u0440\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443 \u0438\u0437 Iconify",
          selectExistingSvg: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0439 SVG \u0444\u0430\u0439\u043B",
          selectIconFromLibrary: "\u0412\u044B\u0431\u0440\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443 \u0438\u0437 \u0432\u0430\u0448\u0435\u0439 \u0431\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0438"
        },
        details: {
          outputDirectoryDesc: "\u041A\u0430\u0442\u0430\u043B\u043E\u0433, \u0433\u0434\u0435 \u0431\u0443\u0434\u0435\u0442 \u0441\u043E\u0437\u0434\u0430\u043D icons.ts \u0438\u043B\u0438 sprite.svg",
          svgFoldersDesc: "\u041F\u0430\u043F\u043A\u0438 \u0434\u043B\u044F \u0441\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u043D\u0438\u044F SVG \u0444\u0430\u0439\u043B\u043E\u0432",
          componentNameDesc: "\u0418\u043C\u044F \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430 Icon (\u043D\u0430\u043F\u0440. Icon)",
          outputFormatDesc: "\u0424\u043E\u0440\u043C\u0430\u0442 \u0432\u044B\u0432\u043E\u0434\u0430 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E (jsx, vue, svelte \u0438 \u0442.\u0434.)",
          webComponentNameDesc: "\u0418\u043C\u044F \u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u0442\u0435\u043B\u044C\u0441\u043A\u043E\u0433\u043E \u044D\u043B\u0435\u043C\u0435\u043D\u0442\u0430 (\u043D\u0430\u043F\u0440. bezier-icon)"
        },
        validation: {
          nameCannotBeEmpty: "\u0418\u043C\u044F \u043D\u0435 \u043C\u043E\u0436\u0435\u0442 \u0431\u044B\u0442\u044C \u043F\u0443\u0441\u0442\u044B\u043C",
          invalidNameFormat: "\u041D\u0435\u0432\u0435\u0440\u043D\u044B\u0439 \u0444\u043E\u0440\u043C\u0430\u0442 \u0438\u043C\u0435\u043D\u0438"
        },
        colors: {
          white: "\u0411\u0435\u043B\u044B\u0439",
          black: "\u0427\u0451\u0440\u043D\u044B\u0439",
          blue: "\u0421\u0438\u043D\u0438\u0439",
          green: "\u0417\u0435\u043B\u0451\u043D\u044B\u0439",
          orange: "\u041E\u0440\u0430\u043D\u0436\u0435\u0432\u044B\u0439",
          red: "\u041A\u0440\u0430\u0441\u043D\u044B\u0439",
          purple: "\u0424\u0438\u043E\u043B\u0435\u0442\u043E\u0432\u044B\u0439",
          pink: "\u0420\u043E\u0437\u043E\u0432\u044B\u0439"
        }
      },
      webview: {
        animation: {
          animationType: "\u0422\u0438\u043F \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438",
          categoryBasic: "\u0411\u0430\u0437\u043E\u0432\u044B\u0435",
          categoryAttention: "\u0412\u043D\u0438\u043C\u0430\u043D\u0438\u0435",
          categoryEntrance: "\u0412\u0445\u043E\u0434",
          categoryDraw: "\u0420\u0438\u0441\u043E\u0432\u0430\u043D\u0438\u0435",
          drawHint: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u0438 \u0440\u0438\u0441\u043E\u0432\u0430\u043D\u0438\u044F \u043B\u0443\u0447\u0448\u0435 \u0432\u0441\u0435\u0433\u043E \u0440\u0430\u0431\u043E\u0442\u0430\u044E\u0442 \u0441 SVG \u043D\u0430 \u043E\u0441\u043D\u043E\u0432\u0435 \u0448\u0442\u0440\u0438\u0445\u043E\u0432. \u0418\u043A\u043E\u043D\u043A\u0430 \u0434\u043E\u043B\u0436\u043D\u0430 \u0438\u043C\u0435\u0442\u044C \u0432\u0438\u0434\u0438\u043C\u044B\u0435 \u0448\u0442\u0440\u0438\u0445\u0438.",
          settings: "\u041D\u0430\u0441\u0442\u0440\u043E\u0439\u043A\u0438",
          duration: "\u0414\u043B\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C",
          delay: "\u0417\u0430\u0434\u0435\u0440\u0436\u043A\u0430",
          timing: "\u0422\u0430\u0439\u043C\u0438\u043D\u0433",
          iteration: "\u0418\u0442\u0435\u0440\u0430\u0446\u0438\u044F",
          direction: "\u041D\u0430\u043F\u0440\u0430\u0432\u043B\u0435\u043D\u0438\u0435",
          timingLinear: "\u041B\u0438\u043D\u0435\u0439\u043D\u044B\u0439",
          timingEase: "\u041F\u043B\u0430\u0432\u043D\u044B\u0439",
          timingEaseIn: "\u041F\u043B\u0430\u0432\u043D\u044B\u0439 \u0432\u0445\u043E\u0434",
          timingEaseOut: "\u041F\u043B\u0430\u0432\u043D\u044B\u0439 \u0432\u044B\u0445\u043E\u0434",
          timingEaseInOut: "\u041F\u043B\u0430\u0432\u043D\u044B\u0439 \u0432\u0445\u043E\u0434-\u0432\u044B\u0445\u043E\u0434",
          iterationOnce: "\u041E\u0434\u0438\u043D \u0440\u0430\u0437",
          iterationTwice: "\u0414\u0432\u0430 \u0440\u0430\u0437\u0430",
          iteration3Times: "3 \u0440\u0430\u0437\u0430",
          iterationInfinite: "\u0411\u0435\u0441\u043A\u043E\u043D\u0435\u0447\u043D\u043E",
          directionNormal: "\u041E\u0431\u044B\u0447\u043D\u043E\u0435",
          directionReverse: "\u041E\u0431\u0440\u0430\u0442\u043D\u043E\u0435",
          directionAlternate: "\u0427\u0435\u0440\u0435\u0434\u0443\u044E\u0449\u0435\u0435\u0441\u044F",
          directionAltReverse: "\u0410\u043B\u044C\u0442. \u043E\u0431\u0440\u0430\u0442\u043D\u043E\u0435",
          export: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442",
          saveAnimation: "\u041D\u0430\u0437\u043D\u0430\u0447\u0438\u0442\u044C",
          saveAnimationTooltip: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u043D\u0430\u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438 \u0434\u043B\u044F \u044D\u0442\u043E\u0439 \u0438\u043A\u043E\u043D\u043A\u0438",
          copyWithAnimation: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0441 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0435\u0439",
          exportHint: "SVG \u0431\u0443\u0434\u0435\u0442 \u0432\u043A\u043B\u044E\u0447\u0430\u0442\u044C CSS \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044E"
        },
        color: {
          colors: "\u0426\u0432\u0435\u0442\u0430",
          globalFilters: "\u0413\u043B\u043E\u0431\u0430\u043B\u044C\u043D\u044B\u0435 \u0444\u0438\u043B\u044C\u0442\u0440\u044B",
          hueRotate: "\u041F\u043E\u0432\u043E\u0440\u043E\u0442 \u0442\u043E\u043D\u0430",
          saturation: "\u041D\u0430\u0441\u044B\u0449\u0435\u043D\u043D\u043E\u0441\u0442\u044C",
          brightness: "\u042F\u0440\u043A\u043E\u0441\u0442\u044C",
          reset: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C",
          resetFilters: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u0432\u0441\u0435 \u0444\u0438\u043B\u044C\u0442\u0440\u044B",
          variants: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442\u044B",
          saveVariant: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0442\u0435\u043A\u0443\u0449\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u043A\u0430\u043A \u0432\u0430\u0440\u0438\u0430\u043D\u0442"
        },
        code: {
          svgSource: "\u0418\u0441\u0445\u043E\u0434\u043D\u044B\u0439 SVG",
          animationCss: "CSS \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438",
          usageExample: "\u041F\u0440\u0438\u043C\u0435\u0440 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F",
          copy: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C",
          copySvg: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG \u0432 \u0431\u0443\u0444\u0435\u0440",
          copyAnimation: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C CSS \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u0438",
          copyUsage: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u043A\u043E\u0434 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F"
        },
        tabs: {
          title: "\u041C\u0435\u043D\u0435\u0434\u0436\u0435\u0440 \u0438\u043A\u043E\u043D\u043E\u043A",
          searchPlaceholder: "\u041F\u043E\u0438\u0441\u043A \u0438\u043A\u043E\u043D\u043E\u043A...",
          workspace: "\u0420\u0430\u0431\u043E\u0447\u0430\u044F \u043E\u0431\u043B\u0430\u0441\u0442\u044C",
          library: "\u0411\u0438\u0431\u043B\u0438\u043E\u0442\u0435\u043A\u0430",
          online: "\u041E\u043D\u043B\u0430\u0439\u043D"
        },
        editor: {
          editorBadge: "\u0420\u0435\u0434\u0430\u043A\u0442\u043E\u0440",
          optimizedBadge: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
          renameIcon: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443",
          zoomOut: "\u0423\u043C\u0435\u043D\u044C\u0448\u0438\u0442\u044C",
          zoomIn: "\u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0442\u044C",
          resetZoom: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043C\u0430\u0441\u0448\u0442\u0430\u0431",
          restartAnimation: "\u041F\u0435\u0440\u0435\u0437\u0430\u043F\u0443\u0441\u0442\u0438\u0442\u044C \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044E",
          buildIcons: "\u0421\u043E\u0431\u0440\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0438",
          copySvg: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG",
          optimizeSvg: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG (SVGO)",
          applyOnBuild: "\u041F\u0440\u0438\u043C\u0435\u043D\u0438\u0442\u044C \u043F\u0440\u0438 \u0441\u0431\u043E\u0440\u043A\u0435",
          discardOptimization: "\u041E\u0442\u043C\u0435\u043D\u0438\u0442\u044C \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0430\u0446\u0438\u044E",
          tabColor: "\u0426\u0432\u0435\u0442",
          tabAnimation: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F",
          tabCode: "\u041A\u043E\u0434"
        },
        details: {
          built: "\u0421\u043E\u0431\u0440\u0430\u043D\u043E",
          draft: "\u0427\u0435\u0440\u043D\u043E\u0432\u0438\u043A",
          zoomOut: "\u0423\u043C\u0435\u043D\u044C\u0448\u0438\u0442\u044C",
          zoomIn: "\u0423\u0432\u0435\u043B\u0438\u0447\u0438\u0442\u044C",
          resetZoom: "\u0421\u0431\u0440\u043E\u0441\u0438\u0442\u044C \u043C\u0430\u0441\u0448\u0442\u0430\u0431",
          copyIconName: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043C\u044F \u0438\u043A\u043E\u043D\u043A\u0438",
          copySvgCode: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG \u043A\u043E\u0434",
          openInEditor: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0432 \u0440\u0435\u0434\u0430\u043A\u0442\u043E\u0440\u0435",
          goToSource: "\u041F\u0435\u0440\u0435\u0439\u0442\u0438 \u043A \u0438\u0441\u0442\u043E\u0447\u043D\u0438\u043A\u0443",
          colors: "\u0426\u0432\u0435\u0442\u0430",
          colorsWarning: "\u042D\u0442\u043E\u0442 SVG \u0438\u043C\u0435\u0435\u0442 {count} \u0443\u043D\u0438\u043A\u0430\u043B\u044C\u043D\u044B\u0445 \u0446\u0432\u0435\u0442\u043E\u0432. \u041F\u0440\u0435\u0434\u043F\u0440\u043E\u0441\u043C\u043E\u0442\u0440 \u0446\u0432\u0435\u0442\u043E\u0432 \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D \u0434\u043B\u044F \u0440\u0430\u0441\u0442\u0440\u043E\u0432\u044B\u0445 SVG.",
          usesCurrentColor: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u0443\u0435\u0442 currentColor",
          inheritsFromCss: "\u043D\u0430\u0441\u043B\u0435\u0434\u0443\u0435\u0442\u0441\u044F \u0438\u0437 CSS",
          noColorsDetected: "\u0426\u0432\u0435\u0442\u0430 \u043D\u0435 \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u044B",
          properties: "\u0421\u0432\u043E\u0439\u0441\u0442\u0432\u0430",
          viewBox: "viewBox",
          dimensions: "\u0420\u0430\u0437\u043C\u0435\u0440\u044B",
          fileSize: "\u0420\u0430\u0437\u043C\u0435\u0440 \u0444\u0430\u0439\u043B\u0430",
          elements: "\u042D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          elementsBreakdown: "\u042D\u043B\u0435\u043C\u0435\u043D\u0442\u044B",
          features: "\u0424\u0443\u043D\u043A\u0446\u0438\u0438",
          sourceLocation: "\u0420\u0430\u0441\u043F\u043E\u043B\u043E\u0436\u0435\u043D\u0438\u0435 \u0438\u0441\u0442\u043E\u0447\u043D\u0438\u043A\u0430",
          animation: "\u0410\u043D\u0438\u043C\u0430\u0446\u0438\u044F",
          variants: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442\u044B",
          variantsDisabled: "\u0412\u0430\u0440\u0438\u0430\u043D\u0442\u044B \u043E\u0442\u043A\u043B\u044E\u0447\u0435\u043D\u044B \u0434\u043B\u044F SVG \u0441 \u0441\u043B\u0438\u0448\u043A\u043E\u043C \u0431\u043E\u043B\u044C\u0448\u0438\u043C \u043A\u043E\u043B\u0438\u0447\u0435\u0441\u0442\u0432\u043E\u043C \u0446\u0432\u0435\u0442\u043E\u0432",
          saveVariant: "\u0421\u043E\u0445\u0440\u0430\u043D\u0438\u0442\u044C \u0442\u0435\u043A\u0443\u0449\u0438\u0435 \u0446\u0432\u0435\u0442\u0430 \u043A\u0430\u043A \u0432\u0430\u0440\u0438\u0430\u043D\u0442",
          usages: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F",
          searchingUsages: "\u041F\u043E\u0438\u0441\u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0439...",
          original: "\u043E\u0440\u0438\u0433\u0438\u043D\u0430\u043B",
          currentlyDefault: "\u0422\u0435\u043A\u0443\u0449\u0438\u0439 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
          setAsDefault: "\u0423\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
          clickToApply: "\u041D\u0430\u0436\u043C\u0438\u0442\u0435 \u0434\u043B\u044F \u043F\u0440\u0438\u043C\u0435\u043D\u0435\u043D\u0438\u044F",
          activeDefault: "\u0430\u043A\u0442\u0438\u0432\u043D\u044B\u0439 \u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E",
          delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C",
          license: "\u041B\u0438\u0446\u0435\u043D\u0437\u0438\u044F",
          collection: "\u041A\u043E\u043B\u043B\u0435\u043A\u0446\u0438\u044F",
          author: "\u0410\u0432\u0442\u043E\u0440",
          licenseType: "\u041B\u0438\u0446\u0435\u043D\u0437\u0438\u044F",
          unknownAuthor: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E",
          unknownLicense: "\u041D\u0435\u0438\u0437\u0432\u0435\u0441\u0442\u043D\u043E",
          licenseUnknown: "\u0418\u043D\u0444\u043E\u0440\u043C\u0430\u0446\u0438\u044F \u043E \u043B\u0438\u0446\u0435\u043D\u0437\u0438\u0438 \u043D\u0435\u0434\u043E\u0441\u0442\u0443\u043F\u043D\u0430",
          download: "\u0421\u043A\u0430\u0447\u0430\u0442\u044C"
        },
        spritePreview: {
          icons: "\u0438\u043A\u043E\u043D\u043E\u043A",
          openFile: "\u041E\u0442\u043A\u0440\u044B\u0442\u044C \u0444\u0430\u0439\u043B",
          refresh: "\u041E\u0431\u043D\u043E\u0432\u0438\u0442\u044C",
          copyName: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043C\u044F",
          copySvg: "\u041A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG",
          editIcon: "\u0420\u0435\u0434\u0430\u043A\u0442\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0438\u043A\u043E\u043D\u043A\u0443",
          showDetails: "\u041F\u043E\u043A\u0430\u0437\u0430\u0442\u044C \u0434\u0435\u0442\u0430\u043B\u0438",
          exportComponent: "\u042D\u043A\u0441\u043F\u043E\u0440\u0442 \u043A\u043E\u043C\u043F\u043E\u043D\u0435\u043D\u0442\u0430",
          rename: "\u041F\u0435\u0440\u0435\u0438\u043C\u0435\u043D\u043E\u0432\u0430\u0442\u044C",
          delete: "\u0423\u0434\u0430\u043B\u0438\u0442\u044C"
        },
        js: {
          svgWillIncludeAnimation: "SVG \u0431\u0443\u0434\u0435\u0442 \u0432\u043A\u043B\u044E\u0447\u0430\u0442\u044C CSS \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044E",
          svgCodeCopied: "SVG \u043A\u043E\u0434 \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
          animationCssCopied: "CSS \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044F \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D\u0430 \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
          usageCodeCopied: "\u041A\u043E\u0434 \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u0441\u043A\u043E\u043F\u0438\u0440\u043E\u0432\u0430\u043D \u0432 \u0431\u0443\u0444\u0435\u0440 \u043E\u0431\u043C\u0435\u043D\u0430",
          optimizeSvgo: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u0442\u044C SVG (SVGO)",
          optimal: "\u041E\u043F\u0442\u0438\u043C\u0430\u043B\u044C\u043D\u043E",
          alreadyOptimized: "\u0423\u0436\u0435 \u043E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E",
          selectAnimationToEnable: "\u0412\u044B\u0431\u0435\u0440\u0438\u0442\u0435 \u0430\u043D\u0438\u043C\u0430\u0446\u0438\u044E \u0434\u043B\u044F \u0430\u043A\u0442\u0438\u0432\u0430\u0446\u0438\u0438",
          originalColor: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B: {color}",
          addFillColor: "\u0414\u043E\u0431\u0430\u0432\u0438\u0442\u044C \u0446\u0432\u0435\u0442 \u0437\u0430\u043B\u0438\u0432\u043A\u0438",
          noIconsFound: "\u0418\u043A\u043E\u043D\u043A\u0438 \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B. \u041E\u0442\u0441\u043A\u0430\u043D\u0438\u0440\u0443\u0439\u0442\u0435 \u0440\u0430\u0431\u043E\u0447\u0435\u0435 \u043F\u0440\u043E\u0441\u0442\u0440\u0430\u043D\u0441\u0442\u0432\u043E \u0434\u043B\u044F \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u0438\u044F SVG \u0444\u0430\u0439\u043B\u043E\u0432.",
          noIconsMatch: "\u041D\u0435\u0442 \u0438\u043A\u043E\u043D\u043E\u043A, \u0441\u043E\u043E\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0443\u044E\u0449\u0438\u0445 \u0432\u0430\u0448\u0435\u043C\u0443 \u043F\u043E\u0438\u0441\u043A\u0443.",
          noUsagesFound: "\u0418\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u044F \u043D\u0435 \u043D\u0430\u0439\u0434\u0435\u043D\u044B \u0432 \u0440\u0430\u0431\u043E\u0447\u0435\u043C \u043F\u0440\u043E\u0441\u0442\u0440\u0430\u043D\u0441\u0442\u0432\u0435",
          original: "\u041E\u0440\u0438\u0433\u0438\u043D\u0430\u043B:",
          optimized: "\u041E\u043F\u0442\u0438\u043C\u0438\u0437\u0438\u0440\u043E\u0432\u0430\u043D\u043E:",
          saved: "\u0421\u044D\u043A\u043E\u043D\u043E\u043C\u043B\u0435\u043D\u043E:",
          alreadyOptimal: "\u0423\u0436\u0435 \u043E\u043F\u0442\u0438\u043C\u0430\u043B\u044C\u043D\u043E",
          searchingUsages: "\u041F\u043E\u0438\u0441\u043A \u0438\u0441\u043F\u043E\u043B\u044C\u0437\u043E\u0432\u0430\u043D\u0438\u0439...",
          noColorsDetected: "\u0426\u0432\u0435\u0442\u0430 \u043D\u0435 \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0435\u043D\u044B",
          browseIconify: "\u041E\u0431\u0437\u043E\u0440 \u0438\u043A\u043E\u043D\u043E\u043A Iconify",
          comingSoon: "\u0421\u043A\u043E\u0440\u043E...",
          scanWorkspaceBtn: "\u0421\u043A\u0430\u043D\u0438\u0440\u043E\u0432\u0430\u0442\u044C \u0440\u0430\u0431\u043E\u0447\u0435\u0435 \u043F\u0440\u043E\u0441\u0442\u0440\u0430\u043D\u0441\u0442\u0432\u043E"
        }
      }
    };
  }
});

// src/i18n/index.ts
function t(key, params) {
  return i18n.t(key, params);
}
var vscode3, SUPPORTED_LOCALES, locales, I18nService, i18n;
var init_i18n = __esm({
  "src/i18n/index.ts"() {
    "use strict";
    vscode3 = __toESM(require("vscode"));
    init_en();
    init_es();
    init_zh();
    init_ru();
    SUPPORTED_LOCALES = [
      { code: "auto", name: "Auto (System)", nativeName: "Auto", flag: "\u{1F310}" },
      { code: "en", name: "English", nativeName: "English", flag: "\u{1F1EC}\u{1F1E7}" },
      { code: "es", name: "Spanish", nativeName: "Espa\xF1ol", flag: "\u{1F1EA}\u{1F1F8}" },
      { code: "zh", name: "Chinese", nativeName: "\u4E2D\u6587", flag: "\u{1F1E8}\u{1F1F3}" },
      { code: "ru", name: "Russian", nativeName: "\u0420\u0443\u0441\u0441\u043A\u0438\u0439", flag: "\u{1F1F7}\u{1F1FA}" }
    ];
    locales = {
      en: en_default,
      es: es_default,
      zh: zh_default,
      ru: ru_default
    };
    I18nService = class _I18nService {
      static instance;
      currentLocale = "en";
      translations = en_default;
      _onDidChangeLocale = new vscode3.EventEmitter();
      /**
       * Event that fires when the locale changes
       */
      onDidChangeLocale = this._onDidChangeLocale.event;
      constructor() {
        this.initializeLocale();
      }
      /**
       * Get singleton instance
       */
      static getInstance() {
        if (!_I18nService.instance) {
          _I18nService.instance = new _I18nService();
        }
        return _I18nService.instance;
      }
      /**
       * Initialize locale from configuration or system
       */
      initializeLocale() {
        const config = vscode3.workspace.getConfiguration("iconStudio");
        const configuredLocale = config.get("language", "auto");
        if (configuredLocale === "auto") {
          this.currentLocale = this.detectSystemLocale();
        } else {
          this.currentLocale = configuredLocale;
        }
        this.loadTranslations();
      }
      /**
       * Detect system locale from VS Code environment
       */
      detectSystemLocale() {
        const vscodeLang = vscode3.env.language;
        if (vscodeLang.startsWith("es")) return "es";
        if (vscodeLang.startsWith("zh")) return "zh";
        if (vscodeLang.startsWith("ru")) return "ru";
        return "en";
      }
      /**
       * Load translations for current locale
       */
      loadTranslations() {
        this.translations = locales[this.currentLocale] || locales.en;
      }
      /**
       * Get current locale code
       */
      getLocale() {
        return this.currentLocale;
      }
      /**
       * Get configured locale (may be 'auto')
       */
      getConfiguredLocale() {
        const config = vscode3.workspace.getConfiguration("iconStudio");
        return config.get("language", "auto");
      }
      /**
       * Set locale and reload translations
       */
      async setLocale(locale) {
        const config = vscode3.workspace.getConfiguration("iconStudio");
        await config.update("language", locale, vscode3.ConfigurationTarget.Global);
        if (locale === "auto") {
          this.currentLocale = this.detectSystemLocale();
        } else {
          this.currentLocale = locale;
        }
        this.loadTranslations();
        this._onDidChangeLocale.fire(this.currentLocale);
      }
      /**
       * Get a translation by key path (e.g., 'welcome.title')
       * Supports interpolation with {placeholder} syntax
       */
      t(key, params) {
        const keys = key.split(".");
        let value = this.translations;
        for (const k of keys) {
          if (value && typeof value === "object" && k in value) {
            value = value[k];
          } else {
            value = this.getEnglishFallback(key);
            break;
          }
        }
        if (typeof value !== "string") {
          return key;
        }
        if (params) {
          return this.interpolate(value, params);
        }
        return value;
      }
      /**
       * Get English fallback for missing translations
       */
      getEnglishFallback(key) {
        const keys = key.split(".");
        let value = locales.en;
        for (const k of keys) {
          if (value && typeof value === "object" && k in value) {
            value = value[k];
          } else {
            return key;
          }
        }
        return typeof value === "string" ? value : key;
      }
      /**
       * Interpolate parameters into translation string
       */
      interpolate(text, params) {
        return text.replace(/\{(\w+)\}/g, (match, key) => {
          return params[key] !== void 0 ? String(params[key]) : match;
        });
      }
      /**
       * Get all translations for current locale (useful for webviews)
       */
      getAllTranslations() {
        return this.translations;
      }
      /**
       * Get translations for a specific section
       */
      getSection(section) {
        return this.translations[section];
      }
      /**
       * Get supported locales list
       */
      getSupportedLocales() {
        return SUPPORTED_LOCALES;
      }
      /**
       * Get current locale info
       */
      getCurrentLocaleInfo() {
        return SUPPORTED_LOCALES.find((l) => l.code === this.currentLocale) || SUPPORTED_LOCALES[1];
      }
      /**
       * Check if a locale is supported
       */
      isSupported(locale) {
        return locale in locales;
      }
      /**
       * Dispose resources
       */
      dispose() {
        this._onDidChangeLocale.dispose();
      }
    };
    i18n = I18nService.getInstance();
  }
});

// src/services/AnimationKeyframes.ts
function getKeyframesForAnimation(animationType) {
  return ANIMATION_KEYFRAMES[animationType] || `@keyframes ${animationType} {
  /* Custom animation */
}`;
}
var ANIMATION_KEYFRAMES, ANIMATION_CATEGORIES;
var init_AnimationKeyframes = __esm({
  "src/services/AnimationKeyframes.ts"() {
    "use strict";
    ANIMATION_KEYFRAMES = {
      // Basic animations
      spin: "@keyframes spin {\n  from { transform: rotate(0deg); }\n  to { transform: rotate(360deg); }\n}",
      "spin-reverse": "@keyframes spin-reverse {\n  from { transform: rotate(360deg); }\n  to { transform: rotate(0deg); }\n}",
      pulse: "@keyframes pulse {\n  0%, 100% { transform: scale(1); opacity: 1; }\n  50% { transform: scale(1.1); opacity: 0.8; }\n}",
      "pulse-grow": "@keyframes pulse-grow {\n  0%, 100% { transform: scale(1); }\n  50% { transform: scale(1.2); }\n}",
      bounce: "@keyframes bounce {\n  0%, 100% { transform: translateY(0); }\n  50% { transform: translateY(-8px); }\n}",
      "bounce-horizontal": "@keyframes bounce-horizontal {\n  0%, 100% { transform: translateX(0); }\n  50% { transform: translateX(8px); }\n}",
      shake: "@keyframes shake {\n  0%, 100% { transform: translateX(0); }\n  25% { transform: translateX(-4px); }\n  75% { transform: translateX(4px); }\n}",
      "shake-vertical": "@keyframes shake-vertical {\n  0%, 100% { transform: translateY(0); }\n  25% { transform: translateY(-4px); }\n  75% { transform: translateY(4px); }\n}",
      fade: "@keyframes fade {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0.3; }\n}",
      "fade-in": "@keyframes fade-in {\n  from { opacity: 0; }\n  to { opacity: 1; }\n}",
      "fade-out": "@keyframes fade-out {\n  from { opacity: 1; }\n  to { opacity: 0; }\n}",
      float: "@keyframes float {\n  0%, 100% { transform: translateY(0); }\n  50% { transform: translateY(-6px); }\n}",
      blink: "@keyframes blink {\n  0%, 100% { opacity: 1; }\n  50% { opacity: 0; }\n}",
      glow: "@keyframes glow {\n  0%, 100% { filter: drop-shadow(0 0 2px currentColor); }\n  50% { filter: drop-shadow(0 0 10px currentColor) drop-shadow(0 0 20px currentColor); }\n}",
      // Attention seekers
      swing: "@keyframes swing {\n  0%, 100% { transform: rotate(0deg); transform-origin: top center; }\n  25% { transform: rotate(15deg); }\n  75% { transform: rotate(-15deg); }\n}",
      wobble: "@keyframes wobble {\n  0%, 100% { transform: translateX(0) rotate(0); }\n  15% { transform: translateX(-6px) rotate(-5deg); }\n  30% { transform: translateX(5px) rotate(3deg); }\n  45% { transform: translateX(-4px) rotate(-3deg); }\n  60% { transform: translateX(3px) rotate(2deg); }\n  75% { transform: translateX(-2px) rotate(-1deg); }\n}",
      "rubber-band": "@keyframes rubber-band {\n  0%, 100% { transform: scaleX(1); }\n  30% { transform: scaleX(1.25) scaleY(0.75); }\n  40% { transform: scaleX(0.75) scaleY(1.25); }\n  50% { transform: scaleX(1.15) scaleY(0.85); }\n  65% { transform: scaleX(0.95) scaleY(1.05); }\n  75% { transform: scaleX(1.05) scaleY(0.95); }\n}",
      jello: "@keyframes jello {\n  0%, 11.1%, 100% { transform: skewX(0) skewY(0); }\n  22.2% { transform: skewX(-12.5deg) skewY(-12.5deg); }\n  33.3% { transform: skewX(6.25deg) skewY(6.25deg); }\n  44.4% { transform: skewX(-3.125deg) skewY(-3.125deg); }\n  55.5% { transform: skewX(1.5625deg) skewY(1.5625deg); }\n}",
      heartbeat: "@keyframes heartbeat {\n  0%, 100% { transform: scale(1); }\n  14% { transform: scale(1.15); }\n  28% { transform: scale(1); }\n  42% { transform: scale(1.15); }\n  70% { transform: scale(1); }\n}",
      tada: "@keyframes tada {\n  0%, 100% { transform: scale(1) rotate(0); }\n  10%, 20% { transform: scale(0.9) rotate(-3deg); }\n  30%, 50%, 70%, 90% { transform: scale(1.1) rotate(3deg); }\n  40%, 60%, 80% { transform: scale(1.1) rotate(-3deg); }\n}",
      // Entrance/Exit animations
      "zoom-in": "@keyframes zoom-in {\n  from { transform: scale(0); opacity: 0; }\n  to { transform: scale(1); opacity: 1; }\n}",
      "zoom-out": "@keyframes zoom-out {\n  from { transform: scale(1); opacity: 1; }\n  to { transform: scale(0); opacity: 0; }\n}",
      "slide-in-up": "@keyframes slide-in-up {\n  from { transform: translateY(100%); opacity: 0; }\n  to { transform: translateY(0); opacity: 1; }\n}",
      "slide-in-down": "@keyframes slide-in-down {\n  from { transform: translateY(-100%); opacity: 0; }\n  to { transform: translateY(0); opacity: 1; }\n}",
      "slide-in-left": "@keyframes slide-in-left {\n  from { transform: translateX(-100%); opacity: 0; }\n  to { transform: translateX(0); opacity: 1; }\n}",
      "slide-in-right": "@keyframes slide-in-right {\n  from { transform: translateX(100%); opacity: 0; }\n  to { transform: translateX(0); opacity: 1; }\n}",
      flip: "@keyframes flip {\n  0% { transform: perspective(400px) rotateY(0); }\n  100% { transform: perspective(400px) rotateY(360deg); }\n}",
      "flip-x": "@keyframes flip-x {\n  0% { transform: perspective(400px) rotateX(0); }\n  100% { transform: perspective(400px) rotateX(360deg); }\n}",
      // Draw animations (for stroke-based SVGs)
      draw: "@keyframes draw {\n  from { stroke-dashoffset: var(--path-length, 1000); }\n  to { stroke-dashoffset: 0; }\n}",
      "draw-reverse": "@keyframes draw-reverse {\n  from { stroke-dashoffset: 0; }\n  to { stroke-dashoffset: var(--path-length, 1000); }\n}",
      "draw-loop": "@keyframes draw-loop {\n  0% { stroke-dashoffset: var(--path-length, 1000); }\n  45% { stroke-dashoffset: 0; }\n  55% { stroke-dashoffset: 0; }\n  100% { stroke-dashoffset: var(--path-length, 1000); }\n}"
    };
    ANIMATION_CATEGORIES = {
      basic: [
        "none",
        "spin",
        "spin-reverse",
        "pulse",
        "pulse-grow",
        "bounce",
        "bounce-horizontal",
        "shake",
        "shake-vertical",
        "fade",
        "float",
        "blink",
        "glow"
      ],
      attention: ["swing", "wobble", "rubber-band", "jello", "heartbeat", "tada"],
      entrance: [
        "fade-in",
        "fade-out",
        "zoom-in",
        "zoom-out",
        "slide-in-up",
        "slide-in-down",
        "slide-in-left",
        "slide-in-right",
        "flip",
        "flip-x"
      ],
      draw: ["draw", "draw-reverse", "draw-loop"],
      custom: ["custom"]
    };
  }
});

// src/services/LicenseService.ts
async function fetchCollections() {
  if (collectionsCache) {
    return collectionsCache;
  }
  return new Promise((resolve3, reject) => {
    const url = "https://api.iconify.design/collections";
    https.get(url, (res) => {
      let data = "";
      res.on("data", (chunk) => data += chunk);
      res.on("end", () => {
        try {
          if (res.statusCode === 200) {
            collectionsCache = JSON.parse(data);
            resolve3(collectionsCache);
          } else {
            reject(new Error(`Failed to fetch collections: ${res.statusCode}`));
          }
        } catch (parseError) {
          reject(parseError);
        }
      });
    }).on("error", reject);
  });
}
function parseIconifyName(iconName) {
  const knownPrefixes = [
    // Multi-segment prefixes (must come first)
    "material-symbols-light",
    "material-symbols",
    "icon-park-outline",
    "icon-park-solid",
    "icon-park-twotone",
    "icon-park",
    "fluent-emoji-flat",
    "fluent-emoji-high-contrast",
    "fluent-emoji",
    "fluent-color",
    "fa-solid",
    "fa-regular",
    "fa-brands",
    "fa6-solid",
    "fa6-regular",
    "fa6-brands",
    "fa7-solid",
    "fa7-regular",
    "fa7-brands",
    "simple-icons",
    "skill-icons",
    "circle-flags",
    "game-icons",
    "ant-design",
    "eos-icons",
    "grommet-icons",
    "radix-icons",
    "vscode-icons",
    "akar-icons",
    "system-uicons",
    "pepicons-pop",
    "pepicons-print",
    "pepicons-pencil",
    "lets-icons",
    "line-md",
    "mdi-light",
    // Single-segment prefixes
    "mdi",
    "fa",
    "fa6",
    "fa7",
    "ph",
    "ri",
    "bi",
    "ic",
    "tabler",
    "lucide",
    "heroicons",
    "carbon",
    "ion",
    "fluent",
    "octicon",
    "codicon",
    "logos",
    "devicon",
    "noto",
    "twemoji",
    "openmoji",
    "flag",
    "wi",
    "healthicons",
    "ep",
    "bx",
    "bxs",
    "bxl",
    "cil",
    "cib",
    "cif",
    "iconoir",
    "mingcute",
    "solar",
    "uil",
    "uis",
    "uim",
    "uit",
    "feather",
    "eva",
    "prime",
    "gridicons",
    "jam",
    "ci",
    "clarity",
    "f7",
    "fe",
    "gg",
    "la",
    "majesticons",
    "memory",
    "mi",
    "maki",
    "mynaui",
    "nimbus",
    "nrk",
    "ooui",
    "pajamas",
    "pixelarticons",
    "proicons",
    "quill",
    "si",
    "subway",
    "tdesign",
    "teenyicons",
    "typcn",
    "vaadin",
    "whh",
    "zondicons",
    "streamline",
    "hugeicons"
  ];
  for (const prefix of knownPrefixes) {
    if (iconName.startsWith(`${prefix}-`)) {
      return {
        prefix,
        name: iconName.substring(prefix.length + 1)
      };
    }
  }
  const match = iconName.match(/^([a-z0-9]+)-(.+)$/i);
  if (match) {
    return {
      prefix: match[1],
      name: match[2]
    };
  }
  return null;
}
function getIconLicenseInfoSync(prefix) {
  if (collectionsCache && collectionsCache[prefix]) {
    const info = collectionsCache[prefix];
    return {
      name: info.name,
      author: info.author,
      license: info.license
    };
  }
  return null;
}
async function getIconLicenseInfo(iconName) {
  const parsed = parseIconifyName(iconName);
  if (!parsed) {
    return { isIconify: false };
  }
  const { prefix } = parsed;
  if (collectionsCache && collectionsCache[prefix]) {
    const info = collectionsCache[prefix];
    return {
      isIconify: true,
      collection: info.name,
      author: info.author,
      license: info.license
    };
  }
  try {
    const collections = await fetchCollections();
    if (collections[prefix]) {
      return {
        isIconify: true,
        collection: collections[prefix].name,
        author: collections[prefix].author,
        license: collections[prefix].license
      };
    }
  } catch {
  }
  return {
    isIconify: true,
    collection: prefix
    // Use prefix as collection name
  };
}
async function scanIconsForAttribution(iconsPath) {
  const attributions = [];
  if (!fs15.existsSync(iconsPath)) {
    return attributions;
  }
  const content = fs15.readFileSync(iconsPath, "utf-8");
  const namePattern = /name:\s*['"]([^'"]+)['"]/g;
  let match;
  const iconNames = [];
  while ((match = namePattern.exec(content)) !== null) {
    iconNames.push(match[1]);
  }
  const collections = await fetchCollections();
  const processedPrefixes = /* @__PURE__ */ new Set();
  for (const iconName of iconNames) {
    const parsed = parseIconifyName(iconName);
    if (!parsed) continue;
    const { prefix, name: _name } = parsed;
    if (processedPrefixes.has(prefix)) {
      const existingAttribution = attributions.find((a) => a.prefix === prefix);
      if (existingAttribution) {
        continue;
      }
    }
    const collectionInfo = collections[prefix];
    if (collectionInfo) {
      processedPrefixes.add(prefix);
      attributions.push({
        iconName,
        prefix,
        collection: collectionInfo.name,
        author: collectionInfo.author,
        license: collectionInfo.license
      });
    }
  }
  return attributions;
}
function groupByCollection(attributions) {
  const grouped = /* @__PURE__ */ new Map();
  for (const attr of attributions) {
    const key = attr.prefix;
    if (!grouped.has(key)) {
      grouped.set(key, []);
    }
    grouped.get(key).push(attr);
  }
  return grouped;
}
function generateCollectionLicense(prefix, attributions, allIconNames) {
  const first = attributions[0];
  const iconCount = allIconNames.filter((name) => {
    const parsed = parseIconifyName(name);
    return parsed?.prefix === prefix;
  }).length;
  let content = `# ${first.collection}

`;
  content += `## License Information

`;
  content += `- **License**: ${first.license.title} (${first.license.spdx})
`;
  if (first.license.url) {
    content += `- **License URL**: ${first.license.url}
`;
  }
  content += `
## Author

`;
  content += `- **Name**: ${first.author.name}
`;
  if (first.author.url) {
    content += `- **URL**: ${first.author.url}
`;
  }
  content += `
## Icons Used (${iconCount})

`;
  const iconsFromCollection = allIconNames.filter((name) => {
    const parsed = parseIconifyName(name);
    return parsed?.prefix === prefix;
  });
  for (const iconName of iconsFromCollection) {
    content += `- \`${iconName}\`
`;
  }
  content += `
---
`;
  content += `*This file was auto-generated by SageBox Icon Studio*
`;
  return content;
}
function generateCombinedLicense(attributions, allIconNames) {
  const grouped = groupByCollection(attributions);
  let content = `# Icon Licenses

`;
  content += `This file contains license information for icons imported from Iconify.

`;
  content += `---

`;
  for (const [prefix, attrs] of grouped) {
    const first = attrs[0];
    const iconCount = allIconNames.filter((name) => {
      const parsed = parseIconifyName(name);
      return parsed?.prefix === prefix;
    }).length;
    content += `## ${first.collection}

`;
    content += `| Field | Value |
`;
    content += `|-------|-------|
`;
    content += `| **License** | ${first.license.title} (${first.license.spdx}) |
`;
    content += `| **Author** | ${first.author.name} |
`;
    if (first.author.url) {
      content += `| **Author URL** | [${first.author.url}](${first.author.url}) |
`;
    }
    if (first.license.url) {
      content += `| **License URL** | [${first.license.url}](${first.license.url}) |
`;
    }
    content += `| **Icons Used** | ${iconCount} |
`;
    content += `
`;
    const iconsFromCollection = allIconNames.filter((name) => {
      const parsed = parseIconifyName(name);
      return parsed?.prefix === prefix;
    });
    if (iconsFromCollection.length <= 10) {
      content += `**Icons**: ${iconsFromCollection.map((i) => `\`${i}\``).join(", ")}

`;
    } else {
      content += `<details>
<summary>Show ${iconsFromCollection.length} icons</summary>

`;
      for (const iconName of iconsFromCollection) {
        content += `- \`${iconName}\`
`;
      }
      content += `
</details>

`;
    }
    content += `---

`;
  }
  content += `
*This file was auto-generated by SageBox Icon Studio on ${(/* @__PURE__ */ new Date()).toISOString().split("T")[0]}*
`;
  return content;
}
async function generateLicenseFiles(outputPath, options = { combined: true, perCollection: false, licensesFolder: "icon-licenses" }) {
  const iconsPath = path18.join(outputPath, "icons.js");
  if (!fs15.existsSync(iconsPath)) {
    return {
      success: false,
      files: [],
      message: "No icons.js file found. Build your icons first."
    };
  }
  const attributions = await scanIconsForAttribution(iconsPath);
  if (attributions.length === 0) {
    return {
      success: false,
      files: [],
      message: "No Iconify icons detected in icons.js. License generation is only for icons imported from Iconify."
    };
  }
  const content = fs15.readFileSync(iconsPath, "utf-8");
  const namePattern = /name:\s*['"]([^'"]+)['"]/g;
  const allIconNames = [];
  let match;
  while ((match = namePattern.exec(content)) !== null) {
    allIconNames.push(match[1]);
  }
  const folderName = options.licensesFolder || "icon-licenses";
  const licensesPath = path18.join(outputPath, folderName);
  if (!fs15.existsSync(licensesPath)) {
    fs15.mkdirSync(licensesPath, { recursive: true });
  }
  const createdFiles = [];
  const grouped = groupByCollection(attributions);
  if (options.combined !== false) {
    const combinedContent = generateCombinedLicense(attributions, allIconNames);
    const combinedPath = path18.join(licensesPath, "LICENSES.md");
    fs15.writeFileSync(combinedPath, combinedContent);
    createdFiles.push(combinedPath);
  }
  if (options.perCollection) {
    for (const [prefix, attrs] of grouped) {
      const collectionContent = generateCollectionLicense(prefix, attrs, allIconNames);
      const collectionPath = path18.join(licensesPath, `LICENSE-${prefix}.md`);
      fs15.writeFileSync(collectionPath, collectionContent);
      createdFiles.push(collectionPath);
    }
  }
  const collectionCount = grouped.size;
  const iconCount = allIconNames.filter((name) => parseIconifyName(name) !== null).length;
  return {
    success: true,
    files: createdFiles,
    message: `Generated license files for ${iconCount} icons from ${collectionCount} collection(s).`
  };
}
async function getLicenseSummary(outputPath) {
  const iconsPath = path18.join(outputPath, "icons.js");
  if (!fs15.existsSync(iconsPath)) {
    return { collections: [], totalIcons: 0 };
  }
  const attributions = await scanIconsForAttribution(iconsPath);
  const grouped = groupByCollection(attributions);
  const content = fs15.readFileSync(iconsPath, "utf-8");
  const namePattern = /name:\s*['"]([^'"]+)['"]/g;
  const allIconNames = [];
  let match;
  while ((match = namePattern.exec(content)) !== null) {
    allIconNames.push(match[1]);
  }
  const collections = [];
  let totalIcons = 0;
  for (const [prefix, attrs] of grouped) {
    const first = attrs[0];
    const iconCount = allIconNames.filter((name) => {
      const parsed = parseIconifyName(name);
      return parsed?.prefix === prefix;
    }).length;
    collections.push({
      prefix,
      name: first.collection,
      license: first.license.title,
      iconCount
    });
    totalIcons += iconCount;
  }
  return { collections, totalIcons };
}
var https, path18, fs15, collectionsCache;
var init_LicenseService = __esm({
  "src/services/LicenseService.ts"() {
    "use strict";
    https = __toESM(require("https"));
    path18 = __toESM(require("path"));
    fs15 = __toESM(require("fs"));
    collectionsCache = null;
  }
});

// node_modules/@trysound/sax/lib/sax.js
var require_sax = __commonJS({
  "node_modules/@trysound/sax/lib/sax.js"(exports2) {
    (function(sax) {
      sax.parser = function(strict, opt) {
        return new SAXParser(strict, opt);
      };
      sax.SAXParser = SAXParser;
      sax.MAX_BUFFER_LENGTH = 64 * 1024;
      var buffers = [
        "comment",
        "sgmlDecl",
        "textNode",
        "tagName",
        "doctype",
        "procInstName",
        "procInstBody",
        "entity",
        "attribName",
        "attribValue",
        "cdata",
        "script"
      ];
      sax.EVENTS = [
        "text",
        "processinginstruction",
        "sgmldeclaration",
        "doctype",
        "comment",
        "opentagstart",
        "attribute",
        "opentag",
        "closetag",
        "opencdata",
        "cdata",
        "closecdata",
        "error",
        "end",
        "ready",
        "script",
        "opennamespace",
        "closenamespace"
      ];
      function SAXParser(strict, opt) {
        if (!(this instanceof SAXParser)) {
          return new SAXParser(strict, opt);
        }
        var parser = this;
        clearBuffers(parser);
        parser.q = parser.c = "";
        parser.bufferCheckPosition = sax.MAX_BUFFER_LENGTH;
        parser.opt = opt || {};
        parser.opt.lowercase = parser.opt.lowercase || parser.opt.lowercasetags;
        parser.looseCase = parser.opt.lowercase ? "toLowerCase" : "toUpperCase";
        parser.tags = [];
        parser.closed = parser.closedRoot = parser.sawRoot = false;
        parser.tag = parser.error = null;
        parser.strict = !!strict;
        parser.noscript = !!(strict || parser.opt.noscript);
        parser.state = S.BEGIN;
        parser.strictEntities = parser.opt.strictEntities;
        parser.ENTITIES = parser.strictEntities ? Object.create(sax.XML_ENTITIES) : Object.create(sax.ENTITIES);
        parser.attribList = [];
        if (parser.opt.xmlns) {
          parser.ns = Object.create(rootNS);
        }
        parser.trackPosition = parser.opt.position !== false;
        if (parser.trackPosition) {
          parser.position = parser.line = parser.column = 0;
        }
        emit(parser, "onready");
      }
      if (!Object.create) {
        Object.create = function(o) {
          function F() {
          }
          F.prototype = o;
          var newf = new F();
          return newf;
        };
      }
      if (!Object.keys) {
        Object.keys = function(o) {
          var a = [];
          for (var i in o) if (o.hasOwnProperty(i)) a.push(i);
          return a;
        };
      }
      function checkBufferLength(parser) {
        var maxAllowed = Math.max(sax.MAX_BUFFER_LENGTH, 10);
        var maxActual = 0;
        for (var i = 0, l = buffers.length; i < l; i++) {
          var len = parser[buffers[i]].length;
          if (len > maxAllowed) {
            switch (buffers[i]) {
              case "textNode":
                closeText(parser);
                break;
              case "cdata":
                emitNode(parser, "oncdata", parser.cdata);
                parser.cdata = "";
                break;
              case "script":
                emitNode(parser, "onscript", parser.script);
                parser.script = "";
                break;
              default:
                error(parser, "Max buffer length exceeded: " + buffers[i]);
            }
          }
          maxActual = Math.max(maxActual, len);
        }
        var m = sax.MAX_BUFFER_LENGTH - maxActual;
        parser.bufferCheckPosition = m + parser.position;
      }
      function clearBuffers(parser) {
        for (var i = 0, l = buffers.length; i < l; i++) {
          parser[buffers[i]] = "";
        }
      }
      function flushBuffers(parser) {
        closeText(parser);
        if (parser.cdata !== "") {
          emitNode(parser, "oncdata", parser.cdata);
          parser.cdata = "";
        }
        if (parser.script !== "") {
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
      }
      SAXParser.prototype = {
        end: function() {
          end(this);
        },
        write,
        resume: function() {
          this.error = null;
          return this;
        },
        close: function() {
          return this.write(null);
        },
        flush: function() {
          flushBuffers(this);
        }
      };
      var CDATA = "[CDATA[";
      var DOCTYPE = "DOCTYPE";
      var XML_NAMESPACE = "http://www.w3.org/XML/1998/namespace";
      var XMLNS_NAMESPACE = "http://www.w3.org/2000/xmlns/";
      var rootNS = { xml: XML_NAMESPACE, xmlns: XMLNS_NAMESPACE };
      var nameStart = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var nameBody = /[:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      var entityStart = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
      var entityBody = /[#:_A-Za-z\u00C0-\u00D6\u00D8-\u00F6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD\u00B7\u0300-\u036F\u203F-\u2040.\d-]/;
      function isWhitespace(c) {
        return c === " " || c === "\n" || c === "\r" || c === "	";
      }
      function isQuote(c) {
        return c === '"' || c === "'";
      }
      function isAttribEnd(c) {
        return c === ">" || isWhitespace(c);
      }
      function isMatch(regex, c) {
        return regex.test(c);
      }
      function notMatch(regex, c) {
        return !isMatch(regex, c);
      }
      var S = 0;
      sax.STATE = {
        BEGIN: S++,
        // leading byte order mark or whitespace
        BEGIN_WHITESPACE: S++,
        // leading whitespace
        TEXT: S++,
        // general stuff
        TEXT_ENTITY: S++,
        // &amp and such.
        OPEN_WAKA: S++,
        // <
        SGML_DECL: S++,
        // <!BLARG
        SGML_DECL_QUOTED: S++,
        // <!BLARG foo "bar
        DOCTYPE: S++,
        // <!DOCTYPE
        DOCTYPE_QUOTED: S++,
        // <!DOCTYPE "//blah
        DOCTYPE_DTD: S++,
        // <!DOCTYPE "//blah" [ ...
        DOCTYPE_DTD_QUOTED: S++,
        // <!DOCTYPE "//blah" [ "foo
        COMMENT_STARTING: S++,
        // <!-
        COMMENT: S++,
        // <!--
        COMMENT_ENDING: S++,
        // <!-- blah -
        COMMENT_ENDED: S++,
        // <!-- blah --
        CDATA: S++,
        // <![CDATA[ something
        CDATA_ENDING: S++,
        // ]
        CDATA_ENDING_2: S++,
        // ]]
        PROC_INST: S++,
        // <?hi
        PROC_INST_BODY: S++,
        // <?hi there
        PROC_INST_ENDING: S++,
        // <?hi "there" ?
        OPEN_TAG: S++,
        // <strong
        OPEN_TAG_SLASH: S++,
        // <strong /
        ATTRIB: S++,
        // <a
        ATTRIB_NAME: S++,
        // <a foo
        ATTRIB_NAME_SAW_WHITE: S++,
        // <a foo _
        ATTRIB_VALUE: S++,
        // <a foo=
        ATTRIB_VALUE_QUOTED: S++,
        // <a foo="bar
        ATTRIB_VALUE_CLOSED: S++,
        // <a foo="bar"
        ATTRIB_VALUE_UNQUOTED: S++,
        // <a foo=bar
        ATTRIB_VALUE_ENTITY_Q: S++,
        // <foo bar="&quot;"
        ATTRIB_VALUE_ENTITY_U: S++,
        // <foo bar=&quot
        CLOSE_TAG: S++,
        // </a
        CLOSE_TAG_SAW_WHITE: S++,
        // </a   >
        SCRIPT: S++,
        // <script> ...
        SCRIPT_ENDING: S++
        // <script> ... <
      };
      sax.XML_ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'"
      };
      sax.ENTITIES = {
        "amp": "&",
        "gt": ">",
        "lt": "<",
        "quot": '"',
        "apos": "'",
        "AElig": 198,
        "Aacute": 193,
        "Acirc": 194,
        "Agrave": 192,
        "Aring": 197,
        "Atilde": 195,
        "Auml": 196,
        "Ccedil": 199,
        "ETH": 208,
        "Eacute": 201,
        "Ecirc": 202,
        "Egrave": 200,
        "Euml": 203,
        "Iacute": 205,
        "Icirc": 206,
        "Igrave": 204,
        "Iuml": 207,
        "Ntilde": 209,
        "Oacute": 211,
        "Ocirc": 212,
        "Ograve": 210,
        "Oslash": 216,
        "Otilde": 213,
        "Ouml": 214,
        "THORN": 222,
        "Uacute": 218,
        "Ucirc": 219,
        "Ugrave": 217,
        "Uuml": 220,
        "Yacute": 221,
        "aacute": 225,
        "acirc": 226,
        "aelig": 230,
        "agrave": 224,
        "aring": 229,
        "atilde": 227,
        "auml": 228,
        "ccedil": 231,
        "eacute": 233,
        "ecirc": 234,
        "egrave": 232,
        "eth": 240,
        "euml": 235,
        "iacute": 237,
        "icirc": 238,
        "igrave": 236,
        "iuml": 239,
        "ntilde": 241,
        "oacute": 243,
        "ocirc": 244,
        "ograve": 242,
        "oslash": 248,
        "otilde": 245,
        "ouml": 246,
        "szlig": 223,
        "thorn": 254,
        "uacute": 250,
        "ucirc": 251,
        "ugrave": 249,
        "uuml": 252,
        "yacute": 253,
        "yuml": 255,
        "copy": 169,
        "reg": 174,
        "nbsp": 160,
        "iexcl": 161,
        "cent": 162,
        "pound": 163,
        "curren": 164,
        "yen": 165,
        "brvbar": 166,
        "sect": 167,
        "uml": 168,
        "ordf": 170,
        "laquo": 171,
        "not": 172,
        "shy": 173,
        "macr": 175,
        "deg": 176,
        "plusmn": 177,
        "sup1": 185,
        "sup2": 178,
        "sup3": 179,
        "acute": 180,
        "micro": 181,
        "para": 182,
        "middot": 183,
        "cedil": 184,
        "ordm": 186,
        "raquo": 187,
        "frac14": 188,
        "frac12": 189,
        "frac34": 190,
        "iquest": 191,
        "times": 215,
        "divide": 247,
        "OElig": 338,
        "oelig": 339,
        "Scaron": 352,
        "scaron": 353,
        "Yuml": 376,
        "fnof": 402,
        "circ": 710,
        "tilde": 732,
        "Alpha": 913,
        "Beta": 914,
        "Gamma": 915,
        "Delta": 916,
        "Epsilon": 917,
        "Zeta": 918,
        "Eta": 919,
        "Theta": 920,
        "Iota": 921,
        "Kappa": 922,
        "Lambda": 923,
        "Mu": 924,
        "Nu": 925,
        "Xi": 926,
        "Omicron": 927,
        "Pi": 928,
        "Rho": 929,
        "Sigma": 931,
        "Tau": 932,
        "Upsilon": 933,
        "Phi": 934,
        "Chi": 935,
        "Psi": 936,
        "Omega": 937,
        "alpha": 945,
        "beta": 946,
        "gamma": 947,
        "delta": 948,
        "epsilon": 949,
        "zeta": 950,
        "eta": 951,
        "theta": 952,
        "iota": 953,
        "kappa": 954,
        "lambda": 955,
        "mu": 956,
        "nu": 957,
        "xi": 958,
        "omicron": 959,
        "pi": 960,
        "rho": 961,
        "sigmaf": 962,
        "sigma": 963,
        "tau": 964,
        "upsilon": 965,
        "phi": 966,
        "chi": 967,
        "psi": 968,
        "omega": 969,
        "thetasym": 977,
        "upsih": 978,
        "piv": 982,
        "ensp": 8194,
        "emsp": 8195,
        "thinsp": 8201,
        "zwnj": 8204,
        "zwj": 8205,
        "lrm": 8206,
        "rlm": 8207,
        "ndash": 8211,
        "mdash": 8212,
        "lsquo": 8216,
        "rsquo": 8217,
        "sbquo": 8218,
        "ldquo": 8220,
        "rdquo": 8221,
        "bdquo": 8222,
        "dagger": 8224,
        "Dagger": 8225,
        "bull": 8226,
        "hellip": 8230,
        "permil": 8240,
        "prime": 8242,
        "Prime": 8243,
        "lsaquo": 8249,
        "rsaquo": 8250,
        "oline": 8254,
        "frasl": 8260,
        "euro": 8364,
        "image": 8465,
        "weierp": 8472,
        "real": 8476,
        "trade": 8482,
        "alefsym": 8501,
        "larr": 8592,
        "uarr": 8593,
        "rarr": 8594,
        "darr": 8595,
        "harr": 8596,
        "crarr": 8629,
        "lArr": 8656,
        "uArr": 8657,
        "rArr": 8658,
        "dArr": 8659,
        "hArr": 8660,
        "forall": 8704,
        "part": 8706,
        "exist": 8707,
        "empty": 8709,
        "nabla": 8711,
        "isin": 8712,
        "notin": 8713,
        "ni": 8715,
        "prod": 8719,
        "sum": 8721,
        "minus": 8722,
        "lowast": 8727,
        "radic": 8730,
        "prop": 8733,
        "infin": 8734,
        "ang": 8736,
        "and": 8743,
        "or": 8744,
        "cap": 8745,
        "cup": 8746,
        "int": 8747,
        "there4": 8756,
        "sim": 8764,
        "cong": 8773,
        "asymp": 8776,
        "ne": 8800,
        "equiv": 8801,
        "le": 8804,
        "ge": 8805,
        "sub": 8834,
        "sup": 8835,
        "nsub": 8836,
        "sube": 8838,
        "supe": 8839,
        "oplus": 8853,
        "otimes": 8855,
        "perp": 8869,
        "sdot": 8901,
        "lceil": 8968,
        "rceil": 8969,
        "lfloor": 8970,
        "rfloor": 8971,
        "lang": 9001,
        "rang": 9002,
        "loz": 9674,
        "spades": 9824,
        "clubs": 9827,
        "hearts": 9829,
        "diams": 9830
      };
      Object.keys(sax.ENTITIES).forEach(function(key) {
        var e = sax.ENTITIES[key];
        var s2 = typeof e === "number" ? String.fromCharCode(e) : e;
        sax.ENTITIES[key] = s2;
      });
      for (var s in sax.STATE) {
        sax.STATE[sax.STATE[s]] = s;
      }
      S = sax.STATE;
      function emit(parser, event, data) {
        parser[event] && parser[event](data);
      }
      function emitNode(parser, nodeType, data) {
        if (parser.textNode) closeText(parser);
        emit(parser, nodeType, data);
      }
      function closeText(parser) {
        parser.textNode = textopts(parser.opt, parser.textNode);
        if (parser.textNode) emit(parser, "ontext", parser.textNode);
        parser.textNode = "";
      }
      function textopts(opt, text) {
        if (opt.trim) text = text.trim();
        if (opt.normalize) text = text.replace(/\s+/g, " ");
        return text;
      }
      function error(parser, reason) {
        closeText(parser);
        const message = reason + "\nLine: " + parser.line + "\nColumn: " + parser.column + "\nChar: " + parser.c;
        const error2 = new Error(message);
        error2.reason = reason;
        error2.line = parser.line;
        error2.column = parser.column;
        parser.error = error2;
        emit(parser, "onerror", error2);
        return parser;
      }
      function end(parser) {
        if (parser.sawRoot && !parser.closedRoot) strictFail(parser, "Unclosed root tag");
        if (parser.state !== S.BEGIN && parser.state !== S.BEGIN_WHITESPACE && parser.state !== S.TEXT) {
          error(parser, "Unexpected end");
        }
        closeText(parser);
        parser.c = "";
        parser.closed = true;
        emit(parser, "onend");
        SAXParser.call(parser, parser.strict, parser.opt);
        return parser;
      }
      function strictFail(parser, message) {
        if (typeof parser !== "object" || !(parser instanceof SAXParser)) {
          throw new Error("bad call to strictFail");
        }
        if (parser.strict) {
          error(parser, message);
        }
      }
      function newTag(parser) {
        if (!parser.strict) parser.tagName = parser.tagName[parser.looseCase]();
        var parent = parser.tags[parser.tags.length - 1] || parser;
        var tag = parser.tag = { name: parser.tagName, attributes: {} };
        if (parser.opt.xmlns) {
          tag.ns = parent.ns;
        }
        parser.attribList.length = 0;
        emitNode(parser, "onopentagstart", tag);
      }
      function qname(name, attribute) {
        var i = name.indexOf(":");
        var qualName = i < 0 ? ["", name] : name.split(":");
        var prefix = qualName[0];
        var local = qualName[1];
        if (attribute && name === "xmlns") {
          prefix = "xmlns";
          local = "";
        }
        return { prefix, local };
      }
      function attrib(parser) {
        if (!parser.strict) {
          parser.attribName = parser.attribName[parser.looseCase]();
        }
        if (parser.attribList.indexOf(parser.attribName) !== -1 || parser.tag.attributes.hasOwnProperty(parser.attribName)) {
          parser.attribName = parser.attribValue = "";
          return;
        }
        if (parser.opt.xmlns) {
          var qn = qname(parser.attribName, true);
          var prefix = qn.prefix;
          var local = qn.local;
          if (prefix === "xmlns") {
            if (local === "xml" && parser.attribValue !== XML_NAMESPACE) {
              strictFail(
                parser,
                "xml: prefix must be bound to " + XML_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else if (local === "xmlns" && parser.attribValue !== XMLNS_NAMESPACE) {
              strictFail(
                parser,
                "xmlns: prefix must be bound to " + XMLNS_NAMESPACE + "\nActual: " + parser.attribValue
              );
            } else {
              var tag = parser.tag;
              var parent = parser.tags[parser.tags.length - 1] || parser;
              if (tag.ns === parent.ns) {
                tag.ns = Object.create(parent.ns);
              }
              tag.ns[local] = parser.attribValue;
            }
          }
          parser.attribList.push([parser.attribName, parser.attribValue]);
        } else {
          parser.tag.attributes[parser.attribName] = parser.attribValue;
          emitNode(parser, "onattribute", {
            name: parser.attribName,
            value: parser.attribValue
          });
        }
        parser.attribName = parser.attribValue = "";
      }
      function openTag(parser, selfClosing) {
        if (parser.opt.xmlns) {
          var tag = parser.tag;
          var qn = qname(parser.tagName);
          tag.prefix = qn.prefix;
          tag.local = qn.local;
          tag.uri = tag.ns[qn.prefix] || "";
          if (tag.prefix && !tag.uri) {
            strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(parser.tagName));
            tag.uri = qn.prefix;
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (tag.ns && parent.ns !== tag.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              emitNode(parser, "onopennamespace", {
                prefix: p,
                uri: tag.ns[p]
              });
            });
          }
          for (var i = 0, l = parser.attribList.length; i < l; i++) {
            var nv = parser.attribList[i];
            var name = nv[0];
            var value = nv[1];
            var qualName = qname(name, true);
            var prefix = qualName.prefix;
            var local = qualName.local;
            var uri = prefix === "" ? "" : tag.ns[prefix] || "";
            var a = {
              name,
              value,
              prefix,
              local,
              uri
            };
            if (prefix && prefix !== "xmlns" && !uri) {
              strictFail(parser, "Unbound namespace prefix: " + JSON.stringify(prefix));
              a.uri = prefix;
            }
            parser.tag.attributes[name] = a;
            emitNode(parser, "onattribute", a);
          }
          parser.attribList.length = 0;
        }
        parser.tag.isSelfClosing = !!selfClosing;
        parser.sawRoot = true;
        parser.tags.push(parser.tag);
        emitNode(parser, "onopentag", parser.tag);
        if (!selfClosing) {
          if (!parser.noscript && parser.tagName.toLowerCase() === "script") {
            parser.state = S.SCRIPT;
          } else {
            parser.state = S.TEXT;
          }
          parser.tag = null;
          parser.tagName = "";
        }
        parser.attribName = parser.attribValue = "";
        parser.attribList.length = 0;
      }
      function closeTag(parser) {
        if (!parser.tagName) {
          strictFail(parser, "Weird empty close tag.");
          parser.textNode += "</>";
          parser.state = S.TEXT;
          return;
        }
        if (parser.script) {
          if (parser.tagName !== "script") {
            parser.script += "</" + parser.tagName + ">";
            parser.tagName = "";
            parser.state = S.SCRIPT;
            return;
          }
          emitNode(parser, "onscript", parser.script);
          parser.script = "";
        }
        var t2 = parser.tags.length;
        var tagName = parser.tagName;
        if (!parser.strict) {
          tagName = tagName[parser.looseCase]();
        }
        var closeTo = tagName;
        while (t2--) {
          var close = parser.tags[t2];
          if (close.name !== closeTo) {
            strictFail(parser, "Unexpected close tag");
          } else {
            break;
          }
        }
        if (t2 < 0) {
          strictFail(parser, "Unmatched closing tag: " + parser.tagName);
          parser.textNode += "</" + parser.tagName + ">";
          parser.state = S.TEXT;
          return;
        }
        parser.tagName = tagName;
        var s2 = parser.tags.length;
        while (s2-- > t2) {
          var tag = parser.tag = parser.tags.pop();
          parser.tagName = parser.tag.name;
          emitNode(parser, "onclosetag", parser.tagName);
          var x = {};
          for (var i in tag.ns) {
            x[i] = tag.ns[i];
          }
          var parent = parser.tags[parser.tags.length - 1] || parser;
          if (parser.opt.xmlns && tag.ns !== parent.ns) {
            Object.keys(tag.ns).forEach(function(p) {
              var n = tag.ns[p];
              emitNode(parser, "onclosenamespace", { prefix: p, uri: n });
            });
          }
        }
        if (t2 === 0) parser.closedRoot = true;
        parser.tagName = parser.attribValue = parser.attribName = "";
        parser.attribList.length = 0;
        parser.state = S.TEXT;
      }
      function parseEntity(parser) {
        var entity = parser.entity;
        var entityLC = entity.toLowerCase();
        var num;
        var numStr = "";
        if (parser.ENTITIES[entity]) {
          return parser.ENTITIES[entity];
        }
        if (parser.ENTITIES[entityLC]) {
          return parser.ENTITIES[entityLC];
        }
        entity = entityLC;
        if (entity.charAt(0) === "#") {
          if (entity.charAt(1) === "x") {
            entity = entity.slice(2);
            num = parseInt(entity, 16);
            numStr = num.toString(16);
          } else {
            entity = entity.slice(1);
            num = parseInt(entity, 10);
            numStr = num.toString(10);
          }
        }
        entity = entity.replace(/^0+/, "");
        if (isNaN(num) || numStr.toLowerCase() !== entity) {
          strictFail(parser, "Invalid character entity");
          return "&" + parser.entity + ";";
        }
        return String.fromCodePoint(num);
      }
      function beginWhiteSpace(parser, c) {
        if (c === "<") {
          parser.state = S.OPEN_WAKA;
          parser.startTagPosition = parser.position;
        } else if (!isWhitespace(c)) {
          strictFail(parser, "Non-whitespace before first tag.");
          parser.textNode = c;
          parser.state = S.TEXT;
        }
      }
      function charAt(chunk, i) {
        var result = "";
        if (i < chunk.length) {
          result = chunk.charAt(i);
        }
        return result;
      }
      function write(chunk) {
        var parser = this;
        if (this.error) {
          throw this.error;
        }
        if (parser.closed) {
          return error(
            parser,
            "Cannot write after close. Assign an onready handler."
          );
        }
        if (chunk === null) {
          return end(parser);
        }
        if (typeof chunk === "object") {
          chunk = chunk.toString();
        }
        var i = 0;
        var c = "";
        while (true) {
          c = charAt(chunk, i++);
          parser.c = c;
          if (!c) {
            break;
          }
          if (parser.trackPosition) {
            parser.position++;
            if (c === "\n") {
              parser.line++;
              parser.column = 0;
            } else {
              parser.column++;
            }
          }
          switch (parser.state) {
            case S.BEGIN:
              parser.state = S.BEGIN_WHITESPACE;
              if (c === "\uFEFF") {
                continue;
              }
              beginWhiteSpace(parser, c);
              continue;
            case S.BEGIN_WHITESPACE:
              beginWhiteSpace(parser, c);
              continue;
            case S.TEXT:
              if (parser.sawRoot && !parser.closedRoot) {
                var starti = i - 1;
                while (c && c !== "<" && c !== "&") {
                  c = charAt(chunk, i++);
                  if (c && parser.trackPosition) {
                    parser.position++;
                    if (c === "\n") {
                      parser.line++;
                      parser.column = 0;
                    } else {
                      parser.column++;
                    }
                  }
                }
                parser.textNode += chunk.substring(starti, i - 1);
              }
              if (c === "<" && !(parser.sawRoot && parser.closedRoot && !parser.strict)) {
                parser.state = S.OPEN_WAKA;
                parser.startTagPosition = parser.position;
              } else {
                if (!isWhitespace(c) && (!parser.sawRoot || parser.closedRoot)) {
                  strictFail(parser, "Text data outside of root node.");
                }
                if (c === "&") {
                  parser.state = S.TEXT_ENTITY;
                } else {
                  parser.textNode += c;
                }
              }
              continue;
            case S.SCRIPT:
              if (c === "<") {
                parser.state = S.SCRIPT_ENDING;
              } else {
                parser.script += c;
              }
              continue;
            case S.SCRIPT_ENDING:
              if (c === "/") {
                parser.state = S.CLOSE_TAG;
              } else {
                parser.script += "<" + c;
                parser.state = S.SCRIPT;
              }
              continue;
            case S.OPEN_WAKA:
              if (c === "!") {
                parser.state = S.SGML_DECL;
                parser.sgmlDecl = "";
              } else if (isWhitespace(c)) {
              } else if (isMatch(nameStart, c)) {
                parser.state = S.OPEN_TAG;
                parser.tagName = c;
              } else if (c === "/") {
                parser.state = S.CLOSE_TAG;
                parser.tagName = "";
              } else if (c === "?") {
                parser.state = S.PROC_INST;
                parser.procInstName = parser.procInstBody = "";
              } else {
                strictFail(parser, "Unencoded <");
                if (parser.startTagPosition + 1 < parser.position) {
                  var pad = parser.position - parser.startTagPosition;
                  c = new Array(pad).join(" ") + c;
                }
                parser.textNode += "<" + c;
                parser.state = S.TEXT;
              }
              continue;
            case S.SGML_DECL:
              if ((parser.sgmlDecl + c).toUpperCase() === CDATA) {
                emitNode(parser, "onopencdata");
                parser.state = S.CDATA;
                parser.sgmlDecl = "";
                parser.cdata = "";
              } else if (parser.sgmlDecl + c === "--") {
                parser.state = S.COMMENT;
                parser.comment = "";
                parser.sgmlDecl = "";
              } else if ((parser.sgmlDecl + c).toUpperCase() === DOCTYPE) {
                parser.state = S.DOCTYPE;
                if (parser.doctype || parser.sawRoot) {
                  strictFail(
                    parser,
                    "Inappropriately located doctype declaration"
                  );
                }
                parser.doctype = "";
                parser.sgmlDecl = "";
              } else if (c === ">") {
                emitNode(parser, "onsgmldeclaration", parser.sgmlDecl);
                parser.sgmlDecl = "";
                parser.state = S.TEXT;
              } else if (isQuote(c)) {
                parser.state = S.SGML_DECL_QUOTED;
                parser.sgmlDecl += c;
              } else {
                parser.sgmlDecl += c;
              }
              continue;
            case S.SGML_DECL_QUOTED:
              if (c === parser.q) {
                parser.state = S.SGML_DECL;
                parser.q = "";
              }
              parser.sgmlDecl += c;
              continue;
            case S.DOCTYPE:
              if (c === ">") {
                parser.state = S.TEXT;
                emitNode(parser, "ondoctype", parser.doctype);
                parser.doctype = true;
              } else {
                parser.doctype += c;
                if (c === "[") {
                  parser.state = S.DOCTYPE_DTD;
                } else if (isQuote(c)) {
                  parser.state = S.DOCTYPE_QUOTED;
                  parser.q = c;
                }
              }
              continue;
            case S.DOCTYPE_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.q = "";
                parser.state = S.DOCTYPE;
              }
              continue;
            case S.DOCTYPE_DTD:
              parser.doctype += c;
              if (c === "]") {
                parser.state = S.DOCTYPE;
              } else if (isQuote(c)) {
                parser.state = S.DOCTYPE_DTD_QUOTED;
                parser.q = c;
              }
              continue;
            case S.DOCTYPE_DTD_QUOTED:
              parser.doctype += c;
              if (c === parser.q) {
                parser.state = S.DOCTYPE_DTD;
                parser.q = "";
              }
              continue;
            case S.COMMENT:
              if (c === "-") {
                parser.state = S.COMMENT_ENDING;
              } else {
                parser.comment += c;
              }
              continue;
            case S.COMMENT_ENDING:
              if (c === "-") {
                parser.state = S.COMMENT_ENDED;
                parser.comment = textopts(parser.opt, parser.comment);
                if (parser.comment) {
                  emitNode(parser, "oncomment", parser.comment);
                }
                parser.comment = "";
              } else {
                parser.comment += "-" + c;
                parser.state = S.COMMENT;
              }
              continue;
            case S.COMMENT_ENDED:
              if (c !== ">") {
                strictFail(parser, "Malformed comment");
                parser.comment += "--" + c;
                parser.state = S.COMMENT;
              } else {
                parser.state = S.TEXT;
              }
              continue;
            case S.CDATA:
              if (c === "]") {
                parser.state = S.CDATA_ENDING;
              } else {
                parser.cdata += c;
              }
              continue;
            case S.CDATA_ENDING:
              if (c === "]") {
                parser.state = S.CDATA_ENDING_2;
              } else {
                parser.cdata += "]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.CDATA_ENDING_2:
              if (c === ">") {
                if (parser.cdata) {
                  emitNode(parser, "oncdata", parser.cdata);
                }
                emitNode(parser, "onclosecdata");
                parser.cdata = "";
                parser.state = S.TEXT;
              } else if (c === "]") {
                parser.cdata += "]";
              } else {
                parser.cdata += "]]" + c;
                parser.state = S.CDATA;
              }
              continue;
            case S.PROC_INST:
              if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else if (isWhitespace(c)) {
                parser.state = S.PROC_INST_BODY;
              } else {
                parser.procInstName += c;
              }
              continue;
            case S.PROC_INST_BODY:
              if (!parser.procInstBody && isWhitespace(c)) {
                continue;
              } else if (c === "?") {
                parser.state = S.PROC_INST_ENDING;
              } else {
                parser.procInstBody += c;
              }
              continue;
            case S.PROC_INST_ENDING:
              if (c === ">") {
                emitNode(parser, "onprocessinginstruction", {
                  name: parser.procInstName,
                  body: parser.procInstBody
                });
                parser.procInstName = parser.procInstBody = "";
                parser.state = S.TEXT;
              } else {
                parser.procInstBody += "?" + c;
                parser.state = S.PROC_INST_BODY;
              }
              continue;
            case S.OPEN_TAG:
              if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else {
                newTag(parser);
                if (c === ">") {
                  openTag(parser);
                } else if (c === "/") {
                  parser.state = S.OPEN_TAG_SLASH;
                } else {
                  if (!isWhitespace(c)) {
                    strictFail(parser, "Invalid character in tag name");
                  }
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.OPEN_TAG_SLASH:
              if (c === ">") {
                openTag(parser, true);
                closeTag(parser);
              } else {
                strictFail(parser, "Forward-slash in opening tag not followed by >");
                parser.state = S.ATTRIB;
              }
              continue;
            case S.ATTRIB:
              if (isWhitespace(c)) {
                continue;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (c === ">") {
                strictFail(parser, "Attribute without value");
                parser.attribValue = parser.attribName;
                attrib(parser);
                openTag(parser);
              } else if (isWhitespace(c)) {
                parser.state = S.ATTRIB_NAME_SAW_WHITE;
              } else if (isMatch(nameBody, c)) {
                parser.attribName += c;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_NAME_SAW_WHITE:
              if (c === "=") {
                parser.state = S.ATTRIB_VALUE;
              } else if (isWhitespace(c)) {
                continue;
              } else {
                strictFail(parser, "Attribute without value");
                parser.tag.attributes[parser.attribName] = "";
                parser.attribValue = "";
                emitNode(parser, "onattribute", {
                  name: parser.attribName,
                  value: ""
                });
                parser.attribName = "";
                if (c === ">") {
                  openTag(parser);
                } else if (isMatch(nameStart, c)) {
                  parser.attribName = c;
                  parser.state = S.ATTRIB_NAME;
                } else {
                  strictFail(parser, "Invalid attribute name");
                  parser.state = S.ATTRIB;
                }
              }
              continue;
            case S.ATTRIB_VALUE:
              if (isWhitespace(c)) {
                continue;
              } else if (isQuote(c)) {
                parser.q = c;
                parser.state = S.ATTRIB_VALUE_QUOTED;
              } else {
                strictFail(parser, "Unquoted attribute value");
                parser.state = S.ATTRIB_VALUE_UNQUOTED;
                parser.attribValue = c;
              }
              continue;
            case S.ATTRIB_VALUE_QUOTED:
              if (c !== parser.q) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_Q;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              parser.q = "";
              parser.state = S.ATTRIB_VALUE_CLOSED;
              continue;
            case S.ATTRIB_VALUE_CLOSED:
              if (isWhitespace(c)) {
                parser.state = S.ATTRIB;
              } else if (c === ">") {
                openTag(parser);
              } else if (c === "/") {
                parser.state = S.OPEN_TAG_SLASH;
              } else if (isMatch(nameStart, c)) {
                strictFail(parser, "No whitespace between attributes");
                parser.attribName = c;
                parser.attribValue = "";
                parser.state = S.ATTRIB_NAME;
              } else {
                strictFail(parser, "Invalid attribute name");
              }
              continue;
            case S.ATTRIB_VALUE_UNQUOTED:
              if (!isAttribEnd(c)) {
                if (c === "&") {
                  parser.state = S.ATTRIB_VALUE_ENTITY_U;
                } else {
                  parser.attribValue += c;
                }
                continue;
              }
              attrib(parser);
              if (c === ">") {
                openTag(parser);
              } else {
                parser.state = S.ATTRIB;
              }
              continue;
            case S.CLOSE_TAG:
              if (!parser.tagName) {
                if (isWhitespace(c)) {
                  continue;
                } else if (notMatch(nameStart, c)) {
                  if (parser.script) {
                    parser.script += "</" + c;
                    parser.state = S.SCRIPT;
                  } else {
                    strictFail(parser, "Invalid tagname in closing tag.");
                  }
                } else {
                  parser.tagName = c;
                }
              } else if (c === ">") {
                closeTag(parser);
              } else if (isMatch(nameBody, c)) {
                parser.tagName += c;
              } else if (parser.script) {
                parser.script += "</" + parser.tagName;
                parser.tagName = "";
                parser.state = S.SCRIPT;
              } else {
                if (!isWhitespace(c)) {
                  strictFail(parser, "Invalid tagname in closing tag");
                }
                parser.state = S.CLOSE_TAG_SAW_WHITE;
              }
              continue;
            case S.CLOSE_TAG_SAW_WHITE:
              if (isWhitespace(c)) {
                continue;
              }
              if (c === ">") {
                closeTag(parser);
              } else {
                strictFail(parser, "Invalid characters in closing tag");
              }
              continue;
            case S.TEXT_ENTITY:
            case S.ATTRIB_VALUE_ENTITY_Q:
            case S.ATTRIB_VALUE_ENTITY_U:
              var returnState;
              var buffer;
              switch (parser.state) {
                case S.TEXT_ENTITY:
                  returnState = S.TEXT;
                  buffer = "textNode";
                  break;
                case S.ATTRIB_VALUE_ENTITY_Q:
                  returnState = S.ATTRIB_VALUE_QUOTED;
                  buffer = "attribValue";
                  break;
                case S.ATTRIB_VALUE_ENTITY_U:
                  returnState = S.ATTRIB_VALUE_UNQUOTED;
                  buffer = "attribValue";
                  break;
              }
              if (c === ";") {
                var parsedEntity = parseEntity(parser);
                if (parser.state === S.TEXT_ENTITY && !sax.ENTITIES[parser.entity] && parsedEntity !== "&" + parser.entity + ";") {
                  chunk = chunk.slice(0, i) + parsedEntity + chunk.slice(i);
                } else {
                  parser[buffer] += parsedEntity;
                }
                parser.entity = "";
                parser.state = returnState;
              } else if (isMatch(parser.entity.length ? entityBody : entityStart, c)) {
                parser.entity += c;
              } else {
                strictFail(parser, "Invalid character in entity name");
                parser[buffer] += "&" + parser.entity + c;
                parser.entity = "";
                parser.state = returnState;
              }
              continue;
            default:
              throw new Error(parser, "Unknown state: " + parser.state);
          }
        }
        if (parser.position >= parser.bufferCheckPosition) {
          checkBufferLength(parser);
        }
        return parser;
      }
    })(typeof exports2 === "undefined" ? exports2.sax = {} : exports2);
  }
});

// node_modules/svgo/plugins/_collections.js
var require_collections = __commonJS({
  "node_modules/svgo/plugins/_collections.js"(exports2) {
    "use strict";
    exports2.elemsGroups = {
      animation: /* @__PURE__ */ new Set([
        "animate",
        "animateColor",
        "animateMotion",
        "animateTransform",
        "set"
      ]),
      descriptive: /* @__PURE__ */ new Set(["desc", "metadata", "title"]),
      shape: /* @__PURE__ */ new Set([
        "circle",
        "ellipse",
        "line",
        "path",
        "polygon",
        "polyline",
        "rect"
      ]),
      structural: /* @__PURE__ */ new Set(["defs", "g", "svg", "symbol", "use"]),
      paintServer: /* @__PURE__ */ new Set([
        "hatch",
        "linearGradient",
        "meshGradient",
        "pattern",
        "radialGradient",
        "solidColor"
      ]),
      nonRendering: /* @__PURE__ */ new Set([
        "clipPath",
        "filter",
        "linearGradient",
        "marker",
        "mask",
        "pattern",
        "radialGradient",
        "solidColor",
        "symbol"
      ]),
      container: /* @__PURE__ */ new Set([
        "a",
        "defs",
        "foreignObject",
        "g",
        "marker",
        "mask",
        "missing-glyph",
        "pattern",
        "svg",
        "switch",
        "symbol"
      ]),
      textContent: /* @__PURE__ */ new Set([
        "altGlyph",
        "altGlyphDef",
        "altGlyphItem",
        "glyph",
        "glyphRef",
        "text",
        "textPath",
        "tref",
        "tspan"
      ]),
      textContentChild: /* @__PURE__ */ new Set(["altGlyph", "textPath", "tref", "tspan"]),
      lightSource: /* @__PURE__ */ new Set([
        "feDiffuseLighting",
        "feDistantLight",
        "fePointLight",
        "feSpecularLighting",
        "feSpotLight"
      ]),
      filterPrimitive: /* @__PURE__ */ new Set([
        "feBlend",
        "feColorMatrix",
        "feComponentTransfer",
        "feComposite",
        "feConvolveMatrix",
        "feDiffuseLighting",
        "feDisplacementMap",
        "feDropShadow",
        "feFlood",
        "feFuncA",
        "feFuncB",
        "feFuncG",
        "feFuncR",
        "feGaussianBlur",
        "feImage",
        "feMerge",
        "feMergeNode",
        "feMorphology",
        "feOffset",
        "feSpecularLighting",
        "feTile",
        "feTurbulence"
      ])
    };
    exports2.textElems = /* @__PURE__ */ new Set([
      ...exports2.elemsGroups.textContent,
      "pre",
      "title"
    ]);
    exports2.pathElems = /* @__PURE__ */ new Set(["glyph", "missing-glyph", "path"]);
    exports2.attrsGroups = {
      animationAddition: /* @__PURE__ */ new Set(["additive", "accumulate"]),
      animationAttributeTarget: /* @__PURE__ */ new Set(["attributeType", "attributeName"]),
      animationEvent: /* @__PURE__ */ new Set(["onbegin", "onend", "onrepeat", "onload"]),
      animationTiming: /* @__PURE__ */ new Set([
        "begin",
        "dur",
        "end",
        "fill",
        "max",
        "min",
        "repeatCount",
        "repeatDur",
        "restart"
      ]),
      animationValue: /* @__PURE__ */ new Set([
        "by",
        "calcMode",
        "from",
        "keySplines",
        "keyTimes",
        "to",
        "values"
      ]),
      conditionalProcessing: /* @__PURE__ */ new Set([
        "requiredExtensions",
        "requiredFeatures",
        "systemLanguage"
      ]),
      core: /* @__PURE__ */ new Set(["id", "tabindex", "xml:base", "xml:lang", "xml:space"]),
      graphicalEvent: /* @__PURE__ */ new Set([
        "onactivate",
        "onclick",
        "onfocusin",
        "onfocusout",
        "onload",
        "onmousedown",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup"
      ]),
      presentation: /* @__PURE__ */ new Set([
        "alignment-baseline",
        "baseline-shift",
        "clip-path",
        "clip-rule",
        "clip",
        "color-interpolation-filters",
        "color-interpolation",
        "color-profile",
        "color-rendering",
        "color",
        "cursor",
        "direction",
        "display",
        "dominant-baseline",
        "enable-background",
        "fill-opacity",
        "fill-rule",
        "fill",
        "filter",
        "flood-color",
        "flood-opacity",
        "font-family",
        "font-size-adjust",
        "font-size",
        "font-stretch",
        "font-style",
        "font-variant",
        "font-weight",
        "glyph-orientation-horizontal",
        "glyph-orientation-vertical",
        "image-rendering",
        "letter-spacing",
        "lighting-color",
        "marker-end",
        "marker-mid",
        "marker-start",
        "mask",
        "opacity",
        "overflow",
        "paint-order",
        "pointer-events",
        "shape-rendering",
        "stop-color",
        "stop-opacity",
        "stroke-dasharray",
        "stroke-dashoffset",
        "stroke-linecap",
        "stroke-linejoin",
        "stroke-miterlimit",
        "stroke-opacity",
        "stroke-width",
        "stroke",
        "text-anchor",
        "text-decoration",
        "text-overflow",
        "text-rendering",
        "transform-origin",
        "transform",
        "unicode-bidi",
        "vector-effect",
        "visibility",
        "word-spacing",
        "writing-mode"
      ]),
      xlink: /* @__PURE__ */ new Set([
        "xlink:actuate",
        "xlink:arcrole",
        "xlink:href",
        "xlink:role",
        "xlink:show",
        "xlink:title",
        "xlink:type"
      ]),
      documentEvent: /* @__PURE__ */ new Set([
        "onabort",
        "onerror",
        "onresize",
        "onscroll",
        "onunload",
        "onzoom"
      ]),
      documentElementEvent: /* @__PURE__ */ new Set(["oncopy", "oncut", "onpaste"]),
      globalEvent: /* @__PURE__ */ new Set([
        "oncancel",
        "oncanplay",
        "oncanplaythrough",
        "onchange",
        "onclick",
        "onclose",
        "oncuechange",
        "ondblclick",
        "ondrag",
        "ondragend",
        "ondragenter",
        "ondragleave",
        "ondragover",
        "ondragstart",
        "ondrop",
        "ondurationchange",
        "onemptied",
        "onended",
        "onerror",
        "onfocus",
        "oninput",
        "oninvalid",
        "onkeydown",
        "onkeypress",
        "onkeyup",
        "onload",
        "onloadeddata",
        "onloadedmetadata",
        "onloadstart",
        "onmousedown",
        "onmouseenter",
        "onmouseleave",
        "onmousemove",
        "onmouseout",
        "onmouseover",
        "onmouseup",
        "onmousewheel",
        "onpause",
        "onplay",
        "onplaying",
        "onprogress",
        "onratechange",
        "onreset",
        "onresize",
        "onscroll",
        "onseeked",
        "onseeking",
        "onselect",
        "onshow",
        "onstalled",
        "onsubmit",
        "onsuspend",
        "ontimeupdate",
        "ontoggle",
        "onvolumechange",
        "onwaiting"
      ]),
      filterPrimitive: /* @__PURE__ */ new Set(["x", "y", "width", "height", "result"]),
      transferFunction: /* @__PURE__ */ new Set([
        "amplitude",
        "exponent",
        "intercept",
        "offset",
        "slope",
        "tableValues",
        "type"
      ])
    };
    exports2.attrsGroupsDefaults = {
      core: { "xml:space": "default" },
      presentation: {
        clip: "auto",
        "clip-path": "none",
        "clip-rule": "nonzero",
        mask: "none",
        opacity: "1",
        "stop-color": "#000",
        "stop-opacity": "1",
        "fill-opacity": "1",
        "fill-rule": "nonzero",
        fill: "#000",
        stroke: "none",
        "stroke-width": "1",
        "stroke-linecap": "butt",
        "stroke-linejoin": "miter",
        "stroke-miterlimit": "4",
        "stroke-dasharray": "none",
        "stroke-dashoffset": "0",
        "stroke-opacity": "1",
        "paint-order": "normal",
        "vector-effect": "none",
        display: "inline",
        visibility: "visible",
        "marker-start": "none",
        "marker-mid": "none",
        "marker-end": "none",
        "color-interpolation": "sRGB",
        "color-interpolation-filters": "linearRGB",
        "color-rendering": "auto",
        "shape-rendering": "auto",
        "text-rendering": "auto",
        "image-rendering": "auto",
        "font-style": "normal",
        "font-variant": "normal",
        "font-weight": "normal",
        "font-stretch": "normal",
        "font-size": "medium",
        "font-size-adjust": "none",
        kerning: "auto",
        "letter-spacing": "normal",
        "word-spacing": "normal",
        "text-decoration": "none",
        "text-anchor": "start",
        "text-overflow": "clip",
        "writing-mode": "lr-tb",
        "glyph-orientation-vertical": "auto",
        "glyph-orientation-horizontal": "0deg",
        direction: "ltr",
        "unicode-bidi": "normal",
        "dominant-baseline": "auto",
        "alignment-baseline": "baseline",
        "baseline-shift": "baseline"
      },
      transferFunction: {
        slope: "1",
        intercept: "0",
        amplitude: "1",
        exponent: "1",
        offset: "0"
      }
    };
    exports2.elems = {
      a: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "style",
          "target",
          "transform"
        ]),
        defaults: {
          target: "_self"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view",
          // not spec compliant
          "tspan"
        ])
      },
      altGlyph: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "dx",
          "dy",
          "externalResourcesRequired",
          "format",
          "glyphRef",
          "rotate",
          "style",
          "x",
          "y"
        ])
      },
      altGlyphDef: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        content: /* @__PURE__ */ new Set(["glyphRef"])
      },
      altGlyphItem: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        content: /* @__PURE__ */ new Set(["glyphRef", "altGlyphItem"])
      },
      animate: {
        attrsGroups: /* @__PURE__ */ new Set([
          "animationAddition",
          "animationAttributeTarget",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "conditionalProcessing",
          "core",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      animateColor: {
        attrsGroups: /* @__PURE__ */ new Set([
          "animationAddition",
          "animationAttributeTarget",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "conditionalProcessing",
          "core",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      animateMotion: {
        attrsGroups: /* @__PURE__ */ new Set([
          "animationAddition",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "conditionalProcessing",
          "core",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "externalResourcesRequired",
          "keyPoints",
          "origin",
          "path",
          "rotate"
        ]),
        defaults: {
          rotate: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["mpath"])
      },
      animateTransform: {
        attrsGroups: /* @__PURE__ */ new Set([
          "animationAddition",
          "animationAttributeTarget",
          "animationEvent",
          "animationTiming",
          "animationValue",
          "conditionalProcessing",
          "core",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "type"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      circle: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "cx",
          "cy",
          "externalResourcesRequired",
          "r",
          "style",
          "transform"
        ]),
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      clipPath: {
        attrsGroups: /* @__PURE__ */ new Set(["conditionalProcessing", "core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "clipPathUnits",
          "externalResourcesRequired",
          "style",
          "transform"
        ]),
        defaults: {
          clipPathUnits: "userSpaceOnUse"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "shape"]),
        content: /* @__PURE__ */ new Set(["text", "use"])
      },
      "color-profile": {
        attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["local", "name", "rendering-intent"]),
        defaults: {
          name: "sRGB",
          "rendering-intent": "auto"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      cursor: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "conditionalProcessing", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "x", "y"]),
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      defs: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      desc: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"])
      },
      ellipse: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "cx",
          "cy",
          "externalResourcesRequired",
          "rx",
          "ry",
          "style",
          "transform"
        ]),
        defaults: {
          cx: "0",
          cy: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      feBlend: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "style",
          // TODO: in - 'If no value is provided and this is the first filter primitive,
          // then this filter primitive will use SourceGraphic as its input'
          "in",
          "in2",
          "mode"
        ]),
        defaults: {
          mode: "normal"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feColorMatrix: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in", "type", "values"]),
        defaults: {
          type: "matrix"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feComponentTransfer: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in"]),
        content: /* @__PURE__ */ new Set(["feFuncA", "feFuncB", "feFuncG", "feFuncR"])
      },
      feComposite: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "in",
          "in2",
          "k1",
          "k2",
          "k3",
          "k4",
          "operator",
          "style"
        ]),
        defaults: {
          operator: "over",
          k1: "0",
          k2: "0",
          k3: "0",
          k4: "0"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feConvolveMatrix: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "in",
          "kernelMatrix",
          "order",
          "style",
          // TODO: divisor - 'The default value is the sum of all values in kernelMatrix,
          // with the exception that if the sum is zero, then the divisor is set to 1'
          "bias",
          "divisor",
          // TODO: targetX - 'By default, the convolution matrix is centered in X over each
          // pixel of the input image (i.e., targetX = floor ( orderX / 2 ))'
          "edgeMode",
          "targetX",
          "targetY",
          // TODO: kernelUnitLength - 'The first number is the <dx> value. The second number
          // is the <dy> value. If the <dy> value is not specified, it defaults to the same value as <dx>'
          "kernelUnitLength",
          "preserveAlpha"
        ]),
        defaults: {
          order: "3",
          bias: "0",
          edgeMode: "duplicate",
          preserveAlpha: "false"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feDiffuseLighting: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "diffuseConstant",
          "in",
          "kernelUnitLength",
          "style",
          "surfaceScale"
        ]),
        defaults: {
          surfaceScale: "1",
          diffuseConstant: "1"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set([
          // TODO: 'exactly one light source element, in any order'
          "feDistantLight",
          "fePointLight",
          "feSpotLight"
        ])
      },
      feDisplacementMap: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "in",
          "in2",
          "scale",
          "style",
          "xChannelSelector",
          "yChannelSelector"
        ]),
        defaults: {
          scale: "0",
          xChannelSelector: "A",
          yChannelSelector: "A"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feDistantLight: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["azimuth", "elevation"]),
        defaults: {
          azimuth: "0",
          elevation: "0"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feFlood: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"]),
        content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
      },
      feFuncA: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
        content: /* @__PURE__ */ new Set(["set", "animate"])
      },
      feFuncB: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
        content: /* @__PURE__ */ new Set(["set", "animate"])
      },
      feFuncG: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
        content: /* @__PURE__ */ new Set(["set", "animate"])
      },
      feFuncR: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "transferFunction"]),
        content: /* @__PURE__ */ new Set(["set", "animate"])
      },
      feGaussianBlur: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in", "stdDeviation"]),
        defaults: {
          stdDeviation: "0"
        },
        content: /* @__PURE__ */ new Set(["set", "animate"])
      },
      feImage: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive", "xlink"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "href",
          "preserveAspectRatio",
          "style",
          "xlink:href"
        ]),
        defaults: {
          preserveAspectRatio: "xMidYMid meet"
        },
        content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set"])
      },
      feMerge: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"]),
        content: /* @__PURE__ */ new Set(["feMergeNode"])
      },
      feMergeNode: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["in"]),
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feMorphology: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in", "operator", "radius"]),
        defaults: {
          operator: "erode",
          radius: "0"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feOffset: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in", "dx", "dy"]),
        defaults: {
          dx: "0",
          dy: "0"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      fePointLight: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["x", "y", "z"]),
        defaults: {
          x: "0",
          y: "0",
          z: "0"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feSpecularLighting: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "in",
          "kernelUnitLength",
          "specularConstant",
          "specularExponent",
          "style",
          "surfaceScale"
        ]),
        defaults: {
          surfaceScale: "1",
          specularConstant: "1",
          specularExponent: "1"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "descriptive",
          // TODO: exactly one 'light source element'
          "lightSource"
        ])
      },
      feSpotLight: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set([
          "limitingConeAngle",
          "pointsAtX",
          "pointsAtY",
          "pointsAtZ",
          "specularExponent",
          "x",
          "y",
          "z"
        ]),
        defaults: {
          x: "0",
          y: "0",
          z: "0",
          pointsAtX: "0",
          pointsAtY: "0",
          pointsAtZ: "0",
          specularExponent: "1"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feTile: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "in"]),
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      feTurbulence: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "filterPrimitive"]),
        attrs: /* @__PURE__ */ new Set([
          "baseFrequency",
          "class",
          "numOctaves",
          "seed",
          "stitchTiles",
          "style",
          "type"
        ]),
        defaults: {
          baseFrequency: "0",
          numOctaves: "1",
          seed: "0",
          stitchTiles: "noStitch",
          type: "turbulence"
        },
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      filter: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "filterRes",
          "filterUnits",
          "height",
          "href",
          "primitiveUnits",
          "style",
          "width",
          "x",
          "xlink:href",
          "y"
        ]),
        defaults: {
          primitiveUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive", "filterPrimitive"]),
        content: /* @__PURE__ */ new Set(["animate", "set"])
      },
      font: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "horiz-adv-x",
          "horiz-origin-x",
          "horiz-origin-y",
          "style",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y"
        ]),
        defaults: {
          "horiz-origin-x": "0",
          "horiz-origin-y": "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["font-face", "glyph", "hkern", "missing-glyph", "vkern"])
      },
      "font-face": {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set([
          "font-family",
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "unicode-range",
          "units-per-em",
          "panose-1",
          "stemv",
          "stemh",
          "slope",
          "cap-height",
          "x-height",
          "accent-height",
          "ascent",
          "descent",
          "widths",
          "bbox",
          "ideographic",
          "alphabetic",
          "mathematical",
          "hanging",
          "v-ideographic",
          "v-alphabetic",
          "v-mathematical",
          "v-hanging",
          "underline-position",
          "underline-thickness",
          "strikethrough-position",
          "strikethrough-thickness",
          "overline-position",
          "overline-thickness"
        ]),
        defaults: {
          "font-style": "all",
          "font-variant": "normal",
          "font-weight": "all",
          "font-stretch": "normal",
          "unicode-range": "U+0-10FFFF",
          "units-per-em": "1000",
          "panose-1": "0 0 0 0 0 0 0 0 0 0",
          slope: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set([
          // TODO: "at most one 'font-face-src' element"
          "font-face-src"
        ])
      },
      // TODO: empty content
      "font-face-format": {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["string"])
      },
      "font-face-name": {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["name"])
      },
      "font-face-src": {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        content: /* @__PURE__ */ new Set(["font-face-name", "font-face-uri"])
      },
      "font-face-uri": {
        attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["href", "xlink:href"]),
        content: /* @__PURE__ */ new Set(["font-face-format"])
      },
      foreignObject: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "style",
          "transform",
          "width",
          "x",
          "y"
        ]),
        defaults: {
          x: "0",
          y: "0"
        }
      },
      g: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      glyph: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "arabic-form",
          "class",
          "d",
          "glyph-name",
          "horiz-adv-x",
          "lang",
          "orientation",
          "style",
          "unicode",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y"
        ]),
        defaults: {
          "arabic-form": "initial"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      glyphRef: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "d",
          "horiz-adv-x",
          "style",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y"
        ]),
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      hatch: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "hatchContentUnits",
          "hatchUnits",
          "pitch",
          "rotate",
          "style",
          "transform",
          "x",
          "y"
        ]),
        defaults: {
          hatchUnits: "objectBoundingBox",
          hatchContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          pitch: "0",
          rotate: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"]),
        content: /* @__PURE__ */ new Set(["hatchPath"])
      },
      hatchPath: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "d", "offset"]),
        defaults: {
          offset: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      hkern: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["u1", "g1", "u2", "g2", "k"])
      },
      image: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "href",
          "preserveAspectRatio",
          "style",
          "transform",
          "width",
          "x",
          "xlink:href",
          "y"
        ]),
        defaults: {
          x: "0",
          y: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      line: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "style",
          "transform",
          "x1",
          "x2",
          "y1",
          "y2"
        ]),
        defaults: {
          x1: "0",
          y1: "0",
          x2: "0",
          y2: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      linearGradient: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "gradientTransform",
          "gradientUnits",
          "href",
          "spreadMethod",
          "style",
          "x1",
          "x2",
          "xlink:href",
          "y1",
          "y2"
        ]),
        defaults: {
          x1: "0",
          y1: "0",
          x2: "100%",
          y2: "0",
          spreadMethod: "pad"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set", "stop"])
      },
      marker: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "markerHeight",
          "markerUnits",
          "markerWidth",
          "orient",
          "preserveAspectRatio",
          "refX",
          "refY",
          "style",
          "viewBox"
        ]),
        defaults: {
          markerUnits: "strokeWidth",
          refX: "0",
          refY: "0",
          markerWidth: "3",
          markerHeight: "3"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      mask: {
        attrsGroups: /* @__PURE__ */ new Set(["conditionalProcessing", "core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "mask-type",
          "maskContentUnits",
          "maskUnits",
          "style",
          "width",
          "x",
          "y"
        ]),
        defaults: {
          maskUnits: "objectBoundingBox",
          maskContentUnits: "userSpaceOnUse",
          x: "-10%",
          y: "-10%",
          width: "120%",
          height: "120%"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      metadata: {
        attrsGroups: /* @__PURE__ */ new Set(["core"])
      },
      "missing-glyph": {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "d",
          "horiz-adv-x",
          "style",
          "vert-adv-y",
          "vert-origin-x",
          "vert-origin-y"
        ]),
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      mpath: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "href", "xlink:href"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      path: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "d",
          "externalResourcesRequired",
          "pathLength",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      pattern: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "href",
          "patternContentUnits",
          "patternTransform",
          "patternUnits",
          "preserveAspectRatio",
          "style",
          "viewBox",
          "width",
          "x",
          "xlink:href",
          "y"
        ]),
        defaults: {
          patternUnits: "objectBoundingBox",
          patternContentUnits: "userSpaceOnUse",
          x: "0",
          y: "0",
          width: "0",
          height: "0",
          preserveAspectRatio: "xMidYMid meet"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      polygon: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "points",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      polyline: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "points",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      radialGradient: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "cx",
          "cy",
          "externalResourcesRequired",
          "fr",
          "fx",
          "fy",
          "gradientTransform",
          "gradientUnits",
          "href",
          "r",
          "spreadMethod",
          "style",
          "xlink:href"
        ]),
        defaults: {
          gradientUnits: "objectBoundingBox",
          cx: "50%",
          cy: "50%",
          r: "50%"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["animate", "animateTransform", "set", "stop"])
      },
      meshGradient: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "x", "y", "gradientUnits", "transform"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive", "paintServer", "animation"]),
        content: /* @__PURE__ */ new Set(["meshRow"])
      },
      meshRow: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["meshPatch"])
      },
      meshPatch: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["stop"])
      },
      rect: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "rx",
          "ry",
          "style",
          "transform",
          "width",
          "x",
          "y"
        ]),
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      script: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "xlink"]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "type", "href", "xlink:href"])
      },
      set: {
        attrsGroups: /* @__PURE__ */ new Set([
          "animation",
          "animationAttributeTarget",
          "animationTiming",
          "conditionalProcessing",
          "core",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set(["externalResourcesRequired", "to"]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      solidColor: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"]),
        contentGroups: /* @__PURE__ */ new Set(["paintServer"])
      },
      stop: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "presentation"]),
        attrs: /* @__PURE__ */ new Set(["class", "style", "offset", "path"]),
        content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
      },
      style: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["type", "media", "title"]),
        defaults: {
          type: "text/css"
        }
      },
      svg: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "documentEvent",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "baseProfile",
          "class",
          "contentScriptType",
          "contentStyleType",
          "height",
          "preserveAspectRatio",
          "style",
          "version",
          "viewBox",
          "width",
          "x",
          "y",
          "zoomAndPan"
        ]),
        defaults: {
          x: "0",
          y: "0",
          width: "100%",
          height: "100%",
          preserveAspectRatio: "xMidYMid meet",
          zoomAndPan: "magnify",
          version: "1.1",
          baseProfile: "none",
          contentScriptType: "application/ecmascript",
          contentStyleType: "text/css"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      switch: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "style",
          "transform"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "shape"]),
        content: /* @__PURE__ */ new Set([
          "a",
          "foreignObject",
          "g",
          "image",
          "svg",
          "switch",
          "text",
          "use"
        ])
      },
      symbol: {
        attrsGroups: /* @__PURE__ */ new Set(["core", "graphicalEvent", "presentation"]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "preserveAspectRatio",
          "refX",
          "refY",
          "style",
          "viewBox"
        ]),
        defaults: {
          refX: "0",
          refY: "0"
        },
        contentGroups: /* @__PURE__ */ new Set([
          "animation",
          "descriptive",
          "paintServer",
          "shape",
          "structural"
        ]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyphDef",
          "clipPath",
          "color-profile",
          "cursor",
          "filter",
          "font-face",
          "font",
          "foreignObject",
          "image",
          "marker",
          "mask",
          "pattern",
          "script",
          "style",
          "switch",
          "text",
          "view"
        ])
      },
      text: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "dx",
          "dy",
          "externalResourcesRequired",
          "lengthAdjust",
          "rotate",
          "style",
          "textLength",
          "transform",
          "x",
          "y"
        ]),
        defaults: {
          x: "0",
          y: "0",
          lengthAdjust: "spacing"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive", "textContentChild"]),
        content: /* @__PURE__ */ new Set(["a"])
      },
      textPath: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "d",
          "externalResourcesRequired",
          "href",
          "method",
          "spacing",
          "startOffset",
          "style",
          "xlink:href"
        ]),
        defaults: {
          startOffset: "0",
          method: "align",
          spacing: "exact"
        },
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ])
      },
      title: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["class", "style"])
      },
      tref: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "href",
          "style",
          "xlink:href"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set(["animate", "animateColor", "set"])
      },
      tspan: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "dx",
          "dy",
          "externalResourcesRequired",
          "lengthAdjust",
          "rotate",
          "style",
          "textLength",
          "x",
          "y"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"]),
        content: /* @__PURE__ */ new Set([
          "a",
          "altGlyph",
          "animate",
          "animateColor",
          "set",
          "tref",
          "tspan"
        ])
      },
      use: {
        attrsGroups: /* @__PURE__ */ new Set([
          "conditionalProcessing",
          "core",
          "graphicalEvent",
          "presentation",
          "xlink"
        ]),
        attrs: /* @__PURE__ */ new Set([
          "class",
          "externalResourcesRequired",
          "height",
          "href",
          "style",
          "transform",
          "width",
          "x",
          "xlink:href",
          "y"
        ]),
        defaults: {
          x: "0",
          y: "0"
        },
        contentGroups: /* @__PURE__ */ new Set(["animation", "descriptive"])
      },
      view: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set([
          "externalResourcesRequired",
          "preserveAspectRatio",
          "viewBox",
          "viewTarget",
          "zoomAndPan"
        ]),
        contentGroups: /* @__PURE__ */ new Set(["descriptive"])
      },
      vkern: {
        attrsGroups: /* @__PURE__ */ new Set(["core"]),
        attrs: /* @__PURE__ */ new Set(["u1", "g1", "u2", "g2", "k"])
      }
    };
    exports2.editorNamespaces = /* @__PURE__ */ new Set([
      "http://creativecommons.org/ns#",
      "http://inkscape.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://ns.adobe.com/AdobeIllustrator/10.0/",
      "http://ns.adobe.com/AdobeSVGViewerExtensions/3.0/",
      "http://ns.adobe.com/Extensibility/1.0/",
      "http://ns.adobe.com/Flows/1.0/",
      "http://ns.adobe.com/GenericCustomNamespace/1.0/",
      "http://ns.adobe.com/Graphs/1.0/",
      "http://ns.adobe.com/ImageReplacement/1.0/",
      "http://ns.adobe.com/SaveForWeb/1.0/",
      "http://ns.adobe.com/Variables/1.0/",
      "http://ns.adobe.com/XPath/1.0/",
      "http://purl.org/dc/elements/1.1/",
      "http://schemas.microsoft.com/visio/2003/SVGExtensions/",
      "http://sodipodi.sourceforge.net/DTD/sodipodi-0.dtd",
      "http://taptrix.com/vectorillustrator/svg_extensions",
      "http://www.bohemiancoding.com/sketch/ns",
      "http://www.figma.com/figma/ns",
      "http://www.inkscape.org/namespaces/inkscape",
      "http://www.serif.com/",
      "http://www.vector.evaxdesign.sk",
      "http://www.w3.org/1999/02/22-rdf-syntax-ns#"
    ]);
    exports2.referencesProps = /* @__PURE__ */ new Set([
      "clip-path",
      "color-profile",
      "fill",
      "filter",
      "marker-end",
      "marker-mid",
      "marker-start",
      "mask",
      "stroke",
      "style"
    ]);
    exports2.inheritableAttrs = /* @__PURE__ */ new Set([
      "clip-rule",
      "color-interpolation-filters",
      "color-interpolation",
      "color-profile",
      "color-rendering",
      "color",
      "cursor",
      "direction",
      "dominant-baseline",
      "fill-opacity",
      "fill-rule",
      "fill",
      "font-family",
      "font-size-adjust",
      "font-size",
      "font-stretch",
      "font-style",
      "font-variant",
      "font-weight",
      "font",
      "glyph-orientation-horizontal",
      "glyph-orientation-vertical",
      "image-rendering",
      "letter-spacing",
      "marker-end",
      "marker-mid",
      "marker-start",
      "marker",
      "paint-order",
      "pointer-events",
      "shape-rendering",
      "stroke-dasharray",
      "stroke-dashoffset",
      "stroke-linecap",
      "stroke-linejoin",
      "stroke-miterlimit",
      "stroke-opacity",
      "stroke-width",
      "stroke",
      "text-anchor",
      "text-rendering",
      "transform",
      "visibility",
      "word-spacing",
      "writing-mode"
    ]);
    exports2.presentationNonInheritableGroupAttrs = /* @__PURE__ */ new Set([
      "clip-path",
      "display",
      "filter",
      "mask",
      "opacity",
      "text-decoration",
      "transform",
      "unicode-bidi"
    ]);
    exports2.colorsNames = {
      aliceblue: "#f0f8ff",
      antiquewhite: "#faebd7",
      aqua: "#0ff",
      aquamarine: "#7fffd4",
      azure: "#f0ffff",
      beige: "#f5f5dc",
      bisque: "#ffe4c4",
      black: "#000",
      blanchedalmond: "#ffebcd",
      blue: "#00f",
      blueviolet: "#8a2be2",
      brown: "#a52a2a",
      burlywood: "#deb887",
      cadetblue: "#5f9ea0",
      chartreuse: "#7fff00",
      chocolate: "#d2691e",
      coral: "#ff7f50",
      cornflowerblue: "#6495ed",
      cornsilk: "#fff8dc",
      crimson: "#dc143c",
      cyan: "#0ff",
      darkblue: "#00008b",
      darkcyan: "#008b8b",
      darkgoldenrod: "#b8860b",
      darkgray: "#a9a9a9",
      darkgreen: "#006400",
      darkgrey: "#a9a9a9",
      darkkhaki: "#bdb76b",
      darkmagenta: "#8b008b",
      darkolivegreen: "#556b2f",
      darkorange: "#ff8c00",
      darkorchid: "#9932cc",
      darkred: "#8b0000",
      darksalmon: "#e9967a",
      darkseagreen: "#8fbc8f",
      darkslateblue: "#483d8b",
      darkslategray: "#2f4f4f",
      darkslategrey: "#2f4f4f",
      darkturquoise: "#00ced1",
      darkviolet: "#9400d3",
      deeppink: "#ff1493",
      deepskyblue: "#00bfff",
      dimgray: "#696969",
      dimgrey: "#696969",
      dodgerblue: "#1e90ff",
      firebrick: "#b22222",
      floralwhite: "#fffaf0",
      forestgreen: "#228b22",
      fuchsia: "#f0f",
      gainsboro: "#dcdcdc",
      ghostwhite: "#f8f8ff",
      gold: "#ffd700",
      goldenrod: "#daa520",
      gray: "#808080",
      green: "#008000",
      greenyellow: "#adff2f",
      grey: "#808080",
      honeydew: "#f0fff0",
      hotpink: "#ff69b4",
      indianred: "#cd5c5c",
      indigo: "#4b0082",
      ivory: "#fffff0",
      khaki: "#f0e68c",
      lavender: "#e6e6fa",
      lavenderblush: "#fff0f5",
      lawngreen: "#7cfc00",
      lemonchiffon: "#fffacd",
      lightblue: "#add8e6",
      lightcoral: "#f08080",
      lightcyan: "#e0ffff",
      lightgoldenrodyellow: "#fafad2",
      lightgray: "#d3d3d3",
      lightgreen: "#90ee90",
      lightgrey: "#d3d3d3",
      lightpink: "#ffb6c1",
      lightsalmon: "#ffa07a",
      lightseagreen: "#20b2aa",
      lightskyblue: "#87cefa",
      lightslategray: "#789",
      lightslategrey: "#789",
      lightsteelblue: "#b0c4de",
      lightyellow: "#ffffe0",
      lime: "#0f0",
      limegreen: "#32cd32",
      linen: "#faf0e6",
      magenta: "#f0f",
      maroon: "#800000",
      mediumaquamarine: "#66cdaa",
      mediumblue: "#0000cd",
      mediumorchid: "#ba55d3",
      mediumpurple: "#9370db",
      mediumseagreen: "#3cb371",
      mediumslateblue: "#7b68ee",
      mediumspringgreen: "#00fa9a",
      mediumturquoise: "#48d1cc",
      mediumvioletred: "#c71585",
      midnightblue: "#191970",
      mintcream: "#f5fffa",
      mistyrose: "#ffe4e1",
      moccasin: "#ffe4b5",
      navajowhite: "#ffdead",
      navy: "#000080",
      oldlace: "#fdf5e6",
      olive: "#808000",
      olivedrab: "#6b8e23",
      orange: "#ffa500",
      orangered: "#ff4500",
      orchid: "#da70d6",
      palegoldenrod: "#eee8aa",
      palegreen: "#98fb98",
      paleturquoise: "#afeeee",
      palevioletred: "#db7093",
      papayawhip: "#ffefd5",
      peachpuff: "#ffdab9",
      peru: "#cd853f",
      pink: "#ffc0cb",
      plum: "#dda0dd",
      powderblue: "#b0e0e6",
      purple: "#800080",
      rebeccapurple: "#639",
      red: "#f00",
      rosybrown: "#bc8f8f",
      royalblue: "#4169e1",
      saddlebrown: "#8b4513",
      salmon: "#fa8072",
      sandybrown: "#f4a460",
      seagreen: "#2e8b57",
      seashell: "#fff5ee",
      sienna: "#a0522d",
      silver: "#c0c0c0",
      skyblue: "#87ceeb",
      slateblue: "#6a5acd",
      slategray: "#708090",
      slategrey: "#708090",
      snow: "#fffafa",
      springgreen: "#00ff7f",
      steelblue: "#4682b4",
      tan: "#d2b48c",
      teal: "#008080",
      thistle: "#d8bfd8",
      tomato: "#ff6347",
      turquoise: "#40e0d0",
      violet: "#ee82ee",
      wheat: "#f5deb3",
      white: "#fff",
      whitesmoke: "#f5f5f5",
      yellow: "#ff0",
      yellowgreen: "#9acd32"
    };
    exports2.colorsShortNames = {
      "#f0ffff": "azure",
      "#f5f5dc": "beige",
      "#ffe4c4": "bisque",
      "#a52a2a": "brown",
      "#ff7f50": "coral",
      "#ffd700": "gold",
      "#808080": "gray",
      "#008000": "green",
      "#4b0082": "indigo",
      "#fffff0": "ivory",
      "#f0e68c": "khaki",
      "#faf0e6": "linen",
      "#800000": "maroon",
      "#000080": "navy",
      "#808000": "olive",
      "#ffa500": "orange",
      "#da70d6": "orchid",
      "#cd853f": "peru",
      "#ffc0cb": "pink",
      "#dda0dd": "plum",
      "#800080": "purple",
      "#f00": "red",
      "#ff0000": "red",
      "#fa8072": "salmon",
      "#a0522d": "sienna",
      "#c0c0c0": "silver",
      "#fffafa": "snow",
      "#d2b48c": "tan",
      "#008080": "teal",
      "#ff6347": "tomato",
      "#ee82ee": "violet",
      "#f5deb3": "wheat"
    };
    exports2.colorsProps = /* @__PURE__ */ new Set([
      "color",
      "fill",
      "flood-color",
      "lighting-color",
      "stop-color",
      "stroke"
    ]);
    exports2.pseudoClasses = {
      displayState: /* @__PURE__ */ new Set(["fullscreen", "modal", "picture-in-picture"]),
      input: /* @__PURE__ */ new Set([
        "autofill",
        "blank",
        "checked",
        "default",
        "disabled",
        "enabled",
        "in-range",
        "indetermined",
        "invalid",
        "optional",
        "out-of-range",
        "placeholder-shown",
        "read-only",
        "read-write",
        "required",
        "user-invalid",
        "valid"
      ]),
      linguistic: /* @__PURE__ */ new Set(["dir", "lang"]),
      location: /* @__PURE__ */ new Set([
        "any-link",
        "link",
        "local-link",
        "scope",
        "target-within",
        "target",
        "visited"
      ]),
      resourceState: /* @__PURE__ */ new Set(["playing", "paused"]),
      timeDimensional: /* @__PURE__ */ new Set(["current", "past", "future"]),
      treeStructural: /* @__PURE__ */ new Set([
        "empty",
        "first-child",
        "first-of-type",
        "last-child",
        "last-of-type",
        "nth-child",
        "nth-last-child",
        "nth-last-of-type",
        "nth-of-type",
        "only-child",
        "only-of-type",
        "root"
      ]),
      userAction: /* @__PURE__ */ new Set([
        "active",
        "focus-visible",
        "focus-within",
        "focus",
        "hover"
      ]),
      functional: /* @__PURE__ */ new Set(["is", "not", "where", "has"])
    };
  }
});

// node_modules/svgo/lib/parser.js
var require_parser = __commonJS({
  "node_modules/svgo/lib/parser.js"(exports2) {
    "use strict";
    var SAX = require_sax();
    var { textElems } = require_collections();
    var SvgoParserError = class _SvgoParserError extends Error {
      /**
       * @param message {string}
       * @param line {number}
       * @param column {number}
       * @param source {string}
       * @param file {void | string}
       */
      constructor(message, line, column, source, file) {
        super(message);
        this.name = "SvgoParserError";
        this.message = `${file || "<input>"}:${line}:${column}: ${message}`;
        this.reason = message;
        this.line = line;
        this.column = column;
        this.source = source;
        if (Error.captureStackTrace) {
          Error.captureStackTrace(this, _SvgoParserError);
        }
      }
      toString() {
        const lines = this.source.split(/\r?\n/);
        const startLine = Math.max(this.line - 3, 0);
        const endLine = Math.min(this.line + 2, lines.length);
        const lineNumberWidth = String(endLine).length;
        const startColumn = Math.max(this.column - 54, 0);
        const endColumn = Math.max(this.column + 20, 80);
        const code = lines.slice(startLine, endLine).map((line, index) => {
          const lineSlice = line.slice(startColumn, endColumn);
          let ellipsisPrefix = "";
          let ellipsisSuffix = "";
          if (startColumn !== 0) {
            ellipsisPrefix = startColumn > line.length - 1 ? " " : "\u2026";
          }
          if (endColumn < line.length - 1) {
            ellipsisSuffix = "\u2026";
          }
          const number = startLine + 1 + index;
          const gutter = ` ${number.toString().padStart(lineNumberWidth)} | `;
          if (number === this.line) {
            const gutterSpacing = gutter.replace(/[^|]/g, " ");
            const lineSpacing = (ellipsisPrefix + line.slice(startColumn, this.column - 1)).replace(/[^\t]/g, " ");
            const spacing = gutterSpacing + lineSpacing;
            return `>${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}
 ${spacing}^`;
          }
          return ` ${gutter}${ellipsisPrefix}${lineSlice}${ellipsisSuffix}`;
        }).join("\n");
        return `${this.name}: ${this.message}

${code}
`;
      }
    };
    var entityDeclaration = /<!ENTITY\s+(\S+)\s+(?:'([^']+)'|"([^"]+)")\s*>/g;
    var config = {
      strict: true,
      trim: false,
      normalize: false,
      lowercase: true,
      xmlns: true,
      position: true
    };
    var parseSvg = (data, from) => {
      const sax = SAX.parser(config.strict, config);
      const root = { type: "root", children: [] };
      let current = root;
      const stack = [root];
      const pushToContent = (node) => {
        Object.defineProperty(node, "parentNode", {
          writable: true,
          value: current
        });
        current.children.push(node);
      };
      sax.ondoctype = (doctype) => {
        const node = {
          type: "doctype",
          // TODO parse doctype for name, public and system to match xast
          name: "svg",
          data: {
            doctype
          }
        };
        pushToContent(node);
        const subsetStart = doctype.indexOf("[");
        if (subsetStart >= 0) {
          entityDeclaration.lastIndex = subsetStart;
          let entityMatch = entityDeclaration.exec(data);
          while (entityMatch != null) {
            sax.ENTITIES[entityMatch[1]] = entityMatch[2] || entityMatch[3];
            entityMatch = entityDeclaration.exec(data);
          }
        }
      };
      sax.onprocessinginstruction = (data2) => {
        const node = {
          type: "instruction",
          name: data2.name,
          value: data2.body
        };
        pushToContent(node);
      };
      sax.oncomment = (comment) => {
        const node = {
          type: "comment",
          value: comment.trim()
        };
        pushToContent(node);
      };
      sax.oncdata = (cdata) => {
        const node = {
          type: "cdata",
          value: cdata
        };
        pushToContent(node);
      };
      sax.onopentag = (data2) => {
        let element = {
          type: "element",
          name: data2.name,
          attributes: {},
          children: []
        };
        for (const [name, attr] of Object.entries(data2.attributes)) {
          element.attributes[name] = attr.value;
        }
        pushToContent(element);
        current = element;
        stack.push(element);
      };
      sax.ontext = (text) => {
        if (current.type === "element") {
          if (textElems.has(current.name)) {
            const node = {
              type: "text",
              value: text
            };
            pushToContent(node);
          } else if (/\S/.test(text)) {
            const node = {
              type: "text",
              value: text.trim()
            };
            pushToContent(node);
          }
        }
      };
      sax.onclosetag = () => {
        stack.pop();
        current = stack[stack.length - 1];
      };
      sax.onerror = (e) => {
        const error = new SvgoParserError(
          e.reason,
          e.line + 1,
          e.column,
          data,
          from
        );
        if (e.message.indexOf("Unexpected end") === -1) {
          throw error;
        }
      };
      sax.write(data).close();
      return root;
    };
    exports2.parseSvg = parseSvg;
  }
});

// node_modules/svgo/lib/stringifier.js
var require_stringifier = __commonJS({
  "node_modules/svgo/lib/stringifier.js"(exports2) {
    "use strict";
    var { textElems } = require_collections();
    var encodeEntity = (char) => {
      return entities[char];
    };
    var defaults = {
      doctypeStart: "<!DOCTYPE",
      doctypeEnd: ">",
      procInstStart: "<?",
      procInstEnd: "?>",
      tagOpenStart: "<",
      tagOpenEnd: ">",
      tagCloseStart: "</",
      tagCloseEnd: ">",
      tagShortStart: "<",
      tagShortEnd: "/>",
      attrStart: '="',
      attrEnd: '"',
      commentStart: "<!--",
      commentEnd: "-->",
      cdataStart: "<![CDATA[",
      cdataEnd: "]]>",
      textStart: "",
      textEnd: "",
      indent: 4,
      regEntities: /[&'"<>]/g,
      regValEntities: /[&"<>]/g,
      encodeEntity,
      pretty: false,
      useShortTags: true,
      eol: "lf",
      finalNewline: false
    };
    var entities = {
      "&": "&amp;",
      "'": "&apos;",
      '"': "&quot;",
      ">": "&gt;",
      "<": "&lt;"
    };
    var stringifySvg = (data, userOptions = {}) => {
      const config = { ...defaults, ...userOptions };
      const indent = config.indent;
      let newIndent = "    ";
      if (typeof indent === "number" && Number.isNaN(indent) === false) {
        newIndent = indent < 0 ? "	" : " ".repeat(indent);
      } else if (typeof indent === "string") {
        newIndent = indent;
      }
      const state = {
        indent: newIndent,
        textContext: null,
        indentLevel: 0
      };
      const eol = config.eol === "crlf" ? "\r\n" : "\n";
      if (config.pretty) {
        config.doctypeEnd += eol;
        config.procInstEnd += eol;
        config.commentEnd += eol;
        config.cdataEnd += eol;
        config.tagShortEnd += eol;
        config.tagOpenEnd += eol;
        config.tagCloseEnd += eol;
        config.textEnd += eol;
      }
      let svg = stringifyNode(data, config, state);
      if (config.finalNewline && svg.length > 0 && !svg.endsWith("\n")) {
        svg += eol;
      }
      return svg;
    };
    exports2.stringifySvg = stringifySvg;
    var stringifyNode = (data, config, state) => {
      let svg = "";
      state.indentLevel += 1;
      for (const item of data.children) {
        if (item.type === "element") {
          svg += stringifyElement(item, config, state);
        }
        if (item.type === "text") {
          svg += stringifyText(item, config, state);
        }
        if (item.type === "doctype") {
          svg += stringifyDoctype(item, config);
        }
        if (item.type === "instruction") {
          svg += stringifyInstruction(item, config);
        }
        if (item.type === "comment") {
          svg += stringifyComment(item, config);
        }
        if (item.type === "cdata") {
          svg += stringifyCdata(item, config, state);
        }
      }
      state.indentLevel -= 1;
      return svg;
    };
    var createIndent = (config, state) => {
      let indent = "";
      if (config.pretty && state.textContext == null) {
        indent = state.indent.repeat(state.indentLevel - 1);
      }
      return indent;
    };
    var stringifyDoctype = (node, config) => {
      return config.doctypeStart + node.data.doctype + config.doctypeEnd;
    };
    var stringifyInstruction = (node, config) => {
      return config.procInstStart + node.name + " " + node.value + config.procInstEnd;
    };
    var stringifyComment = (node, config) => {
      return config.commentStart + node.value + config.commentEnd;
    };
    var stringifyCdata = (node, config, state) => {
      return createIndent(config, state) + config.cdataStart + node.value + config.cdataEnd;
    };
    var stringifyElement = (node, config, state) => {
      if (node.children.length === 0) {
        if (config.useShortTags) {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagShortEnd;
        } else {
          return createIndent(config, state) + config.tagShortStart + node.name + stringifyAttributes(node, config) + config.tagOpenEnd + config.tagCloseStart + node.name + config.tagCloseEnd;
        }
      } else {
        let tagOpenStart = config.tagOpenStart;
        let tagOpenEnd = config.tagOpenEnd;
        let tagCloseStart = config.tagCloseStart;
        let tagCloseEnd = config.tagCloseEnd;
        let openIndent = createIndent(config, state);
        let closeIndent = createIndent(config, state);
        if (state.textContext) {
          tagOpenStart = defaults.tagOpenStart;
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          tagCloseEnd = defaults.tagCloseEnd;
          openIndent = "";
        } else if (textElems.has(node.name)) {
          tagOpenEnd = defaults.tagOpenEnd;
          tagCloseStart = defaults.tagCloseStart;
          closeIndent = "";
          state.textContext = node;
        }
        const children = stringifyNode(node, config, state);
        if (state.textContext === node) {
          state.textContext = null;
        }
        return openIndent + tagOpenStart + node.name + stringifyAttributes(node, config) + tagOpenEnd + children + closeIndent + tagCloseStart + node.name + tagCloseEnd;
      }
    };
    var stringifyAttributes = (node, config) => {
      let attrs = "";
      for (const [name, value] of Object.entries(node.attributes)) {
        if (value !== void 0) {
          const encodedValue = value.toString().replace(config.regValEntities, config.encodeEntity);
          attrs += " " + name + config.attrStart + encodedValue + config.attrEnd;
        } else {
          attrs += " " + name;
        }
      }
      return attrs;
    };
    var stringifyText = (node, config, state) => {
      return createIndent(config, state) + config.textStart + node.value.replace(config.regEntities, config.encodeEntity) + (state.textContext ? "" : config.textEnd);
    };
  }
});

// node_modules/domelementtype/lib/index.js
var require_lib = __commonJS({
  "node_modules/domelementtype/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.Doctype = exports2.CDATA = exports2.Tag = exports2.Style = exports2.Script = exports2.Comment = exports2.Directive = exports2.Text = exports2.Root = exports2.isTag = exports2.ElementType = void 0;
    var ElementType;
    (function(ElementType2) {
      ElementType2["Root"] = "root";
      ElementType2["Text"] = "text";
      ElementType2["Directive"] = "directive";
      ElementType2["Comment"] = "comment";
      ElementType2["Script"] = "script";
      ElementType2["Style"] = "style";
      ElementType2["Tag"] = "tag";
      ElementType2["CDATA"] = "cdata";
      ElementType2["Doctype"] = "doctype";
    })(ElementType = exports2.ElementType || (exports2.ElementType = {}));
    function isTag(elem) {
      return elem.type === ElementType.Tag || elem.type === ElementType.Script || elem.type === ElementType.Style;
    }
    exports2.isTag = isTag;
    exports2.Root = ElementType.Root;
    exports2.Text = ElementType.Text;
    exports2.Directive = ElementType.Directive;
    exports2.Comment = ElementType.Comment;
    exports2.Script = ElementType.Script;
    exports2.Style = ElementType.Style;
    exports2.Tag = ElementType.Tag;
    exports2.CDATA = ElementType.CDATA;
    exports2.Doctype = ElementType.Doctype;
  }
});

// node_modules/domhandler/lib/node.js
var require_node = __commonJS({
  "node_modules/domhandler/lib/node.js"(exports2) {
    "use strict";
    var __extends = exports2 && exports2.__extends || /* @__PURE__ */ (function() {
      var extendStatics = function(d, b) {
        extendStatics = Object.setPrototypeOf || { __proto__: [] } instanceof Array && function(d2, b2) {
          d2.__proto__ = b2;
        } || function(d2, b2) {
          for (var p in b2) if (Object.prototype.hasOwnProperty.call(b2, p)) d2[p] = b2[p];
        };
        return extendStatics(d, b);
      };
      return function(d, b) {
        if (typeof b !== "function" && b !== null)
          throw new TypeError("Class extends value " + String(b) + " is not a constructor or null");
        extendStatics(d, b);
        function __() {
          this.constructor = d;
        }
        d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
      };
    })();
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.cloneNode = exports2.hasChildren = exports2.isDocument = exports2.isDirective = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = exports2.Element = exports2.Document = exports2.CDATA = exports2.NodeWithChildren = exports2.ProcessingInstruction = exports2.Comment = exports2.Text = exports2.DataNode = exports2.Node = void 0;
    var domelementtype_1 = require_lib();
    var Node = (
      /** @class */
      (function() {
        function Node2() {
          this.parent = null;
          this.prev = null;
          this.next = null;
          this.startIndex = null;
          this.endIndex = null;
        }
        Object.defineProperty(Node2.prototype, "parentNode", {
          // Read-write aliases for properties
          /**
           * Same as {@link parent}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.parent;
          },
          set: function(parent) {
            this.parent = parent;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "previousSibling", {
          /**
           * Same as {@link prev}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.prev;
          },
          set: function(prev) {
            this.prev = prev;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Node2.prototype, "nextSibling", {
          /**
           * Same as {@link next}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.next;
          },
          set: function(next) {
            this.next = next;
          },
          enumerable: false,
          configurable: true
        });
        Node2.prototype.cloneNode = function(recursive) {
          if (recursive === void 0) {
            recursive = false;
          }
          return cloneNode(this, recursive);
        };
        return Node2;
      })()
    );
    exports2.Node = Node;
    var DataNode = (
      /** @class */
      (function(_super) {
        __extends(DataNode2, _super);
        function DataNode2(data) {
          var _this = _super.call(this) || this;
          _this.data = data;
          return _this;
        }
        Object.defineProperty(DataNode2.prototype, "nodeValue", {
          /**
           * Same as {@link data}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.data;
          },
          set: function(data) {
            this.data = data;
          },
          enumerable: false,
          configurable: true
        });
        return DataNode2;
      })(Node)
    );
    exports2.DataNode = DataNode;
    var Text = (
      /** @class */
      (function(_super) {
        __extends(Text2, _super);
        function Text2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Text;
          return _this;
        }
        Object.defineProperty(Text2.prototype, "nodeType", {
          get: function() {
            return 3;
          },
          enumerable: false,
          configurable: true
        });
        return Text2;
      })(DataNode)
    );
    exports2.Text = Text;
    var Comment = (
      /** @class */
      (function(_super) {
        __extends(Comment2, _super);
        function Comment2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Comment;
          return _this;
        }
        Object.defineProperty(Comment2.prototype, "nodeType", {
          get: function() {
            return 8;
          },
          enumerable: false,
          configurable: true
        });
        return Comment2;
      })(DataNode)
    );
    exports2.Comment = Comment;
    var ProcessingInstruction = (
      /** @class */
      (function(_super) {
        __extends(ProcessingInstruction2, _super);
        function ProcessingInstruction2(name, data) {
          var _this = _super.call(this, data) || this;
          _this.name = name;
          _this.type = domelementtype_1.ElementType.Directive;
          return _this;
        }
        Object.defineProperty(ProcessingInstruction2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        return ProcessingInstruction2;
      })(DataNode)
    );
    exports2.ProcessingInstruction = ProcessingInstruction;
    var NodeWithChildren = (
      /** @class */
      (function(_super) {
        __extends(NodeWithChildren2, _super);
        function NodeWithChildren2(children) {
          var _this = _super.call(this) || this;
          _this.children = children;
          return _this;
        }
        Object.defineProperty(NodeWithChildren2.prototype, "firstChild", {
          // Aliases
          /** First child of the node. */
          get: function() {
            var _a;
            return (_a = this.children[0]) !== null && _a !== void 0 ? _a : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "lastChild", {
          /** Last child of the node. */
          get: function() {
            return this.children.length > 0 ? this.children[this.children.length - 1] : null;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(NodeWithChildren2.prototype, "childNodes", {
          /**
           * Same as {@link children}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.children;
          },
          set: function(children) {
            this.children = children;
          },
          enumerable: false,
          configurable: true
        });
        return NodeWithChildren2;
      })(Node)
    );
    exports2.NodeWithChildren = NodeWithChildren;
    var CDATA = (
      /** @class */
      (function(_super) {
        __extends(CDATA2, _super);
        function CDATA2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.CDATA;
          return _this;
        }
        Object.defineProperty(CDATA2.prototype, "nodeType", {
          get: function() {
            return 4;
          },
          enumerable: false,
          configurable: true
        });
        return CDATA2;
      })(NodeWithChildren)
    );
    exports2.CDATA = CDATA;
    var Document = (
      /** @class */
      (function(_super) {
        __extends(Document2, _super);
        function Document2() {
          var _this = _super !== null && _super.apply(this, arguments) || this;
          _this.type = domelementtype_1.ElementType.Root;
          return _this;
        }
        Object.defineProperty(Document2.prototype, "nodeType", {
          get: function() {
            return 9;
          },
          enumerable: false,
          configurable: true
        });
        return Document2;
      })(NodeWithChildren)
    );
    exports2.Document = Document;
    var Element = (
      /** @class */
      (function(_super) {
        __extends(Element2, _super);
        function Element2(name, attribs, children, type) {
          if (children === void 0) {
            children = [];
          }
          if (type === void 0) {
            type = name === "script" ? domelementtype_1.ElementType.Script : name === "style" ? domelementtype_1.ElementType.Style : domelementtype_1.ElementType.Tag;
          }
          var _this = _super.call(this, children) || this;
          _this.name = name;
          _this.attribs = attribs;
          _this.type = type;
          return _this;
        }
        Object.defineProperty(Element2.prototype, "nodeType", {
          get: function() {
            return 1;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "tagName", {
          // DOM Level 1 aliases
          /**
           * Same as {@link name}.
           * [DOM spec](https://dom.spec.whatwg.org)-compatible alias.
           */
          get: function() {
            return this.name;
          },
          set: function(name) {
            this.name = name;
          },
          enumerable: false,
          configurable: true
        });
        Object.defineProperty(Element2.prototype, "attributes", {
          get: function() {
            var _this = this;
            return Object.keys(this.attribs).map(function(name) {
              var _a, _b;
              return {
                name,
                value: _this.attribs[name],
                namespace: (_a = _this["x-attribsNamespace"]) === null || _a === void 0 ? void 0 : _a[name],
                prefix: (_b = _this["x-attribsPrefix"]) === null || _b === void 0 ? void 0 : _b[name]
              };
            });
          },
          enumerable: false,
          configurable: true
        });
        return Element2;
      })(NodeWithChildren)
    );
    exports2.Element = Element;
    function isTag(node) {
      return (0, domelementtype_1.isTag)(node);
    }
    exports2.isTag = isTag;
    function isCDATA(node) {
      return node.type === domelementtype_1.ElementType.CDATA;
    }
    exports2.isCDATA = isCDATA;
    function isText(node) {
      return node.type === domelementtype_1.ElementType.Text;
    }
    exports2.isText = isText;
    function isComment(node) {
      return node.type === domelementtype_1.ElementType.Comment;
    }
    exports2.isComment = isComment;
    function isDirective(node) {
      return node.type === domelementtype_1.ElementType.Directive;
    }
    exports2.isDirective = isDirective;
    function isDocument(node) {
      return node.type === domelementtype_1.ElementType.Root;
    }
    exports2.isDocument = isDocument;
    function hasChildren(node) {
      return Object.prototype.hasOwnProperty.call(node, "children");
    }
    exports2.hasChildren = hasChildren;
    function cloneNode(node, recursive) {
      if (recursive === void 0) {
        recursive = false;
      }
      var result;
      if (isText(node)) {
        result = new Text(node.data);
      } else if (isComment(node)) {
        result = new Comment(node.data);
      } else if (isTag(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_1 = new Element(node.name, __assign({}, node.attribs), children);
        children.forEach(function(child) {
          return child.parent = clone_1;
        });
        if (node.namespace != null) {
          clone_1.namespace = node.namespace;
        }
        if (node["x-attribsNamespace"]) {
          clone_1["x-attribsNamespace"] = __assign({}, node["x-attribsNamespace"]);
        }
        if (node["x-attribsPrefix"]) {
          clone_1["x-attribsPrefix"] = __assign({}, node["x-attribsPrefix"]);
        }
        result = clone_1;
      } else if (isCDATA(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_2 = new CDATA(children);
        children.forEach(function(child) {
          return child.parent = clone_2;
        });
        result = clone_2;
      } else if (isDocument(node)) {
        var children = recursive ? cloneChildren(node.children) : [];
        var clone_3 = new Document(children);
        children.forEach(function(child) {
          return child.parent = clone_3;
        });
        if (node["x-mode"]) {
          clone_3["x-mode"] = node["x-mode"];
        }
        result = clone_3;
      } else if (isDirective(node)) {
        var instruction = new ProcessingInstruction(node.name, node.data);
        if (node["x-name"] != null) {
          instruction["x-name"] = node["x-name"];
          instruction["x-publicId"] = node["x-publicId"];
          instruction["x-systemId"] = node["x-systemId"];
        }
        result = instruction;
      } else {
        throw new Error("Not implemented yet: ".concat(node.type));
      }
      result.startIndex = node.startIndex;
      result.endIndex = node.endIndex;
      if (node.sourceCodeLocation != null) {
        result.sourceCodeLocation = node.sourceCodeLocation;
      }
      return result;
    }
    exports2.cloneNode = cloneNode;
    function cloneChildren(childs) {
      var children = childs.map(function(child) {
        return cloneNode(child, true);
      });
      for (var i = 1; i < children.length; i++) {
        children[i].prev = children[i - 1];
        children[i - 1].next = children[i];
      }
      return children;
    }
  }
});

// node_modules/domhandler/lib/index.js
var require_lib2 = __commonJS({
  "node_modules/domhandler/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DomHandler = void 0;
    var domelementtype_1 = require_lib();
    var node_js_1 = require_node();
    __exportStar(require_node(), exports2);
    var defaultOpts = {
      withStartIndices: false,
      withEndIndices: false,
      xmlMode: false
    };
    var DomHandler = (
      /** @class */
      (function() {
        function DomHandler2(callback, options, elementCB) {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
          if (typeof options === "function") {
            elementCB = options;
            options = defaultOpts;
          }
          if (typeof callback === "object") {
            options = callback;
            callback = void 0;
          }
          this.callback = callback !== null && callback !== void 0 ? callback : null;
          this.options = options !== null && options !== void 0 ? options : defaultOpts;
          this.elementCB = elementCB !== null && elementCB !== void 0 ? elementCB : null;
        }
        DomHandler2.prototype.onparserinit = function(parser) {
          this.parser = parser;
        };
        DomHandler2.prototype.onreset = function() {
          this.dom = [];
          this.root = new node_js_1.Document(this.dom);
          this.done = false;
          this.tagStack = [this.root];
          this.lastNode = null;
          this.parser = null;
        };
        DomHandler2.prototype.onend = function() {
          if (this.done)
            return;
          this.done = true;
          this.parser = null;
          this.handleCallback(null);
        };
        DomHandler2.prototype.onerror = function(error) {
          this.handleCallback(error);
        };
        DomHandler2.prototype.onclosetag = function() {
          this.lastNode = null;
          var elem = this.tagStack.pop();
          if (this.options.withEndIndices) {
            elem.endIndex = this.parser.endIndex;
          }
          if (this.elementCB)
            this.elementCB(elem);
        };
        DomHandler2.prototype.onopentag = function(name, attribs) {
          var type = this.options.xmlMode ? domelementtype_1.ElementType.Tag : void 0;
          var element = new node_js_1.Element(name, attribs, void 0, type);
          this.addNode(element);
          this.tagStack.push(element);
        };
        DomHandler2.prototype.ontext = function(data) {
          var lastNode = this.lastNode;
          if (lastNode && lastNode.type === domelementtype_1.ElementType.Text) {
            lastNode.data += data;
            if (this.options.withEndIndices) {
              lastNode.endIndex = this.parser.endIndex;
            }
          } else {
            var node = new node_js_1.Text(data);
            this.addNode(node);
            this.lastNode = node;
          }
        };
        DomHandler2.prototype.oncomment = function(data) {
          if (this.lastNode && this.lastNode.type === domelementtype_1.ElementType.Comment) {
            this.lastNode.data += data;
            return;
          }
          var node = new node_js_1.Comment(data);
          this.addNode(node);
          this.lastNode = node;
        };
        DomHandler2.prototype.oncommentend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.oncdatastart = function() {
          var text = new node_js_1.Text("");
          var node = new node_js_1.CDATA([text]);
          this.addNode(node);
          text.parent = node;
          this.lastNode = text;
        };
        DomHandler2.prototype.oncdataend = function() {
          this.lastNode = null;
        };
        DomHandler2.prototype.onprocessinginstruction = function(name, data) {
          var node = new node_js_1.ProcessingInstruction(name, data);
          this.addNode(node);
        };
        DomHandler2.prototype.handleCallback = function(error) {
          if (typeof this.callback === "function") {
            this.callback(error, this.dom);
          } else if (error) {
            throw error;
          }
        };
        DomHandler2.prototype.addNode = function(node) {
          var parent = this.tagStack[this.tagStack.length - 1];
          var previousSibling = parent.children[parent.children.length - 1];
          if (this.options.withStartIndices) {
            node.startIndex = this.parser.startIndex;
          }
          if (this.options.withEndIndices) {
            node.endIndex = this.parser.endIndex;
          }
          parent.children.push(node);
          if (previousSibling) {
            node.prev = previousSibling;
            previousSibling.next = node;
          }
          node.parent = parent;
          this.lastNode = null;
        };
        return DomHandler2;
      })()
    );
    exports2.DomHandler = DomHandler;
    exports2.default = DomHandler;
  }
});

// node_modules/entities/lib/generated/decode-data-html.js
var require_decode_data_html = __commonJS({
  "node_modules/entities/lib/generated/decode-data-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      '\u1D41<\xD5\u0131\u028A\u049D\u057B\u05D0\u0675\u06DE\u07A2\u07D6\u080F\u0A4A\u0A91\u0DA1\u0E6D\u0F09\u0F26\u10CA\u1228\u12E1\u1415\u149D\u14C3\u14DF\u1525\0\0\0\0\0\0\u156B\u16CD\u198D\u1C12\u1DDD\u1F7E\u2060\u21B0\u228D\u23C0\u23FB\u2442\u2824\u2912\u2D08\u2E48\u2FCE\u3016\u32BA\u3639\u37AC\u38FE\u3A28\u3A71\u3AE0\u3B2E\u0800EMabcfglmnoprstu\\bfms\x7F\x84\x8B\x90\x95\x98\xA6\xB3\xB9\xC8\xCFlig\u803B\xC6\u40C6P\u803B&\u4026cute\u803B\xC1\u40C1reve;\u4102\u0100iyx}rc\u803B\xC2\u40C2;\u4410r;\uC000\u{1D504}rave\u803B\xC0\u40C0pha;\u4391acr;\u4100d;\u6A53\u0100gp\x9D\xA1on;\u4104f;\uC000\u{1D538}plyFunction;\u6061ing\u803B\xC5\u40C5\u0100cs\xBE\xC3r;\uC000\u{1D49C}ign;\u6254ilde\u803B\xC3\u40C3ml\u803B\xC4\u40C4\u0400aceforsu\xE5\xFB\xFE\u0117\u011C\u0122\u0127\u012A\u0100cr\xEA\xF2kslash;\u6216\u0176\xF6\xF8;\u6AE7ed;\u6306y;\u4411\u0180crt\u0105\u010B\u0114ause;\u6235noullis;\u612Ca;\u4392r;\uC000\u{1D505}pf;\uC000\u{1D539}eve;\u42D8c\xF2\u0113mpeq;\u624E\u0700HOacdefhilorsu\u014D\u0151\u0156\u0180\u019E\u01A2\u01B5\u01B7\u01BA\u01DC\u0215\u0273\u0278\u027Ecy;\u4427PY\u803B\xA9\u40A9\u0180cpy\u015D\u0162\u017Aute;\u4106\u0100;i\u0167\u0168\u62D2talDifferentialD;\u6145leys;\u612D\u0200aeio\u0189\u018E\u0194\u0198ron;\u410Cdil\u803B\xC7\u40C7rc;\u4108nint;\u6230ot;\u410A\u0100dn\u01A7\u01ADilla;\u40B8terDot;\u40B7\xF2\u017Fi;\u43A7rcle\u0200DMPT\u01C7\u01CB\u01D1\u01D6ot;\u6299inus;\u6296lus;\u6295imes;\u6297o\u0100cs\u01E2\u01F8kwiseContourIntegral;\u6232eCurly\u0100DQ\u0203\u020FoubleQuote;\u601Duote;\u6019\u0200lnpu\u021E\u0228\u0247\u0255on\u0100;e\u0225\u0226\u6237;\u6A74\u0180git\u022F\u0236\u023Aruent;\u6261nt;\u622FourIntegral;\u622E\u0100fr\u024C\u024E;\u6102oduct;\u6210nterClockwiseContourIntegral;\u6233oss;\u6A2Fcr;\uC000\u{1D49E}p\u0100;C\u0284\u0285\u62D3ap;\u624D\u0580DJSZacefios\u02A0\u02AC\u02B0\u02B4\u02B8\u02CB\u02D7\u02E1\u02E6\u0333\u048D\u0100;o\u0179\u02A5trahd;\u6911cy;\u4402cy;\u4405cy;\u440F\u0180grs\u02BF\u02C4\u02C7ger;\u6021r;\u61A1hv;\u6AE4\u0100ay\u02D0\u02D5ron;\u410E;\u4414l\u0100;t\u02DD\u02DE\u6207a;\u4394r;\uC000\u{1D507}\u0100af\u02EB\u0327\u0100cm\u02F0\u0322ritical\u0200ADGT\u0300\u0306\u0316\u031Ccute;\u40B4o\u0174\u030B\u030D;\u42D9bleAcute;\u42DDrave;\u4060ilde;\u42DCond;\u62C4ferentialD;\u6146\u0470\u033D\0\0\0\u0342\u0354\0\u0405f;\uC000\u{1D53B}\u0180;DE\u0348\u0349\u034D\u40A8ot;\u60DCqual;\u6250ble\u0300CDLRUV\u0363\u0372\u0382\u03CF\u03E2\u03F8ontourIntegra\xEC\u0239o\u0274\u0379\0\0\u037B\xBB\u0349nArrow;\u61D3\u0100eo\u0387\u03A4ft\u0180ART\u0390\u0396\u03A1rrow;\u61D0ightArrow;\u61D4e\xE5\u02CAng\u0100LR\u03AB\u03C4eft\u0100AR\u03B3\u03B9rrow;\u67F8ightArrow;\u67FAightArrow;\u67F9ight\u0100AT\u03D8\u03DErrow;\u61D2ee;\u62A8p\u0241\u03E9\0\0\u03EFrrow;\u61D1ownArrow;\u61D5erticalBar;\u6225n\u0300ABLRTa\u0412\u042A\u0430\u045E\u047F\u037Crrow\u0180;BU\u041D\u041E\u0422\u6193ar;\u6913pArrow;\u61F5reve;\u4311eft\u02D2\u043A\0\u0446\0\u0450ightVector;\u6950eeVector;\u695Eector\u0100;B\u0459\u045A\u61BDar;\u6956ight\u01D4\u0467\0\u0471eeVector;\u695Fector\u0100;B\u047A\u047B\u61C1ar;\u6957ee\u0100;A\u0486\u0487\u62A4rrow;\u61A7\u0100ct\u0492\u0497r;\uC000\u{1D49F}rok;\u4110\u0800NTacdfglmopqstux\u04BD\u04C0\u04C4\u04CB\u04DE\u04E2\u04E7\u04EE\u04F5\u0521\u052F\u0536\u0552\u055D\u0560\u0565G;\u414AH\u803B\xD0\u40D0cute\u803B\xC9\u40C9\u0180aiy\u04D2\u04D7\u04DCron;\u411Arc\u803B\xCA\u40CA;\u442Dot;\u4116r;\uC000\u{1D508}rave\u803B\xC8\u40C8ement;\u6208\u0100ap\u04FA\u04FEcr;\u4112ty\u0253\u0506\0\0\u0512mallSquare;\u65FBerySmallSquare;\u65AB\u0100gp\u0526\u052Aon;\u4118f;\uC000\u{1D53C}silon;\u4395u\u0100ai\u053C\u0549l\u0100;T\u0542\u0543\u6A75ilde;\u6242librium;\u61CC\u0100ci\u0557\u055Ar;\u6130m;\u6A73a;\u4397ml\u803B\xCB\u40CB\u0100ip\u056A\u056Fsts;\u6203onentialE;\u6147\u0280cfios\u0585\u0588\u058D\u05B2\u05CCy;\u4424r;\uC000\u{1D509}lled\u0253\u0597\0\0\u05A3mallSquare;\u65FCerySmallSquare;\u65AA\u0370\u05BA\0\u05BF\0\0\u05C4f;\uC000\u{1D53D}All;\u6200riertrf;\u6131c\xF2\u05CB\u0600JTabcdfgorst\u05E8\u05EC\u05EF\u05FA\u0600\u0612\u0616\u061B\u061D\u0623\u066C\u0672cy;\u4403\u803B>\u403Emma\u0100;d\u05F7\u05F8\u4393;\u43DCreve;\u411E\u0180eiy\u0607\u060C\u0610dil;\u4122rc;\u411C;\u4413ot;\u4120r;\uC000\u{1D50A};\u62D9pf;\uC000\u{1D53E}eater\u0300EFGLST\u0635\u0644\u064E\u0656\u065B\u0666qual\u0100;L\u063E\u063F\u6265ess;\u62DBullEqual;\u6267reater;\u6AA2ess;\u6277lantEqual;\u6A7Eilde;\u6273cr;\uC000\u{1D4A2};\u626B\u0400Aacfiosu\u0685\u068B\u0696\u069B\u069E\u06AA\u06BE\u06CARDcy;\u442A\u0100ct\u0690\u0694ek;\u42C7;\u405Eirc;\u4124r;\u610ClbertSpace;\u610B\u01F0\u06AF\0\u06B2f;\u610DizontalLine;\u6500\u0100ct\u06C3\u06C5\xF2\u06A9rok;\u4126mp\u0144\u06D0\u06D8ownHum\xF0\u012Fqual;\u624F\u0700EJOacdfgmnostu\u06FA\u06FE\u0703\u0707\u070E\u071A\u071E\u0721\u0728\u0744\u0778\u078B\u078F\u0795cy;\u4415lig;\u4132cy;\u4401cute\u803B\xCD\u40CD\u0100iy\u0713\u0718rc\u803B\xCE\u40CE;\u4418ot;\u4130r;\u6111rave\u803B\xCC\u40CC\u0180;ap\u0720\u072F\u073F\u0100cg\u0734\u0737r;\u412AinaryI;\u6148lie\xF3\u03DD\u01F4\u0749\0\u0762\u0100;e\u074D\u074E\u622C\u0100gr\u0753\u0758ral;\u622Bsection;\u62C2isible\u0100CT\u076C\u0772omma;\u6063imes;\u6062\u0180gpt\u077F\u0783\u0788on;\u412Ef;\uC000\u{1D540}a;\u4399cr;\u6110ilde;\u4128\u01EB\u079A\0\u079Ecy;\u4406l\u803B\xCF\u40CF\u0280cfosu\u07AC\u07B7\u07BC\u07C2\u07D0\u0100iy\u07B1\u07B5rc;\u4134;\u4419r;\uC000\u{1D50D}pf;\uC000\u{1D541}\u01E3\u07C7\0\u07CCr;\uC000\u{1D4A5}rcy;\u4408kcy;\u4404\u0380HJacfos\u07E4\u07E8\u07EC\u07F1\u07FD\u0802\u0808cy;\u4425cy;\u440Cppa;\u439A\u0100ey\u07F6\u07FBdil;\u4136;\u441Ar;\uC000\u{1D50E}pf;\uC000\u{1D542}cr;\uC000\u{1D4A6}\u0580JTaceflmost\u0825\u0829\u082C\u0850\u0863\u09B3\u09B8\u09C7\u09CD\u0A37\u0A47cy;\u4409\u803B<\u403C\u0280cmnpr\u0837\u083C\u0841\u0844\u084Dute;\u4139bda;\u439Bg;\u67EAlacetrf;\u6112r;\u619E\u0180aey\u0857\u085C\u0861ron;\u413Ddil;\u413B;\u441B\u0100fs\u0868\u0970t\u0500ACDFRTUVar\u087E\u08A9\u08B1\u08E0\u08E6\u08FC\u092F\u095B\u0390\u096A\u0100nr\u0883\u088FgleBracket;\u67E8row\u0180;BR\u0899\u089A\u089E\u6190ar;\u61E4ightArrow;\u61C6eiling;\u6308o\u01F5\u08B7\0\u08C3bleBracket;\u67E6n\u01D4\u08C8\0\u08D2eeVector;\u6961ector\u0100;B\u08DB\u08DC\u61C3ar;\u6959loor;\u630Aight\u0100AV\u08EF\u08F5rrow;\u6194ector;\u694E\u0100er\u0901\u0917e\u0180;AV\u0909\u090A\u0910\u62A3rrow;\u61A4ector;\u695Aiangle\u0180;BE\u0924\u0925\u0929\u62B2ar;\u69CFqual;\u62B4p\u0180DTV\u0937\u0942\u094CownVector;\u6951eeVector;\u6960ector\u0100;B\u0956\u0957\u61BFar;\u6958ector\u0100;B\u0965\u0966\u61BCar;\u6952ight\xE1\u039Cs\u0300EFGLST\u097E\u098B\u0995\u099D\u09A2\u09ADqualGreater;\u62DAullEqual;\u6266reater;\u6276ess;\u6AA1lantEqual;\u6A7Dilde;\u6272r;\uC000\u{1D50F}\u0100;e\u09BD\u09BE\u62D8ftarrow;\u61DAidot;\u413F\u0180npw\u09D4\u0A16\u0A1Bg\u0200LRlr\u09DE\u09F7\u0A02\u0A10eft\u0100AR\u09E6\u09ECrrow;\u67F5ightArrow;\u67F7ightArrow;\u67F6eft\u0100ar\u03B3\u0A0Aight\xE1\u03BFight\xE1\u03CAf;\uC000\u{1D543}er\u0100LR\u0A22\u0A2CeftArrow;\u6199ightArrow;\u6198\u0180cht\u0A3E\u0A40\u0A42\xF2\u084C;\u61B0rok;\u4141;\u626A\u0400acefiosu\u0A5A\u0A5D\u0A60\u0A77\u0A7C\u0A85\u0A8B\u0A8Ep;\u6905y;\u441C\u0100dl\u0A65\u0A6FiumSpace;\u605Flintrf;\u6133r;\uC000\u{1D510}nusPlus;\u6213pf;\uC000\u{1D544}c\xF2\u0A76;\u439C\u0480Jacefostu\u0AA3\u0AA7\u0AAD\u0AC0\u0B14\u0B19\u0D91\u0D97\u0D9Ecy;\u440Acute;\u4143\u0180aey\u0AB4\u0AB9\u0ABEron;\u4147dil;\u4145;\u441D\u0180gsw\u0AC7\u0AF0\u0B0Eative\u0180MTV\u0AD3\u0ADF\u0AE8ediumSpace;\u600Bhi\u0100cn\u0AE6\u0AD8\xEB\u0AD9eryThi\xEE\u0AD9ted\u0100GL\u0AF8\u0B06reaterGreate\xF2\u0673essLes\xF3\u0A48Line;\u400Ar;\uC000\u{1D511}\u0200Bnpt\u0B22\u0B28\u0B37\u0B3Areak;\u6060BreakingSpace;\u40A0f;\u6115\u0680;CDEGHLNPRSTV\u0B55\u0B56\u0B6A\u0B7C\u0BA1\u0BEB\u0C04\u0C5E\u0C84\u0CA6\u0CD8\u0D61\u0D85\u6AEC\u0100ou\u0B5B\u0B64ngruent;\u6262pCap;\u626DoubleVerticalBar;\u6226\u0180lqx\u0B83\u0B8A\u0B9Bement;\u6209ual\u0100;T\u0B92\u0B93\u6260ilde;\uC000\u2242\u0338ists;\u6204reater\u0380;EFGLST\u0BB6\u0BB7\u0BBD\u0BC9\u0BD3\u0BD8\u0BE5\u626Fqual;\u6271ullEqual;\uC000\u2267\u0338reater;\uC000\u226B\u0338ess;\u6279lantEqual;\uC000\u2A7E\u0338ilde;\u6275ump\u0144\u0BF2\u0BFDownHump;\uC000\u224E\u0338qual;\uC000\u224F\u0338e\u0100fs\u0C0A\u0C27tTriangle\u0180;BE\u0C1A\u0C1B\u0C21\u62EAar;\uC000\u29CF\u0338qual;\u62ECs\u0300;EGLST\u0C35\u0C36\u0C3C\u0C44\u0C4B\u0C58\u626Equal;\u6270reater;\u6278ess;\uC000\u226A\u0338lantEqual;\uC000\u2A7D\u0338ilde;\u6274ested\u0100GL\u0C68\u0C79reaterGreater;\uC000\u2AA2\u0338essLess;\uC000\u2AA1\u0338recedes\u0180;ES\u0C92\u0C93\u0C9B\u6280qual;\uC000\u2AAF\u0338lantEqual;\u62E0\u0100ei\u0CAB\u0CB9verseElement;\u620CghtTriangle\u0180;BE\u0CCB\u0CCC\u0CD2\u62EBar;\uC000\u29D0\u0338qual;\u62ED\u0100qu\u0CDD\u0D0CuareSu\u0100bp\u0CE8\u0CF9set\u0100;E\u0CF0\u0CF3\uC000\u228F\u0338qual;\u62E2erset\u0100;E\u0D03\u0D06\uC000\u2290\u0338qual;\u62E3\u0180bcp\u0D13\u0D24\u0D4Eset\u0100;E\u0D1B\u0D1E\uC000\u2282\u20D2qual;\u6288ceeds\u0200;EST\u0D32\u0D33\u0D3B\u0D46\u6281qual;\uC000\u2AB0\u0338lantEqual;\u62E1ilde;\uC000\u227F\u0338erset\u0100;E\u0D58\u0D5B\uC000\u2283\u20D2qual;\u6289ilde\u0200;EFT\u0D6E\u0D6F\u0D75\u0D7F\u6241qual;\u6244ullEqual;\u6247ilde;\u6249erticalBar;\u6224cr;\uC000\u{1D4A9}ilde\u803B\xD1\u40D1;\u439D\u0700Eacdfgmoprstuv\u0DBD\u0DC2\u0DC9\u0DD5\u0DDB\u0DE0\u0DE7\u0DFC\u0E02\u0E20\u0E22\u0E32\u0E3F\u0E44lig;\u4152cute\u803B\xD3\u40D3\u0100iy\u0DCE\u0DD3rc\u803B\xD4\u40D4;\u441Eblac;\u4150r;\uC000\u{1D512}rave\u803B\xD2\u40D2\u0180aei\u0DEE\u0DF2\u0DF6cr;\u414Cga;\u43A9cron;\u439Fpf;\uC000\u{1D546}enCurly\u0100DQ\u0E0E\u0E1AoubleQuote;\u601Cuote;\u6018;\u6A54\u0100cl\u0E27\u0E2Cr;\uC000\u{1D4AA}ash\u803B\xD8\u40D8i\u016C\u0E37\u0E3Cde\u803B\xD5\u40D5es;\u6A37ml\u803B\xD6\u40D6er\u0100BP\u0E4B\u0E60\u0100ar\u0E50\u0E53r;\u603Eac\u0100ek\u0E5A\u0E5C;\u63DEet;\u63B4arenthesis;\u63DC\u0480acfhilors\u0E7F\u0E87\u0E8A\u0E8F\u0E92\u0E94\u0E9D\u0EB0\u0EFCrtialD;\u6202y;\u441Fr;\uC000\u{1D513}i;\u43A6;\u43A0usMinus;\u40B1\u0100ip\u0EA2\u0EADncareplan\xE5\u069Df;\u6119\u0200;eio\u0EB9\u0EBA\u0EE0\u0EE4\u6ABBcedes\u0200;EST\u0EC8\u0EC9\u0ECF\u0EDA\u627Aqual;\u6AAFlantEqual;\u627Cilde;\u627Eme;\u6033\u0100dp\u0EE9\u0EEEuct;\u620Fortion\u0100;a\u0225\u0EF9l;\u621D\u0100ci\u0F01\u0F06r;\uC000\u{1D4AB};\u43A8\u0200Ufos\u0F11\u0F16\u0F1B\u0F1FOT\u803B"\u4022r;\uC000\u{1D514}pf;\u611Acr;\uC000\u{1D4AC}\u0600BEacefhiorsu\u0F3E\u0F43\u0F47\u0F60\u0F73\u0FA7\u0FAA\u0FAD\u1096\u10A9\u10B4\u10BEarr;\u6910G\u803B\xAE\u40AE\u0180cnr\u0F4E\u0F53\u0F56ute;\u4154g;\u67EBr\u0100;t\u0F5C\u0F5D\u61A0l;\u6916\u0180aey\u0F67\u0F6C\u0F71ron;\u4158dil;\u4156;\u4420\u0100;v\u0F78\u0F79\u611Cerse\u0100EU\u0F82\u0F99\u0100lq\u0F87\u0F8Eement;\u620Builibrium;\u61CBpEquilibrium;\u696Fr\xBB\u0F79o;\u43A1ght\u0400ACDFTUVa\u0FC1\u0FEB\u0FF3\u1022\u1028\u105B\u1087\u03D8\u0100nr\u0FC6\u0FD2gleBracket;\u67E9row\u0180;BL\u0FDC\u0FDD\u0FE1\u6192ar;\u61E5eftArrow;\u61C4eiling;\u6309o\u01F5\u0FF9\0\u1005bleBracket;\u67E7n\u01D4\u100A\0\u1014eeVector;\u695Dector\u0100;B\u101D\u101E\u61C2ar;\u6955loor;\u630B\u0100er\u102D\u1043e\u0180;AV\u1035\u1036\u103C\u62A2rrow;\u61A6ector;\u695Biangle\u0180;BE\u1050\u1051\u1055\u62B3ar;\u69D0qual;\u62B5p\u0180DTV\u1063\u106E\u1078ownVector;\u694FeeVector;\u695Cector\u0100;B\u1082\u1083\u61BEar;\u6954ector\u0100;B\u1091\u1092\u61C0ar;\u6953\u0100pu\u109B\u109Ef;\u611DndImplies;\u6970ightarrow;\u61DB\u0100ch\u10B9\u10BCr;\u611B;\u61B1leDelayed;\u69F4\u0680HOacfhimoqstu\u10E4\u10F1\u10F7\u10FD\u1119\u111E\u1151\u1156\u1161\u1167\u11B5\u11BB\u11BF\u0100Cc\u10E9\u10EEHcy;\u4429y;\u4428FTcy;\u442Ccute;\u415A\u0280;aeiy\u1108\u1109\u110E\u1113\u1117\u6ABCron;\u4160dil;\u415Erc;\u415C;\u4421r;\uC000\u{1D516}ort\u0200DLRU\u112A\u1134\u113E\u1149ownArrow\xBB\u041EeftArrow\xBB\u089AightArrow\xBB\u0FDDpArrow;\u6191gma;\u43A3allCircle;\u6218pf;\uC000\u{1D54A}\u0272\u116D\0\0\u1170t;\u621Aare\u0200;ISU\u117B\u117C\u1189\u11AF\u65A1ntersection;\u6293u\u0100bp\u118F\u119Eset\u0100;E\u1197\u1198\u628Fqual;\u6291erset\u0100;E\u11A8\u11A9\u6290qual;\u6292nion;\u6294cr;\uC000\u{1D4AE}ar;\u62C6\u0200bcmp\u11C8\u11DB\u1209\u120B\u0100;s\u11CD\u11CE\u62D0et\u0100;E\u11CD\u11D5qual;\u6286\u0100ch\u11E0\u1205eeds\u0200;EST\u11ED\u11EE\u11F4\u11FF\u627Bqual;\u6AB0lantEqual;\u627Dilde;\u627FTh\xE1\u0F8C;\u6211\u0180;es\u1212\u1213\u1223\u62D1rset\u0100;E\u121C\u121D\u6283qual;\u6287et\xBB\u1213\u0580HRSacfhiors\u123E\u1244\u1249\u1255\u125E\u1271\u1276\u129F\u12C2\u12C8\u12D1ORN\u803B\xDE\u40DEADE;\u6122\u0100Hc\u124E\u1252cy;\u440By;\u4426\u0100bu\u125A\u125C;\u4009;\u43A4\u0180aey\u1265\u126A\u126Fron;\u4164dil;\u4162;\u4422r;\uC000\u{1D517}\u0100ei\u127B\u1289\u01F2\u1280\0\u1287efore;\u6234a;\u4398\u0100cn\u128E\u1298kSpace;\uC000\u205F\u200ASpace;\u6009lde\u0200;EFT\u12AB\u12AC\u12B2\u12BC\u623Cqual;\u6243ullEqual;\u6245ilde;\u6248pf;\uC000\u{1D54B}ipleDot;\u60DB\u0100ct\u12D6\u12DBr;\uC000\u{1D4AF}rok;\u4166\u0AE1\u12F7\u130E\u131A\u1326\0\u132C\u1331\0\0\0\0\0\u1338\u133D\u1377\u1385\0\u13FF\u1404\u140A\u1410\u0100cr\u12FB\u1301ute\u803B\xDA\u40DAr\u0100;o\u1307\u1308\u619Fcir;\u6949r\u01E3\u1313\0\u1316y;\u440Eve;\u416C\u0100iy\u131E\u1323rc\u803B\xDB\u40DB;\u4423blac;\u4170r;\uC000\u{1D518}rave\u803B\xD9\u40D9acr;\u416A\u0100di\u1341\u1369er\u0100BP\u1348\u135D\u0100ar\u134D\u1350r;\u405Fac\u0100ek\u1357\u1359;\u63DFet;\u63B5arenthesis;\u63DDon\u0100;P\u1370\u1371\u62C3lus;\u628E\u0100gp\u137B\u137Fon;\u4172f;\uC000\u{1D54C}\u0400ADETadps\u1395\u13AE\u13B8\u13C4\u03E8\u13D2\u13D7\u13F3rrow\u0180;BD\u1150\u13A0\u13A4ar;\u6912ownArrow;\u61C5ownArrow;\u6195quilibrium;\u696Eee\u0100;A\u13CB\u13CC\u62A5rrow;\u61A5own\xE1\u03F3er\u0100LR\u13DE\u13E8eftArrow;\u6196ightArrow;\u6197i\u0100;l\u13F9\u13FA\u43D2on;\u43A5ing;\u416Ecr;\uC000\u{1D4B0}ilde;\u4168ml\u803B\xDC\u40DC\u0480Dbcdefosv\u1427\u142C\u1430\u1433\u143E\u1485\u148A\u1490\u1496ash;\u62ABar;\u6AEBy;\u4412ash\u0100;l\u143B\u143C\u62A9;\u6AE6\u0100er\u1443\u1445;\u62C1\u0180bty\u144C\u1450\u147Aar;\u6016\u0100;i\u144F\u1455cal\u0200BLST\u1461\u1465\u146A\u1474ar;\u6223ine;\u407Ceparator;\u6758ilde;\u6240ThinSpace;\u600Ar;\uC000\u{1D519}pf;\uC000\u{1D54D}cr;\uC000\u{1D4B1}dash;\u62AA\u0280cefos\u14A7\u14AC\u14B1\u14B6\u14BCirc;\u4174dge;\u62C0r;\uC000\u{1D51A}pf;\uC000\u{1D54E}cr;\uC000\u{1D4B2}\u0200fios\u14CB\u14D0\u14D2\u14D8r;\uC000\u{1D51B};\u439Epf;\uC000\u{1D54F}cr;\uC000\u{1D4B3}\u0480AIUacfosu\u14F1\u14F5\u14F9\u14FD\u1504\u150F\u1514\u151A\u1520cy;\u442Fcy;\u4407cy;\u442Ecute\u803B\xDD\u40DD\u0100iy\u1509\u150Drc;\u4176;\u442Br;\uC000\u{1D51C}pf;\uC000\u{1D550}cr;\uC000\u{1D4B4}ml;\u4178\u0400Hacdefos\u1535\u1539\u153F\u154B\u154F\u155D\u1560\u1564cy;\u4416cute;\u4179\u0100ay\u1544\u1549ron;\u417D;\u4417ot;\u417B\u01F2\u1554\0\u155BoWidt\xE8\u0AD9a;\u4396r;\u6128pf;\u6124cr;\uC000\u{1D4B5}\u0BE1\u1583\u158A\u1590\0\u15B0\u15B6\u15BF\0\0\0\0\u15C6\u15DB\u15EB\u165F\u166D\0\u1695\u169B\u16B2\u16B9\0\u16BEcute\u803B\xE1\u40E1reve;\u4103\u0300;Ediuy\u159C\u159D\u15A1\u15A3\u15A8\u15AD\u623E;\uC000\u223E\u0333;\u623Frc\u803B\xE2\u40E2te\u80BB\xB4\u0306;\u4430lig\u803B\xE6\u40E6\u0100;r\xB2\u15BA;\uC000\u{1D51E}rave\u803B\xE0\u40E0\u0100ep\u15CA\u15D6\u0100fp\u15CF\u15D4sym;\u6135\xE8\u15D3ha;\u43B1\u0100ap\u15DFc\u0100cl\u15E4\u15E7r;\u4101g;\u6A3F\u0264\u15F0\0\0\u160A\u0280;adsv\u15FA\u15FB\u15FF\u1601\u1607\u6227nd;\u6A55;\u6A5Clope;\u6A58;\u6A5A\u0380;elmrsz\u1618\u1619\u161B\u161E\u163F\u164F\u1659\u6220;\u69A4e\xBB\u1619sd\u0100;a\u1625\u1626\u6221\u0461\u1630\u1632\u1634\u1636\u1638\u163A\u163C\u163E;\u69A8;\u69A9;\u69AA;\u69AB;\u69AC;\u69AD;\u69AE;\u69AFt\u0100;v\u1645\u1646\u621Fb\u0100;d\u164C\u164D\u62BE;\u699D\u0100pt\u1654\u1657h;\u6222\xBB\xB9arr;\u637C\u0100gp\u1663\u1667on;\u4105f;\uC000\u{1D552}\u0380;Eaeiop\u12C1\u167B\u167D\u1682\u1684\u1687\u168A;\u6A70cir;\u6A6F;\u624Ad;\u624Bs;\u4027rox\u0100;e\u12C1\u1692\xF1\u1683ing\u803B\xE5\u40E5\u0180cty\u16A1\u16A6\u16A8r;\uC000\u{1D4B6};\u402Amp\u0100;e\u12C1\u16AF\xF1\u0288ilde\u803B\xE3\u40E3ml\u803B\xE4\u40E4\u0100ci\u16C2\u16C8onin\xF4\u0272nt;\u6A11\u0800Nabcdefiklnoprsu\u16ED\u16F1\u1730\u173C\u1743\u1748\u1778\u177D\u17E0\u17E6\u1839\u1850\u170D\u193D\u1948\u1970ot;\u6AED\u0100cr\u16F6\u171Ek\u0200ceps\u1700\u1705\u170D\u1713ong;\u624Cpsilon;\u43F6rime;\u6035im\u0100;e\u171A\u171B\u623Dq;\u62CD\u0176\u1722\u1726ee;\u62BDed\u0100;g\u172C\u172D\u6305e\xBB\u172Drk\u0100;t\u135C\u1737brk;\u63B6\u0100oy\u1701\u1741;\u4431quo;\u601E\u0280cmprt\u1753\u175B\u1761\u1764\u1768aus\u0100;e\u010A\u0109ptyv;\u69B0s\xE9\u170Cno\xF5\u0113\u0180ahw\u176F\u1771\u1773;\u43B2;\u6136een;\u626Cr;\uC000\u{1D51F}g\u0380costuvw\u178D\u179D\u17B3\u17C1\u17D5\u17DB\u17DE\u0180aiu\u1794\u1796\u179A\xF0\u0760rc;\u65EFp\xBB\u1371\u0180dpt\u17A4\u17A8\u17ADot;\u6A00lus;\u6A01imes;\u6A02\u0271\u17B9\0\0\u17BEcup;\u6A06ar;\u6605riangle\u0100du\u17CD\u17D2own;\u65BDp;\u65B3plus;\u6A04e\xE5\u1444\xE5\u14ADarow;\u690D\u0180ako\u17ED\u1826\u1835\u0100cn\u17F2\u1823k\u0180lst\u17FA\u05AB\u1802ozenge;\u69EBriangle\u0200;dlr\u1812\u1813\u1818\u181D\u65B4own;\u65BEeft;\u65C2ight;\u65B8k;\u6423\u01B1\u182B\0\u1833\u01B2\u182F\0\u1831;\u6592;\u65914;\u6593ck;\u6588\u0100eo\u183E\u184D\u0100;q\u1843\u1846\uC000=\u20E5uiv;\uC000\u2261\u20E5t;\u6310\u0200ptwx\u1859\u185E\u1867\u186Cf;\uC000\u{1D553}\u0100;t\u13CB\u1863om\xBB\u13CCtie;\u62C8\u0600DHUVbdhmptuv\u1885\u1896\u18AA\u18BB\u18D7\u18DB\u18EC\u18FF\u1905\u190A\u1910\u1921\u0200LRlr\u188E\u1890\u1892\u1894;\u6557;\u6554;\u6556;\u6553\u0280;DUdu\u18A1\u18A2\u18A4\u18A6\u18A8\u6550;\u6566;\u6569;\u6564;\u6567\u0200LRlr\u18B3\u18B5\u18B7\u18B9;\u655D;\u655A;\u655C;\u6559\u0380;HLRhlr\u18CA\u18CB\u18CD\u18CF\u18D1\u18D3\u18D5\u6551;\u656C;\u6563;\u6560;\u656B;\u6562;\u655Fox;\u69C9\u0200LRlr\u18E4\u18E6\u18E8\u18EA;\u6555;\u6552;\u6510;\u650C\u0280;DUdu\u06BD\u18F7\u18F9\u18FB\u18FD;\u6565;\u6568;\u652C;\u6534inus;\u629Flus;\u629Eimes;\u62A0\u0200LRlr\u1919\u191B\u191D\u191F;\u655B;\u6558;\u6518;\u6514\u0380;HLRhlr\u1930\u1931\u1933\u1935\u1937\u1939\u193B\u6502;\u656A;\u6561;\u655E;\u653C;\u6524;\u651C\u0100ev\u0123\u1942bar\u803B\xA6\u40A6\u0200ceio\u1951\u1956\u195A\u1960r;\uC000\u{1D4B7}mi;\u604Fm\u0100;e\u171A\u171Cl\u0180;bh\u1968\u1969\u196B\u405C;\u69C5sub;\u67C8\u016C\u1974\u197El\u0100;e\u1979\u197A\u6022t\xBB\u197Ap\u0180;Ee\u012F\u1985\u1987;\u6AAE\u0100;q\u06DC\u06DB\u0CE1\u19A7\0\u19E8\u1A11\u1A15\u1A32\0\u1A37\u1A50\0\0\u1AB4\0\0\u1AC1\0\0\u1B21\u1B2E\u1B4D\u1B52\0\u1BFD\0\u1C0C\u0180cpr\u19AD\u19B2\u19DDute;\u4107\u0300;abcds\u19BF\u19C0\u19C4\u19CA\u19D5\u19D9\u6229nd;\u6A44rcup;\u6A49\u0100au\u19CF\u19D2p;\u6A4Bp;\u6A47ot;\u6A40;\uC000\u2229\uFE00\u0100eo\u19E2\u19E5t;\u6041\xEE\u0693\u0200aeiu\u19F0\u19FB\u1A01\u1A05\u01F0\u19F5\0\u19F8s;\u6A4Don;\u410Ddil\u803B\xE7\u40E7rc;\u4109ps\u0100;s\u1A0C\u1A0D\u6A4Cm;\u6A50ot;\u410B\u0180dmn\u1A1B\u1A20\u1A26il\u80BB\xB8\u01ADptyv;\u69B2t\u8100\xA2;e\u1A2D\u1A2E\u40A2r\xE4\u01B2r;\uC000\u{1D520}\u0180cei\u1A3D\u1A40\u1A4Dy;\u4447ck\u0100;m\u1A47\u1A48\u6713ark\xBB\u1A48;\u43C7r\u0380;Ecefms\u1A5F\u1A60\u1A62\u1A6B\u1AA4\u1AAA\u1AAE\u65CB;\u69C3\u0180;el\u1A69\u1A6A\u1A6D\u42C6q;\u6257e\u0261\u1A74\0\0\u1A88rrow\u0100lr\u1A7C\u1A81eft;\u61BAight;\u61BB\u0280RSacd\u1A92\u1A94\u1A96\u1A9A\u1A9F\xBB\u0F47;\u64C8st;\u629Birc;\u629Aash;\u629Dnint;\u6A10id;\u6AEFcir;\u69C2ubs\u0100;u\u1ABB\u1ABC\u6663it\xBB\u1ABC\u02EC\u1AC7\u1AD4\u1AFA\0\u1B0Aon\u0100;e\u1ACD\u1ACE\u403A\u0100;q\xC7\xC6\u026D\u1AD9\0\0\u1AE2a\u0100;t\u1ADE\u1ADF\u402C;\u4040\u0180;fl\u1AE8\u1AE9\u1AEB\u6201\xEE\u1160e\u0100mx\u1AF1\u1AF6ent\xBB\u1AE9e\xF3\u024D\u01E7\u1AFE\0\u1B07\u0100;d\u12BB\u1B02ot;\u6A6Dn\xF4\u0246\u0180fry\u1B10\u1B14\u1B17;\uC000\u{1D554}o\xE4\u0254\u8100\xA9;s\u0155\u1B1Dr;\u6117\u0100ao\u1B25\u1B29rr;\u61B5ss;\u6717\u0100cu\u1B32\u1B37r;\uC000\u{1D4B8}\u0100bp\u1B3C\u1B44\u0100;e\u1B41\u1B42\u6ACF;\u6AD1\u0100;e\u1B49\u1B4A\u6AD0;\u6AD2dot;\u62EF\u0380delprvw\u1B60\u1B6C\u1B77\u1B82\u1BAC\u1BD4\u1BF9arr\u0100lr\u1B68\u1B6A;\u6938;\u6935\u0270\u1B72\0\0\u1B75r;\u62DEc;\u62DFarr\u0100;p\u1B7F\u1B80\u61B6;\u693D\u0300;bcdos\u1B8F\u1B90\u1B96\u1BA1\u1BA5\u1BA8\u622Arcap;\u6A48\u0100au\u1B9B\u1B9Ep;\u6A46p;\u6A4Aot;\u628Dr;\u6A45;\uC000\u222A\uFE00\u0200alrv\u1BB5\u1BBF\u1BDE\u1BE3rr\u0100;m\u1BBC\u1BBD\u61B7;\u693Cy\u0180evw\u1BC7\u1BD4\u1BD8q\u0270\u1BCE\0\0\u1BD2re\xE3\u1B73u\xE3\u1B75ee;\u62CEedge;\u62CFen\u803B\xA4\u40A4earrow\u0100lr\u1BEE\u1BF3eft\xBB\u1B80ight\xBB\u1BBDe\xE4\u1BDD\u0100ci\u1C01\u1C07onin\xF4\u01F7nt;\u6231lcty;\u632D\u0980AHabcdefhijlorstuwz\u1C38\u1C3B\u1C3F\u1C5D\u1C69\u1C75\u1C8A\u1C9E\u1CAC\u1CB7\u1CFB\u1CFF\u1D0D\u1D7B\u1D91\u1DAB\u1DBB\u1DC6\u1DCDr\xF2\u0381ar;\u6965\u0200glrs\u1C48\u1C4D\u1C52\u1C54ger;\u6020eth;\u6138\xF2\u1133h\u0100;v\u1C5A\u1C5B\u6010\xBB\u090A\u016B\u1C61\u1C67arow;\u690Fa\xE3\u0315\u0100ay\u1C6E\u1C73ron;\u410F;\u4434\u0180;ao\u0332\u1C7C\u1C84\u0100gr\u02BF\u1C81r;\u61CAtseq;\u6A77\u0180glm\u1C91\u1C94\u1C98\u803B\xB0\u40B0ta;\u43B4ptyv;\u69B1\u0100ir\u1CA3\u1CA8sht;\u697F;\uC000\u{1D521}ar\u0100lr\u1CB3\u1CB5\xBB\u08DC\xBB\u101E\u0280aegsv\u1CC2\u0378\u1CD6\u1CDC\u1CE0m\u0180;os\u0326\u1CCA\u1CD4nd\u0100;s\u0326\u1CD1uit;\u6666amma;\u43DDin;\u62F2\u0180;io\u1CE7\u1CE8\u1CF8\u40F7de\u8100\xF7;o\u1CE7\u1CF0ntimes;\u62C7n\xF8\u1CF7cy;\u4452c\u026F\u1D06\0\0\u1D0Arn;\u631Eop;\u630D\u0280lptuw\u1D18\u1D1D\u1D22\u1D49\u1D55lar;\u4024f;\uC000\u{1D555}\u0280;emps\u030B\u1D2D\u1D37\u1D3D\u1D42q\u0100;d\u0352\u1D33ot;\u6251inus;\u6238lus;\u6214quare;\u62A1blebarwedg\xE5\xFAn\u0180adh\u112E\u1D5D\u1D67ownarrow\xF3\u1C83arpoon\u0100lr\u1D72\u1D76ef\xF4\u1CB4igh\xF4\u1CB6\u0162\u1D7F\u1D85karo\xF7\u0F42\u026F\u1D8A\0\0\u1D8Ern;\u631Fop;\u630C\u0180cot\u1D98\u1DA3\u1DA6\u0100ry\u1D9D\u1DA1;\uC000\u{1D4B9};\u4455l;\u69F6rok;\u4111\u0100dr\u1DB0\u1DB4ot;\u62F1i\u0100;f\u1DBA\u1816\u65BF\u0100ah\u1DC0\u1DC3r\xF2\u0429a\xF2\u0FA6angle;\u69A6\u0100ci\u1DD2\u1DD5y;\u445Fgrarr;\u67FF\u0900Dacdefglmnopqrstux\u1E01\u1E09\u1E19\u1E38\u0578\u1E3C\u1E49\u1E61\u1E7E\u1EA5\u1EAF\u1EBD\u1EE1\u1F2A\u1F37\u1F44\u1F4E\u1F5A\u0100Do\u1E06\u1D34o\xF4\u1C89\u0100cs\u1E0E\u1E14ute\u803B\xE9\u40E9ter;\u6A6E\u0200aioy\u1E22\u1E27\u1E31\u1E36ron;\u411Br\u0100;c\u1E2D\u1E2E\u6256\u803B\xEA\u40EAlon;\u6255;\u444Dot;\u4117\u0100Dr\u1E41\u1E45ot;\u6252;\uC000\u{1D522}\u0180;rs\u1E50\u1E51\u1E57\u6A9Aave\u803B\xE8\u40E8\u0100;d\u1E5C\u1E5D\u6A96ot;\u6A98\u0200;ils\u1E6A\u1E6B\u1E72\u1E74\u6A99nters;\u63E7;\u6113\u0100;d\u1E79\u1E7A\u6A95ot;\u6A97\u0180aps\u1E85\u1E89\u1E97cr;\u4113ty\u0180;sv\u1E92\u1E93\u1E95\u6205et\xBB\u1E93p\u01001;\u1E9D\u1EA4\u0133\u1EA1\u1EA3;\u6004;\u6005\u6003\u0100gs\u1EAA\u1EAC;\u414Bp;\u6002\u0100gp\u1EB4\u1EB8on;\u4119f;\uC000\u{1D556}\u0180als\u1EC4\u1ECE\u1ED2r\u0100;s\u1ECA\u1ECB\u62D5l;\u69E3us;\u6A71i\u0180;lv\u1EDA\u1EDB\u1EDF\u43B5on\xBB\u1EDB;\u43F5\u0200csuv\u1EEA\u1EF3\u1F0B\u1F23\u0100io\u1EEF\u1E31rc\xBB\u1E2E\u0269\u1EF9\0\0\u1EFB\xED\u0548ant\u0100gl\u1F02\u1F06tr\xBB\u1E5Dess\xBB\u1E7A\u0180aei\u1F12\u1F16\u1F1Als;\u403Dst;\u625Fv\u0100;D\u0235\u1F20D;\u6A78parsl;\u69E5\u0100Da\u1F2F\u1F33ot;\u6253rr;\u6971\u0180cdi\u1F3E\u1F41\u1EF8r;\u612Fo\xF4\u0352\u0100ah\u1F49\u1F4B;\u43B7\u803B\xF0\u40F0\u0100mr\u1F53\u1F57l\u803B\xEB\u40EBo;\u60AC\u0180cip\u1F61\u1F64\u1F67l;\u4021s\xF4\u056E\u0100eo\u1F6C\u1F74ctatio\xEE\u0559nential\xE5\u0579\u09E1\u1F92\0\u1F9E\0\u1FA1\u1FA7\0\0\u1FC6\u1FCC\0\u1FD3\0\u1FE6\u1FEA\u2000\0\u2008\u205Allingdotse\xF1\u1E44y;\u4444male;\u6640\u0180ilr\u1FAD\u1FB3\u1FC1lig;\u8000\uFB03\u0269\u1FB9\0\0\u1FBDg;\u8000\uFB00ig;\u8000\uFB04;\uC000\u{1D523}lig;\u8000\uFB01lig;\uC000fj\u0180alt\u1FD9\u1FDC\u1FE1t;\u666Dig;\u8000\uFB02ns;\u65B1of;\u4192\u01F0\u1FEE\0\u1FF3f;\uC000\u{1D557}\u0100ak\u05BF\u1FF7\u0100;v\u1FFC\u1FFD\u62D4;\u6AD9artint;\u6A0D\u0100ao\u200C\u2055\u0100cs\u2011\u2052\u03B1\u201A\u2030\u2038\u2045\u2048\0\u2050\u03B2\u2022\u2025\u2027\u202A\u202C\0\u202E\u803B\xBD\u40BD;\u6153\u803B\xBC\u40BC;\u6155;\u6159;\u615B\u01B3\u2034\0\u2036;\u6154;\u6156\u02B4\u203E\u2041\0\0\u2043\u803B\xBE\u40BE;\u6157;\u615C5;\u6158\u01B6\u204C\0\u204E;\u615A;\u615D8;\u615El;\u6044wn;\u6322cr;\uC000\u{1D4BB}\u0880Eabcdefgijlnorstv\u2082\u2089\u209F\u20A5\u20B0\u20B4\u20F0\u20F5\u20FA\u20FF\u2103\u2112\u2138\u0317\u213E\u2152\u219E\u0100;l\u064D\u2087;\u6A8C\u0180cmp\u2090\u2095\u209Dute;\u41F5ma\u0100;d\u209C\u1CDA\u43B3;\u6A86reve;\u411F\u0100iy\u20AA\u20AErc;\u411D;\u4433ot;\u4121\u0200;lqs\u063E\u0642\u20BD\u20C9\u0180;qs\u063E\u064C\u20C4lan\xF4\u0665\u0200;cdl\u0665\u20D2\u20D5\u20E5c;\u6AA9ot\u0100;o\u20DC\u20DD\u6A80\u0100;l\u20E2\u20E3\u6A82;\u6A84\u0100;e\u20EA\u20ED\uC000\u22DB\uFE00s;\u6A94r;\uC000\u{1D524}\u0100;g\u0673\u061Bmel;\u6137cy;\u4453\u0200;Eaj\u065A\u210C\u210E\u2110;\u6A92;\u6AA5;\u6AA4\u0200Eaes\u211B\u211D\u2129\u2134;\u6269p\u0100;p\u2123\u2124\u6A8Arox\xBB\u2124\u0100;q\u212E\u212F\u6A88\u0100;q\u212E\u211Bim;\u62E7pf;\uC000\u{1D558}\u0100ci\u2143\u2146r;\u610Am\u0180;el\u066B\u214E\u2150;\u6A8E;\u6A90\u8300>;cdlqr\u05EE\u2160\u216A\u216E\u2173\u2179\u0100ci\u2165\u2167;\u6AA7r;\u6A7Aot;\u62D7Par;\u6995uest;\u6A7C\u0280adels\u2184\u216A\u2190\u0656\u219B\u01F0\u2189\0\u218Epro\xF8\u209Er;\u6978q\u0100lq\u063F\u2196les\xF3\u2088i\xED\u066B\u0100en\u21A3\u21ADrtneqq;\uC000\u2269\uFE00\xC5\u21AA\u0500Aabcefkosy\u21C4\u21C7\u21F1\u21F5\u21FA\u2218\u221D\u222F\u2268\u227Dr\xF2\u03A0\u0200ilmr\u21D0\u21D4\u21D7\u21DBrs\xF0\u1484f\xBB\u2024il\xF4\u06A9\u0100dr\u21E0\u21E4cy;\u444A\u0180;cw\u08F4\u21EB\u21EFir;\u6948;\u61ADar;\u610Firc;\u4125\u0180alr\u2201\u220E\u2213rts\u0100;u\u2209\u220A\u6665it\xBB\u220Alip;\u6026con;\u62B9r;\uC000\u{1D525}s\u0100ew\u2223\u2229arow;\u6925arow;\u6926\u0280amopr\u223A\u223E\u2243\u225E\u2263rr;\u61FFtht;\u623Bk\u0100lr\u2249\u2253eftarrow;\u61A9ightarrow;\u61AAf;\uC000\u{1D559}bar;\u6015\u0180clt\u226F\u2274\u2278r;\uC000\u{1D4BD}as\xE8\u21F4rok;\u4127\u0100bp\u2282\u2287ull;\u6043hen\xBB\u1C5B\u0AE1\u22A3\0\u22AA\0\u22B8\u22C5\u22CE\0\u22D5\u22F3\0\0\u22F8\u2322\u2367\u2362\u237F\0\u2386\u23AA\u23B4cute\u803B\xED\u40ED\u0180;iy\u0771\u22B0\u22B5rc\u803B\xEE\u40EE;\u4438\u0100cx\u22BC\u22BFy;\u4435cl\u803B\xA1\u40A1\u0100fr\u039F\u22C9;\uC000\u{1D526}rave\u803B\xEC\u40EC\u0200;ino\u073E\u22DD\u22E9\u22EE\u0100in\u22E2\u22E6nt;\u6A0Ct;\u622Dfin;\u69DCta;\u6129lig;\u4133\u0180aop\u22FE\u231A\u231D\u0180cgt\u2305\u2308\u2317r;\u412B\u0180elp\u071F\u230F\u2313in\xE5\u078Ear\xF4\u0720h;\u4131f;\u62B7ed;\u41B5\u0280;cfot\u04F4\u232C\u2331\u233D\u2341are;\u6105in\u0100;t\u2338\u2339\u621Eie;\u69DDdo\xF4\u2319\u0280;celp\u0757\u234C\u2350\u235B\u2361al;\u62BA\u0100gr\u2355\u2359er\xF3\u1563\xE3\u234Darhk;\u6A17rod;\u6A3C\u0200cgpt\u236F\u2372\u2376\u237By;\u4451on;\u412Ff;\uC000\u{1D55A}a;\u43B9uest\u803B\xBF\u40BF\u0100ci\u238A\u238Fr;\uC000\u{1D4BE}n\u0280;Edsv\u04F4\u239B\u239D\u23A1\u04F3;\u62F9ot;\u62F5\u0100;v\u23A6\u23A7\u62F4;\u62F3\u0100;i\u0777\u23AElde;\u4129\u01EB\u23B8\0\u23BCcy;\u4456l\u803B\xEF\u40EF\u0300cfmosu\u23CC\u23D7\u23DC\u23E1\u23E7\u23F5\u0100iy\u23D1\u23D5rc;\u4135;\u4439r;\uC000\u{1D527}ath;\u4237pf;\uC000\u{1D55B}\u01E3\u23EC\0\u23F1r;\uC000\u{1D4BF}rcy;\u4458kcy;\u4454\u0400acfghjos\u240B\u2416\u2422\u2427\u242D\u2431\u2435\u243Bppa\u0100;v\u2413\u2414\u43BA;\u43F0\u0100ey\u241B\u2420dil;\u4137;\u443Ar;\uC000\u{1D528}reen;\u4138cy;\u4445cy;\u445Cpf;\uC000\u{1D55C}cr;\uC000\u{1D4C0}\u0B80ABEHabcdefghjlmnoprstuv\u2470\u2481\u2486\u248D\u2491\u250E\u253D\u255A\u2580\u264E\u265E\u2665\u2679\u267D\u269A\u26B2\u26D8\u275D\u2768\u278B\u27C0\u2801\u2812\u0180art\u2477\u247A\u247Cr\xF2\u09C6\xF2\u0395ail;\u691Barr;\u690E\u0100;g\u0994\u248B;\u6A8Bar;\u6962\u0963\u24A5\0\u24AA\0\u24B1\0\0\0\0\0\u24B5\u24BA\0\u24C6\u24C8\u24CD\0\u24F9ute;\u413Amptyv;\u69B4ra\xEE\u084Cbda;\u43BBg\u0180;dl\u088E\u24C1\u24C3;\u6991\xE5\u088E;\u6A85uo\u803B\xAB\u40ABr\u0400;bfhlpst\u0899\u24DE\u24E6\u24E9\u24EB\u24EE\u24F1\u24F5\u0100;f\u089D\u24E3s;\u691Fs;\u691D\xEB\u2252p;\u61ABl;\u6939im;\u6973l;\u61A2\u0180;ae\u24FF\u2500\u2504\u6AABil;\u6919\u0100;s\u2509\u250A\u6AAD;\uC000\u2AAD\uFE00\u0180abr\u2515\u2519\u251Drr;\u690Crk;\u6772\u0100ak\u2522\u252Cc\u0100ek\u2528\u252A;\u407B;\u405B\u0100es\u2531\u2533;\u698Bl\u0100du\u2539\u253B;\u698F;\u698D\u0200aeuy\u2546\u254B\u2556\u2558ron;\u413E\u0100di\u2550\u2554il;\u413C\xEC\u08B0\xE2\u2529;\u443B\u0200cqrs\u2563\u2566\u256D\u257Da;\u6936uo\u0100;r\u0E19\u1746\u0100du\u2572\u2577har;\u6967shar;\u694Bh;\u61B2\u0280;fgqs\u258B\u258C\u0989\u25F3\u25FF\u6264t\u0280ahlrt\u2598\u25A4\u25B7\u25C2\u25E8rrow\u0100;t\u0899\u25A1a\xE9\u24F6arpoon\u0100du\u25AF\u25B4own\xBB\u045Ap\xBB\u0966eftarrows;\u61C7ight\u0180ahs\u25CD\u25D6\u25DErrow\u0100;s\u08F4\u08A7arpoon\xF3\u0F98quigarro\xF7\u21F0hreetimes;\u62CB\u0180;qs\u258B\u0993\u25FAlan\xF4\u09AC\u0280;cdgs\u09AC\u260A\u260D\u261D\u2628c;\u6AA8ot\u0100;o\u2614\u2615\u6A7F\u0100;r\u261A\u261B\u6A81;\u6A83\u0100;e\u2622\u2625\uC000\u22DA\uFE00s;\u6A93\u0280adegs\u2633\u2639\u263D\u2649\u264Bppro\xF8\u24C6ot;\u62D6q\u0100gq\u2643\u2645\xF4\u0989gt\xF2\u248C\xF4\u099Bi\xED\u09B2\u0180ilr\u2655\u08E1\u265Asht;\u697C;\uC000\u{1D529}\u0100;E\u099C\u2663;\u6A91\u0161\u2669\u2676r\u0100du\u25B2\u266E\u0100;l\u0965\u2673;\u696Alk;\u6584cy;\u4459\u0280;acht\u0A48\u2688\u268B\u2691\u2696r\xF2\u25C1orne\xF2\u1D08ard;\u696Bri;\u65FA\u0100io\u269F\u26A4dot;\u4140ust\u0100;a\u26AC\u26AD\u63B0che\xBB\u26AD\u0200Eaes\u26BB\u26BD\u26C9\u26D4;\u6268p\u0100;p\u26C3\u26C4\u6A89rox\xBB\u26C4\u0100;q\u26CE\u26CF\u6A87\u0100;q\u26CE\u26BBim;\u62E6\u0400abnoptwz\u26E9\u26F4\u26F7\u271A\u272F\u2741\u2747\u2750\u0100nr\u26EE\u26F1g;\u67ECr;\u61FDr\xEB\u08C1g\u0180lmr\u26FF\u270D\u2714eft\u0100ar\u09E6\u2707ight\xE1\u09F2apsto;\u67FCight\xE1\u09FDparrow\u0100lr\u2725\u2729ef\xF4\u24EDight;\u61AC\u0180afl\u2736\u2739\u273Dr;\u6985;\uC000\u{1D55D}us;\u6A2Dimes;\u6A34\u0161\u274B\u274Fst;\u6217\xE1\u134E\u0180;ef\u2757\u2758\u1800\u65CAnge\xBB\u2758ar\u0100;l\u2764\u2765\u4028t;\u6993\u0280achmt\u2773\u2776\u277C\u2785\u2787r\xF2\u08A8orne\xF2\u1D8Car\u0100;d\u0F98\u2783;\u696D;\u600Eri;\u62BF\u0300achiqt\u2798\u279D\u0A40\u27A2\u27AE\u27BBquo;\u6039r;\uC000\u{1D4C1}m\u0180;eg\u09B2\u27AA\u27AC;\u6A8D;\u6A8F\u0100bu\u252A\u27B3o\u0100;r\u0E1F\u27B9;\u601Arok;\u4142\u8400<;cdhilqr\u082B\u27D2\u2639\u27DC\u27E0\u27E5\u27EA\u27F0\u0100ci\u27D7\u27D9;\u6AA6r;\u6A79re\xE5\u25F2mes;\u62C9arr;\u6976uest;\u6A7B\u0100Pi\u27F5\u27F9ar;\u6996\u0180;ef\u2800\u092D\u181B\u65C3r\u0100du\u2807\u280Dshar;\u694Ahar;\u6966\u0100en\u2817\u2821rtneqq;\uC000\u2268\uFE00\xC5\u281E\u0700Dacdefhilnopsu\u2840\u2845\u2882\u288E\u2893\u28A0\u28A5\u28A8\u28DA\u28E2\u28E4\u0A83\u28F3\u2902Dot;\u623A\u0200clpr\u284E\u2852\u2863\u287Dr\u803B\xAF\u40AF\u0100et\u2857\u2859;\u6642\u0100;e\u285E\u285F\u6720se\xBB\u285F\u0100;s\u103B\u2868to\u0200;dlu\u103B\u2873\u2877\u287Bow\xEE\u048Cef\xF4\u090F\xF0\u13D1ker;\u65AE\u0100oy\u2887\u288Cmma;\u6A29;\u443Cash;\u6014asuredangle\xBB\u1626r;\uC000\u{1D52A}o;\u6127\u0180cdn\u28AF\u28B4\u28C9ro\u803B\xB5\u40B5\u0200;acd\u1464\u28BD\u28C0\u28C4s\xF4\u16A7ir;\u6AF0ot\u80BB\xB7\u01B5us\u0180;bd\u28D2\u1903\u28D3\u6212\u0100;u\u1D3C\u28D8;\u6A2A\u0163\u28DE\u28E1p;\u6ADB\xF2\u2212\xF0\u0A81\u0100dp\u28E9\u28EEels;\u62A7f;\uC000\u{1D55E}\u0100ct\u28F8\u28FDr;\uC000\u{1D4C2}pos\xBB\u159D\u0180;lm\u2909\u290A\u290D\u43BCtimap;\u62B8\u0C00GLRVabcdefghijlmoprstuvw\u2942\u2953\u297E\u2989\u2998\u29DA\u29E9\u2A15\u2A1A\u2A58\u2A5D\u2A83\u2A95\u2AA4\u2AA8\u2B04\u2B07\u2B44\u2B7F\u2BAE\u2C34\u2C67\u2C7C\u2CE9\u0100gt\u2947\u294B;\uC000\u22D9\u0338\u0100;v\u2950\u0BCF\uC000\u226B\u20D2\u0180elt\u295A\u2972\u2976ft\u0100ar\u2961\u2967rrow;\u61CDightarrow;\u61CE;\uC000\u22D8\u0338\u0100;v\u297B\u0C47\uC000\u226A\u20D2ightarrow;\u61CF\u0100Dd\u298E\u2993ash;\u62AFash;\u62AE\u0280bcnpt\u29A3\u29A7\u29AC\u29B1\u29CCla\xBB\u02DEute;\u4144g;\uC000\u2220\u20D2\u0280;Eiop\u0D84\u29BC\u29C0\u29C5\u29C8;\uC000\u2A70\u0338d;\uC000\u224B\u0338s;\u4149ro\xF8\u0D84ur\u0100;a\u29D3\u29D4\u666El\u0100;s\u29D3\u0B38\u01F3\u29DF\0\u29E3p\u80BB\xA0\u0B37mp\u0100;e\u0BF9\u0C00\u0280aeouy\u29F4\u29FE\u2A03\u2A10\u2A13\u01F0\u29F9\0\u29FB;\u6A43on;\u4148dil;\u4146ng\u0100;d\u0D7E\u2A0Aot;\uC000\u2A6D\u0338p;\u6A42;\u443Dash;\u6013\u0380;Aadqsx\u0B92\u2A29\u2A2D\u2A3B\u2A41\u2A45\u2A50rr;\u61D7r\u0100hr\u2A33\u2A36k;\u6924\u0100;o\u13F2\u13F0ot;\uC000\u2250\u0338ui\xF6\u0B63\u0100ei\u2A4A\u2A4Ear;\u6928\xED\u0B98ist\u0100;s\u0BA0\u0B9Fr;\uC000\u{1D52B}\u0200Eest\u0BC5\u2A66\u2A79\u2A7C\u0180;qs\u0BBC\u2A6D\u0BE1\u0180;qs\u0BBC\u0BC5\u2A74lan\xF4\u0BE2i\xED\u0BEA\u0100;r\u0BB6\u2A81\xBB\u0BB7\u0180Aap\u2A8A\u2A8D\u2A91r\xF2\u2971rr;\u61AEar;\u6AF2\u0180;sv\u0F8D\u2A9C\u0F8C\u0100;d\u2AA1\u2AA2\u62FC;\u62FAcy;\u445A\u0380AEadest\u2AB7\u2ABA\u2ABE\u2AC2\u2AC5\u2AF6\u2AF9r\xF2\u2966;\uC000\u2266\u0338rr;\u619Ar;\u6025\u0200;fqs\u0C3B\u2ACE\u2AE3\u2AEFt\u0100ar\u2AD4\u2AD9rro\xF7\u2AC1ightarro\xF7\u2A90\u0180;qs\u0C3B\u2ABA\u2AEAlan\xF4\u0C55\u0100;s\u0C55\u2AF4\xBB\u0C36i\xED\u0C5D\u0100;r\u0C35\u2AFEi\u0100;e\u0C1A\u0C25i\xE4\u0D90\u0100pt\u2B0C\u2B11f;\uC000\u{1D55F}\u8180\xAC;in\u2B19\u2B1A\u2B36\u40ACn\u0200;Edv\u0B89\u2B24\u2B28\u2B2E;\uC000\u22F9\u0338ot;\uC000\u22F5\u0338\u01E1\u0B89\u2B33\u2B35;\u62F7;\u62F6i\u0100;v\u0CB8\u2B3C\u01E1\u0CB8\u2B41\u2B43;\u62FE;\u62FD\u0180aor\u2B4B\u2B63\u2B69r\u0200;ast\u0B7B\u2B55\u2B5A\u2B5Flle\xEC\u0B7Bl;\uC000\u2AFD\u20E5;\uC000\u2202\u0338lint;\u6A14\u0180;ce\u0C92\u2B70\u2B73u\xE5\u0CA5\u0100;c\u0C98\u2B78\u0100;e\u0C92\u2B7D\xF1\u0C98\u0200Aait\u2B88\u2B8B\u2B9D\u2BA7r\xF2\u2988rr\u0180;cw\u2B94\u2B95\u2B99\u619B;\uC000\u2933\u0338;\uC000\u219D\u0338ghtarrow\xBB\u2B95ri\u0100;e\u0CCB\u0CD6\u0380chimpqu\u2BBD\u2BCD\u2BD9\u2B04\u0B78\u2BE4\u2BEF\u0200;cer\u0D32\u2BC6\u0D37\u2BC9u\xE5\u0D45;\uC000\u{1D4C3}ort\u026D\u2B05\0\0\u2BD6ar\xE1\u2B56m\u0100;e\u0D6E\u2BDF\u0100;q\u0D74\u0D73su\u0100bp\u2BEB\u2BED\xE5\u0CF8\xE5\u0D0B\u0180bcp\u2BF6\u2C11\u2C19\u0200;Ees\u2BFF\u2C00\u0D22\u2C04\u6284;\uC000\u2AC5\u0338et\u0100;e\u0D1B\u2C0Bq\u0100;q\u0D23\u2C00c\u0100;e\u0D32\u2C17\xF1\u0D38\u0200;Ees\u2C22\u2C23\u0D5F\u2C27\u6285;\uC000\u2AC6\u0338et\u0100;e\u0D58\u2C2Eq\u0100;q\u0D60\u2C23\u0200gilr\u2C3D\u2C3F\u2C45\u2C47\xEC\u0BD7lde\u803B\xF1\u40F1\xE7\u0C43iangle\u0100lr\u2C52\u2C5Ceft\u0100;e\u0C1A\u2C5A\xF1\u0C26ight\u0100;e\u0CCB\u2C65\xF1\u0CD7\u0100;m\u2C6C\u2C6D\u43BD\u0180;es\u2C74\u2C75\u2C79\u4023ro;\u6116p;\u6007\u0480DHadgilrs\u2C8F\u2C94\u2C99\u2C9E\u2CA3\u2CB0\u2CB6\u2CD3\u2CE3ash;\u62ADarr;\u6904p;\uC000\u224D\u20D2ash;\u62AC\u0100et\u2CA8\u2CAC;\uC000\u2265\u20D2;\uC000>\u20D2nfin;\u69DE\u0180Aet\u2CBD\u2CC1\u2CC5rr;\u6902;\uC000\u2264\u20D2\u0100;r\u2CCA\u2CCD\uC000<\u20D2ie;\uC000\u22B4\u20D2\u0100At\u2CD8\u2CDCrr;\u6903rie;\uC000\u22B5\u20D2im;\uC000\u223C\u20D2\u0180Aan\u2CF0\u2CF4\u2D02rr;\u61D6r\u0100hr\u2CFA\u2CFDk;\u6923\u0100;o\u13E7\u13E5ear;\u6927\u1253\u1A95\0\0\0\0\0\0\0\0\0\0\0\0\0\u2D2D\0\u2D38\u2D48\u2D60\u2D65\u2D72\u2D84\u1B07\0\0\u2D8D\u2DAB\0\u2DC8\u2DCE\0\u2DDC\u2E19\u2E2B\u2E3E\u2E43\u0100cs\u2D31\u1A97ute\u803B\xF3\u40F3\u0100iy\u2D3C\u2D45r\u0100;c\u1A9E\u2D42\u803B\xF4\u40F4;\u443E\u0280abios\u1AA0\u2D52\u2D57\u01C8\u2D5Alac;\u4151v;\u6A38old;\u69BClig;\u4153\u0100cr\u2D69\u2D6Dir;\u69BF;\uC000\u{1D52C}\u036F\u2D79\0\0\u2D7C\0\u2D82n;\u42DBave\u803B\xF2\u40F2;\u69C1\u0100bm\u2D88\u0DF4ar;\u69B5\u0200acit\u2D95\u2D98\u2DA5\u2DA8r\xF2\u1A80\u0100ir\u2D9D\u2DA0r;\u69BEoss;\u69BBn\xE5\u0E52;\u69C0\u0180aei\u2DB1\u2DB5\u2DB9cr;\u414Dga;\u43C9\u0180cdn\u2DC0\u2DC5\u01CDron;\u43BF;\u69B6pf;\uC000\u{1D560}\u0180ael\u2DD4\u2DD7\u01D2r;\u69B7rp;\u69B9\u0380;adiosv\u2DEA\u2DEB\u2DEE\u2E08\u2E0D\u2E10\u2E16\u6228r\xF2\u1A86\u0200;efm\u2DF7\u2DF8\u2E02\u2E05\u6A5Dr\u0100;o\u2DFE\u2DFF\u6134f\xBB\u2DFF\u803B\xAA\u40AA\u803B\xBA\u40BAgof;\u62B6r;\u6A56lope;\u6A57;\u6A5B\u0180clo\u2E1F\u2E21\u2E27\xF2\u2E01ash\u803B\xF8\u40F8l;\u6298i\u016C\u2E2F\u2E34de\u803B\xF5\u40F5es\u0100;a\u01DB\u2E3As;\u6A36ml\u803B\xF6\u40F6bar;\u633D\u0AE1\u2E5E\0\u2E7D\0\u2E80\u2E9D\0\u2EA2\u2EB9\0\0\u2ECB\u0E9C\0\u2F13\0\0\u2F2B\u2FBC\0\u2FC8r\u0200;ast\u0403\u2E67\u2E72\u0E85\u8100\xB6;l\u2E6D\u2E6E\u40B6le\xEC\u0403\u0269\u2E78\0\0\u2E7Bm;\u6AF3;\u6AFDy;\u443Fr\u0280cimpt\u2E8B\u2E8F\u2E93\u1865\u2E97nt;\u4025od;\u402Eil;\u6030enk;\u6031r;\uC000\u{1D52D}\u0180imo\u2EA8\u2EB0\u2EB4\u0100;v\u2EAD\u2EAE\u43C6;\u43D5ma\xF4\u0A76ne;\u660E\u0180;tv\u2EBF\u2EC0\u2EC8\u43C0chfork\xBB\u1FFD;\u43D6\u0100au\u2ECF\u2EDFn\u0100ck\u2ED5\u2EDDk\u0100;h\u21F4\u2EDB;\u610E\xF6\u21F4s\u0480;abcdemst\u2EF3\u2EF4\u1908\u2EF9\u2EFD\u2F04\u2F06\u2F0A\u2F0E\u402Bcir;\u6A23ir;\u6A22\u0100ou\u1D40\u2F02;\u6A25;\u6A72n\u80BB\xB1\u0E9Dim;\u6A26wo;\u6A27\u0180ipu\u2F19\u2F20\u2F25ntint;\u6A15f;\uC000\u{1D561}nd\u803B\xA3\u40A3\u0500;Eaceinosu\u0EC8\u2F3F\u2F41\u2F44\u2F47\u2F81\u2F89\u2F92\u2F7E\u2FB6;\u6AB3p;\u6AB7u\xE5\u0ED9\u0100;c\u0ECE\u2F4C\u0300;acens\u0EC8\u2F59\u2F5F\u2F66\u2F68\u2F7Eppro\xF8\u2F43urlye\xF1\u0ED9\xF1\u0ECE\u0180aes\u2F6F\u2F76\u2F7Approx;\u6AB9qq;\u6AB5im;\u62E8i\xED\u0EDFme\u0100;s\u2F88\u0EAE\u6032\u0180Eas\u2F78\u2F90\u2F7A\xF0\u2F75\u0180dfp\u0EEC\u2F99\u2FAF\u0180als\u2FA0\u2FA5\u2FAAlar;\u632Eine;\u6312urf;\u6313\u0100;t\u0EFB\u2FB4\xEF\u0EFBrel;\u62B0\u0100ci\u2FC0\u2FC5r;\uC000\u{1D4C5};\u43C8ncsp;\u6008\u0300fiopsu\u2FDA\u22E2\u2FDF\u2FE5\u2FEB\u2FF1r;\uC000\u{1D52E}pf;\uC000\u{1D562}rime;\u6057cr;\uC000\u{1D4C6}\u0180aeo\u2FF8\u3009\u3013t\u0100ei\u2FFE\u3005rnion\xF3\u06B0nt;\u6A16st\u0100;e\u3010\u3011\u403F\xF1\u1F19\xF4\u0F14\u0A80ABHabcdefhilmnoprstux\u3040\u3051\u3055\u3059\u30E0\u310E\u312B\u3147\u3162\u3172\u318E\u3206\u3215\u3224\u3229\u3258\u326E\u3272\u3290\u32B0\u32B7\u0180art\u3047\u304A\u304Cr\xF2\u10B3\xF2\u03DDail;\u691Car\xF2\u1C65ar;\u6964\u0380cdenqrt\u3068\u3075\u3078\u307F\u308F\u3094\u30CC\u0100eu\u306D\u3071;\uC000\u223D\u0331te;\u4155i\xE3\u116Emptyv;\u69B3g\u0200;del\u0FD1\u3089\u308B\u308D;\u6992;\u69A5\xE5\u0FD1uo\u803B\xBB\u40BBr\u0580;abcfhlpstw\u0FDC\u30AC\u30AF\u30B7\u30B9\u30BC\u30BE\u30C0\u30C3\u30C7\u30CAp;\u6975\u0100;f\u0FE0\u30B4s;\u6920;\u6933s;\u691E\xEB\u225D\xF0\u272El;\u6945im;\u6974l;\u61A3;\u619D\u0100ai\u30D1\u30D5il;\u691Ao\u0100;n\u30DB\u30DC\u6236al\xF3\u0F1E\u0180abr\u30E7\u30EA\u30EEr\xF2\u17E5rk;\u6773\u0100ak\u30F3\u30FDc\u0100ek\u30F9\u30FB;\u407D;\u405D\u0100es\u3102\u3104;\u698Cl\u0100du\u310A\u310C;\u698E;\u6990\u0200aeuy\u3117\u311C\u3127\u3129ron;\u4159\u0100di\u3121\u3125il;\u4157\xEC\u0FF2\xE2\u30FA;\u4440\u0200clqs\u3134\u3137\u313D\u3144a;\u6937dhar;\u6969uo\u0100;r\u020E\u020Dh;\u61B3\u0180acg\u314E\u315F\u0F44l\u0200;ips\u0F78\u3158\u315B\u109Cn\xE5\u10BBar\xF4\u0FA9t;\u65AD\u0180ilr\u3169\u1023\u316Esht;\u697D;\uC000\u{1D52F}\u0100ao\u3177\u3186r\u0100du\u317D\u317F\xBB\u047B\u0100;l\u1091\u3184;\u696C\u0100;v\u318B\u318C\u43C1;\u43F1\u0180gns\u3195\u31F9\u31FCht\u0300ahlrst\u31A4\u31B0\u31C2\u31D8\u31E4\u31EErrow\u0100;t\u0FDC\u31ADa\xE9\u30C8arpoon\u0100du\u31BB\u31BFow\xEE\u317Ep\xBB\u1092eft\u0100ah\u31CA\u31D0rrow\xF3\u0FEAarpoon\xF3\u0551ightarrows;\u61C9quigarro\xF7\u30CBhreetimes;\u62CCg;\u42DAingdotse\xF1\u1F32\u0180ahm\u320D\u3210\u3213r\xF2\u0FEAa\xF2\u0551;\u600Foust\u0100;a\u321E\u321F\u63B1che\xBB\u321Fmid;\u6AEE\u0200abpt\u3232\u323D\u3240\u3252\u0100nr\u3237\u323Ag;\u67EDr;\u61FEr\xEB\u1003\u0180afl\u3247\u324A\u324Er;\u6986;\uC000\u{1D563}us;\u6A2Eimes;\u6A35\u0100ap\u325D\u3267r\u0100;g\u3263\u3264\u4029t;\u6994olint;\u6A12ar\xF2\u31E3\u0200achq\u327B\u3280\u10BC\u3285quo;\u603Ar;\uC000\u{1D4C7}\u0100bu\u30FB\u328Ao\u0100;r\u0214\u0213\u0180hir\u3297\u329B\u32A0re\xE5\u31F8mes;\u62CAi\u0200;efl\u32AA\u1059\u1821\u32AB\u65B9tri;\u69CEluhar;\u6968;\u611E\u0D61\u32D5\u32DB\u32DF\u332C\u3338\u3371\0\u337A\u33A4\0\0\u33EC\u33F0\0\u3428\u3448\u345A\u34AD\u34B1\u34CA\u34F1\0\u3616\0\0\u3633cute;\u415Bqu\xEF\u27BA\u0500;Eaceinpsy\u11ED\u32F3\u32F5\u32FF\u3302\u330B\u330F\u331F\u3326\u3329;\u6AB4\u01F0\u32FA\0\u32FC;\u6AB8on;\u4161u\xE5\u11FE\u0100;d\u11F3\u3307il;\u415Frc;\u415D\u0180Eas\u3316\u3318\u331B;\u6AB6p;\u6ABAim;\u62E9olint;\u6A13i\xED\u1204;\u4441ot\u0180;be\u3334\u1D47\u3335\u62C5;\u6A66\u0380Aacmstx\u3346\u334A\u3357\u335B\u335E\u3363\u336Drr;\u61D8r\u0100hr\u3350\u3352\xEB\u2228\u0100;o\u0A36\u0A34t\u803B\xA7\u40A7i;\u403Bwar;\u6929m\u0100in\u3369\xF0nu\xF3\xF1t;\u6736r\u0100;o\u3376\u2055\uC000\u{1D530}\u0200acoy\u3382\u3386\u3391\u33A0rp;\u666F\u0100hy\u338B\u338Fcy;\u4449;\u4448rt\u026D\u3399\0\0\u339Ci\xE4\u1464ara\xEC\u2E6F\u803B\xAD\u40AD\u0100gm\u33A8\u33B4ma\u0180;fv\u33B1\u33B2\u33B2\u43C3;\u43C2\u0400;deglnpr\u12AB\u33C5\u33C9\u33CE\u33D6\u33DE\u33E1\u33E6ot;\u6A6A\u0100;q\u12B1\u12B0\u0100;E\u33D3\u33D4\u6A9E;\u6AA0\u0100;E\u33DB\u33DC\u6A9D;\u6A9Fe;\u6246lus;\u6A24arr;\u6972ar\xF2\u113D\u0200aeit\u33F8\u3408\u340F\u3417\u0100ls\u33FD\u3404lsetm\xE9\u336Ahp;\u6A33parsl;\u69E4\u0100dl\u1463\u3414e;\u6323\u0100;e\u341C\u341D\u6AAA\u0100;s\u3422\u3423\u6AAC;\uC000\u2AAC\uFE00\u0180flp\u342E\u3433\u3442tcy;\u444C\u0100;b\u3438\u3439\u402F\u0100;a\u343E\u343F\u69C4r;\u633Ff;\uC000\u{1D564}a\u0100dr\u344D\u0402es\u0100;u\u3454\u3455\u6660it\xBB\u3455\u0180csu\u3460\u3479\u349F\u0100au\u3465\u346Fp\u0100;s\u1188\u346B;\uC000\u2293\uFE00p\u0100;s\u11B4\u3475;\uC000\u2294\uFE00u\u0100bp\u347F\u348F\u0180;es\u1197\u119C\u3486et\u0100;e\u1197\u348D\xF1\u119D\u0180;es\u11A8\u11AD\u3496et\u0100;e\u11A8\u349D\xF1\u11AE\u0180;af\u117B\u34A6\u05B0r\u0165\u34AB\u05B1\xBB\u117Car\xF2\u1148\u0200cemt\u34B9\u34BE\u34C2\u34C5r;\uC000\u{1D4C8}tm\xEE\xF1i\xEC\u3415ar\xE6\u11BE\u0100ar\u34CE\u34D5r\u0100;f\u34D4\u17BF\u6606\u0100an\u34DA\u34EDight\u0100ep\u34E3\u34EApsilo\xEE\u1EE0h\xE9\u2EAFs\xBB\u2852\u0280bcmnp\u34FB\u355E\u1209\u358B\u358E\u0480;Edemnprs\u350E\u350F\u3511\u3515\u351E\u3523\u352C\u3531\u3536\u6282;\u6AC5ot;\u6ABD\u0100;d\u11DA\u351Aot;\u6AC3ult;\u6AC1\u0100Ee\u3528\u352A;\u6ACB;\u628Alus;\u6ABFarr;\u6979\u0180eiu\u353D\u3552\u3555t\u0180;en\u350E\u3545\u354Bq\u0100;q\u11DA\u350Feq\u0100;q\u352B\u3528m;\u6AC7\u0100bp\u355A\u355C;\u6AD5;\u6AD3c\u0300;acens\u11ED\u356C\u3572\u3579\u357B\u3326ppro\xF8\u32FAurlye\xF1\u11FE\xF1\u11F3\u0180aes\u3582\u3588\u331Bppro\xF8\u331Aq\xF1\u3317g;\u666A\u0680123;Edehlmnps\u35A9\u35AC\u35AF\u121C\u35B2\u35B4\u35C0\u35C9\u35D5\u35DA\u35DF\u35E8\u35ED\u803B\xB9\u40B9\u803B\xB2\u40B2\u803B\xB3\u40B3;\u6AC6\u0100os\u35B9\u35BCt;\u6ABEub;\u6AD8\u0100;d\u1222\u35C5ot;\u6AC4s\u0100ou\u35CF\u35D2l;\u67C9b;\u6AD7arr;\u697Bult;\u6AC2\u0100Ee\u35E4\u35E6;\u6ACC;\u628Blus;\u6AC0\u0180eiu\u35F4\u3609\u360Ct\u0180;en\u121C\u35FC\u3602q\u0100;q\u1222\u35B2eq\u0100;q\u35E7\u35E4m;\u6AC8\u0100bp\u3611\u3613;\u6AD4;\u6AD6\u0180Aan\u361C\u3620\u362Drr;\u61D9r\u0100hr\u3626\u3628\xEB\u222E\u0100;o\u0A2B\u0A29war;\u692Alig\u803B\xDF\u40DF\u0BE1\u3651\u365D\u3660\u12CE\u3673\u3679\0\u367E\u36C2\0\0\0\0\0\u36DB\u3703\0\u3709\u376C\0\0\0\u3787\u0272\u3656\0\0\u365Bget;\u6316;\u43C4r\xEB\u0E5F\u0180aey\u3666\u366B\u3670ron;\u4165dil;\u4163;\u4442lrec;\u6315r;\uC000\u{1D531}\u0200eiko\u3686\u369D\u36B5\u36BC\u01F2\u368B\0\u3691e\u01004f\u1284\u1281a\u0180;sv\u3698\u3699\u369B\u43B8ym;\u43D1\u0100cn\u36A2\u36B2k\u0100as\u36A8\u36AEppro\xF8\u12C1im\xBB\u12ACs\xF0\u129E\u0100as\u36BA\u36AE\xF0\u12C1rn\u803B\xFE\u40FE\u01EC\u031F\u36C6\u22E7es\u8180\xD7;bd\u36CF\u36D0\u36D8\u40D7\u0100;a\u190F\u36D5r;\u6A31;\u6A30\u0180eps\u36E1\u36E3\u3700\xE1\u2A4D\u0200;bcf\u0486\u36EC\u36F0\u36F4ot;\u6336ir;\u6AF1\u0100;o\u36F9\u36FC\uC000\u{1D565}rk;\u6ADA\xE1\u3362rime;\u6034\u0180aip\u370F\u3712\u3764d\xE5\u1248\u0380adempst\u3721\u374D\u3740\u3751\u3757\u375C\u375Fngle\u0280;dlqr\u3730\u3731\u3736\u3740\u3742\u65B5own\xBB\u1DBBeft\u0100;e\u2800\u373E\xF1\u092E;\u625Cight\u0100;e\u32AA\u374B\xF1\u105Aot;\u65ECinus;\u6A3Alus;\u6A39b;\u69CDime;\u6A3Bezium;\u63E2\u0180cht\u3772\u377D\u3781\u0100ry\u3777\u377B;\uC000\u{1D4C9};\u4446cy;\u445Brok;\u4167\u0100io\u378B\u378Ex\xF4\u1777head\u0100lr\u3797\u37A0eftarro\xF7\u084Fightarrow\xBB\u0F5D\u0900AHabcdfghlmoprstuw\u37D0\u37D3\u37D7\u37E4\u37F0\u37FC\u380E\u381C\u3823\u3834\u3851\u385D\u386B\u38A9\u38CC\u38D2\u38EA\u38F6r\xF2\u03EDar;\u6963\u0100cr\u37DC\u37E2ute\u803B\xFA\u40FA\xF2\u1150r\u01E3\u37EA\0\u37EDy;\u445Eve;\u416D\u0100iy\u37F5\u37FArc\u803B\xFB\u40FB;\u4443\u0180abh\u3803\u3806\u380Br\xF2\u13ADlac;\u4171a\xF2\u13C3\u0100ir\u3813\u3818sht;\u697E;\uC000\u{1D532}rave\u803B\xF9\u40F9\u0161\u3827\u3831r\u0100lr\u382C\u382E\xBB\u0957\xBB\u1083lk;\u6580\u0100ct\u3839\u384D\u026F\u383F\0\0\u384Arn\u0100;e\u3845\u3846\u631Cr\xBB\u3846op;\u630Fri;\u65F8\u0100al\u3856\u385Acr;\u416B\u80BB\xA8\u0349\u0100gp\u3862\u3866on;\u4173f;\uC000\u{1D566}\u0300adhlsu\u114B\u3878\u387D\u1372\u3891\u38A0own\xE1\u13B3arpoon\u0100lr\u3888\u388Cef\xF4\u382Digh\xF4\u382Fi\u0180;hl\u3899\u389A\u389C\u43C5\xBB\u13FAon\xBB\u389Aparrows;\u61C8\u0180cit\u38B0\u38C4\u38C8\u026F\u38B6\0\0\u38C1rn\u0100;e\u38BC\u38BD\u631Dr\xBB\u38BDop;\u630Eng;\u416Fri;\u65F9cr;\uC000\u{1D4CA}\u0180dir\u38D9\u38DD\u38E2ot;\u62F0lde;\u4169i\u0100;f\u3730\u38E8\xBB\u1813\u0100am\u38EF\u38F2r\xF2\u38A8l\u803B\xFC\u40FCangle;\u69A7\u0780ABDacdeflnoprsz\u391C\u391F\u3929\u392D\u39B5\u39B8\u39BD\u39DF\u39E4\u39E8\u39F3\u39F9\u39FD\u3A01\u3A20r\xF2\u03F7ar\u0100;v\u3926\u3927\u6AE8;\u6AE9as\xE8\u03E1\u0100nr\u3932\u3937grt;\u699C\u0380eknprst\u34E3\u3946\u394B\u3952\u395D\u3964\u3996app\xE1\u2415othin\xE7\u1E96\u0180hir\u34EB\u2EC8\u3959op\xF4\u2FB5\u0100;h\u13B7\u3962\xEF\u318D\u0100iu\u3969\u396Dgm\xE1\u33B3\u0100bp\u3972\u3984setneq\u0100;q\u397D\u3980\uC000\u228A\uFE00;\uC000\u2ACB\uFE00setneq\u0100;q\u398F\u3992\uC000\u228B\uFE00;\uC000\u2ACC\uFE00\u0100hr\u399B\u399Fet\xE1\u369Ciangle\u0100lr\u39AA\u39AFeft\xBB\u0925ight\xBB\u1051y;\u4432ash\xBB\u1036\u0180elr\u39C4\u39D2\u39D7\u0180;be\u2DEA\u39CB\u39CFar;\u62BBq;\u625Alip;\u62EE\u0100bt\u39DC\u1468a\xF2\u1469r;\uC000\u{1D533}tr\xE9\u39AEsu\u0100bp\u39EF\u39F1\xBB\u0D1C\xBB\u0D59pf;\uC000\u{1D567}ro\xF0\u0EFBtr\xE9\u39B4\u0100cu\u3A06\u3A0Br;\uC000\u{1D4CB}\u0100bp\u3A10\u3A18n\u0100Ee\u3980\u3A16\xBB\u397En\u0100Ee\u3992\u3A1E\xBB\u3990igzag;\u699A\u0380cefoprs\u3A36\u3A3B\u3A56\u3A5B\u3A54\u3A61\u3A6Airc;\u4175\u0100di\u3A40\u3A51\u0100bg\u3A45\u3A49ar;\u6A5Fe\u0100;q\u15FA\u3A4F;\u6259erp;\u6118r;\uC000\u{1D534}pf;\uC000\u{1D568}\u0100;e\u1479\u3A66at\xE8\u1479cr;\uC000\u{1D4CC}\u0AE3\u178E\u3A87\0\u3A8B\0\u3A90\u3A9B\0\0\u3A9D\u3AA8\u3AAB\u3AAF\0\0\u3AC3\u3ACE\0\u3AD8\u17DC\u17DFtr\xE9\u17D1r;\uC000\u{1D535}\u0100Aa\u3A94\u3A97r\xF2\u03C3r\xF2\u09F6;\u43BE\u0100Aa\u3AA1\u3AA4r\xF2\u03B8r\xF2\u09EBa\xF0\u2713is;\u62FB\u0180dpt\u17A4\u3AB5\u3ABE\u0100fl\u3ABA\u17A9;\uC000\u{1D569}im\xE5\u17B2\u0100Aa\u3AC7\u3ACAr\xF2\u03CEr\xF2\u0A01\u0100cq\u3AD2\u17B8r;\uC000\u{1D4CD}\u0100pt\u17D6\u3ADCr\xE9\u17D4\u0400acefiosu\u3AF0\u3AFD\u3B08\u3B0C\u3B11\u3B15\u3B1B\u3B21c\u0100uy\u3AF6\u3AFBte\u803B\xFD\u40FD;\u444F\u0100iy\u3B02\u3B06rc;\u4177;\u444Bn\u803B\xA5\u40A5r;\uC000\u{1D536}cy;\u4457pf;\uC000\u{1D56A}cr;\uC000\u{1D4CE}\u0100cm\u3B26\u3B29y;\u444El\u803B\xFF\u40FF\u0500acdefhiosw\u3B42\u3B48\u3B54\u3B58\u3B64\u3B69\u3B6D\u3B74\u3B7A\u3B80cute;\u417A\u0100ay\u3B4D\u3B52ron;\u417E;\u4437ot;\u417C\u0100et\u3B5D\u3B61tr\xE6\u155Fa;\u43B6r;\uC000\u{1D537}cy;\u4436grarr;\u61DDpf;\uC000\u{1D56B}cr;\uC000\u{1D4CF}\u0100jn\u3B85\u3B87;\u600Dj;\u600C'.split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/generated/decode-data-xml.js
var require_decode_data_xml = __commonJS({
  "node_modules/entities/lib/generated/decode-data-xml.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.default = new Uint16Array(
      // prettier-ignore
      "\u0200aglq	\x1B\u026D\0\0p;\u4026os;\u4027t;\u403Et;\u403Cuot;\u4022".split("").map(function(c) {
        return c.charCodeAt(0);
      })
    );
  }
});

// node_modules/entities/lib/decode_codepoint.js
var require_decode_codepoint = __commonJS({
  "node_modules/entities/lib/decode_codepoint.js"(exports2) {
    "use strict";
    var _a;
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.replaceCodePoint = exports2.fromCodePoint = void 0;
    var decodeMap = /* @__PURE__ */ new Map([
      [0, 65533],
      // C1 Unicode control character reference replacements
      [128, 8364],
      [130, 8218],
      [131, 402],
      [132, 8222],
      [133, 8230],
      [134, 8224],
      [135, 8225],
      [136, 710],
      [137, 8240],
      [138, 352],
      [139, 8249],
      [140, 338],
      [142, 381],
      [145, 8216],
      [146, 8217],
      [147, 8220],
      [148, 8221],
      [149, 8226],
      [150, 8211],
      [151, 8212],
      [152, 732],
      [153, 8482],
      [154, 353],
      [155, 8250],
      [156, 339],
      [158, 382],
      [159, 376]
    ]);
    exports2.fromCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition, node/no-unsupported-features/es-builtins
    (_a = String.fromCodePoint) !== null && _a !== void 0 ? _a : function(codePoint) {
      var output = "";
      if (codePoint > 65535) {
        codePoint -= 65536;
        output += String.fromCharCode(codePoint >>> 10 & 1023 | 55296);
        codePoint = 56320 | codePoint & 1023;
      }
      output += String.fromCharCode(codePoint);
      return output;
    };
    function replaceCodePoint(codePoint) {
      var _a2;
      if (codePoint >= 55296 && codePoint <= 57343 || codePoint > 1114111) {
        return 65533;
      }
      return (_a2 = decodeMap.get(codePoint)) !== null && _a2 !== void 0 ? _a2 : codePoint;
    }
    exports2.replaceCodePoint = replaceCodePoint;
    function decodeCodePoint(codePoint) {
      return (0, exports2.fromCodePoint)(replaceCodePoint(codePoint));
    }
    exports2.default = decodeCodePoint;
  }
});

// node_modules/entities/lib/decode.js
var require_decode = __commonJS({
  "node_modules/entities/lib/decode.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXML = exports2.decodeHTMLStrict = exports2.decodeHTMLAttribute = exports2.decodeHTML = exports2.determineBranch = exports2.EntityDecoder = exports2.DecodingMode = exports2.BinTrieFlags = exports2.fromCodePoint = exports2.replaceCodePoint = exports2.decodeCodePoint = exports2.xmlDecodeTree = exports2.htmlDecodeTree = void 0;
    var decode_data_html_js_1 = __importDefault(require_decode_data_html());
    exports2.htmlDecodeTree = decode_data_html_js_1.default;
    var decode_data_xml_js_1 = __importDefault(require_decode_data_xml());
    exports2.xmlDecodeTree = decode_data_xml_js_1.default;
    var decode_codepoint_js_1 = __importStar(require_decode_codepoint());
    exports2.decodeCodePoint = decode_codepoint_js_1.default;
    var decode_codepoint_js_2 = require_decode_codepoint();
    Object.defineProperty(exports2, "replaceCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.replaceCodePoint;
    } });
    Object.defineProperty(exports2, "fromCodePoint", { enumerable: true, get: function() {
      return decode_codepoint_js_2.fromCodePoint;
    } });
    var CharCodes;
    (function(CharCodes2) {
      CharCodes2[CharCodes2["NUM"] = 35] = "NUM";
      CharCodes2[CharCodes2["SEMI"] = 59] = "SEMI";
      CharCodes2[CharCodes2["EQUALS"] = 61] = "EQUALS";
      CharCodes2[CharCodes2["ZERO"] = 48] = "ZERO";
      CharCodes2[CharCodes2["NINE"] = 57] = "NINE";
      CharCodes2[CharCodes2["LOWER_A"] = 97] = "LOWER_A";
      CharCodes2[CharCodes2["LOWER_F"] = 102] = "LOWER_F";
      CharCodes2[CharCodes2["LOWER_X"] = 120] = "LOWER_X";
      CharCodes2[CharCodes2["LOWER_Z"] = 122] = "LOWER_Z";
      CharCodes2[CharCodes2["UPPER_A"] = 65] = "UPPER_A";
      CharCodes2[CharCodes2["UPPER_F"] = 70] = "UPPER_F";
      CharCodes2[CharCodes2["UPPER_Z"] = 90] = "UPPER_Z";
    })(CharCodes || (CharCodes = {}));
    var TO_LOWER_BIT = 32;
    var BinTrieFlags;
    (function(BinTrieFlags2) {
      BinTrieFlags2[BinTrieFlags2["VALUE_LENGTH"] = 49152] = "VALUE_LENGTH";
      BinTrieFlags2[BinTrieFlags2["BRANCH_LENGTH"] = 16256] = "BRANCH_LENGTH";
      BinTrieFlags2[BinTrieFlags2["JUMP_TABLE"] = 127] = "JUMP_TABLE";
    })(BinTrieFlags = exports2.BinTrieFlags || (exports2.BinTrieFlags = {}));
    function isNumber(code) {
      return code >= CharCodes.ZERO && code <= CharCodes.NINE;
    }
    function isHexadecimalCharacter(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_F || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_F;
    }
    function isAsciiAlphaNumeric(code) {
      return code >= CharCodes.UPPER_A && code <= CharCodes.UPPER_Z || code >= CharCodes.LOWER_A && code <= CharCodes.LOWER_Z || isNumber(code);
    }
    function isEntityInAttributeInvalidEnd(code) {
      return code === CharCodes.EQUALS || isAsciiAlphaNumeric(code);
    }
    var EntityDecoderState;
    (function(EntityDecoderState2) {
      EntityDecoderState2[EntityDecoderState2["EntityStart"] = 0] = "EntityStart";
      EntityDecoderState2[EntityDecoderState2["NumericStart"] = 1] = "NumericStart";
      EntityDecoderState2[EntityDecoderState2["NumericDecimal"] = 2] = "NumericDecimal";
      EntityDecoderState2[EntityDecoderState2["NumericHex"] = 3] = "NumericHex";
      EntityDecoderState2[EntityDecoderState2["NamedEntity"] = 4] = "NamedEntity";
    })(EntityDecoderState || (EntityDecoderState = {}));
    var DecodingMode;
    (function(DecodingMode2) {
      DecodingMode2[DecodingMode2["Legacy"] = 0] = "Legacy";
      DecodingMode2[DecodingMode2["Strict"] = 1] = "Strict";
      DecodingMode2[DecodingMode2["Attribute"] = 2] = "Attribute";
    })(DecodingMode = exports2.DecodingMode || (exports2.DecodingMode = {}));
    var EntityDecoder = (
      /** @class */
      (function() {
        function EntityDecoder2(decodeTree, emitCodePoint, errors) {
          this.decodeTree = decodeTree;
          this.emitCodePoint = emitCodePoint;
          this.errors = errors;
          this.state = EntityDecoderState.EntityStart;
          this.consumed = 1;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.decodeMode = DecodingMode.Strict;
        }
        EntityDecoder2.prototype.startEntity = function(decodeMode) {
          this.decodeMode = decodeMode;
          this.state = EntityDecoderState.EntityStart;
          this.result = 0;
          this.treeIndex = 0;
          this.excess = 1;
          this.consumed = 1;
        };
        EntityDecoder2.prototype.write = function(str, offset) {
          switch (this.state) {
            case EntityDecoderState.EntityStart: {
              if (str.charCodeAt(offset) === CharCodes.NUM) {
                this.state = EntityDecoderState.NumericStart;
                this.consumed += 1;
                return this.stateNumericStart(str, offset + 1);
              }
              this.state = EntityDecoderState.NamedEntity;
              return this.stateNamedEntity(str, offset);
            }
            case EntityDecoderState.NumericStart: {
              return this.stateNumericStart(str, offset);
            }
            case EntityDecoderState.NumericDecimal: {
              return this.stateNumericDecimal(str, offset);
            }
            case EntityDecoderState.NumericHex: {
              return this.stateNumericHex(str, offset);
            }
            case EntityDecoderState.NamedEntity: {
              return this.stateNamedEntity(str, offset);
            }
          }
        };
        EntityDecoder2.prototype.stateNumericStart = function(str, offset) {
          if (offset >= str.length) {
            return -1;
          }
          if ((str.charCodeAt(offset) | TO_LOWER_BIT) === CharCodes.LOWER_X) {
            this.state = EntityDecoderState.NumericHex;
            this.consumed += 1;
            return this.stateNumericHex(str, offset + 1);
          }
          this.state = EntityDecoderState.NumericDecimal;
          return this.stateNumericDecimal(str, offset);
        };
        EntityDecoder2.prototype.addToNumericResult = function(str, start, end, base) {
          if (start !== end) {
            var digitCount = end - start;
            this.result = this.result * Math.pow(base, digitCount) + parseInt(str.substr(start, digitCount), base);
            this.consumed += digitCount;
          }
        };
        EntityDecoder2.prototype.stateNumericHex = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char) || isHexadecimalCharacter(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 16);
              return this.emitNumericEntity(char, 3);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 16);
          return -1;
        };
        EntityDecoder2.prototype.stateNumericDecimal = function(str, offset) {
          var startIdx = offset;
          while (offset < str.length) {
            var char = str.charCodeAt(offset);
            if (isNumber(char)) {
              offset += 1;
            } else {
              this.addToNumericResult(str, startIdx, offset, 10);
              return this.emitNumericEntity(char, 2);
            }
          }
          this.addToNumericResult(str, startIdx, offset, 10);
          return -1;
        };
        EntityDecoder2.prototype.emitNumericEntity = function(lastCp, expectedLength) {
          var _a;
          if (this.consumed <= expectedLength) {
            (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
            return 0;
          }
          if (lastCp === CharCodes.SEMI) {
            this.consumed += 1;
          } else if (this.decodeMode === DecodingMode.Strict) {
            return 0;
          }
          this.emitCodePoint((0, decode_codepoint_js_1.replaceCodePoint)(this.result), this.consumed);
          if (this.errors) {
            if (lastCp !== CharCodes.SEMI) {
              this.errors.missingSemicolonAfterCharacterReference();
            }
            this.errors.validateNumericCharacterReference(this.result);
          }
          return this.consumed;
        };
        EntityDecoder2.prototype.stateNamedEntity = function(str, offset) {
          var decodeTree = this.decodeTree;
          var current = decodeTree[this.treeIndex];
          var valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
          for (; offset < str.length; offset++, this.excess++) {
            var char = str.charCodeAt(offset);
            this.treeIndex = determineBranch(decodeTree, current, this.treeIndex + Math.max(1, valueLength), char);
            if (this.treeIndex < 0) {
              return this.result === 0 || // If we are parsing an attribute
              this.decodeMode === DecodingMode.Attribute && // We shouldn't have consumed any characters after the entity,
              (valueLength === 0 || // And there should be no invalid characters.
              isEntityInAttributeInvalidEnd(char)) ? 0 : this.emitNotTerminatedNamedEntity();
            }
            current = decodeTree[this.treeIndex];
            valueLength = (current & BinTrieFlags.VALUE_LENGTH) >> 14;
            if (valueLength !== 0) {
              if (char === CharCodes.SEMI) {
                return this.emitNamedEntityData(this.treeIndex, valueLength, this.consumed + this.excess);
              }
              if (this.decodeMode !== DecodingMode.Strict) {
                this.result = this.treeIndex;
                this.consumed += this.excess;
                this.excess = 0;
              }
            }
          }
          return -1;
        };
        EntityDecoder2.prototype.emitNotTerminatedNamedEntity = function() {
          var _a;
          var _b = this, result = _b.result, decodeTree = _b.decodeTree;
          var valueLength = (decodeTree[result] & BinTrieFlags.VALUE_LENGTH) >> 14;
          this.emitNamedEntityData(result, valueLength, this.consumed);
          (_a = this.errors) === null || _a === void 0 ? void 0 : _a.missingSemicolonAfterCharacterReference();
          return this.consumed;
        };
        EntityDecoder2.prototype.emitNamedEntityData = function(result, valueLength, consumed) {
          var decodeTree = this.decodeTree;
          this.emitCodePoint(valueLength === 1 ? decodeTree[result] & ~BinTrieFlags.VALUE_LENGTH : decodeTree[result + 1], consumed);
          if (valueLength === 3) {
            this.emitCodePoint(decodeTree[result + 2], consumed);
          }
          return consumed;
        };
        EntityDecoder2.prototype.end = function() {
          var _a;
          switch (this.state) {
            case EntityDecoderState.NamedEntity: {
              return this.result !== 0 && (this.decodeMode !== DecodingMode.Attribute || this.result === this.treeIndex) ? this.emitNotTerminatedNamedEntity() : 0;
            }
            // Otherwise, emit a numeric entity if we have one.
            case EntityDecoderState.NumericDecimal: {
              return this.emitNumericEntity(0, 2);
            }
            case EntityDecoderState.NumericHex: {
              return this.emitNumericEntity(0, 3);
            }
            case EntityDecoderState.NumericStart: {
              (_a = this.errors) === null || _a === void 0 ? void 0 : _a.absenceOfDigitsInNumericCharacterReference(this.consumed);
              return 0;
            }
            case EntityDecoderState.EntityStart: {
              return 0;
            }
          }
        };
        return EntityDecoder2;
      })()
    );
    exports2.EntityDecoder = EntityDecoder;
    function getDecoder(decodeTree) {
      var ret = "";
      var decoder = new EntityDecoder(decodeTree, function(str) {
        return ret += (0, decode_codepoint_js_1.fromCodePoint)(str);
      });
      return function decodeWithTrie(str, decodeMode) {
        var lastIndex = 0;
        var offset = 0;
        while ((offset = str.indexOf("&", offset)) >= 0) {
          ret += str.slice(lastIndex, offset);
          decoder.startEntity(decodeMode);
          var len = decoder.write(
            str,
            // Skip the "&"
            offset + 1
          );
          if (len < 0) {
            lastIndex = offset + decoder.end();
            break;
          }
          lastIndex = offset + len;
          offset = len === 0 ? lastIndex + 1 : lastIndex;
        }
        var result = ret + str.slice(lastIndex);
        ret = "";
        return result;
      };
    }
    function determineBranch(decodeTree, current, nodeIdx, char) {
      var branchCount = (current & BinTrieFlags.BRANCH_LENGTH) >> 7;
      var jumpOffset = current & BinTrieFlags.JUMP_TABLE;
      if (branchCount === 0) {
        return jumpOffset !== 0 && char === jumpOffset ? nodeIdx : -1;
      }
      if (jumpOffset) {
        var value = char - jumpOffset;
        return value < 0 || value >= branchCount ? -1 : decodeTree[nodeIdx + value] - 1;
      }
      var lo = nodeIdx;
      var hi = lo + branchCount - 1;
      while (lo <= hi) {
        var mid = lo + hi >>> 1;
        var midVal = decodeTree[mid];
        if (midVal < char) {
          lo = mid + 1;
        } else if (midVal > char) {
          hi = mid - 1;
        } else {
          return decodeTree[mid + branchCount];
        }
      }
      return -1;
    }
    exports2.determineBranch = determineBranch;
    var htmlDecoder = getDecoder(decode_data_html_js_1.default);
    var xmlDecoder = getDecoder(decode_data_xml_js_1.default);
    function decodeHTML(str, mode) {
      if (mode === void 0) {
        mode = DecodingMode.Legacy;
      }
      return htmlDecoder(str, mode);
    }
    exports2.decodeHTML = decodeHTML;
    function decodeHTMLAttribute(str) {
      return htmlDecoder(str, DecodingMode.Attribute);
    }
    exports2.decodeHTMLAttribute = decodeHTMLAttribute;
    function decodeHTMLStrict(str) {
      return htmlDecoder(str, DecodingMode.Strict);
    }
    exports2.decodeHTMLStrict = decodeHTMLStrict;
    function decodeXML(str) {
      return xmlDecoder(str, DecodingMode.Strict);
    }
    exports2.decodeXML = decodeXML;
  }
});

// node_modules/entities/lib/generated/encode-html.js
var require_encode_html = __commonJS({
  "node_modules/entities/lib/generated/encode-html.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    function restoreDiff(arr) {
      for (var i = 1; i < arr.length; i++) {
        arr[i][0] += arr[i - 1][0] + 1;
      }
      return arr;
    }
    exports2.default = new Map(/* @__PURE__ */ restoreDiff([[9, "&Tab;"], [0, "&NewLine;"], [22, "&excl;"], [0, "&quot;"], [0, "&num;"], [0, "&dollar;"], [0, "&percnt;"], [0, "&amp;"], [0, "&apos;"], [0, "&lpar;"], [0, "&rpar;"], [0, "&ast;"], [0, "&plus;"], [0, "&comma;"], [1, "&period;"], [0, "&sol;"], [10, "&colon;"], [0, "&semi;"], [0, { v: "&lt;", n: 8402, o: "&nvlt;" }], [0, { v: "&equals;", n: 8421, o: "&bne;" }], [0, { v: "&gt;", n: 8402, o: "&nvgt;" }], [0, "&quest;"], [0, "&commat;"], [26, "&lbrack;"], [0, "&bsol;"], [0, "&rbrack;"], [0, "&Hat;"], [0, "&lowbar;"], [0, "&DiacriticalGrave;"], [5, { n: 106, o: "&fjlig;" }], [20, "&lbrace;"], [0, "&verbar;"], [0, "&rbrace;"], [34, "&nbsp;"], [0, "&iexcl;"], [0, "&cent;"], [0, "&pound;"], [0, "&curren;"], [0, "&yen;"], [0, "&brvbar;"], [0, "&sect;"], [0, "&die;"], [0, "&copy;"], [0, "&ordf;"], [0, "&laquo;"], [0, "&not;"], [0, "&shy;"], [0, "&circledR;"], [0, "&macr;"], [0, "&deg;"], [0, "&PlusMinus;"], [0, "&sup2;"], [0, "&sup3;"], [0, "&acute;"], [0, "&micro;"], [0, "&para;"], [0, "&centerdot;"], [0, "&cedil;"], [0, "&sup1;"], [0, "&ordm;"], [0, "&raquo;"], [0, "&frac14;"], [0, "&frac12;"], [0, "&frac34;"], [0, "&iquest;"], [0, "&Agrave;"], [0, "&Aacute;"], [0, "&Acirc;"], [0, "&Atilde;"], [0, "&Auml;"], [0, "&angst;"], [0, "&AElig;"], [0, "&Ccedil;"], [0, "&Egrave;"], [0, "&Eacute;"], [0, "&Ecirc;"], [0, "&Euml;"], [0, "&Igrave;"], [0, "&Iacute;"], [0, "&Icirc;"], [0, "&Iuml;"], [0, "&ETH;"], [0, "&Ntilde;"], [0, "&Ograve;"], [0, "&Oacute;"], [0, "&Ocirc;"], [0, "&Otilde;"], [0, "&Ouml;"], [0, "&times;"], [0, "&Oslash;"], [0, "&Ugrave;"], [0, "&Uacute;"], [0, "&Ucirc;"], [0, "&Uuml;"], [0, "&Yacute;"], [0, "&THORN;"], [0, "&szlig;"], [0, "&agrave;"], [0, "&aacute;"], [0, "&acirc;"], [0, "&atilde;"], [0, "&auml;"], [0, "&aring;"], [0, "&aelig;"], [0, "&ccedil;"], [0, "&egrave;"], [0, "&eacute;"], [0, "&ecirc;"], [0, "&euml;"], [0, "&igrave;"], [0, "&iacute;"], [0, "&icirc;"], [0, "&iuml;"], [0, "&eth;"], [0, "&ntilde;"], [0, "&ograve;"], [0, "&oacute;"], [0, "&ocirc;"], [0, "&otilde;"], [0, "&ouml;"], [0, "&div;"], [0, "&oslash;"], [0, "&ugrave;"], [0, "&uacute;"], [0, "&ucirc;"], [0, "&uuml;"], [0, "&yacute;"], [0, "&thorn;"], [0, "&yuml;"], [0, "&Amacr;"], [0, "&amacr;"], [0, "&Abreve;"], [0, "&abreve;"], [0, "&Aogon;"], [0, "&aogon;"], [0, "&Cacute;"], [0, "&cacute;"], [0, "&Ccirc;"], [0, "&ccirc;"], [0, "&Cdot;"], [0, "&cdot;"], [0, "&Ccaron;"], [0, "&ccaron;"], [0, "&Dcaron;"], [0, "&dcaron;"], [0, "&Dstrok;"], [0, "&dstrok;"], [0, "&Emacr;"], [0, "&emacr;"], [2, "&Edot;"], [0, "&edot;"], [0, "&Eogon;"], [0, "&eogon;"], [0, "&Ecaron;"], [0, "&ecaron;"], [0, "&Gcirc;"], [0, "&gcirc;"], [0, "&Gbreve;"], [0, "&gbreve;"], [0, "&Gdot;"], [0, "&gdot;"], [0, "&Gcedil;"], [1, "&Hcirc;"], [0, "&hcirc;"], [0, "&Hstrok;"], [0, "&hstrok;"], [0, "&Itilde;"], [0, "&itilde;"], [0, "&Imacr;"], [0, "&imacr;"], [2, "&Iogon;"], [0, "&iogon;"], [0, "&Idot;"], [0, "&imath;"], [0, "&IJlig;"], [0, "&ijlig;"], [0, "&Jcirc;"], [0, "&jcirc;"], [0, "&Kcedil;"], [0, "&kcedil;"], [0, "&kgreen;"], [0, "&Lacute;"], [0, "&lacute;"], [0, "&Lcedil;"], [0, "&lcedil;"], [0, "&Lcaron;"], [0, "&lcaron;"], [0, "&Lmidot;"], [0, "&lmidot;"], [0, "&Lstrok;"], [0, "&lstrok;"], [0, "&Nacute;"], [0, "&nacute;"], [0, "&Ncedil;"], [0, "&ncedil;"], [0, "&Ncaron;"], [0, "&ncaron;"], [0, "&napos;"], [0, "&ENG;"], [0, "&eng;"], [0, "&Omacr;"], [0, "&omacr;"], [2, "&Odblac;"], [0, "&odblac;"], [0, "&OElig;"], [0, "&oelig;"], [0, "&Racute;"], [0, "&racute;"], [0, "&Rcedil;"], [0, "&rcedil;"], [0, "&Rcaron;"], [0, "&rcaron;"], [0, "&Sacute;"], [0, "&sacute;"], [0, "&Scirc;"], [0, "&scirc;"], [0, "&Scedil;"], [0, "&scedil;"], [0, "&Scaron;"], [0, "&scaron;"], [0, "&Tcedil;"], [0, "&tcedil;"], [0, "&Tcaron;"], [0, "&tcaron;"], [0, "&Tstrok;"], [0, "&tstrok;"], [0, "&Utilde;"], [0, "&utilde;"], [0, "&Umacr;"], [0, "&umacr;"], [0, "&Ubreve;"], [0, "&ubreve;"], [0, "&Uring;"], [0, "&uring;"], [0, "&Udblac;"], [0, "&udblac;"], [0, "&Uogon;"], [0, "&uogon;"], [0, "&Wcirc;"], [0, "&wcirc;"], [0, "&Ycirc;"], [0, "&ycirc;"], [0, "&Yuml;"], [0, "&Zacute;"], [0, "&zacute;"], [0, "&Zdot;"], [0, "&zdot;"], [0, "&Zcaron;"], [0, "&zcaron;"], [19, "&fnof;"], [34, "&imped;"], [63, "&gacute;"], [65, "&jmath;"], [142, "&circ;"], [0, "&caron;"], [16, "&breve;"], [0, "&DiacriticalDot;"], [0, "&ring;"], [0, "&ogon;"], [0, "&DiacriticalTilde;"], [0, "&dblac;"], [51, "&DownBreve;"], [127, "&Alpha;"], [0, "&Beta;"], [0, "&Gamma;"], [0, "&Delta;"], [0, "&Epsilon;"], [0, "&Zeta;"], [0, "&Eta;"], [0, "&Theta;"], [0, "&Iota;"], [0, "&Kappa;"], [0, "&Lambda;"], [0, "&Mu;"], [0, "&Nu;"], [0, "&Xi;"], [0, "&Omicron;"], [0, "&Pi;"], [0, "&Rho;"], [1, "&Sigma;"], [0, "&Tau;"], [0, "&Upsilon;"], [0, "&Phi;"], [0, "&Chi;"], [0, "&Psi;"], [0, "&ohm;"], [7, "&alpha;"], [0, "&beta;"], [0, "&gamma;"], [0, "&delta;"], [0, "&epsi;"], [0, "&zeta;"], [0, "&eta;"], [0, "&theta;"], [0, "&iota;"], [0, "&kappa;"], [0, "&lambda;"], [0, "&mu;"], [0, "&nu;"], [0, "&xi;"], [0, "&omicron;"], [0, "&pi;"], [0, "&rho;"], [0, "&sigmaf;"], [0, "&sigma;"], [0, "&tau;"], [0, "&upsi;"], [0, "&phi;"], [0, "&chi;"], [0, "&psi;"], [0, "&omega;"], [7, "&thetasym;"], [0, "&Upsi;"], [2, "&phiv;"], [0, "&piv;"], [5, "&Gammad;"], [0, "&digamma;"], [18, "&kappav;"], [0, "&rhov;"], [3, "&epsiv;"], [0, "&backepsilon;"], [10, "&IOcy;"], [0, "&DJcy;"], [0, "&GJcy;"], [0, "&Jukcy;"], [0, "&DScy;"], [0, "&Iukcy;"], [0, "&YIcy;"], [0, "&Jsercy;"], [0, "&LJcy;"], [0, "&NJcy;"], [0, "&TSHcy;"], [0, "&KJcy;"], [1, "&Ubrcy;"], [0, "&DZcy;"], [0, "&Acy;"], [0, "&Bcy;"], [0, "&Vcy;"], [0, "&Gcy;"], [0, "&Dcy;"], [0, "&IEcy;"], [0, "&ZHcy;"], [0, "&Zcy;"], [0, "&Icy;"], [0, "&Jcy;"], [0, "&Kcy;"], [0, "&Lcy;"], [0, "&Mcy;"], [0, "&Ncy;"], [0, "&Ocy;"], [0, "&Pcy;"], [0, "&Rcy;"], [0, "&Scy;"], [0, "&Tcy;"], [0, "&Ucy;"], [0, "&Fcy;"], [0, "&KHcy;"], [0, "&TScy;"], [0, "&CHcy;"], [0, "&SHcy;"], [0, "&SHCHcy;"], [0, "&HARDcy;"], [0, "&Ycy;"], [0, "&SOFTcy;"], [0, "&Ecy;"], [0, "&YUcy;"], [0, "&YAcy;"], [0, "&acy;"], [0, "&bcy;"], [0, "&vcy;"], [0, "&gcy;"], [0, "&dcy;"], [0, "&iecy;"], [0, "&zhcy;"], [0, "&zcy;"], [0, "&icy;"], [0, "&jcy;"], [0, "&kcy;"], [0, "&lcy;"], [0, "&mcy;"], [0, "&ncy;"], [0, "&ocy;"], [0, "&pcy;"], [0, "&rcy;"], [0, "&scy;"], [0, "&tcy;"], [0, "&ucy;"], [0, "&fcy;"], [0, "&khcy;"], [0, "&tscy;"], [0, "&chcy;"], [0, "&shcy;"], [0, "&shchcy;"], [0, "&hardcy;"], [0, "&ycy;"], [0, "&softcy;"], [0, "&ecy;"], [0, "&yucy;"], [0, "&yacy;"], [1, "&iocy;"], [0, "&djcy;"], [0, "&gjcy;"], [0, "&jukcy;"], [0, "&dscy;"], [0, "&iukcy;"], [0, "&yicy;"], [0, "&jsercy;"], [0, "&ljcy;"], [0, "&njcy;"], [0, "&tshcy;"], [0, "&kjcy;"], [1, "&ubrcy;"], [0, "&dzcy;"], [7074, "&ensp;"], [0, "&emsp;"], [0, "&emsp13;"], [0, "&emsp14;"], [1, "&numsp;"], [0, "&puncsp;"], [0, "&ThinSpace;"], [0, "&hairsp;"], [0, "&NegativeMediumSpace;"], [0, "&zwnj;"], [0, "&zwj;"], [0, "&lrm;"], [0, "&rlm;"], [0, "&dash;"], [2, "&ndash;"], [0, "&mdash;"], [0, "&horbar;"], [0, "&Verbar;"], [1, "&lsquo;"], [0, "&CloseCurlyQuote;"], [0, "&lsquor;"], [1, "&ldquo;"], [0, "&CloseCurlyDoubleQuote;"], [0, "&bdquo;"], [1, "&dagger;"], [0, "&Dagger;"], [0, "&bull;"], [2, "&nldr;"], [0, "&hellip;"], [9, "&permil;"], [0, "&pertenk;"], [0, "&prime;"], [0, "&Prime;"], [0, "&tprime;"], [0, "&backprime;"], [3, "&lsaquo;"], [0, "&rsaquo;"], [3, "&oline;"], [2, "&caret;"], [1, "&hybull;"], [0, "&frasl;"], [10, "&bsemi;"], [7, "&qprime;"], [7, { v: "&MediumSpace;", n: 8202, o: "&ThickSpace;" }], [0, "&NoBreak;"], [0, "&af;"], [0, "&InvisibleTimes;"], [0, "&ic;"], [72, "&euro;"], [46, "&tdot;"], [0, "&DotDot;"], [37, "&complexes;"], [2, "&incare;"], [4, "&gscr;"], [0, "&hamilt;"], [0, "&Hfr;"], [0, "&Hopf;"], [0, "&planckh;"], [0, "&hbar;"], [0, "&imagline;"], [0, "&Ifr;"], [0, "&lagran;"], [0, "&ell;"], [1, "&naturals;"], [0, "&numero;"], [0, "&copysr;"], [0, "&weierp;"], [0, "&Popf;"], [0, "&Qopf;"], [0, "&realine;"], [0, "&real;"], [0, "&reals;"], [0, "&rx;"], [3, "&trade;"], [1, "&integers;"], [2, "&mho;"], [0, "&zeetrf;"], [0, "&iiota;"], [2, "&bernou;"], [0, "&Cayleys;"], [1, "&escr;"], [0, "&Escr;"], [0, "&Fouriertrf;"], [1, "&Mellintrf;"], [0, "&order;"], [0, "&alefsym;"], [0, "&beth;"], [0, "&gimel;"], [0, "&daleth;"], [12, "&CapitalDifferentialD;"], [0, "&dd;"], [0, "&ee;"], [0, "&ii;"], [10, "&frac13;"], [0, "&frac23;"], [0, "&frac15;"], [0, "&frac25;"], [0, "&frac35;"], [0, "&frac45;"], [0, "&frac16;"], [0, "&frac56;"], [0, "&frac18;"], [0, "&frac38;"], [0, "&frac58;"], [0, "&frac78;"], [49, "&larr;"], [0, "&ShortUpArrow;"], [0, "&rarr;"], [0, "&darr;"], [0, "&harr;"], [0, "&updownarrow;"], [0, "&nwarr;"], [0, "&nearr;"], [0, "&LowerRightArrow;"], [0, "&LowerLeftArrow;"], [0, "&nlarr;"], [0, "&nrarr;"], [1, { v: "&rarrw;", n: 824, o: "&nrarrw;" }], [0, "&Larr;"], [0, "&Uarr;"], [0, "&Rarr;"], [0, "&Darr;"], [0, "&larrtl;"], [0, "&rarrtl;"], [0, "&LeftTeeArrow;"], [0, "&mapstoup;"], [0, "&map;"], [0, "&DownTeeArrow;"], [1, "&hookleftarrow;"], [0, "&hookrightarrow;"], [0, "&larrlp;"], [0, "&looparrowright;"], [0, "&harrw;"], [0, "&nharr;"], [1, "&lsh;"], [0, "&rsh;"], [0, "&ldsh;"], [0, "&rdsh;"], [1, "&crarr;"], [0, "&cularr;"], [0, "&curarr;"], [2, "&circlearrowleft;"], [0, "&circlearrowright;"], [0, "&leftharpoonup;"], [0, "&DownLeftVector;"], [0, "&RightUpVector;"], [0, "&LeftUpVector;"], [0, "&rharu;"], [0, "&DownRightVector;"], [0, "&dharr;"], [0, "&dharl;"], [0, "&RightArrowLeftArrow;"], [0, "&udarr;"], [0, "&LeftArrowRightArrow;"], [0, "&leftleftarrows;"], [0, "&upuparrows;"], [0, "&rightrightarrows;"], [0, "&ddarr;"], [0, "&leftrightharpoons;"], [0, "&Equilibrium;"], [0, "&nlArr;"], [0, "&nhArr;"], [0, "&nrArr;"], [0, "&DoubleLeftArrow;"], [0, "&DoubleUpArrow;"], [0, "&DoubleRightArrow;"], [0, "&dArr;"], [0, "&DoubleLeftRightArrow;"], [0, "&DoubleUpDownArrow;"], [0, "&nwArr;"], [0, "&neArr;"], [0, "&seArr;"], [0, "&swArr;"], [0, "&lAarr;"], [0, "&rAarr;"], [1, "&zigrarr;"], [6, "&larrb;"], [0, "&rarrb;"], [15, "&DownArrowUpArrow;"], [7, "&loarr;"], [0, "&roarr;"], [0, "&hoarr;"], [0, "&forall;"], [0, "&comp;"], [0, { v: "&part;", n: 824, o: "&npart;" }], [0, "&exist;"], [0, "&nexist;"], [0, "&empty;"], [1, "&Del;"], [0, "&Element;"], [0, "&NotElement;"], [1, "&ni;"], [0, "&notni;"], [2, "&prod;"], [0, "&coprod;"], [0, "&sum;"], [0, "&minus;"], [0, "&MinusPlus;"], [0, "&dotplus;"], [1, "&Backslash;"], [0, "&lowast;"], [0, "&compfn;"], [1, "&radic;"], [2, "&prop;"], [0, "&infin;"], [0, "&angrt;"], [0, { v: "&ang;", n: 8402, o: "&nang;" }], [0, "&angmsd;"], [0, "&angsph;"], [0, "&mid;"], [0, "&nmid;"], [0, "&DoubleVerticalBar;"], [0, "&NotDoubleVerticalBar;"], [0, "&and;"], [0, "&or;"], [0, { v: "&cap;", n: 65024, o: "&caps;" }], [0, { v: "&cup;", n: 65024, o: "&cups;" }], [0, "&int;"], [0, "&Int;"], [0, "&iiint;"], [0, "&conint;"], [0, "&Conint;"], [0, "&Cconint;"], [0, "&cwint;"], [0, "&ClockwiseContourIntegral;"], [0, "&awconint;"], [0, "&there4;"], [0, "&becaus;"], [0, "&ratio;"], [0, "&Colon;"], [0, "&dotminus;"], [1, "&mDDot;"], [0, "&homtht;"], [0, { v: "&sim;", n: 8402, o: "&nvsim;" }], [0, { v: "&backsim;", n: 817, o: "&race;" }], [0, { v: "&ac;", n: 819, o: "&acE;" }], [0, "&acd;"], [0, "&VerticalTilde;"], [0, "&NotTilde;"], [0, { v: "&eqsim;", n: 824, o: "&nesim;" }], [0, "&sime;"], [0, "&NotTildeEqual;"], [0, "&cong;"], [0, "&simne;"], [0, "&ncong;"], [0, "&ap;"], [0, "&nap;"], [0, "&ape;"], [0, { v: "&apid;", n: 824, o: "&napid;" }], [0, "&backcong;"], [0, { v: "&asympeq;", n: 8402, o: "&nvap;" }], [0, { v: "&bump;", n: 824, o: "&nbump;" }], [0, { v: "&bumpe;", n: 824, o: "&nbumpe;" }], [0, { v: "&doteq;", n: 824, o: "&nedot;" }], [0, "&doteqdot;"], [0, "&efDot;"], [0, "&erDot;"], [0, "&Assign;"], [0, "&ecolon;"], [0, "&ecir;"], [0, "&circeq;"], [1, "&wedgeq;"], [0, "&veeeq;"], [1, "&triangleq;"], [2, "&equest;"], [0, "&ne;"], [0, { v: "&Congruent;", n: 8421, o: "&bnequiv;" }], [0, "&nequiv;"], [1, { v: "&le;", n: 8402, o: "&nvle;" }], [0, { v: "&ge;", n: 8402, o: "&nvge;" }], [0, { v: "&lE;", n: 824, o: "&nlE;" }], [0, { v: "&gE;", n: 824, o: "&ngE;" }], [0, { v: "&lnE;", n: 65024, o: "&lvertneqq;" }], [0, { v: "&gnE;", n: 65024, o: "&gvertneqq;" }], [0, { v: "&ll;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nLtv;"], [7577, "&nLt;"]])) }], [0, { v: "&gg;", n: new Map(/* @__PURE__ */ restoreDiff([[824, "&nGtv;"], [7577, "&nGt;"]])) }], [0, "&between;"], [0, "&NotCupCap;"], [0, "&nless;"], [0, "&ngt;"], [0, "&nle;"], [0, "&nge;"], [0, "&lesssim;"], [0, "&GreaterTilde;"], [0, "&nlsim;"], [0, "&ngsim;"], [0, "&LessGreater;"], [0, "&gl;"], [0, "&NotLessGreater;"], [0, "&NotGreaterLess;"], [0, "&pr;"], [0, "&sc;"], [0, "&prcue;"], [0, "&sccue;"], [0, "&PrecedesTilde;"], [0, { v: "&scsim;", n: 824, o: "&NotSucceedsTilde;" }], [0, "&NotPrecedes;"], [0, "&NotSucceeds;"], [0, { v: "&sub;", n: 8402, o: "&NotSubset;" }], [0, { v: "&sup;", n: 8402, o: "&NotSuperset;" }], [0, "&nsub;"], [0, "&nsup;"], [0, "&sube;"], [0, "&supe;"], [0, "&NotSubsetEqual;"], [0, "&NotSupersetEqual;"], [0, { v: "&subne;", n: 65024, o: "&varsubsetneq;" }], [0, { v: "&supne;", n: 65024, o: "&varsupsetneq;" }], [1, "&cupdot;"], [0, "&UnionPlus;"], [0, { v: "&sqsub;", n: 824, o: "&NotSquareSubset;" }], [0, { v: "&sqsup;", n: 824, o: "&NotSquareSuperset;" }], [0, "&sqsube;"], [0, "&sqsupe;"], [0, { v: "&sqcap;", n: 65024, o: "&sqcaps;" }], [0, { v: "&sqcup;", n: 65024, o: "&sqcups;" }], [0, "&CirclePlus;"], [0, "&CircleMinus;"], [0, "&CircleTimes;"], [0, "&osol;"], [0, "&CircleDot;"], [0, "&circledcirc;"], [0, "&circledast;"], [1, "&circleddash;"], [0, "&boxplus;"], [0, "&boxminus;"], [0, "&boxtimes;"], [0, "&dotsquare;"], [0, "&RightTee;"], [0, "&dashv;"], [0, "&DownTee;"], [0, "&bot;"], [1, "&models;"], [0, "&DoubleRightTee;"], [0, "&Vdash;"], [0, "&Vvdash;"], [0, "&VDash;"], [0, "&nvdash;"], [0, "&nvDash;"], [0, "&nVdash;"], [0, "&nVDash;"], [0, "&prurel;"], [1, "&LeftTriangle;"], [0, "&RightTriangle;"], [0, { v: "&LeftTriangleEqual;", n: 8402, o: "&nvltrie;" }], [0, { v: "&RightTriangleEqual;", n: 8402, o: "&nvrtrie;" }], [0, "&origof;"], [0, "&imof;"], [0, "&multimap;"], [0, "&hercon;"], [0, "&intcal;"], [0, "&veebar;"], [1, "&barvee;"], [0, "&angrtvb;"], [0, "&lrtri;"], [0, "&bigwedge;"], [0, "&bigvee;"], [0, "&bigcap;"], [0, "&bigcup;"], [0, "&diam;"], [0, "&sdot;"], [0, "&sstarf;"], [0, "&divideontimes;"], [0, "&bowtie;"], [0, "&ltimes;"], [0, "&rtimes;"], [0, "&leftthreetimes;"], [0, "&rightthreetimes;"], [0, "&backsimeq;"], [0, "&curlyvee;"], [0, "&curlywedge;"], [0, "&Sub;"], [0, "&Sup;"], [0, "&Cap;"], [0, "&Cup;"], [0, "&fork;"], [0, "&epar;"], [0, "&lessdot;"], [0, "&gtdot;"], [0, { v: "&Ll;", n: 824, o: "&nLl;" }], [0, { v: "&Gg;", n: 824, o: "&nGg;" }], [0, { v: "&leg;", n: 65024, o: "&lesg;" }], [0, { v: "&gel;", n: 65024, o: "&gesl;" }], [2, "&cuepr;"], [0, "&cuesc;"], [0, "&NotPrecedesSlantEqual;"], [0, "&NotSucceedsSlantEqual;"], [0, "&NotSquareSubsetEqual;"], [0, "&NotSquareSupersetEqual;"], [2, "&lnsim;"], [0, "&gnsim;"], [0, "&precnsim;"], [0, "&scnsim;"], [0, "&nltri;"], [0, "&NotRightTriangle;"], [0, "&nltrie;"], [0, "&NotRightTriangleEqual;"], [0, "&vellip;"], [0, "&ctdot;"], [0, "&utdot;"], [0, "&dtdot;"], [0, "&disin;"], [0, "&isinsv;"], [0, "&isins;"], [0, { v: "&isindot;", n: 824, o: "&notindot;" }], [0, "&notinvc;"], [0, "&notinvb;"], [1, { v: "&isinE;", n: 824, o: "&notinE;" }], [0, "&nisd;"], [0, "&xnis;"], [0, "&nis;"], [0, "&notnivc;"], [0, "&notnivb;"], [6, "&barwed;"], [0, "&Barwed;"], [1, "&lceil;"], [0, "&rceil;"], [0, "&LeftFloor;"], [0, "&rfloor;"], [0, "&drcrop;"], [0, "&dlcrop;"], [0, "&urcrop;"], [0, "&ulcrop;"], [0, "&bnot;"], [1, "&profline;"], [0, "&profsurf;"], [1, "&telrec;"], [0, "&target;"], [5, "&ulcorn;"], [0, "&urcorn;"], [0, "&dlcorn;"], [0, "&drcorn;"], [2, "&frown;"], [0, "&smile;"], [9, "&cylcty;"], [0, "&profalar;"], [7, "&topbot;"], [6, "&ovbar;"], [1, "&solbar;"], [60, "&angzarr;"], [51, "&lmoustache;"], [0, "&rmoustache;"], [2, "&OverBracket;"], [0, "&bbrk;"], [0, "&bbrktbrk;"], [37, "&OverParenthesis;"], [0, "&UnderParenthesis;"], [0, "&OverBrace;"], [0, "&UnderBrace;"], [2, "&trpezium;"], [4, "&elinters;"], [59, "&blank;"], [164, "&circledS;"], [55, "&boxh;"], [1, "&boxv;"], [9, "&boxdr;"], [3, "&boxdl;"], [3, "&boxur;"], [3, "&boxul;"], [3, "&boxvr;"], [7, "&boxvl;"], [7, "&boxhd;"], [7, "&boxhu;"], [7, "&boxvh;"], [19, "&boxH;"], [0, "&boxV;"], [0, "&boxdR;"], [0, "&boxDr;"], [0, "&boxDR;"], [0, "&boxdL;"], [0, "&boxDl;"], [0, "&boxDL;"], [0, "&boxuR;"], [0, "&boxUr;"], [0, "&boxUR;"], [0, "&boxuL;"], [0, "&boxUl;"], [0, "&boxUL;"], [0, "&boxvR;"], [0, "&boxVr;"], [0, "&boxVR;"], [0, "&boxvL;"], [0, "&boxVl;"], [0, "&boxVL;"], [0, "&boxHd;"], [0, "&boxhD;"], [0, "&boxHD;"], [0, "&boxHu;"], [0, "&boxhU;"], [0, "&boxHU;"], [0, "&boxvH;"], [0, "&boxVh;"], [0, "&boxVH;"], [19, "&uhblk;"], [3, "&lhblk;"], [3, "&block;"], [8, "&blk14;"], [0, "&blk12;"], [0, "&blk34;"], [13, "&square;"], [8, "&blacksquare;"], [0, "&EmptyVerySmallSquare;"], [1, "&rect;"], [0, "&marker;"], [2, "&fltns;"], [1, "&bigtriangleup;"], [0, "&blacktriangle;"], [0, "&triangle;"], [2, "&blacktriangleright;"], [0, "&rtri;"], [3, "&bigtriangledown;"], [0, "&blacktriangledown;"], [0, "&dtri;"], [2, "&blacktriangleleft;"], [0, "&ltri;"], [6, "&loz;"], [0, "&cir;"], [32, "&tridot;"], [2, "&bigcirc;"], [8, "&ultri;"], [0, "&urtri;"], [0, "&lltri;"], [0, "&EmptySmallSquare;"], [0, "&FilledSmallSquare;"], [8, "&bigstar;"], [0, "&star;"], [7, "&phone;"], [49, "&female;"], [1, "&male;"], [29, "&spades;"], [2, "&clubs;"], [1, "&hearts;"], [0, "&diamondsuit;"], [3, "&sung;"], [2, "&flat;"], [0, "&natural;"], [0, "&sharp;"], [163, "&check;"], [3, "&cross;"], [8, "&malt;"], [21, "&sext;"], [33, "&VerticalSeparator;"], [25, "&lbbrk;"], [0, "&rbbrk;"], [84, "&bsolhsub;"], [0, "&suphsol;"], [28, "&LeftDoubleBracket;"], [0, "&RightDoubleBracket;"], [0, "&lang;"], [0, "&rang;"], [0, "&Lang;"], [0, "&Rang;"], [0, "&loang;"], [0, "&roang;"], [7, "&longleftarrow;"], [0, "&longrightarrow;"], [0, "&longleftrightarrow;"], [0, "&DoubleLongLeftArrow;"], [0, "&DoubleLongRightArrow;"], [0, "&DoubleLongLeftRightArrow;"], [1, "&longmapsto;"], [2, "&dzigrarr;"], [258, "&nvlArr;"], [0, "&nvrArr;"], [0, "&nvHarr;"], [0, "&Map;"], [6, "&lbarr;"], [0, "&bkarow;"], [0, "&lBarr;"], [0, "&dbkarow;"], [0, "&drbkarow;"], [0, "&DDotrahd;"], [0, "&UpArrowBar;"], [0, "&DownArrowBar;"], [2, "&Rarrtl;"], [2, "&latail;"], [0, "&ratail;"], [0, "&lAtail;"], [0, "&rAtail;"], [0, "&larrfs;"], [0, "&rarrfs;"], [0, "&larrbfs;"], [0, "&rarrbfs;"], [2, "&nwarhk;"], [0, "&nearhk;"], [0, "&hksearow;"], [0, "&hkswarow;"], [0, "&nwnear;"], [0, "&nesear;"], [0, "&seswar;"], [0, "&swnwar;"], [8, { v: "&rarrc;", n: 824, o: "&nrarrc;" }], [1, "&cudarrr;"], [0, "&ldca;"], [0, "&rdca;"], [0, "&cudarrl;"], [0, "&larrpl;"], [2, "&curarrm;"], [0, "&cularrp;"], [7, "&rarrpl;"], [2, "&harrcir;"], [0, "&Uarrocir;"], [0, "&lurdshar;"], [0, "&ldrushar;"], [2, "&LeftRightVector;"], [0, "&RightUpDownVector;"], [0, "&DownLeftRightVector;"], [0, "&LeftUpDownVector;"], [0, "&LeftVectorBar;"], [0, "&RightVectorBar;"], [0, "&RightUpVectorBar;"], [0, "&RightDownVectorBar;"], [0, "&DownLeftVectorBar;"], [0, "&DownRightVectorBar;"], [0, "&LeftUpVectorBar;"], [0, "&LeftDownVectorBar;"], [0, "&LeftTeeVector;"], [0, "&RightTeeVector;"], [0, "&RightUpTeeVector;"], [0, "&RightDownTeeVector;"], [0, "&DownLeftTeeVector;"], [0, "&DownRightTeeVector;"], [0, "&LeftUpTeeVector;"], [0, "&LeftDownTeeVector;"], [0, "&lHar;"], [0, "&uHar;"], [0, "&rHar;"], [0, "&dHar;"], [0, "&luruhar;"], [0, "&ldrdhar;"], [0, "&ruluhar;"], [0, "&rdldhar;"], [0, "&lharul;"], [0, "&llhard;"], [0, "&rharul;"], [0, "&lrhard;"], [0, "&udhar;"], [0, "&duhar;"], [0, "&RoundImplies;"], [0, "&erarr;"], [0, "&simrarr;"], [0, "&larrsim;"], [0, "&rarrsim;"], [0, "&rarrap;"], [0, "&ltlarr;"], [1, "&gtrarr;"], [0, "&subrarr;"], [1, "&suplarr;"], [0, "&lfisht;"], [0, "&rfisht;"], [0, "&ufisht;"], [0, "&dfisht;"], [5, "&lopar;"], [0, "&ropar;"], [4, "&lbrke;"], [0, "&rbrke;"], [0, "&lbrkslu;"], [0, "&rbrksld;"], [0, "&lbrksld;"], [0, "&rbrkslu;"], [0, "&langd;"], [0, "&rangd;"], [0, "&lparlt;"], [0, "&rpargt;"], [0, "&gtlPar;"], [0, "&ltrPar;"], [3, "&vzigzag;"], [1, "&vangrt;"], [0, "&angrtvbd;"], [6, "&ange;"], [0, "&range;"], [0, "&dwangle;"], [0, "&uwangle;"], [0, "&angmsdaa;"], [0, "&angmsdab;"], [0, "&angmsdac;"], [0, "&angmsdad;"], [0, "&angmsdae;"], [0, "&angmsdaf;"], [0, "&angmsdag;"], [0, "&angmsdah;"], [0, "&bemptyv;"], [0, "&demptyv;"], [0, "&cemptyv;"], [0, "&raemptyv;"], [0, "&laemptyv;"], [0, "&ohbar;"], [0, "&omid;"], [0, "&opar;"], [1, "&operp;"], [1, "&olcross;"], [0, "&odsold;"], [1, "&olcir;"], [0, "&ofcir;"], [0, "&olt;"], [0, "&ogt;"], [0, "&cirscir;"], [0, "&cirE;"], [0, "&solb;"], [0, "&bsolb;"], [3, "&boxbox;"], [3, "&trisb;"], [0, "&rtriltri;"], [0, { v: "&LeftTriangleBar;", n: 824, o: "&NotLeftTriangleBar;" }], [0, { v: "&RightTriangleBar;", n: 824, o: "&NotRightTriangleBar;" }], [11, "&iinfin;"], [0, "&infintie;"], [0, "&nvinfin;"], [4, "&eparsl;"], [0, "&smeparsl;"], [0, "&eqvparsl;"], [5, "&blacklozenge;"], [8, "&RuleDelayed;"], [1, "&dsol;"], [9, "&bigodot;"], [0, "&bigoplus;"], [0, "&bigotimes;"], [1, "&biguplus;"], [1, "&bigsqcup;"], [5, "&iiiint;"], [0, "&fpartint;"], [2, "&cirfnint;"], [0, "&awint;"], [0, "&rppolint;"], [0, "&scpolint;"], [0, "&npolint;"], [0, "&pointint;"], [0, "&quatint;"], [0, "&intlarhk;"], [10, "&pluscir;"], [0, "&plusacir;"], [0, "&simplus;"], [0, "&plusdu;"], [0, "&plussim;"], [0, "&plustwo;"], [1, "&mcomma;"], [0, "&minusdu;"], [2, "&loplus;"], [0, "&roplus;"], [0, "&Cross;"], [0, "&timesd;"], [0, "&timesbar;"], [1, "&smashp;"], [0, "&lotimes;"], [0, "&rotimes;"], [0, "&otimesas;"], [0, "&Otimes;"], [0, "&odiv;"], [0, "&triplus;"], [0, "&triminus;"], [0, "&tritime;"], [0, "&intprod;"], [2, "&amalg;"], [0, "&capdot;"], [1, "&ncup;"], [0, "&ncap;"], [0, "&capand;"], [0, "&cupor;"], [0, "&cupcap;"], [0, "&capcup;"], [0, "&cupbrcap;"], [0, "&capbrcup;"], [0, "&cupcup;"], [0, "&capcap;"], [0, "&ccups;"], [0, "&ccaps;"], [2, "&ccupssm;"], [2, "&And;"], [0, "&Or;"], [0, "&andand;"], [0, "&oror;"], [0, "&orslope;"], [0, "&andslope;"], [1, "&andv;"], [0, "&orv;"], [0, "&andd;"], [0, "&ord;"], [1, "&wedbar;"], [6, "&sdote;"], [3, "&simdot;"], [2, { v: "&congdot;", n: 824, o: "&ncongdot;" }], [0, "&easter;"], [0, "&apacir;"], [0, { v: "&apE;", n: 824, o: "&napE;" }], [0, "&eplus;"], [0, "&pluse;"], [0, "&Esim;"], [0, "&Colone;"], [0, "&Equal;"], [1, "&ddotseq;"], [0, "&equivDD;"], [0, "&ltcir;"], [0, "&gtcir;"], [0, "&ltquest;"], [0, "&gtquest;"], [0, { v: "&leqslant;", n: 824, o: "&nleqslant;" }], [0, { v: "&geqslant;", n: 824, o: "&ngeqslant;" }], [0, "&lesdot;"], [0, "&gesdot;"], [0, "&lesdoto;"], [0, "&gesdoto;"], [0, "&lesdotor;"], [0, "&gesdotol;"], [0, "&lap;"], [0, "&gap;"], [0, "&lne;"], [0, "&gne;"], [0, "&lnap;"], [0, "&gnap;"], [0, "&lEg;"], [0, "&gEl;"], [0, "&lsime;"], [0, "&gsime;"], [0, "&lsimg;"], [0, "&gsiml;"], [0, "&lgE;"], [0, "&glE;"], [0, "&lesges;"], [0, "&gesles;"], [0, "&els;"], [0, "&egs;"], [0, "&elsdot;"], [0, "&egsdot;"], [0, "&el;"], [0, "&eg;"], [2, "&siml;"], [0, "&simg;"], [0, "&simlE;"], [0, "&simgE;"], [0, { v: "&LessLess;", n: 824, o: "&NotNestedLessLess;" }], [0, { v: "&GreaterGreater;", n: 824, o: "&NotNestedGreaterGreater;" }], [1, "&glj;"], [0, "&gla;"], [0, "&ltcc;"], [0, "&gtcc;"], [0, "&lescc;"], [0, "&gescc;"], [0, "&smt;"], [0, "&lat;"], [0, { v: "&smte;", n: 65024, o: "&smtes;" }], [0, { v: "&late;", n: 65024, o: "&lates;" }], [0, "&bumpE;"], [0, { v: "&PrecedesEqual;", n: 824, o: "&NotPrecedesEqual;" }], [0, { v: "&sce;", n: 824, o: "&NotSucceedsEqual;" }], [2, "&prE;"], [0, "&scE;"], [0, "&precneqq;"], [0, "&scnE;"], [0, "&prap;"], [0, "&scap;"], [0, "&precnapprox;"], [0, "&scnap;"], [0, "&Pr;"], [0, "&Sc;"], [0, "&subdot;"], [0, "&supdot;"], [0, "&subplus;"], [0, "&supplus;"], [0, "&submult;"], [0, "&supmult;"], [0, "&subedot;"], [0, "&supedot;"], [0, { v: "&subE;", n: 824, o: "&nsubE;" }], [0, { v: "&supE;", n: 824, o: "&nsupE;" }], [0, "&subsim;"], [0, "&supsim;"], [2, { v: "&subnE;", n: 65024, o: "&varsubsetneqq;" }], [0, { v: "&supnE;", n: 65024, o: "&varsupsetneqq;" }], [2, "&csub;"], [0, "&csup;"], [0, "&csube;"], [0, "&csupe;"], [0, "&subsup;"], [0, "&supsub;"], [0, "&subsub;"], [0, "&supsup;"], [0, "&suphsub;"], [0, "&supdsub;"], [0, "&forkv;"], [0, "&topfork;"], [0, "&mlcp;"], [8, "&Dashv;"], [1, "&Vdashl;"], [0, "&Barv;"], [0, "&vBar;"], [0, "&vBarv;"], [1, "&Vbar;"], [0, "&Not;"], [0, "&bNot;"], [0, "&rnmid;"], [0, "&cirmid;"], [0, "&midcir;"], [0, "&topcir;"], [0, "&nhpar;"], [0, "&parsim;"], [9, { v: "&parsl;", n: 8421, o: "&nparsl;" }], [44343, { n: new Map(/* @__PURE__ */ restoreDiff([[56476, "&Ascr;"], [1, "&Cscr;"], [0, "&Dscr;"], [2, "&Gscr;"], [2, "&Jscr;"], [0, "&Kscr;"], [2, "&Nscr;"], [0, "&Oscr;"], [0, "&Pscr;"], [0, "&Qscr;"], [1, "&Sscr;"], [0, "&Tscr;"], [0, "&Uscr;"], [0, "&Vscr;"], [0, "&Wscr;"], [0, "&Xscr;"], [0, "&Yscr;"], [0, "&Zscr;"], [0, "&ascr;"], [0, "&bscr;"], [0, "&cscr;"], [0, "&dscr;"], [1, "&fscr;"], [1, "&hscr;"], [0, "&iscr;"], [0, "&jscr;"], [0, "&kscr;"], [0, "&lscr;"], [0, "&mscr;"], [0, "&nscr;"], [1, "&pscr;"], [0, "&qscr;"], [0, "&rscr;"], [0, "&sscr;"], [0, "&tscr;"], [0, "&uscr;"], [0, "&vscr;"], [0, "&wscr;"], [0, "&xscr;"], [0, "&yscr;"], [0, "&zscr;"], [52, "&Afr;"], [0, "&Bfr;"], [1, "&Dfr;"], [0, "&Efr;"], [0, "&Ffr;"], [0, "&Gfr;"], [2, "&Jfr;"], [0, "&Kfr;"], [0, "&Lfr;"], [0, "&Mfr;"], [0, "&Nfr;"], [0, "&Ofr;"], [0, "&Pfr;"], [0, "&Qfr;"], [1, "&Sfr;"], [0, "&Tfr;"], [0, "&Ufr;"], [0, "&Vfr;"], [0, "&Wfr;"], [0, "&Xfr;"], [0, "&Yfr;"], [1, "&afr;"], [0, "&bfr;"], [0, "&cfr;"], [0, "&dfr;"], [0, "&efr;"], [0, "&ffr;"], [0, "&gfr;"], [0, "&hfr;"], [0, "&ifr;"], [0, "&jfr;"], [0, "&kfr;"], [0, "&lfr;"], [0, "&mfr;"], [0, "&nfr;"], [0, "&ofr;"], [0, "&pfr;"], [0, "&qfr;"], [0, "&rfr;"], [0, "&sfr;"], [0, "&tfr;"], [0, "&ufr;"], [0, "&vfr;"], [0, "&wfr;"], [0, "&xfr;"], [0, "&yfr;"], [0, "&zfr;"], [0, "&Aopf;"], [0, "&Bopf;"], [1, "&Dopf;"], [0, "&Eopf;"], [0, "&Fopf;"], [0, "&Gopf;"], [1, "&Iopf;"], [0, "&Jopf;"], [0, "&Kopf;"], [0, "&Lopf;"], [0, "&Mopf;"], [1, "&Oopf;"], [3, "&Sopf;"], [0, "&Topf;"], [0, "&Uopf;"], [0, "&Vopf;"], [0, "&Wopf;"], [0, "&Xopf;"], [0, "&Yopf;"], [1, "&aopf;"], [0, "&bopf;"], [0, "&copf;"], [0, "&dopf;"], [0, "&eopf;"], [0, "&fopf;"], [0, "&gopf;"], [0, "&hopf;"], [0, "&iopf;"], [0, "&jopf;"], [0, "&kopf;"], [0, "&lopf;"], [0, "&mopf;"], [0, "&nopf;"], [0, "&oopf;"], [0, "&popf;"], [0, "&qopf;"], [0, "&ropf;"], [0, "&sopf;"], [0, "&topf;"], [0, "&uopf;"], [0, "&vopf;"], [0, "&wopf;"], [0, "&xopf;"], [0, "&yopf;"], [0, "&zopf;"]])) }], [8906, "&fflig;"], [0, "&filig;"], [0, "&fllig;"], [0, "&ffilig;"], [0, "&ffllig;"]]));
  }
});

// node_modules/entities/lib/escape.js
var require_escape = __commonJS({
  "node_modules/entities/lib/escape.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.getCodePoint = exports2.xmlReplacer = void 0;
    exports2.xmlReplacer = /["&'<>$\x80-\uFFFF]/g;
    var xmlCodeMap = /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [39, "&apos;"],
      [60, "&lt;"],
      [62, "&gt;"]
    ]);
    exports2.getCodePoint = // eslint-disable-next-line @typescript-eslint/no-unnecessary-condition
    String.prototype.codePointAt != null ? function(str, index) {
      return str.codePointAt(index);
    } : (
      // http://mathiasbynens.be/notes/javascript-encoding#surrogate-formulae
      function(c, index) {
        return (c.charCodeAt(index) & 64512) === 55296 ? (c.charCodeAt(index) - 55296) * 1024 + c.charCodeAt(index + 1) - 56320 + 65536 : c.charCodeAt(index);
      }
    );
    function encodeXML(str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = exports2.xmlReplacer.exec(str)) !== null) {
        var i = match.index;
        var char = str.charCodeAt(i);
        var next = xmlCodeMap.get(char);
        if (next !== void 0) {
          ret += str.substring(lastIdx, i) + next;
          lastIdx = i + 1;
        } else {
          ret += "".concat(str.substring(lastIdx, i), "&#x").concat((0, exports2.getCodePoint)(str, i).toString(16), ";");
          lastIdx = exports2.xmlReplacer.lastIndex += Number((char & 64512) === 55296);
        }
      }
      return ret + str.substr(lastIdx);
    }
    exports2.encodeXML = encodeXML;
    exports2.escape = encodeXML;
    function getEscaper(regex, map) {
      return function escape(data) {
        var match;
        var lastIdx = 0;
        var result = "";
        while (match = regex.exec(data)) {
          if (lastIdx !== match.index) {
            result += data.substring(lastIdx, match.index);
          }
          result += map.get(match[0].charCodeAt(0));
          lastIdx = match.index + 1;
        }
        return result + data.substring(lastIdx);
      };
    }
    exports2.escapeUTF8 = getEscaper(/[&<>'"]/g, xmlCodeMap);
    exports2.escapeAttribute = getEscaper(/["&\u00A0]/g, /* @__PURE__ */ new Map([
      [34, "&quot;"],
      [38, "&amp;"],
      [160, "&nbsp;"]
    ]));
    exports2.escapeText = getEscaper(/[&<>\u00A0]/g, /* @__PURE__ */ new Map([
      [38, "&amp;"],
      [60, "&lt;"],
      [62, "&gt;"],
      [160, "&nbsp;"]
    ]));
  }
});

// node_modules/entities/lib/encode.js
var require_encode = __commonJS({
  "node_modules/entities/lib/encode.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.encodeNonAsciiHTML = exports2.encodeHTML = void 0;
    var encode_html_js_1 = __importDefault(require_encode_html());
    var escape_js_1 = require_escape();
    var htmlReplacer = /[\t\n!-,./:-@[-`\f{-}$\x80-\uFFFF]/g;
    function encodeHTML(data) {
      return encodeHTMLTrieRe(htmlReplacer, data);
    }
    exports2.encodeHTML = encodeHTML;
    function encodeNonAsciiHTML(data) {
      return encodeHTMLTrieRe(escape_js_1.xmlReplacer, data);
    }
    exports2.encodeNonAsciiHTML = encodeNonAsciiHTML;
    function encodeHTMLTrieRe(regExp, str) {
      var ret = "";
      var lastIdx = 0;
      var match;
      while ((match = regExp.exec(str)) !== null) {
        var i = match.index;
        ret += str.substring(lastIdx, i);
        var char = str.charCodeAt(i);
        var next = encode_html_js_1.default.get(char);
        if (typeof next === "object") {
          if (i + 1 < str.length) {
            var nextChar = str.charCodeAt(i + 1);
            var value = typeof next.n === "number" ? next.n === nextChar ? next.o : void 0 : next.n.get(nextChar);
            if (value !== void 0) {
              ret += value;
              lastIdx = regExp.lastIndex += 1;
              continue;
            }
          }
          next = next.v;
        }
        if (next !== void 0) {
          ret += next;
          lastIdx = i + 1;
        } else {
          var cp = (0, escape_js_1.getCodePoint)(str, i);
          ret += "&#x".concat(cp.toString(16), ";");
          lastIdx = regExp.lastIndex += Number(cp !== char);
        }
      }
      return ret + str.substr(lastIdx);
    }
  }
});

// node_modules/entities/lib/index.js
var require_lib3 = __commonJS({
  "node_modules/entities/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.decodeXMLStrict = exports2.decodeHTML5Strict = exports2.decodeHTML4Strict = exports2.decodeHTML5 = exports2.decodeHTML4 = exports2.decodeHTMLAttribute = exports2.decodeHTMLStrict = exports2.decodeHTML = exports2.decodeXML = exports2.DecodingMode = exports2.EntityDecoder = exports2.encodeHTML5 = exports2.encodeHTML4 = exports2.encodeNonAsciiHTML = exports2.encodeHTML = exports2.escapeText = exports2.escapeAttribute = exports2.escapeUTF8 = exports2.escape = exports2.encodeXML = exports2.encode = exports2.decodeStrict = exports2.decode = exports2.EncodingMode = exports2.EntityLevel = void 0;
    var decode_js_1 = require_decode();
    var encode_js_1 = require_encode();
    var escape_js_1 = require_escape();
    var EntityLevel;
    (function(EntityLevel2) {
      EntityLevel2[EntityLevel2["XML"] = 0] = "XML";
      EntityLevel2[EntityLevel2["HTML"] = 1] = "HTML";
    })(EntityLevel = exports2.EntityLevel || (exports2.EntityLevel = {}));
    var EncodingMode;
    (function(EncodingMode2) {
      EncodingMode2[EncodingMode2["UTF8"] = 0] = "UTF8";
      EncodingMode2[EncodingMode2["ASCII"] = 1] = "ASCII";
      EncodingMode2[EncodingMode2["Extensive"] = 2] = "Extensive";
      EncodingMode2[EncodingMode2["Attribute"] = 3] = "Attribute";
      EncodingMode2[EncodingMode2["Text"] = 4] = "Text";
    })(EncodingMode = exports2.EncodingMode || (exports2.EncodingMode = {}));
    function decode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var level = typeof options === "number" ? options : options.level;
      if (level === EntityLevel.HTML) {
        var mode = typeof options === "object" ? options.mode : void 0;
        return (0, decode_js_1.decodeHTML)(data, mode);
      }
      return (0, decode_js_1.decodeXML)(data);
    }
    exports2.decode = decode;
    function decodeStrict(data, options) {
      var _a;
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      (_a = opts.mode) !== null && _a !== void 0 ? _a : opts.mode = decode_js_1.DecodingMode.Strict;
      return decode(data, opts);
    }
    exports2.decodeStrict = decodeStrict;
    function encode(data, options) {
      if (options === void 0) {
        options = EntityLevel.XML;
      }
      var opts = typeof options === "number" ? { level: options } : options;
      if (opts.mode === EncodingMode.UTF8)
        return (0, escape_js_1.escapeUTF8)(data);
      if (opts.mode === EncodingMode.Attribute)
        return (0, escape_js_1.escapeAttribute)(data);
      if (opts.mode === EncodingMode.Text)
        return (0, escape_js_1.escapeText)(data);
      if (opts.level === EntityLevel.HTML) {
        if (opts.mode === EncodingMode.ASCII) {
          return (0, encode_js_1.encodeNonAsciiHTML)(data);
        }
        return (0, encode_js_1.encodeHTML)(data);
      }
      return (0, escape_js_1.encodeXML)(data);
    }
    exports2.encode = encode;
    var escape_js_2 = require_escape();
    Object.defineProperty(exports2, "encodeXML", { enumerable: true, get: function() {
      return escape_js_2.encodeXML;
    } });
    Object.defineProperty(exports2, "escape", { enumerable: true, get: function() {
      return escape_js_2.escape;
    } });
    Object.defineProperty(exports2, "escapeUTF8", { enumerable: true, get: function() {
      return escape_js_2.escapeUTF8;
    } });
    Object.defineProperty(exports2, "escapeAttribute", { enumerable: true, get: function() {
      return escape_js_2.escapeAttribute;
    } });
    Object.defineProperty(exports2, "escapeText", { enumerable: true, get: function() {
      return escape_js_2.escapeText;
    } });
    var encode_js_2 = require_encode();
    Object.defineProperty(exports2, "encodeHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeNonAsciiHTML", { enumerable: true, get: function() {
      return encode_js_2.encodeNonAsciiHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML4", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    Object.defineProperty(exports2, "encodeHTML5", { enumerable: true, get: function() {
      return encode_js_2.encodeHTML;
    } });
    var decode_js_2 = require_decode();
    Object.defineProperty(exports2, "EntityDecoder", { enumerable: true, get: function() {
      return decode_js_2.EntityDecoder;
    } });
    Object.defineProperty(exports2, "DecodingMode", { enumerable: true, get: function() {
      return decode_js_2.DecodingMode;
    } });
    Object.defineProperty(exports2, "decodeXML", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
    Object.defineProperty(exports2, "decodeHTML", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTMLAttribute", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLAttribute;
    } });
    Object.defineProperty(exports2, "decodeHTML4", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML5", { enumerable: true, get: function() {
      return decode_js_2.decodeHTML;
    } });
    Object.defineProperty(exports2, "decodeHTML4Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeHTML5Strict", { enumerable: true, get: function() {
      return decode_js_2.decodeHTMLStrict;
    } });
    Object.defineProperty(exports2, "decodeXMLStrict", { enumerable: true, get: function() {
      return decode_js_2.decodeXML;
    } });
  }
});

// node_modules/dom-serializer/lib/foreignNames.js
var require_foreignNames = __commonJS({
  "node_modules/dom-serializer/lib/foreignNames.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeNames = exports2.elementNames = void 0;
    exports2.elementNames = new Map([
      "altGlyph",
      "altGlyphDef",
      "altGlyphItem",
      "animateColor",
      "animateMotion",
      "animateTransform",
      "clipPath",
      "feBlend",
      "feColorMatrix",
      "feComponentTransfer",
      "feComposite",
      "feConvolveMatrix",
      "feDiffuseLighting",
      "feDisplacementMap",
      "feDistantLight",
      "feDropShadow",
      "feFlood",
      "feFuncA",
      "feFuncB",
      "feFuncG",
      "feFuncR",
      "feGaussianBlur",
      "feImage",
      "feMerge",
      "feMergeNode",
      "feMorphology",
      "feOffset",
      "fePointLight",
      "feSpecularLighting",
      "feSpotLight",
      "feTile",
      "feTurbulence",
      "foreignObject",
      "glyphRef",
      "linearGradient",
      "radialGradient",
      "textPath"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
    exports2.attributeNames = new Map([
      "definitionURL",
      "attributeName",
      "attributeType",
      "baseFrequency",
      "baseProfile",
      "calcMode",
      "clipPathUnits",
      "diffuseConstant",
      "edgeMode",
      "filterUnits",
      "glyphRef",
      "gradientTransform",
      "gradientUnits",
      "kernelMatrix",
      "kernelUnitLength",
      "keyPoints",
      "keySplines",
      "keyTimes",
      "lengthAdjust",
      "limitingConeAngle",
      "markerHeight",
      "markerUnits",
      "markerWidth",
      "maskContentUnits",
      "maskUnits",
      "numOctaves",
      "pathLength",
      "patternContentUnits",
      "patternTransform",
      "patternUnits",
      "pointsAtX",
      "pointsAtY",
      "pointsAtZ",
      "preserveAlpha",
      "preserveAspectRatio",
      "primitiveUnits",
      "refX",
      "refY",
      "repeatCount",
      "repeatDur",
      "requiredExtensions",
      "requiredFeatures",
      "specularConstant",
      "specularExponent",
      "spreadMethod",
      "startOffset",
      "stdDeviation",
      "stitchTiles",
      "surfaceScale",
      "systemLanguage",
      "tableValues",
      "targetX",
      "targetY",
      "textLength",
      "viewBox",
      "viewTarget",
      "xChannelSelector",
      "yChannelSelector",
      "zoomAndPan"
    ].map(function(val) {
      return [val.toLowerCase(), val];
    }));
  }
});

// node_modules/dom-serializer/lib/index.js
var require_lib4 = __commonJS({
  "node_modules/dom-serializer/lib/index.js"(exports2) {
    "use strict";
    var __assign = exports2 && exports2.__assign || function() {
      __assign = Object.assign || function(t2) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
          s = arguments[i];
          for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
            t2[p] = s[p];
        }
        return t2;
      };
      return __assign.apply(this, arguments);
    };
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.render = void 0;
    var ElementType = __importStar(require_lib());
    var entities_1 = require_lib3();
    var foreignNames_js_1 = require_foreignNames();
    var unencodedElements = /* @__PURE__ */ new Set([
      "style",
      "script",
      "xmp",
      "iframe",
      "noembed",
      "noframes",
      "plaintext",
      "noscript"
    ]);
    function replaceQuotes(value) {
      return value.replace(/"/g, "&quot;");
    }
    function formatAttributes(attributes, opts) {
      var _a;
      if (!attributes)
        return;
      var encode = ((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) === false ? replaceQuotes : opts.xmlMode || opts.encodeEntities !== "utf8" ? entities_1.encodeXML : entities_1.escapeAttribute;
      return Object.keys(attributes).map(function(key) {
        var _a2, _b;
        var value = (_a2 = attributes[key]) !== null && _a2 !== void 0 ? _a2 : "";
        if (opts.xmlMode === "foreign") {
          key = (_b = foreignNames_js_1.attributeNames.get(key)) !== null && _b !== void 0 ? _b : key;
        }
        if (!opts.emptyAttrs && !opts.xmlMode && value === "") {
          return key;
        }
        return "".concat(key, '="').concat(encode(value), '"');
      }).join(" ");
    }
    var singleTag = /* @__PURE__ */ new Set([
      "area",
      "base",
      "basefont",
      "br",
      "col",
      "command",
      "embed",
      "frame",
      "hr",
      "img",
      "input",
      "isindex",
      "keygen",
      "link",
      "meta",
      "param",
      "source",
      "track",
      "wbr"
    ]);
    function render(node, options) {
      if (options === void 0) {
        options = {};
      }
      var nodes = "length" in node ? node : [node];
      var output = "";
      for (var i = 0; i < nodes.length; i++) {
        output += renderNode(nodes[i], options);
      }
      return output;
    }
    exports2.render = render;
    exports2.default = render;
    function renderNode(node, options) {
      switch (node.type) {
        case ElementType.Root:
          return render(node.children, options);
        // @ts-expect-error We don't use `Doctype` yet
        case ElementType.Doctype:
        case ElementType.Directive:
          return renderDirective(node);
        case ElementType.Comment:
          return renderComment(node);
        case ElementType.CDATA:
          return renderCdata(node);
        case ElementType.Script:
        case ElementType.Style:
        case ElementType.Tag:
          return renderTag(node, options);
        case ElementType.Text:
          return renderText(node, options);
      }
    }
    var foreignModeIntegrationPoints = /* @__PURE__ */ new Set([
      "mi",
      "mo",
      "mn",
      "ms",
      "mtext",
      "annotation-xml",
      "foreignObject",
      "desc",
      "title"
    ]);
    var foreignElements = /* @__PURE__ */ new Set(["svg", "math"]);
    function renderTag(elem, opts) {
      var _a;
      if (opts.xmlMode === "foreign") {
        elem.name = (_a = foreignNames_js_1.elementNames.get(elem.name)) !== null && _a !== void 0 ? _a : elem.name;
        if (elem.parent && foreignModeIntegrationPoints.has(elem.parent.name)) {
          opts = __assign(__assign({}, opts), { xmlMode: false });
        }
      }
      if (!opts.xmlMode && foreignElements.has(elem.name)) {
        opts = __assign(__assign({}, opts), { xmlMode: "foreign" });
      }
      var tag = "<".concat(elem.name);
      var attribs = formatAttributes(elem.attribs, opts);
      if (attribs) {
        tag += " ".concat(attribs);
      }
      if (elem.children.length === 0 && (opts.xmlMode ? (
        // In XML mode or foreign mode, and user hasn't explicitly turned off self-closing tags
        opts.selfClosingTags !== false
      ) : (
        // User explicitly asked for self-closing tags, even in HTML mode
        opts.selfClosingTags && singleTag.has(elem.name)
      ))) {
        if (!opts.xmlMode)
          tag += " ";
        tag += "/>";
      } else {
        tag += ">";
        if (elem.children.length > 0) {
          tag += render(elem.children, opts);
        }
        if (opts.xmlMode || !singleTag.has(elem.name)) {
          tag += "</".concat(elem.name, ">");
        }
      }
      return tag;
    }
    function renderDirective(elem) {
      return "<".concat(elem.data, ">");
    }
    function renderText(elem, opts) {
      var _a;
      var data = elem.data || "";
      if (((_a = opts.encodeEntities) !== null && _a !== void 0 ? _a : opts.decodeEntities) !== false && !(!opts.xmlMode && elem.parent && unencodedElements.has(elem.parent.name))) {
        data = opts.xmlMode || opts.encodeEntities !== "utf8" ? (0, entities_1.encodeXML)(data) : (0, entities_1.escapeText)(data);
      }
      return data;
    }
    function renderCdata(elem) {
      return "<![CDATA[".concat(elem.children[0].data, "]]>");
    }
    function renderComment(elem) {
      return "<!--".concat(elem.data, "-->");
    }
  }
});

// node_modules/domutils/lib/stringify.js
var require_stringify = __commonJS({
  "node_modules/domutils/lib/stringify.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getOuterHTML = getOuterHTML;
    exports2.getInnerHTML = getInnerHTML;
    exports2.getText = getText;
    exports2.textContent = textContent;
    exports2.innerText = innerText;
    var domhandler_1 = require_lib2();
    var dom_serializer_1 = __importDefault(require_lib4());
    var domelementtype_1 = require_lib();
    function getOuterHTML(node, options) {
      return (0, dom_serializer_1.default)(node, options);
    }
    function getInnerHTML(node, options) {
      return (0, domhandler_1.hasChildren)(node) ? node.children.map(function(node2) {
        return getOuterHTML(node2, options);
      }).join("") : "";
    }
    function getText(node) {
      if (Array.isArray(node))
        return node.map(getText).join("");
      if ((0, domhandler_1.isTag)(node))
        return node.name === "br" ? "\n" : getText(node.children);
      if ((0, domhandler_1.isCDATA)(node))
        return getText(node.children);
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    function textContent(node) {
      if (Array.isArray(node))
        return node.map(textContent).join("");
      if ((0, domhandler_1.hasChildren)(node) && !(0, domhandler_1.isComment)(node)) {
        return textContent(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
    function innerText(node) {
      if (Array.isArray(node))
        return node.map(innerText).join("");
      if ((0, domhandler_1.hasChildren)(node) && (node.type === domelementtype_1.ElementType.Tag || (0, domhandler_1.isCDATA)(node))) {
        return innerText(node.children);
      }
      if ((0, domhandler_1.isText)(node))
        return node.data;
      return "";
    }
  }
});

// node_modules/domutils/lib/traversal.js
var require_traversal = __commonJS({
  "node_modules/domutils/lib/traversal.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getChildren = getChildren;
    exports2.getParent = getParent;
    exports2.getSiblings = getSiblings;
    exports2.getAttributeValue = getAttributeValue;
    exports2.hasAttrib = hasAttrib;
    exports2.getName = getName;
    exports2.nextElementSibling = nextElementSibling;
    exports2.prevElementSibling = prevElementSibling;
    var domhandler_1 = require_lib2();
    function getChildren(elem) {
      return (0, domhandler_1.hasChildren)(elem) ? elem.children : [];
    }
    function getParent(elem) {
      return elem.parent || null;
    }
    function getSiblings(elem) {
      var _a, _b;
      var parent = getParent(elem);
      if (parent != null)
        return getChildren(parent);
      var siblings = [elem];
      var prev = elem.prev, next = elem.next;
      while (prev != null) {
        siblings.unshift(prev);
        _a = prev, prev = _a.prev;
      }
      while (next != null) {
        siblings.push(next);
        _b = next, next = _b.next;
      }
      return siblings;
    }
    function getAttributeValue(elem, name) {
      var _a;
      return (_a = elem.attribs) === null || _a === void 0 ? void 0 : _a[name];
    }
    function hasAttrib(elem, name) {
      return elem.attribs != null && Object.prototype.hasOwnProperty.call(elem.attribs, name) && elem.attribs[name] != null;
    }
    function getName(elem) {
      return elem.name;
    }
    function nextElementSibling(elem) {
      var _a;
      var next = elem.next;
      while (next !== null && !(0, domhandler_1.isTag)(next))
        _a = next, next = _a.next;
      return next;
    }
    function prevElementSibling(elem) {
      var _a;
      var prev = elem.prev;
      while (prev !== null && !(0, domhandler_1.isTag)(prev))
        _a = prev, prev = _a.prev;
      return prev;
    }
  }
});

// node_modules/domutils/lib/manipulation.js
var require_manipulation = __commonJS({
  "node_modules/domutils/lib/manipulation.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.removeElement = removeElement;
    exports2.replaceElement = replaceElement;
    exports2.appendChild = appendChild;
    exports2.append = append;
    exports2.prependChild = prependChild;
    exports2.prepend = prepend;
    function removeElement(elem) {
      if (elem.prev)
        elem.prev.next = elem.next;
      if (elem.next)
        elem.next.prev = elem.prev;
      if (elem.parent) {
        var childs = elem.parent.children;
        var childsIndex = childs.lastIndexOf(elem);
        if (childsIndex >= 0) {
          childs.splice(childsIndex, 1);
        }
      }
      elem.next = null;
      elem.prev = null;
      elem.parent = null;
    }
    function replaceElement(elem, replacement) {
      var prev = replacement.prev = elem.prev;
      if (prev) {
        prev.next = replacement;
      }
      var next = replacement.next = elem.next;
      if (next) {
        next.prev = replacement;
      }
      var parent = replacement.parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs[childs.lastIndexOf(elem)] = replacement;
        elem.parent = null;
      }
    }
    function appendChild(parent, child) {
      removeElement(child);
      child.next = null;
      child.parent = parent;
      if (parent.children.push(child) > 1) {
        var sibling = parent.children[parent.children.length - 2];
        sibling.next = child;
        child.prev = sibling;
      } else {
        child.prev = null;
      }
    }
    function append(elem, next) {
      removeElement(next);
      var parent = elem.parent;
      var currNext = elem.next;
      next.next = currNext;
      next.prev = elem;
      elem.next = next;
      next.parent = parent;
      if (currNext) {
        currNext.prev = next;
        if (parent) {
          var childs = parent.children;
          childs.splice(childs.lastIndexOf(currNext), 0, next);
        }
      } else if (parent) {
        parent.children.push(next);
      }
    }
    function prependChild(parent, child) {
      removeElement(child);
      child.parent = parent;
      child.prev = null;
      if (parent.children.unshift(child) !== 1) {
        var sibling = parent.children[1];
        sibling.prev = child;
        child.next = sibling;
      } else {
        child.next = null;
      }
    }
    function prepend(elem, prev) {
      removeElement(prev);
      var parent = elem.parent;
      if (parent) {
        var childs = parent.children;
        childs.splice(childs.indexOf(elem), 0, prev);
      }
      if (elem.prev) {
        elem.prev.next = prev;
      }
      prev.parent = parent;
      prev.prev = elem.prev;
      prev.next = elem;
      elem.prev = prev;
    }
  }
});

// node_modules/domutils/lib/querying.js
var require_querying = __commonJS({
  "node_modules/domutils/lib/querying.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filter = filter;
    exports2.find = find;
    exports2.findOneChild = findOneChild;
    exports2.findOne = findOne;
    exports2.existsOne = existsOne;
    exports2.findAll = findAll;
    var domhandler_1 = require_lib2();
    function filter(test, node, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return find(test, Array.isArray(node) ? node : [node], recurse, limit);
    }
    function find(test, nodes, recurse, limit) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (indexStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if (test(elem)) {
          result.push(elem);
          if (--limit <= 0)
            return result;
        }
        if (recurse && (0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
    function findOneChild(test, nodes) {
      return nodes.find(test);
    }
    function findOne(test, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      var searchedNodes = Array.isArray(nodes) ? nodes : [nodes];
      for (var i = 0; i < searchedNodes.length; i++) {
        var node = searchedNodes[i];
        if ((0, domhandler_1.isTag)(node) && test(node)) {
          return node;
        }
        if (recurse && (0, domhandler_1.hasChildren)(node) && node.children.length > 0) {
          var found = findOne(test, node.children, true);
          if (found)
            return found;
        }
      }
      return null;
    }
    function existsOne(test, nodes) {
      return (Array.isArray(nodes) ? nodes : [nodes]).some(function(node) {
        return (0, domhandler_1.isTag)(node) && test(node) || (0, domhandler_1.hasChildren)(node) && existsOne(test, node.children);
      });
    }
    function findAll(test, nodes) {
      var result = [];
      var nodeStack = [Array.isArray(nodes) ? nodes : [nodes]];
      var indexStack = [0];
      for (; ; ) {
        if (indexStack[0] >= nodeStack[0].length) {
          if (nodeStack.length === 1) {
            return result;
          }
          nodeStack.shift();
          indexStack.shift();
          continue;
        }
        var elem = nodeStack[0][indexStack[0]++];
        if ((0, domhandler_1.isTag)(elem) && test(elem))
          result.push(elem);
        if ((0, domhandler_1.hasChildren)(elem) && elem.children.length > 0) {
          indexStack.unshift(0);
          nodeStack.unshift(elem.children);
        }
      }
    }
  }
});

// node_modules/domutils/lib/legacy.js
var require_legacy = __commonJS({
  "node_modules/domutils/lib/legacy.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.testElement = testElement;
    exports2.getElements = getElements;
    exports2.getElementById = getElementById;
    exports2.getElementsByTagName = getElementsByTagName;
    exports2.getElementsByClassName = getElementsByClassName;
    exports2.getElementsByTagType = getElementsByTagType;
    var domhandler_1 = require_lib2();
    var querying_js_1 = require_querying();
    var Checks = {
      tag_name: function(name) {
        if (typeof name === "function") {
          return function(elem) {
            return (0, domhandler_1.isTag)(elem) && name(elem.name);
          };
        } else if (name === "*") {
          return domhandler_1.isTag;
        }
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && elem.name === name;
        };
      },
      tag_type: function(type) {
        if (typeof type === "function") {
          return function(elem) {
            return type(elem.type);
          };
        }
        return function(elem) {
          return elem.type === type;
        };
      },
      tag_contains: function(data) {
        if (typeof data === "function") {
          return function(elem) {
            return (0, domhandler_1.isText)(elem) && data(elem.data);
          };
        }
        return function(elem) {
          return (0, domhandler_1.isText)(elem) && elem.data === data;
        };
      }
    };
    function getAttribCheck(attrib, value) {
      if (typeof value === "function") {
        return function(elem) {
          return (0, domhandler_1.isTag)(elem) && value(elem.attribs[attrib]);
        };
      }
      return function(elem) {
        return (0, domhandler_1.isTag)(elem) && elem.attribs[attrib] === value;
      };
    }
    function combineFuncs(a, b) {
      return function(elem) {
        return a(elem) || b(elem);
      };
    }
    function compileTest(options) {
      var funcs = Object.keys(options).map(function(key) {
        var value = options[key];
        return Object.prototype.hasOwnProperty.call(Checks, key) ? Checks[key](value) : getAttribCheck(key, value);
      });
      return funcs.length === 0 ? null : funcs.reduce(combineFuncs);
    }
    function testElement(options, node) {
      var test = compileTest(options);
      return test ? test(node) : true;
    }
    function getElements(options, nodes, recurse, limit) {
      if (limit === void 0) {
        limit = Infinity;
      }
      var test = compileTest(options);
      return test ? (0, querying_js_1.filter)(test, nodes, recurse, limit) : [];
    }
    function getElementById(id, nodes, recurse) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (!Array.isArray(nodes))
        nodes = [nodes];
      return (0, querying_js_1.findOne)(getAttribCheck("id", id), nodes, recurse);
    }
    function getElementsByTagName(tagName, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_name"](tagName), nodes, recurse, limit);
    }
    function getElementsByClassName(className, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(getAttribCheck("class", className), nodes, recurse, limit);
    }
    function getElementsByTagType(type, nodes, recurse, limit) {
      if (recurse === void 0) {
        recurse = true;
      }
      if (limit === void 0) {
        limit = Infinity;
      }
      return (0, querying_js_1.filter)(Checks["tag_type"](type), nodes, recurse, limit);
    }
  }
});

// node_modules/domutils/lib/helpers.js
var require_helpers = __commonJS({
  "node_modules/domutils/lib/helpers.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.DocumentPosition = void 0;
    exports2.removeSubsets = removeSubsets;
    exports2.compareDocumentPosition = compareDocumentPosition;
    exports2.uniqueSort = uniqueSort;
    var domhandler_1 = require_lib2();
    function removeSubsets(nodes) {
      var idx = nodes.length;
      while (--idx >= 0) {
        var node = nodes[idx];
        if (idx > 0 && nodes.lastIndexOf(node, idx - 1) >= 0) {
          nodes.splice(idx, 1);
          continue;
        }
        for (var ancestor = node.parent; ancestor; ancestor = ancestor.parent) {
          if (nodes.includes(ancestor)) {
            nodes.splice(idx, 1);
            break;
          }
        }
      }
      return nodes;
    }
    var DocumentPosition;
    (function(DocumentPosition2) {
      DocumentPosition2[DocumentPosition2["DISCONNECTED"] = 1] = "DISCONNECTED";
      DocumentPosition2[DocumentPosition2["PRECEDING"] = 2] = "PRECEDING";
      DocumentPosition2[DocumentPosition2["FOLLOWING"] = 4] = "FOLLOWING";
      DocumentPosition2[DocumentPosition2["CONTAINS"] = 8] = "CONTAINS";
      DocumentPosition2[DocumentPosition2["CONTAINED_BY"] = 16] = "CONTAINED_BY";
    })(DocumentPosition || (exports2.DocumentPosition = DocumentPosition = {}));
    function compareDocumentPosition(nodeA, nodeB) {
      var aParents = [];
      var bParents = [];
      if (nodeA === nodeB) {
        return 0;
      }
      var current = (0, domhandler_1.hasChildren)(nodeA) ? nodeA : nodeA.parent;
      while (current) {
        aParents.unshift(current);
        current = current.parent;
      }
      current = (0, domhandler_1.hasChildren)(nodeB) ? nodeB : nodeB.parent;
      while (current) {
        bParents.unshift(current);
        current = current.parent;
      }
      var maxIdx = Math.min(aParents.length, bParents.length);
      var idx = 0;
      while (idx < maxIdx && aParents[idx] === bParents[idx]) {
        idx++;
      }
      if (idx === 0) {
        return DocumentPosition.DISCONNECTED;
      }
      var sharedParent = aParents[idx - 1];
      var siblings = sharedParent.children;
      var aSibling = aParents[idx];
      var bSibling = bParents[idx];
      if (siblings.indexOf(aSibling) > siblings.indexOf(bSibling)) {
        if (sharedParent === nodeB) {
          return DocumentPosition.FOLLOWING | DocumentPosition.CONTAINED_BY;
        }
        return DocumentPosition.FOLLOWING;
      }
      if (sharedParent === nodeA) {
        return DocumentPosition.PRECEDING | DocumentPosition.CONTAINS;
      }
      return DocumentPosition.PRECEDING;
    }
    function uniqueSort(nodes) {
      nodes = nodes.filter(function(node, i, arr) {
        return !arr.includes(node, i + 1);
      });
      nodes.sort(function(a, b) {
        var relative10 = compareDocumentPosition(a, b);
        if (relative10 & DocumentPosition.PRECEDING) {
          return -1;
        } else if (relative10 & DocumentPosition.FOLLOWING) {
          return 1;
        }
        return 0;
      });
      return nodes;
    }
  }
});

// node_modules/domutils/lib/feeds.js
var require_feeds = __commonJS({
  "node_modules/domutils/lib/feeds.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.getFeed = getFeed;
    var stringify_js_1 = require_stringify();
    var legacy_js_1 = require_legacy();
    function getFeed(doc) {
      var feedRoot = getOneElement(isValidFeed, doc);
      return !feedRoot ? null : feedRoot.name === "feed" ? getAtomFeed(feedRoot) : getRssFeed(feedRoot);
    }
    function getAtomFeed(feedRoot) {
      var _a;
      var childs = feedRoot.children;
      var feed = {
        type: "atom",
        items: (0, legacy_js_1.getElementsByTagName)("entry", childs).map(function(item) {
          var _a2;
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "id", children);
          addConditionally(entry, "title", "title", children);
          var href2 = (_a2 = getOneElement("link", children)) === null || _a2 === void 0 ? void 0 : _a2.attribs["href"];
          if (href2) {
            entry.link = href2;
          }
          var description = fetch("summary", children) || fetch("content", children);
          if (description) {
            entry.description = description;
          }
          var pubDate = fetch("updated", children);
          if (pubDate) {
            entry.pubDate = new Date(pubDate);
          }
          return entry;
        })
      };
      addConditionally(feed, "id", "id", childs);
      addConditionally(feed, "title", "title", childs);
      var href = (_a = getOneElement("link", childs)) === null || _a === void 0 ? void 0 : _a.attribs["href"];
      if (href) {
        feed.link = href;
      }
      addConditionally(feed, "description", "subtitle", childs);
      var updated = fetch("updated", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "email", childs, true);
      return feed;
    }
    function getRssFeed(feedRoot) {
      var _a, _b;
      var childs = (_b = (_a = getOneElement("channel", feedRoot.children)) === null || _a === void 0 ? void 0 : _a.children) !== null && _b !== void 0 ? _b : [];
      var feed = {
        type: feedRoot.name.substr(0, 3),
        id: "",
        items: (0, legacy_js_1.getElementsByTagName)("item", feedRoot.children).map(function(item) {
          var children = item.children;
          var entry = { media: getMediaElements(children) };
          addConditionally(entry, "id", "guid", children);
          addConditionally(entry, "title", "title", children);
          addConditionally(entry, "link", "link", children);
          addConditionally(entry, "description", "description", children);
          var pubDate = fetch("pubDate", children) || fetch("dc:date", children);
          if (pubDate)
            entry.pubDate = new Date(pubDate);
          return entry;
        })
      };
      addConditionally(feed, "title", "title", childs);
      addConditionally(feed, "link", "link", childs);
      addConditionally(feed, "description", "description", childs);
      var updated = fetch("lastBuildDate", childs);
      if (updated) {
        feed.updated = new Date(updated);
      }
      addConditionally(feed, "author", "managingEditor", childs, true);
      return feed;
    }
    var MEDIA_KEYS_STRING = ["url", "type", "lang"];
    var MEDIA_KEYS_INT = [
      "fileSize",
      "bitrate",
      "framerate",
      "samplingrate",
      "channels",
      "duration",
      "height",
      "width"
    ];
    function getMediaElements(where) {
      return (0, legacy_js_1.getElementsByTagName)("media:content", where).map(function(elem) {
        var attribs = elem.attribs;
        var media = {
          medium: attribs["medium"],
          isDefault: !!attribs["isDefault"]
        };
        for (var _i = 0, MEDIA_KEYS_STRING_1 = MEDIA_KEYS_STRING; _i < MEDIA_KEYS_STRING_1.length; _i++) {
          var attrib = MEDIA_KEYS_STRING_1[_i];
          if (attribs[attrib]) {
            media[attrib] = attribs[attrib];
          }
        }
        for (var _a = 0, MEDIA_KEYS_INT_1 = MEDIA_KEYS_INT; _a < MEDIA_KEYS_INT_1.length; _a++) {
          var attrib = MEDIA_KEYS_INT_1[_a];
          if (attribs[attrib]) {
            media[attrib] = parseInt(attribs[attrib], 10);
          }
        }
        if (attribs["expression"]) {
          media.expression = attribs["expression"];
        }
        return media;
      });
    }
    function getOneElement(tagName, node) {
      return (0, legacy_js_1.getElementsByTagName)(tagName, node, true, 1)[0];
    }
    function fetch(tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      return (0, stringify_js_1.textContent)((0, legacy_js_1.getElementsByTagName)(tagName, where, recurse, 1)).trim();
    }
    function addConditionally(obj, prop, tagName, where, recurse) {
      if (recurse === void 0) {
        recurse = false;
      }
      var val = fetch(tagName, where, recurse);
      if (val)
        obj[prop] = val;
    }
    function isValidFeed(value) {
      return value === "rss" || value === "feed" || value === "rdf:RDF";
    }
  }
});

// node_modules/domutils/lib/index.js
var require_lib5 = __commonJS({
  "node_modules/domutils/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.hasChildren = exports2.isDocument = exports2.isComment = exports2.isText = exports2.isCDATA = exports2.isTag = void 0;
    __exportStar(require_stringify(), exports2);
    __exportStar(require_traversal(), exports2);
    __exportStar(require_manipulation(), exports2);
    __exportStar(require_querying(), exports2);
    __exportStar(require_legacy(), exports2);
    __exportStar(require_helpers(), exports2);
    __exportStar(require_feeds(), exports2);
    var domhandler_1 = require_lib2();
    Object.defineProperty(exports2, "isTag", { enumerable: true, get: function() {
      return domhandler_1.isTag;
    } });
    Object.defineProperty(exports2, "isCDATA", { enumerable: true, get: function() {
      return domhandler_1.isCDATA;
    } });
    Object.defineProperty(exports2, "isText", { enumerable: true, get: function() {
      return domhandler_1.isText;
    } });
    Object.defineProperty(exports2, "isComment", { enumerable: true, get: function() {
      return domhandler_1.isComment;
    } });
    Object.defineProperty(exports2, "isDocument", { enumerable: true, get: function() {
      return domhandler_1.isDocument;
    } });
    Object.defineProperty(exports2, "hasChildren", { enumerable: true, get: function() {
      return domhandler_1.hasChildren;
    } });
  }
});

// node_modules/boolbase/index.js
var require_boolbase = __commonJS({
  "node_modules/boolbase/index.js"(exports2, module2) {
    module2.exports = {
      trueFunc: function trueFunc() {
        return true;
      },
      falseFunc: function falseFunc() {
        return false;
      }
    };
  }
});

// node_modules/css-what/lib/commonjs/types.js
var require_types = __commonJS({
  "node_modules/css-what/lib/commonjs/types.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.AttributeAction = exports2.IgnoreCaseMode = exports2.SelectorType = void 0;
    var SelectorType;
    (function(SelectorType2) {
      SelectorType2["Attribute"] = "attribute";
      SelectorType2["Pseudo"] = "pseudo";
      SelectorType2["PseudoElement"] = "pseudo-element";
      SelectorType2["Tag"] = "tag";
      SelectorType2["Universal"] = "universal";
      SelectorType2["Adjacent"] = "adjacent";
      SelectorType2["Child"] = "child";
      SelectorType2["Descendant"] = "descendant";
      SelectorType2["Parent"] = "parent";
      SelectorType2["Sibling"] = "sibling";
      SelectorType2["ColumnCombinator"] = "column-combinator";
    })(SelectorType = exports2.SelectorType || (exports2.SelectorType = {}));
    exports2.IgnoreCaseMode = {
      Unknown: null,
      QuirksMode: "quirks",
      IgnoreCase: true,
      CaseSensitive: false
    };
    var AttributeAction;
    (function(AttributeAction2) {
      AttributeAction2["Any"] = "any";
      AttributeAction2["Element"] = "element";
      AttributeAction2["End"] = "end";
      AttributeAction2["Equals"] = "equals";
      AttributeAction2["Exists"] = "exists";
      AttributeAction2["Hyphen"] = "hyphen";
      AttributeAction2["Not"] = "not";
      AttributeAction2["Start"] = "start";
    })(AttributeAction = exports2.AttributeAction || (exports2.AttributeAction = {}));
  }
});

// node_modules/css-what/lib/commonjs/parse.js
var require_parse = __commonJS({
  "node_modules/css-what/lib/commonjs/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = exports2.isTraversal = void 0;
    var types_1 = require_types();
    var reName = /^[^\\#]?(?:\\(?:[\da-f]{1,6}\s?|.)|[\w\-\u00b0-\uFFFF])+/;
    var reEscape = /\\([\da-f]{1,6}\s?|(\s)|.)/gi;
    var actionTypes = /* @__PURE__ */ new Map([
      [126, types_1.AttributeAction.Element],
      [94, types_1.AttributeAction.Start],
      [36, types_1.AttributeAction.End],
      [42, types_1.AttributeAction.Any],
      [33, types_1.AttributeAction.Not],
      [124, types_1.AttributeAction.Hyphen]
    ]);
    var unpackPseudos = /* @__PURE__ */ new Set([
      "has",
      "not",
      "matches",
      "is",
      "where",
      "host",
      "host-context"
    ]);
    function isTraversal(selector) {
      switch (selector.type) {
        case types_1.SelectorType.Adjacent:
        case types_1.SelectorType.Child:
        case types_1.SelectorType.Descendant:
        case types_1.SelectorType.Parent:
        case types_1.SelectorType.Sibling:
        case types_1.SelectorType.ColumnCombinator:
          return true;
        default:
          return false;
      }
    }
    exports2.isTraversal = isTraversal;
    var stripQuotesFromPseudos = /* @__PURE__ */ new Set(["contains", "icontains"]);
    function funescape(_, escaped, escapedWhitespace) {
      var high = parseInt(escaped, 16) - 65536;
      return high !== high || escapedWhitespace ? escaped : high < 0 ? (
        // BMP codepoint
        String.fromCharCode(high + 65536)
      ) : (
        // Supplemental Plane codepoint (surrogate pair)
        String.fromCharCode(high >> 10 | 55296, high & 1023 | 56320)
      );
    }
    function unescapeCSS(str) {
      return str.replace(reEscape, funescape);
    }
    function isQuote(c) {
      return c === 39 || c === 34;
    }
    function isWhitespace(c) {
      return c === 32 || c === 9 || c === 10 || c === 12 || c === 13;
    }
    function parse(selector) {
      var subselects = [];
      var endIndex = parseSelector(subselects, "".concat(selector), 0);
      if (endIndex < selector.length) {
        throw new Error("Unmatched selector: ".concat(selector.slice(endIndex)));
      }
      return subselects;
    }
    exports2.parse = parse;
    function parseSelector(subselects, selector, selectorIndex) {
      var tokens = [];
      function getName(offset) {
        var match = selector.slice(selectorIndex + offset).match(reName);
        if (!match) {
          throw new Error("Expected name, found ".concat(selector.slice(selectorIndex)));
        }
        var name = match[0];
        selectorIndex += offset + name.length;
        return unescapeCSS(name);
      }
      function stripWhitespace(offset) {
        selectorIndex += offset;
        while (selectorIndex < selector.length && isWhitespace(selector.charCodeAt(selectorIndex))) {
          selectorIndex++;
        }
      }
      function readValueWithParenthesis() {
        selectorIndex += 1;
        var start = selectorIndex;
        var counter = 1;
        for (; counter > 0 && selectorIndex < selector.length; selectorIndex++) {
          if (selector.charCodeAt(selectorIndex) === 40 && !isEscaped(selectorIndex)) {
            counter++;
          } else if (selector.charCodeAt(selectorIndex) === 41 && !isEscaped(selectorIndex)) {
            counter--;
          }
        }
        if (counter) {
          throw new Error("Parenthesis not matched");
        }
        return unescapeCSS(selector.slice(start, selectorIndex - 1));
      }
      function isEscaped(pos) {
        var slashCount = 0;
        while (selector.charCodeAt(--pos) === 92)
          slashCount++;
        return (slashCount & 1) === 1;
      }
      function ensureNotTraversal() {
        if (tokens.length > 0 && isTraversal(tokens[tokens.length - 1])) {
          throw new Error("Did not expect successive traversals.");
        }
      }
      function addTraversal(type) {
        if (tokens.length > 0 && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens[tokens.length - 1].type = type;
          return;
        }
        ensureNotTraversal();
        tokens.push({ type });
      }
      function addSpecialAttribute(name, action2) {
        tokens.push({
          type: types_1.SelectorType.Attribute,
          name,
          action: action2,
          value: getName(1),
          namespace: null,
          ignoreCase: "quirks"
        });
      }
      function finalizeSubselector() {
        if (tokens.length && tokens[tokens.length - 1].type === types_1.SelectorType.Descendant) {
          tokens.pop();
        }
        if (tokens.length === 0) {
          throw new Error("Empty sub-selector");
        }
        subselects.push(tokens);
      }
      stripWhitespace(0);
      if (selector.length === selectorIndex) {
        return selectorIndex;
      }
      loop: while (selectorIndex < selector.length) {
        var firstChar = selector.charCodeAt(selectorIndex);
        switch (firstChar) {
          // Whitespace
          case 32:
          case 9:
          case 10:
          case 12:
          case 13: {
            if (tokens.length === 0 || tokens[0].type !== types_1.SelectorType.Descendant) {
              ensureNotTraversal();
              tokens.push({ type: types_1.SelectorType.Descendant });
            }
            stripWhitespace(1);
            break;
          }
          // Traversals
          case 62: {
            addTraversal(types_1.SelectorType.Child);
            stripWhitespace(1);
            break;
          }
          case 60: {
            addTraversal(types_1.SelectorType.Parent);
            stripWhitespace(1);
            break;
          }
          case 126: {
            addTraversal(types_1.SelectorType.Sibling);
            stripWhitespace(1);
            break;
          }
          case 43: {
            addTraversal(types_1.SelectorType.Adjacent);
            stripWhitespace(1);
            break;
          }
          // Special attribute selectors: .class, #id
          case 46: {
            addSpecialAttribute("class", types_1.AttributeAction.Element);
            break;
          }
          case 35: {
            addSpecialAttribute("id", types_1.AttributeAction.Equals);
            break;
          }
          case 91: {
            stripWhitespace(1);
            var name_1 = void 0;
            var namespace = null;
            if (selector.charCodeAt(selectorIndex) === 124) {
              name_1 = getName(1);
            } else if (selector.startsWith("*|", selectorIndex)) {
              namespace = "*";
              name_1 = getName(2);
            } else {
              name_1 = getName(0);
              if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 61) {
                namespace = name_1;
                name_1 = getName(1);
              }
            }
            stripWhitespace(0);
            var action = types_1.AttributeAction.Exists;
            var possibleAction = actionTypes.get(selector.charCodeAt(selectorIndex));
            if (possibleAction) {
              action = possibleAction;
              if (selector.charCodeAt(selectorIndex + 1) !== 61) {
                throw new Error("Expected `=`");
              }
              stripWhitespace(2);
            } else if (selector.charCodeAt(selectorIndex) === 61) {
              action = types_1.AttributeAction.Equals;
              stripWhitespace(1);
            }
            var value = "";
            var ignoreCase = null;
            if (action !== "exists") {
              if (isQuote(selector.charCodeAt(selectorIndex))) {
                var quote = selector.charCodeAt(selectorIndex);
                var sectionEnd = selectorIndex + 1;
                while (sectionEnd < selector.length && (selector.charCodeAt(sectionEnd) !== quote || isEscaped(sectionEnd))) {
                  sectionEnd += 1;
                }
                if (selector.charCodeAt(sectionEnd) !== quote) {
                  throw new Error("Attribute value didn't end");
                }
                value = unescapeCSS(selector.slice(selectorIndex + 1, sectionEnd));
                selectorIndex = sectionEnd + 1;
              } else {
                var valueStart = selectorIndex;
                while (selectorIndex < selector.length && (!isWhitespace(selector.charCodeAt(selectorIndex)) && selector.charCodeAt(selectorIndex) !== 93 || isEscaped(selectorIndex))) {
                  selectorIndex += 1;
                }
                value = unescapeCSS(selector.slice(valueStart, selectorIndex));
              }
              stripWhitespace(0);
              var forceIgnore = selector.charCodeAt(selectorIndex) | 32;
              if (forceIgnore === 115) {
                ignoreCase = false;
                stripWhitespace(1);
              } else if (forceIgnore === 105) {
                ignoreCase = true;
                stripWhitespace(1);
              }
            }
            if (selector.charCodeAt(selectorIndex) !== 93) {
              throw new Error("Attribute selector didn't terminate");
            }
            selectorIndex += 1;
            var attributeSelector = {
              type: types_1.SelectorType.Attribute,
              name: name_1,
              action,
              value,
              namespace,
              ignoreCase
            };
            tokens.push(attributeSelector);
            break;
          }
          case 58: {
            if (selector.charCodeAt(selectorIndex + 1) === 58) {
              tokens.push({
                type: types_1.SelectorType.PseudoElement,
                name: getName(2).toLowerCase(),
                data: selector.charCodeAt(selectorIndex) === 40 ? readValueWithParenthesis() : null
              });
              continue;
            }
            var name_2 = getName(1).toLowerCase();
            var data = null;
            if (selector.charCodeAt(selectorIndex) === 40) {
              if (unpackPseudos.has(name_2)) {
                if (isQuote(selector.charCodeAt(selectorIndex + 1))) {
                  throw new Error("Pseudo-selector ".concat(name_2, " cannot be quoted"));
                }
                data = [];
                selectorIndex = parseSelector(data, selector, selectorIndex + 1);
                if (selector.charCodeAt(selectorIndex) !== 41) {
                  throw new Error("Missing closing parenthesis in :".concat(name_2, " (").concat(selector, ")"));
                }
                selectorIndex += 1;
              } else {
                data = readValueWithParenthesis();
                if (stripQuotesFromPseudos.has(name_2)) {
                  var quot = data.charCodeAt(0);
                  if (quot === data.charCodeAt(data.length - 1) && isQuote(quot)) {
                    data = data.slice(1, -1);
                  }
                }
                data = unescapeCSS(data);
              }
            }
            tokens.push({ type: types_1.SelectorType.Pseudo, name: name_2, data });
            break;
          }
          case 44: {
            finalizeSubselector();
            tokens = [];
            stripWhitespace(1);
            break;
          }
          default: {
            if (selector.startsWith("/*", selectorIndex)) {
              var endIndex = selector.indexOf("*/", selectorIndex + 2);
              if (endIndex < 0) {
                throw new Error("Comment was not terminated");
              }
              selectorIndex = endIndex + 2;
              if (tokens.length === 0) {
                stripWhitespace(0);
              }
              break;
            }
            var namespace = null;
            var name_3 = void 0;
            if (firstChar === 42) {
              selectorIndex += 1;
              name_3 = "*";
            } else if (firstChar === 124) {
              name_3 = "";
              if (selector.charCodeAt(selectorIndex + 1) === 124) {
                addTraversal(types_1.SelectorType.ColumnCombinator);
                stripWhitespace(2);
                break;
              }
            } else if (reName.test(selector.slice(selectorIndex))) {
              name_3 = getName(0);
            } else {
              break loop;
            }
            if (selector.charCodeAt(selectorIndex) === 124 && selector.charCodeAt(selectorIndex + 1) !== 124) {
              namespace = name_3;
              if (selector.charCodeAt(selectorIndex + 1) === 42) {
                name_3 = "*";
                selectorIndex += 2;
              } else {
                name_3 = getName(1);
              }
            }
            tokens.push(name_3 === "*" ? { type: types_1.SelectorType.Universal, namespace } : { type: types_1.SelectorType.Tag, name: name_3, namespace });
          }
        }
      }
      finalizeSubselector();
      return selectorIndex;
    }
  }
});

// node_modules/css-what/lib/commonjs/stringify.js
var require_stringify2 = __commonJS({
  "node_modules/css-what/lib/commonjs/stringify.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = void 0;
    var types_1 = require_types();
    var attribValChars = ["\\", '"'];
    var pseudoValChars = __spreadArray(__spreadArray([], attribValChars, true), ["(", ")"], false);
    var charsToEscapeInAttributeValue = new Set(attribValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInPseudoValue = new Set(pseudoValChars.map(function(c) {
      return c.charCodeAt(0);
    }));
    var charsToEscapeInName = new Set(__spreadArray(__spreadArray([], pseudoValChars, true), [
      "~",
      "^",
      "$",
      "*",
      "+",
      "!",
      "|",
      ":",
      "[",
      "]",
      " ",
      "."
    ], false).map(function(c) {
      return c.charCodeAt(0);
    }));
    function stringify(selector) {
      return selector.map(function(token) {
        return token.map(stringifyToken).join("");
      }).join(", ");
    }
    exports2.stringify = stringify;
    function stringifyToken(token, index, arr) {
      switch (token.type) {
        // Simple types
        case types_1.SelectorType.Child:
          return index === 0 ? "> " : " > ";
        case types_1.SelectorType.Parent:
          return index === 0 ? "< " : " < ";
        case types_1.SelectorType.Sibling:
          return index === 0 ? "~ " : " ~ ";
        case types_1.SelectorType.Adjacent:
          return index === 0 ? "+ " : " + ";
        case types_1.SelectorType.Descendant:
          return " ";
        case types_1.SelectorType.ColumnCombinator:
          return index === 0 ? "|| " : " || ";
        case types_1.SelectorType.Universal:
          return token.namespace === "*" && index + 1 < arr.length && "name" in arr[index + 1] ? "" : "".concat(getNamespace(token.namespace), "*");
        case types_1.SelectorType.Tag:
          return getNamespacedName(token);
        case types_1.SelectorType.PseudoElement:
          return "::".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(escapeName(token.data, charsToEscapeInPseudoValue), ")"));
        case types_1.SelectorType.Pseudo:
          return ":".concat(escapeName(token.name, charsToEscapeInName)).concat(token.data === null ? "" : "(".concat(typeof token.data === "string" ? escapeName(token.data, charsToEscapeInPseudoValue) : stringify(token.data), ")"));
        case types_1.SelectorType.Attribute: {
          if (token.name === "id" && token.action === types_1.AttributeAction.Equals && token.ignoreCase === "quirks" && !token.namespace) {
            return "#".concat(escapeName(token.value, charsToEscapeInName));
          }
          if (token.name === "class" && token.action === types_1.AttributeAction.Element && token.ignoreCase === "quirks" && !token.namespace) {
            return ".".concat(escapeName(token.value, charsToEscapeInName));
          }
          var name_1 = getNamespacedName(token);
          if (token.action === types_1.AttributeAction.Exists) {
            return "[".concat(name_1, "]");
          }
          return "[".concat(name_1).concat(getActionValue(token.action), '="').concat(escapeName(token.value, charsToEscapeInAttributeValue), '"').concat(token.ignoreCase === null ? "" : token.ignoreCase ? " i" : " s", "]");
        }
      }
    }
    function getActionValue(action) {
      switch (action) {
        case types_1.AttributeAction.Equals:
          return "";
        case types_1.AttributeAction.Element:
          return "~";
        case types_1.AttributeAction.Start:
          return "^";
        case types_1.AttributeAction.End:
          return "$";
        case types_1.AttributeAction.Any:
          return "*";
        case types_1.AttributeAction.Not:
          return "!";
        case types_1.AttributeAction.Hyphen:
          return "|";
        case types_1.AttributeAction.Exists:
          throw new Error("Shouldn't be here");
      }
    }
    function getNamespacedName(token) {
      return "".concat(getNamespace(token.namespace)).concat(escapeName(token.name, charsToEscapeInName));
    }
    function getNamespace(namespace) {
      return namespace !== null ? "".concat(namespace === "*" ? "*" : escapeName(namespace, charsToEscapeInName), "|") : "";
    }
    function escapeName(str, charsToEscape) {
      var lastIdx = 0;
      var ret = "";
      for (var i = 0; i < str.length; i++) {
        if (charsToEscape.has(str.charCodeAt(i))) {
          ret += "".concat(str.slice(lastIdx, i), "\\").concat(str.charAt(i));
          lastIdx = i + 1;
        }
      }
      return ret.length > 0 ? ret + str.slice(lastIdx) : str;
    }
  }
});

// node_modules/css-what/lib/commonjs/index.js
var require_commonjs = __commonJS({
  "node_modules/css-what/lib/commonjs/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __exportStar = exports2 && exports2.__exportStar || function(m, exports3) {
      for (var p in m) if (p !== "default" && !Object.prototype.hasOwnProperty.call(exports3, p)) __createBinding(exports3, m, p);
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.stringify = exports2.parse = exports2.isTraversal = void 0;
    __exportStar(require_types(), exports2);
    var parse_1 = require_parse();
    Object.defineProperty(exports2, "isTraversal", { enumerable: true, get: function() {
      return parse_1.isTraversal;
    } });
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_1.parse;
    } });
    var stringify_1 = require_stringify2();
    Object.defineProperty(exports2, "stringify", { enumerable: true, get: function() {
      return stringify_1.stringify;
    } });
  }
});

// node_modules/css-select/lib/sort.js
var require_sort = __commonJS({
  "node_modules/css-select/lib/sort.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.isTraversal = void 0;
    var css_what_1 = require_commonjs();
    var procedure = /* @__PURE__ */ new Map([
      [css_what_1.SelectorType.Universal, 50],
      [css_what_1.SelectorType.Tag, 30],
      [css_what_1.SelectorType.Attribute, 1],
      [css_what_1.SelectorType.Pseudo, 0]
    ]);
    function isTraversal(token) {
      return !procedure.has(token.type);
    }
    exports2.isTraversal = isTraversal;
    var attributes = /* @__PURE__ */ new Map([
      [css_what_1.AttributeAction.Exists, 10],
      [css_what_1.AttributeAction.Equals, 8],
      [css_what_1.AttributeAction.Not, 7],
      [css_what_1.AttributeAction.Start, 6],
      [css_what_1.AttributeAction.End, 6],
      [css_what_1.AttributeAction.Any, 5]
    ]);
    function sortByProcedure(arr) {
      var procs = arr.map(getProcedure);
      for (var i = 1; i < arr.length; i++) {
        var procNew = procs[i];
        if (procNew < 0)
          continue;
        for (var j = i - 1; j >= 0 && procNew < procs[j]; j--) {
          var token = arr[j + 1];
          arr[j + 1] = arr[j];
          arr[j] = token;
          procs[j + 1] = procs[j];
          procs[j] = procNew;
        }
      }
    }
    exports2.default = sortByProcedure;
    function getProcedure(token) {
      var _a, _b;
      var proc = (_a = procedure.get(token.type)) !== null && _a !== void 0 ? _a : -1;
      if (token.type === css_what_1.SelectorType.Attribute) {
        proc = (_b = attributes.get(token.action)) !== null && _b !== void 0 ? _b : 4;
        if (token.action === css_what_1.AttributeAction.Equals && token.name === "id") {
          proc = 9;
        }
        if (token.ignoreCase) {
          proc >>= 1;
        }
      } else if (token.type === css_what_1.SelectorType.Pseudo) {
        if (!token.data) {
          proc = 3;
        } else if (token.name === "has" || token.name === "contains") {
          proc = 0;
        } else if (Array.isArray(token.data)) {
          proc = Math.min.apply(Math, token.data.map(function(d) {
            return Math.min.apply(Math, d.map(getProcedure));
          }));
          if (proc < 0) {
            proc = 0;
          }
        } else {
          proc = 2;
        }
      }
      return proc;
    }
  }
});

// node_modules/css-select/lib/attributes.js
var require_attributes = __commonJS({
  "node_modules/css-select/lib/attributes.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.attributeRules = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var reChars = /[-[\]{}()*+?.,\\^$|#\s]/g;
    function escapeRegex(value) {
      return value.replace(reChars, "\\$&");
    }
    var caseInsensitiveAttributes = /* @__PURE__ */ new Set([
      "accept",
      "accept-charset",
      "align",
      "alink",
      "axis",
      "bgcolor",
      "charset",
      "checked",
      "clear",
      "codetype",
      "color",
      "compact",
      "declare",
      "defer",
      "dir",
      "direction",
      "disabled",
      "enctype",
      "face",
      "frame",
      "hreflang",
      "http-equiv",
      "lang",
      "language",
      "link",
      "media",
      "method",
      "multiple",
      "nohref",
      "noresize",
      "noshade",
      "nowrap",
      "readonly",
      "rel",
      "rev",
      "rules",
      "scope",
      "scrolling",
      "selected",
      "shape",
      "target",
      "text",
      "type",
      "valign",
      "valuetype",
      "vlink"
    ]);
    function shouldIgnoreCase(selector, options) {
      return typeof selector.ignoreCase === "boolean" ? selector.ignoreCase : selector.ignoreCase === "quirks" ? !!options.quirksMode : !options.xmlMode && caseInsensitiveAttributes.has(selector.name);
    }
    exports2.attributeRules = {
      equals: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length === value.length && attr.toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) === value && next(elem);
        };
      },
      hyphen: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function hyphenIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function hyphen(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && (attr.length === len || attr.charAt(len) === "-") && attr.substr(0, len) === value && next(elem);
        };
      },
      element: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (/\s/.test(value)) {
          return boolbase_1.default.falseFunc;
        }
        var regex = new RegExp("(?:^|\\s)".concat(escapeRegex(value), "(?:$|\\s)"), shouldIgnoreCase(data, options) ? "i" : "");
        return function element(elem) {
          var attr = adapter.getAttributeValue(elem, name);
          return attr != null && attr.length >= value.length && regex.test(attr) && next(elem);
        };
      },
      exists: function(next, _a, _b) {
        var name = _a.name;
        var adapter = _b.adapter;
        return function(elem) {
          return adapter.hasAttrib(elem, name) && next(elem);
        };
      },
      start: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= len && attr.substr(0, len).toLowerCase() === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.startsWith(value)) && next(elem);
        };
      },
      end: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        var len = -value.length;
        if (len === 0) {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var _a;
            return ((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.substr(len).toLowerCase()) === value && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.endsWith(value)) && next(elem);
        };
      },
      any: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name, value = data.value;
        if (value === "") {
          return boolbase_1.default.falseFunc;
        }
        if (shouldIgnoreCase(data, options)) {
          var regex_1 = new RegExp(escapeRegex(value), "i");
          return function anyIC(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return attr != null && attr.length >= value.length && regex_1.test(attr) && next(elem);
          };
        }
        return function(elem) {
          var _a;
          return !!((_a = adapter.getAttributeValue(elem, name)) === null || _a === void 0 ? void 0 : _a.includes(value)) && next(elem);
        };
      },
      not: function(next, data, options) {
        var adapter = options.adapter;
        var name = data.name;
        var value = data.value;
        if (value === "") {
          return function(elem) {
            return !!adapter.getAttributeValue(elem, name) && next(elem);
          };
        } else if (shouldIgnoreCase(data, options)) {
          value = value.toLowerCase();
          return function(elem) {
            var attr = adapter.getAttributeValue(elem, name);
            return (attr == null || attr.length !== value.length || attr.toLowerCase() !== value) && next(elem);
          };
        }
        return function(elem) {
          return adapter.getAttributeValue(elem, name) !== value && next(elem);
        };
      }
    };
  }
});

// node_modules/nth-check/lib/parse.js
var require_parse2 = __commonJS({
  "node_modules/nth-check/lib/parse.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.parse = void 0;
    var whitespace = /* @__PURE__ */ new Set([9, 10, 12, 13, 32]);
    var ZERO = "0".charCodeAt(0);
    var NINE = "9".charCodeAt(0);
    function parse(formula) {
      formula = formula.trim().toLowerCase();
      if (formula === "even") {
        return [2, 0];
      } else if (formula === "odd") {
        return [2, 1];
      }
      var idx = 0;
      var a = 0;
      var sign = readSign();
      var number = readNumber();
      if (idx < formula.length && formula.charAt(idx) === "n") {
        idx++;
        a = sign * (number !== null && number !== void 0 ? number : 1);
        skipWhitespace();
        if (idx < formula.length) {
          sign = readSign();
          skipWhitespace();
          number = readNumber();
        } else {
          sign = number = 0;
        }
      }
      if (number === null || idx < formula.length) {
        throw new Error("n-th rule couldn't be parsed ('".concat(formula, "')"));
      }
      return [a, sign * number];
      function readSign() {
        if (formula.charAt(idx) === "-") {
          idx++;
          return -1;
        }
        if (formula.charAt(idx) === "+") {
          idx++;
        }
        return 1;
      }
      function readNumber() {
        var start = idx;
        var value = 0;
        while (idx < formula.length && formula.charCodeAt(idx) >= ZERO && formula.charCodeAt(idx) <= NINE) {
          value = value * 10 + (formula.charCodeAt(idx) - ZERO);
          idx++;
        }
        return idx === start ? null : value;
      }
      function skipWhitespace() {
        while (idx < formula.length && whitespace.has(formula.charCodeAt(idx))) {
          idx++;
        }
      }
    }
    exports2.parse = parse;
  }
});

// node_modules/nth-check/lib/compile.js
var require_compile = __commonJS({
  "node_modules/nth-check/lib/compile.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.generate = exports2.compile = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    function compile(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      if (b < 0 && a <= 0)
        return boolbase_1.default.falseFunc;
      if (a === -1)
        return function(index) {
          return index <= b;
        };
      if (a === 0)
        return function(index) {
          return index === b;
        };
      if (a === 1)
        return b < 0 ? boolbase_1.default.trueFunc : function(index) {
          return index >= b;
        };
      var absA = Math.abs(a);
      var bMod = (b % absA + absA) % absA;
      return a > 1 ? function(index) {
        return index >= b && index % absA === bMod;
      } : function(index) {
        return index <= b && index % absA === bMod;
      };
    }
    exports2.compile = compile;
    function generate(parsed) {
      var a = parsed[0];
      var b = parsed[1] - 1;
      var n = 0;
      if (a < 0) {
        var aPos_1 = -a;
        var minValue_1 = (b % aPos_1 + aPos_1) % aPos_1;
        return function() {
          var val = minValue_1 + aPos_1 * n++;
          return val > b ? null : val;
        };
      }
      if (a === 0)
        return b < 0 ? (
          // There are no result  always return `null`
          function() {
            return null;
          }
        ) : (
          // Return `b` exactly once
          function() {
            return n++ === 0 ? b : null;
          }
        );
      if (b < 0) {
        b += a * Math.ceil(-b / a);
      }
      return function() {
        return a * n++ + b;
      };
    }
    exports2.generate = generate;
  }
});

// node_modules/nth-check/lib/index.js
var require_lib6 = __commonJS({
  "node_modules/nth-check/lib/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.sequence = exports2.generate = exports2.compile = exports2.parse = void 0;
    var parse_js_1 = require_parse2();
    Object.defineProperty(exports2, "parse", { enumerable: true, get: function() {
      return parse_js_1.parse;
    } });
    var compile_js_1 = require_compile();
    Object.defineProperty(exports2, "compile", { enumerable: true, get: function() {
      return compile_js_1.compile;
    } });
    Object.defineProperty(exports2, "generate", { enumerable: true, get: function() {
      return compile_js_1.generate;
    } });
    function nthCheck(formula) {
      return (0, compile_js_1.compile)((0, parse_js_1.parse)(formula));
    }
    exports2.default = nthCheck;
    function sequence(formula) {
      return (0, compile_js_1.generate)((0, parse_js_1.parse)(formula));
    }
    exports2.sequence = sequence;
  }
});

// node_modules/css-select/lib/pseudo-selectors/filters.js
var require_filters = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/filters.js"(exports2) {
    "use strict";
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.filters = void 0;
    var nth_check_1 = __importDefault(require_lib6());
    var boolbase_1 = __importDefault(require_boolbase());
    function getChildFunc(next, adapter) {
      return function(elem) {
        var parent = adapter.getParent(elem);
        return parent != null && adapter.isTag(parent) && next(elem);
      };
    }
    exports2.filters = {
      contains: function(next, text, _a) {
        var adapter = _a.adapter;
        return function contains(elem) {
          return next(elem) && adapter.getText(elem).includes(text);
        };
      },
      icontains: function(next, text, _a) {
        var adapter = _a.adapter;
        var itext = text.toLowerCase();
        return function icontains(elem) {
          return next(elem) && adapter.getText(elem).toLowerCase().includes(itext);
        };
      },
      // Location specific methods
      "nth-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-child": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastChild(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            if (equals(elem, siblings[i]))
              break;
            if (adapter.isTag(siblings[i])) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = 0; i < siblings.length; i++) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      "nth-last-of-type": function(next, rule, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var func = (0, nth_check_1.default)(rule);
        if (func === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        if (func === boolbase_1.default.trueFunc)
          return getChildFunc(next, adapter);
        return function nthLastOfType(elem) {
          var siblings = adapter.getSiblings(elem);
          var pos = 0;
          for (var i = siblings.length - 1; i >= 0; i--) {
            var currentSibling = siblings[i];
            if (equals(elem, currentSibling))
              break;
            if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === adapter.getName(elem)) {
              pos++;
            }
          }
          return func(pos) && next(elem);
        };
      },
      // TODO determine the actual root element
      root: function(next, _rule, _a) {
        var adapter = _a.adapter;
        return function(elem) {
          var parent = adapter.getParent(elem);
          return (parent == null || !adapter.isTag(parent)) && next(elem);
        };
      },
      scope: function(next, rule, options, context) {
        var equals = options.equals;
        if (!context || context.length === 0) {
          return exports2.filters["root"](next, rule, options);
        }
        if (context.length === 1) {
          return function(elem) {
            return equals(context[0], elem) && next(elem);
          };
        }
        return function(elem) {
          return context.includes(elem) && next(elem);
        };
      },
      hover: dynamicStatePseudo("isHovered"),
      visited: dynamicStatePseudo("isVisited"),
      active: dynamicStatePseudo("isActive")
    };
    function dynamicStatePseudo(name) {
      return function dynamicPseudo(next, _rule, _a) {
        var adapter = _a.adapter;
        var func = adapter[name];
        if (typeof func !== "function") {
          return boolbase_1.default.falseFunc;
        }
        return function active(elem) {
          return func(elem) && next(elem);
        };
      };
    }
  }
});

// node_modules/css-select/lib/pseudo-selectors/pseudos.js
var require_pseudos = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/pseudos.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.verifyPseudoArgs = exports2.pseudos = void 0;
    exports2.pseudos = {
      empty: function(elem, _a) {
        var adapter = _a.adapter;
        return !adapter.getChildren(elem).some(function(elem2) {
          return adapter.isTag(elem2) || adapter.getText(elem2) !== "";
        });
      },
      "first-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        if (adapter.prevElementSibling) {
          return adapter.prevElementSibling(elem) == null;
        }
        var firstChild = adapter.getSiblings(elem).find(function(elem2) {
          return adapter.isTag(elem2);
        });
        return firstChild != null && equals(elem, firstChild);
      },
      "last-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          if (equals(elem, siblings[i]))
            return true;
          if (adapter.isTag(siblings[i]))
            break;
        }
        return false;
      },
      "first-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = 0; i < siblings.length; i++) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "last-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var siblings = adapter.getSiblings(elem);
        var elemName = adapter.getName(elem);
        for (var i = siblings.length - 1; i >= 0; i--) {
          var currentSibling = siblings[i];
          if (equals(elem, currentSibling))
            return true;
          if (adapter.isTag(currentSibling) && adapter.getName(currentSibling) === elemName) {
            break;
          }
        }
        return false;
      },
      "only-of-type": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        var elemName = adapter.getName(elem);
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling) || adapter.getName(sibling) !== elemName;
        });
      },
      "only-child": function(elem, _a) {
        var adapter = _a.adapter, equals = _a.equals;
        return adapter.getSiblings(elem).every(function(sibling) {
          return equals(elem, sibling) || !adapter.isTag(sibling);
        });
      }
    };
    function verifyPseudoArgs(func, name, subselect, argIndex) {
      if (subselect === null) {
        if (func.length > argIndex) {
          throw new Error("Pseudo-class :".concat(name, " requires an argument"));
        }
      } else if (func.length === argIndex) {
        throw new Error("Pseudo-class :".concat(name, " doesn't have any arguments"));
      }
    }
    exports2.verifyPseudoArgs = verifyPseudoArgs;
  }
});

// node_modules/css-select/lib/pseudo-selectors/aliases.js
var require_aliases = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/aliases.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = void 0;
    exports2.aliases = {
      // Links
      "any-link": ":is(a, area, link)[href]",
      link: ":any-link:not(:visited)",
      // Forms
      // https://html.spec.whatwg.org/multipage/scripting.html#disabled-elements
      disabled: ":is(\n        :is(button, input, select, textarea, optgroup, option)[disabled],\n        optgroup[disabled] > option,\n        fieldset[disabled]:not(fieldset[disabled] legend:first-of-type *)\n    )",
      enabled: ":not(:disabled)",
      checked: ":is(:is(input[type=radio], input[type=checkbox])[checked], option:selected)",
      required: ":is(input, select, textarea)[required]",
      optional: ":is(input, select, textarea):not([required])",
      // JQuery extensions
      // https://html.spec.whatwg.org/multipage/form-elements.html#concept-option-selectedness
      selected: "option:is([selected], select:not([multiple]):not(:has(> option[selected])) > :first-of-type)",
      checkbox: "[type=checkbox]",
      file: "[type=file]",
      password: "[type=password]",
      radio: "[type=radio]",
      reset: "[type=reset]",
      image: "[type=image]",
      submit: "[type=submit]",
      parent: ":not(:empty)",
      header: ":is(h1, h2, h3, h4, h5, h6)",
      button: ":is(button, input[type=button])",
      input: ":is(input, textarea, select, button)",
      text: "input:is(:not([type!='']), [type=text])"
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/subselects.js
var require_subselects = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/subselects.js"(exports2) {
    "use strict";
    var __spreadArray = exports2 && exports2.__spreadArray || function(to, from, pack) {
      if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
          if (!ar) ar = Array.prototype.slice.call(from, 0, i);
          ar[i] = from[i];
        }
      }
      return to.concat(ar || Array.prototype.slice.call(from));
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.subselects = exports2.getNextSiblings = exports2.ensureIsTag = exports2.PLACEHOLDER_ELEMENT = void 0;
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = require_sort();
    exports2.PLACEHOLDER_ELEMENT = {};
    function ensureIsTag(next, adapter) {
      if (next === boolbase_1.default.falseFunc)
        return boolbase_1.default.falseFunc;
      return function(elem) {
        return adapter.isTag(elem) && next(elem);
      };
    }
    exports2.ensureIsTag = ensureIsTag;
    function getNextSiblings(elem, adapter) {
      var siblings = adapter.getSiblings(elem);
      if (siblings.length <= 1)
        return [];
      var elemIndex = siblings.indexOf(elem);
      if (elemIndex < 0 || elemIndex === siblings.length - 1)
        return [];
      return siblings.slice(elemIndex + 1).filter(adapter.isTag);
    }
    exports2.getNextSiblings = getNextSiblings;
    function copyOptions(options) {
      return {
        xmlMode: !!options.xmlMode,
        lowerCaseAttributeNames: !!options.lowerCaseAttributeNames,
        lowerCaseTags: !!options.lowerCaseTags,
        quirksMode: !!options.quirksMode,
        cacheResults: !!options.cacheResults,
        pseudos: options.pseudos,
        adapter: options.adapter,
        equals: options.equals
      };
    }
    var is = function(next, token, options, context, compileToken) {
      var func = compileToken(token, copyOptions(options), context);
      return func === boolbase_1.default.trueFunc ? next : func === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : function(elem) {
        return func(elem) && next(elem);
      };
    };
    exports2.subselects = {
      is,
      /**
       * `:matches` and `:where` are aliases for `:is`.
       */
      matches: is,
      where: is,
      not: function(next, token, options, context, compileToken) {
        var func = compileToken(token, copyOptions(options), context);
        return func === boolbase_1.default.falseFunc ? next : func === boolbase_1.default.trueFunc ? boolbase_1.default.falseFunc : function(elem) {
          return !func(elem) && next(elem);
        };
      },
      has: function(next, subselect, options, _context, compileToken) {
        var adapter = options.adapter;
        var opts = copyOptions(options);
        opts.relativeSelector = true;
        var context = subselect.some(function(s) {
          return s.some(sort_js_1.isTraversal);
        }) ? (
          // Used as a placeholder. Will be replaced with the actual element.
          [exports2.PLACEHOLDER_ELEMENT]
        ) : void 0;
        var compiled = compileToken(subselect, opts, context);
        if (compiled === boolbase_1.default.falseFunc)
          return boolbase_1.default.falseFunc;
        var hasElement = ensureIsTag(compiled, adapter);
        if (context && compiled !== boolbase_1.default.trueFunc) {
          var _a = compiled.shouldTestNextSiblings, shouldTestNextSiblings_1 = _a === void 0 ? false : _a;
          return function(elem) {
            if (!next(elem))
              return false;
            context[0] = elem;
            var childs = adapter.getChildren(elem);
            var nextElements = shouldTestNextSiblings_1 ? __spreadArray(__spreadArray([], childs, true), getNextSiblings(elem, adapter), true) : childs;
            return adapter.existsOne(hasElement, nextElements);
          };
        }
        return function(elem) {
          return next(elem) && adapter.existsOne(hasElement, adapter.getChildren(elem));
        };
      }
    };
  }
});

// node_modules/css-select/lib/pseudo-selectors/index.js
var require_pseudo_selectors = __commonJS({
  "node_modules/css-select/lib/pseudo-selectors/index.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compilePseudoSelector = exports2.aliases = exports2.pseudos = exports2.filters = void 0;
    var css_what_1 = require_commonjs();
    var filters_js_1 = require_filters();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return filters_js_1.filters;
    } });
    var pseudos_js_1 = require_pseudos();
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return pseudos_js_1.pseudos;
    } });
    var aliases_js_1 = require_aliases();
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return aliases_js_1.aliases;
    } });
    var subselects_js_1 = require_subselects();
    function compilePseudoSelector(next, selector, options, context, compileToken) {
      var _a;
      var name = selector.name, data = selector.data;
      if (Array.isArray(data)) {
        if (!(name in subselects_js_1.subselects)) {
          throw new Error("Unknown pseudo-class :".concat(name, "(").concat(data, ")"));
        }
        return subselects_js_1.subselects[name](next, data, options, context, compileToken);
      }
      var userPseudo = (_a = options.pseudos) === null || _a === void 0 ? void 0 : _a[name];
      var stringPseudo = typeof userPseudo === "string" ? userPseudo : aliases_js_1.aliases[name];
      if (typeof stringPseudo === "string") {
        if (data != null) {
          throw new Error("Pseudo ".concat(name, " doesn't have any arguments"));
        }
        var alias = (0, css_what_1.parse)(stringPseudo);
        return subselects_js_1.subselects["is"](next, alias, options, context, compileToken);
      }
      if (typeof userPseudo === "function") {
        (0, pseudos_js_1.verifyPseudoArgs)(userPseudo, name, data, 1);
        return function(elem) {
          return userPseudo(elem, data) && next(elem);
        };
      }
      if (name in filters_js_1.filters) {
        return filters_js_1.filters[name](next, data, options, context);
      }
      if (name in pseudos_js_1.pseudos) {
        var pseudo_1 = pseudos_js_1.pseudos[name];
        (0, pseudos_js_1.verifyPseudoArgs)(pseudo_1, name, data, 2);
        return function(elem) {
          return pseudo_1(elem, options, data) && next(elem);
        };
      }
      throw new Error("Unknown pseudo-class :".concat(name));
    }
    exports2.compilePseudoSelector = compilePseudoSelector;
  }
});

// node_modules/css-select/lib/general.js
var require_general = __commonJS({
  "node_modules/css-select/lib/general.js"(exports2) {
    "use strict";
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileGeneralSelector = void 0;
    var attributes_js_1 = require_attributes();
    var index_js_1 = require_pseudo_selectors();
    var css_what_1 = require_commonjs();
    function getElementParent(node, adapter) {
      var parent = adapter.getParent(node);
      if (parent && adapter.isTag(parent)) {
        return parent;
      }
      return null;
    }
    function compileGeneralSelector(next, selector, options, context, compileToken) {
      var adapter = options.adapter, equals = options.equals;
      switch (selector.type) {
        case css_what_1.SelectorType.PseudoElement: {
          throw new Error("Pseudo-elements are not supported by css-select");
        }
        case css_what_1.SelectorType.ColumnCombinator: {
          throw new Error("Column combinators are not yet supported by css-select");
        }
        case css_what_1.SelectorType.Attribute: {
          if (selector.namespace != null) {
            throw new Error("Namespaced attributes are not yet supported by css-select");
          }
          if (!options.xmlMode || options.lowerCaseAttributeNames) {
            selector.name = selector.name.toLowerCase();
          }
          return attributes_js_1.attributeRules[selector.action](next, selector, options);
        }
        case css_what_1.SelectorType.Pseudo: {
          return (0, index_js_1.compilePseudoSelector)(next, selector, options, context, compileToken);
        }
        // Tags
        case css_what_1.SelectorType.Tag: {
          if (selector.namespace != null) {
            throw new Error("Namespaced tag names are not yet supported by css-select");
          }
          var name_1 = selector.name;
          if (!options.xmlMode || options.lowerCaseTags) {
            name_1 = name_1.toLowerCase();
          }
          return function tag(elem) {
            return adapter.getName(elem) === name_1 && next(elem);
          };
        }
        // Traversal
        case css_what_1.SelectorType.Descendant: {
          if (options.cacheResults === false || typeof WeakSet === "undefined") {
            return function descendant(elem) {
              var current = elem;
              while (current = getElementParent(current, adapter)) {
                if (next(current)) {
                  return true;
                }
              }
              return false;
            };
          }
          var isFalseCache_1 = /* @__PURE__ */ new WeakSet();
          return function cachedDescendant(elem) {
            var current = elem;
            while (current = getElementParent(current, adapter)) {
              if (!isFalseCache_1.has(current)) {
                if (adapter.isTag(current) && next(current)) {
                  return true;
                }
                isFalseCache_1.add(current);
              }
            }
            return false;
          };
        }
        case "_flexibleDescendant": {
          return function flexibleDescendant(elem) {
            var current = elem;
            do {
              if (next(current))
                return true;
            } while (current = getElementParent(current, adapter));
            return false;
          };
        }
        case css_what_1.SelectorType.Parent: {
          return function parent(elem) {
            return adapter.getChildren(elem).some(function(elem2) {
              return adapter.isTag(elem2) && next(elem2);
            });
          };
        }
        case css_what_1.SelectorType.Child: {
          return function child(elem) {
            var parent = adapter.getParent(elem);
            return parent != null && adapter.isTag(parent) && next(parent);
          };
        }
        case css_what_1.SelectorType.Sibling: {
          return function sibling(elem) {
            var siblings = adapter.getSiblings(elem);
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling) && next(currentSibling)) {
                return true;
              }
            }
            return false;
          };
        }
        case css_what_1.SelectorType.Adjacent: {
          if (adapter.prevElementSibling) {
            return function adjacent(elem) {
              var previous = adapter.prevElementSibling(elem);
              return previous != null && next(previous);
            };
          }
          return function adjacent(elem) {
            var siblings = adapter.getSiblings(elem);
            var lastElement;
            for (var i = 0; i < siblings.length; i++) {
              var currentSibling = siblings[i];
              if (equals(elem, currentSibling))
                break;
              if (adapter.isTag(currentSibling)) {
                lastElement = currentSibling;
              }
            }
            return !!lastElement && next(lastElement);
          };
        }
        case css_what_1.SelectorType.Universal: {
          if (selector.namespace != null && selector.namespace !== "*") {
            throw new Error("Namespaced universal selectors are not yet supported by css-select");
          }
          return next;
        }
      }
    }
    exports2.compileGeneralSelector = compileGeneralSelector;
  }
});

// node_modules/css-select/lib/compile.js
var require_compile2 = __commonJS({
  "node_modules/css-select/lib/compile.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.compileToken = exports2.compileUnsafe = exports2.compile = void 0;
    var css_what_1 = require_commonjs();
    var boolbase_1 = __importDefault(require_boolbase());
    var sort_js_1 = __importStar(require_sort());
    var general_js_1 = require_general();
    var subselects_js_1 = require_subselects();
    function compile(selector, options, context) {
      var next = compileUnsafe(selector, options, context);
      return (0, subselects_js_1.ensureIsTag)(next, options.adapter);
    }
    exports2.compile = compile;
    function compileUnsafe(selector, options, context) {
      var token = typeof selector === "string" ? (0, css_what_1.parse)(selector) : selector;
      return compileToken(token, options, context);
    }
    exports2.compileUnsafe = compileUnsafe;
    function includesScopePseudo(t2) {
      return t2.type === css_what_1.SelectorType.Pseudo && (t2.name === "scope" || Array.isArray(t2.data) && t2.data.some(function(data) {
        return data.some(includesScopePseudo);
      }));
    }
    var DESCENDANT_TOKEN = { type: css_what_1.SelectorType.Descendant };
    var FLEXIBLE_DESCENDANT_TOKEN = {
      type: "_flexibleDescendant"
    };
    var SCOPE_TOKEN = {
      type: css_what_1.SelectorType.Pseudo,
      name: "scope",
      data: null
    };
    function absolutize(token, _a, context) {
      var adapter = _a.adapter;
      var hasContext = !!(context === null || context === void 0 ? void 0 : context.every(function(e) {
        var parent = adapter.isTag(e) && adapter.getParent(e);
        return e === subselects_js_1.PLACEHOLDER_ELEMENT || parent && adapter.isTag(parent);
      }));
      for (var _i = 0, token_1 = token; _i < token_1.length; _i++) {
        var t2 = token_1[_i];
        if (t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]) && t2[0].type !== css_what_1.SelectorType.Descendant) {
        } else if (hasContext && !t2.some(includesScopePseudo)) {
          t2.unshift(DESCENDANT_TOKEN);
        } else {
          continue;
        }
        t2.unshift(SCOPE_TOKEN);
      }
    }
    function compileToken(token, options, context) {
      var _a;
      token.forEach(sort_js_1.default);
      context = (_a = options.context) !== null && _a !== void 0 ? _a : context;
      var isArrayContext = Array.isArray(context);
      var finalContext = context && (Array.isArray(context) ? context : [context]);
      if (options.relativeSelector !== false) {
        absolutize(token, options, finalContext);
      } else if (token.some(function(t2) {
        return t2.length > 0 && (0, sort_js_1.isTraversal)(t2[0]);
      })) {
        throw new Error("Relative selectors are not allowed when the `relativeSelector` option is disabled");
      }
      var shouldTestNextSiblings = false;
      var query = token.map(function(rules) {
        if (rules.length >= 2) {
          var first = rules[0], second = rules[1];
          if (first.type !== css_what_1.SelectorType.Pseudo || first.name !== "scope") {
          } else if (isArrayContext && second.type === css_what_1.SelectorType.Descendant) {
            rules[1] = FLEXIBLE_DESCENDANT_TOKEN;
          } else if (second.type === css_what_1.SelectorType.Adjacent || second.type === css_what_1.SelectorType.Sibling) {
            shouldTestNextSiblings = true;
          }
        }
        return compileRules(rules, options, finalContext);
      }).reduce(reduceRules, boolbase_1.default.falseFunc);
      query.shouldTestNextSiblings = shouldTestNextSiblings;
      return query;
    }
    exports2.compileToken = compileToken;
    function compileRules(rules, options, context) {
      var _a;
      return rules.reduce(function(previous, rule) {
        return previous === boolbase_1.default.falseFunc ? boolbase_1.default.falseFunc : (0, general_js_1.compileGeneralSelector)(previous, rule, options, context, compileToken);
      }, (_a = options.rootFunc) !== null && _a !== void 0 ? _a : boolbase_1.default.trueFunc);
    }
    function reduceRules(a, b) {
      if (b === boolbase_1.default.falseFunc || a === boolbase_1.default.trueFunc) {
        return a;
      }
      if (a === boolbase_1.default.falseFunc || b === boolbase_1.default.trueFunc) {
        return b;
      }
      return function combine(elem) {
        return a(elem) || b(elem);
      };
    }
  }
});

// node_modules/css-select/lib/index.js
var require_lib7 = __commonJS({
  "node_modules/css-select/lib/index.js"(exports2) {
    "use strict";
    var __createBinding = exports2 && exports2.__createBinding || (Object.create ? (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      var desc = Object.getOwnPropertyDescriptor(m, k);
      if (!desc || ("get" in desc ? !m.__esModule : desc.writable || desc.configurable)) {
        desc = { enumerable: true, get: function() {
          return m[k];
        } };
      }
      Object.defineProperty(o, k2, desc);
    }) : (function(o, m, k, k2) {
      if (k2 === void 0) k2 = k;
      o[k2] = m[k];
    }));
    var __setModuleDefault = exports2 && exports2.__setModuleDefault || (Object.create ? (function(o, v) {
      Object.defineProperty(o, "default", { enumerable: true, value: v });
    }) : function(o, v) {
      o["default"] = v;
    });
    var __importStar = exports2 && exports2.__importStar || function(mod) {
      if (mod && mod.__esModule) return mod;
      var result = {};
      if (mod != null) {
        for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
      }
      __setModuleDefault(result, mod);
      return result;
    };
    var __importDefault = exports2 && exports2.__importDefault || function(mod) {
      return mod && mod.__esModule ? mod : { "default": mod };
    };
    Object.defineProperty(exports2, "__esModule", { value: true });
    exports2.aliases = exports2.pseudos = exports2.filters = exports2.is = exports2.selectOne = exports2.selectAll = exports2.prepareContext = exports2._compileToken = exports2._compileUnsafe = exports2.compile = void 0;
    var DomUtils = __importStar(require_lib5());
    var boolbase_1 = __importDefault(require_boolbase());
    var compile_js_1 = require_compile2();
    var subselects_js_1 = require_subselects();
    var defaultEquals = function(a, b) {
      return a === b;
    };
    var defaultOptions2 = {
      adapter: DomUtils,
      equals: defaultEquals
    };
    function convertOptionFormats(options) {
      var _a, _b, _c, _d;
      var opts = options !== null && options !== void 0 ? options : defaultOptions2;
      (_a = opts.adapter) !== null && _a !== void 0 ? _a : opts.adapter = DomUtils;
      (_b = opts.equals) !== null && _b !== void 0 ? _b : opts.equals = (_d = (_c = opts.adapter) === null || _c === void 0 ? void 0 : _c.equals) !== null && _d !== void 0 ? _d : defaultEquals;
      return opts;
    }
    function wrapCompile(func) {
      return function addAdapter(selector, options, context) {
        var opts = convertOptionFormats(options);
        return func(selector, opts, context);
      };
    }
    exports2.compile = wrapCompile(compile_js_1.compile);
    exports2._compileUnsafe = wrapCompile(compile_js_1.compileUnsafe);
    exports2._compileToken = wrapCompile(compile_js_1.compileToken);
    function getSelectorFunc(searchFunc) {
      return function select(query, elements, options) {
        var opts = convertOptionFormats(options);
        if (typeof query !== "function") {
          query = (0, compile_js_1.compileUnsafe)(query, opts, elements);
        }
        var filteredElements = prepareContext(elements, opts.adapter, query.shouldTestNextSiblings);
        return searchFunc(query, filteredElements, opts);
      };
    }
    function prepareContext(elems, adapter, shouldTestNextSiblings) {
      if (shouldTestNextSiblings === void 0) {
        shouldTestNextSiblings = false;
      }
      if (shouldTestNextSiblings) {
        elems = appendNextSiblings(elems, adapter);
      }
      return Array.isArray(elems) ? adapter.removeSubsets(elems) : adapter.getChildren(elems);
    }
    exports2.prepareContext = prepareContext;
    function appendNextSiblings(elem, adapter) {
      var elems = Array.isArray(elem) ? elem.slice(0) : [elem];
      var elemsLength = elems.length;
      for (var i = 0; i < elemsLength; i++) {
        var nextSiblings = (0, subselects_js_1.getNextSiblings)(elems[i], adapter);
        elems.push.apply(elems, nextSiblings);
      }
      return elems;
    }
    exports2.selectAll = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? [] : options.adapter.findAll(query, elems);
    });
    exports2.selectOne = getSelectorFunc(function(query, elems, options) {
      return query === boolbase_1.default.falseFunc || !elems || elems.length === 0 ? null : options.adapter.findOne(query, elems);
    });
    function is(elem, query, options) {
      var opts = convertOptionFormats(options);
      return (typeof query === "function" ? query : (0, compile_js_1.compile)(query, opts))(elem);
    }
    exports2.is = is;
    exports2.default = exports2.selectAll;
    var index_js_1 = require_pseudo_selectors();
    Object.defineProperty(exports2, "filters", { enumerable: true, get: function() {
      return index_js_1.filters;
    } });
    Object.defineProperty(exports2, "pseudos", { enumerable: true, get: function() {
      return index_js_1.pseudos;
    } });
    Object.defineProperty(exports2, "aliases", { enumerable: true, get: function() {
      return index_js_1.aliases;
    } });
  }
});

// node_modules/svgo/lib/svgo/css-select-adapter.js
var require_css_select_adapter = __commonJS({
  "node_modules/svgo/lib/svgo/css-select-adapter.js"(exports2, module2) {
    "use strict";
    var isTag = (node) => {
      return node.type === "element";
    };
    var existsOne = (test, elems) => {
      return elems.some((elem) => {
        if (isTag(elem)) {
          return test(elem) || existsOne(test, getChildren(elem));
        } else {
          return false;
        }
      });
    };
    var getAttributeValue = (elem, name) => {
      return elem.attributes[name];
    };
    var getChildren = (node) => {
      return node.children || [];
    };
    var getName = (elemAst) => {
      return elemAst.name;
    };
    var getParent = (node) => {
      return node.parentNode || null;
    };
    var getSiblings = (elem) => {
      var parent = getParent(elem);
      return parent ? getChildren(parent) : [];
    };
    var getText = (node) => {
      if (node.children[0].type === "text" && node.children[0].type === "cdata") {
        return node.children[0].value;
      }
      return "";
    };
    var hasAttrib = (elem, name) => {
      return elem.attributes[name] !== void 0;
    };
    var removeSubsets = (nodes) => {
      let idx = nodes.length;
      let node;
      let ancestor;
      let replace;
      while (--idx > -1) {
        node = ancestor = nodes[idx];
        nodes[idx] = null;
        replace = true;
        while (ancestor) {
          if (nodes.includes(ancestor)) {
            replace = false;
            nodes.splice(idx, 1);
            break;
          }
          ancestor = getParent(ancestor);
        }
        if (replace) {
          nodes[idx] = node;
        }
      }
      return nodes;
    };
    var findAll = (test, elems) => {
      const result = [];
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            result.push(elem);
          }
          result.push(...findAll(test, getChildren(elem)));
        }
      }
      return result;
    };
    var findOne = (test, elems) => {
      for (const elem of elems) {
        if (isTag(elem)) {
          if (test(elem)) {
            return elem;
          }
          const result = findOne(test, getChildren(elem));
          if (result) {
            return result;
          }
        }
      }
      return null;
    };
    var svgoCssSelectAdapter = {
      isTag,
      existsOne,
      getAttributeValue,
      getChildren,
      getName,
      getParent,
      getSiblings,
      getText,
      hasAttrib,
      removeSubsets,
      findAll,
      findOne
    };
    module2.exports = svgoCssSelectAdapter;
  }
});

// node_modules/svgo/lib/xast.js
var require_xast = __commonJS({
  "node_modules/svgo/lib/xast.js"(exports2) {
    "use strict";
    var { selectAll, selectOne, is } = require_lib7();
    var xastAdaptor = require_css_select_adapter();
    var cssSelectOptions = {
      xmlMode: true,
      adapter: xastAdaptor
    };
    var querySelectorAll = (node, selector) => {
      return selectAll(selector, node, cssSelectOptions);
    };
    exports2.querySelectorAll = querySelectorAll;
    var querySelector = (node, selector) => {
      return selectOne(selector, node, cssSelectOptions);
    };
    exports2.querySelector = querySelector;
    var matches = (node, selector) => {
      return is(node, selector, cssSelectOptions);
    };
    exports2.matches = matches;
    var visitSkip = /* @__PURE__ */ Symbol();
    exports2.visitSkip = visitSkip;
    var visit = (node, visitor, parentNode) => {
      const callbacks = visitor[node.type];
      if (callbacks && callbacks.enter) {
        const symbol = callbacks.enter(node, parentNode);
        if (symbol === visitSkip) {
          return;
        }
      }
      if (node.type === "root") {
        for (const child of node.children) {
          visit(child, visitor, node);
        }
      }
      if (node.type === "element") {
        if (parentNode.children.includes(node)) {
          for (const child of node.children) {
            visit(child, visitor, node);
          }
        }
      }
      if (callbacks && callbacks.exit) {
        callbacks.exit(node, parentNode);
      }
    };
    exports2.visit = visit;
    var detachNodeFromParent = (node, parentNode) => {
      parentNode.children = parentNode.children.filter((child) => child !== node);
    };
    exports2.detachNodeFromParent = detachNodeFromParent;
  }
});

// node_modules/svgo/lib/svgo/plugins.js
var require_plugins = __commonJS({
  "node_modules/svgo/lib/svgo/plugins.js"(exports2) {
    "use strict";
    var { visit } = require_xast();
    var invokePlugins = (ast, info, plugins, overrides, globalOverrides) => {
      for (const plugin of plugins) {
        const override = overrides?.[plugin.name];
        if (override === false) {
          continue;
        }
        const params = { ...plugin.params, ...globalOverrides, ...override };
        const visitor = plugin.fn(ast, params, info);
        if (visitor != null) {
          visit(ast, visitor);
        }
      }
    };
    exports2.invokePlugins = invokePlugins;
    var createPreset = ({ name, plugins }) => {
      return {
        name,
        fn: (ast, params, info) => {
          const { floatPrecision, overrides } = params;
          const globalOverrides = {};
          if (floatPrecision != null) {
            globalOverrides.floatPrecision = floatPrecision;
          }
          if (overrides) {
            const pluginNames = plugins.map(({ name: name2 }) => name2);
            for (const pluginName of Object.keys(overrides)) {
              if (!pluginNames.includes(pluginName)) {
                console.warn(
                  `You are trying to configure ${pluginName} which is not part of ${name}.
Try to put it before or after, for example

plugins: [
  {
    name: '${name}',
  },
  '${pluginName}'
]
`
                );
              }
            }
          }
          invokePlugins(ast, info, plugins, overrides, globalOverrides);
        }
      };
    };
    exports2.createPreset = createPreset;
  }
});

// node_modules/svgo/plugins/removeDoctype.js
var require_removeDoctype = __commonJS({
  "node_modules/svgo/plugins/removeDoctype.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeDoctype";
    exports2.description = "removes doctype declaration";
    exports2.fn = () => {
      return {
        doctype: {
          enter: (node, parentNode) => {
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLProcInst.js
var require_removeXMLProcInst = __commonJS({
  "node_modules/svgo/plugins/removeXMLProcInst.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeXMLProcInst";
    exports2.description = "removes XML processing instructions";
    exports2.fn = () => {
      return {
        instruction: {
          enter: (node, parentNode) => {
            if (node.name === "xml") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeComments.js
var require_removeComments = __commonJS({
  "node_modules/svgo/plugins/removeComments.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeComments";
    exports2.description = "removes comments";
    var DEFAULT_PRESERVE_PATTERNS = [/^!/];
    exports2.fn = (_root, params) => {
      const { preservePatterns = DEFAULT_PRESERVE_PATTERNS } = params;
      return {
        comment: {
          enter: (node, parentNode) => {
            if (preservePatterns) {
              if (!Array.isArray(preservePatterns)) {
                throw Error(
                  `Expected array in removeComments preservePatterns parameter but received ${preservePatterns}`
                );
              }
              const matches = preservePatterns.some((pattern) => {
                return new RegExp(pattern).test(node.value);
              });
              if (matches) {
                return;
              }
            }
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeMetadata.js
var require_removeMetadata = __commonJS({
  "node_modules/svgo/plugins/removeMetadata.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeMetadata";
    exports2.description = "removes <metadata>";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "metadata") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEditorsNSData.js
var require_removeEditorsNSData = __commonJS({
  "node_modules/svgo/plugins/removeEditorsNSData.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { editorNamespaces } = require_collections();
    exports2.name = "removeEditorsNSData";
    exports2.description = "removes editors namespaces, elements and attributes";
    exports2.fn = (_root, params) => {
      let namespaces = [...editorNamespaces];
      if (Array.isArray(params.additionalNamespaces)) {
        namespaces = [...editorNamespaces, ...params.additionalNamespaces];
      }
      const prefixes = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg") {
              for (const [name, value] of Object.entries(node.attributes)) {
                if (name.startsWith("xmlns:") && namespaces.includes(value)) {
                  prefixes.push(name.slice("xmlns:".length));
                  delete node.attributes[name];
                }
              }
            }
            for (const name of Object.keys(node.attributes)) {
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefixes.includes(prefix)) {
                  delete node.attributes[name];
                }
              }
            }
            if (node.name.includes(":")) {
              const [prefix] = node.name.split(":");
              if (prefixes.includes(prefix)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupAttrs.js
var require_cleanupAttrs = __commonJS({
  "node_modules/svgo/plugins/cleanupAttrs.js"(exports2) {
    "use strict";
    exports2.name = "cleanupAttrs";
    exports2.description = "cleanups attributes from newlines, trailing and repeating spaces";
    var regNewlinesNeedSpace = /(\S)\r?\n(\S)/g;
    var regNewlines = /\r?\n/g;
    var regSpaces = /\s{2,}/g;
    exports2.fn = (root, params) => {
      const { newlines = true, trim = true, spaces = true } = params;
      return {
        element: {
          enter: (node) => {
            for (const name of Object.keys(node.attributes)) {
              if (newlines) {
                node.attributes[name] = node.attributes[name].replace(
                  regNewlinesNeedSpace,
                  (match, p1, p2) => p1 + " " + p2
                );
                node.attributes[name] = node.attributes[name].replace(
                  regNewlines,
                  ""
                );
              }
              if (trim) {
                node.attributes[name] = node.attributes[name].trim();
              }
              if (spaces) {
                node.attributes[name] = node.attributes[name].replace(
                  regSpaces,
                  " "
                );
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/mergeStyles.js
var require_mergeStyles = __commonJS({
  "node_modules/svgo/plugins/mergeStyles.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    exports2.name = "mergeStyles";
    exports2.description = "merge multiple style elements into one";
    exports2.fn = () => {
      let firstStyleElement = null;
      let collectedStyles = "";
      let styleContentType = "text";
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style") {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            let css = "";
            for (const child of node.children) {
              if (child.type === "text") {
                css += child.value;
              }
              if (child.type === "cdata") {
                styleContentType = "cdata";
                css += child.value;
              }
            }
            if (css.trim().length === 0) {
              detachNodeFromParent(node, parentNode);
              return;
            }
            if (node.attributes.media == null) {
              collectedStyles += css;
            } else {
              collectedStyles += `@media ${node.attributes.media}{${css}}`;
              delete node.attributes.media;
            }
            if (firstStyleElement == null) {
              firstStyleElement = node;
            } else {
              detachNodeFromParent(node, parentNode);
              const child = { type: styleContentType, value: collectedStyles };
              Object.defineProperty(child, "parentNode", {
                writable: true,
                value: firstStyleElement
              });
              firstStyleElement.children = [child];
            }
          }
        }
      };
    };
  }
});

// node_modules/css-tree/cjs/tokenizer/types.cjs
var require_types2 = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/types.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    var Ident = 1;
    var Function2 = 2;
    var AtKeyword = 3;
    var Hash = 4;
    var String2 = 5;
    var BadString = 6;
    var Url = 7;
    var BadUrl = 8;
    var Delim = 9;
    var Number2 = 10;
    var Percentage = 11;
    var Dimension = 12;
    var WhiteSpace = 13;
    var CDO = 14;
    var CDC = 15;
    var Colon = 16;
    var Semicolon = 17;
    var Comma = 18;
    var LeftSquareBracket = 19;
    var RightSquareBracket = 20;
    var LeftParenthesis = 21;
    var RightParenthesis = 22;
    var LeftCurlyBracket = 23;
    var RightCurlyBracket = 24;
    var Comment = 25;
    exports2.AtKeyword = AtKeyword;
    exports2.BadString = BadString;
    exports2.BadUrl = BadUrl;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.Colon = Colon;
    exports2.Comma = Comma;
    exports2.Comment = Comment;
    exports2.Delim = Delim;
    exports2.Dimension = Dimension;
    exports2.EOF = EOF;
    exports2.Function = Function2;
    exports2.Hash = Hash;
    exports2.Ident = Ident;
    exports2.LeftCurlyBracket = LeftCurlyBracket;
    exports2.LeftParenthesis = LeftParenthesis;
    exports2.LeftSquareBracket = LeftSquareBracket;
    exports2.Number = Number2;
    exports2.Percentage = Percentage;
    exports2.RightCurlyBracket = RightCurlyBracket;
    exports2.RightParenthesis = RightParenthesis;
    exports2.RightSquareBracket = RightSquareBracket;
    exports2.Semicolon = Semicolon;
    exports2.String = String2;
    exports2.Url = Url;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs
var require_char_code_definitions = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isHexDigit(code) {
      return isDigit(code) || // 0 .. 9
      code >= 65 && code <= 70 || // A .. F
      code >= 97 && code <= 102;
    }
    function isUppercaseLetter(code) {
      return code >= 65 && code <= 90;
    }
    function isLowercaseLetter(code) {
      return code >= 97 && code <= 122;
    }
    function isLetter(code) {
      return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    function isNonAscii(code) {
      return code >= 128;
    }
    function isNameStart(code) {
      return isLetter(code) || isNonAscii(code) || code === 95;
    }
    function isName(code) {
      return isNameStart(code) || isDigit(code) || code === 45;
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function isNewline(code) {
      return code === 10 || code === 13 || code === 12;
    }
    function isWhiteSpace(code) {
      return isNewline(code) || code === 32 || code === 9;
    }
    function isValidEscape(first, second) {
      if (first !== 92) {
        return false;
      }
      if (isNewline(second) || second === EOF) {
        return false;
      }
      return true;
    }
    function isIdentifierStart(first, second, third) {
      if (first === 45) {
        return isNameStart(second) || second === 45 || isValidEscape(second, third);
      }
      if (isNameStart(first)) {
        return true;
      }
      if (first === 92) {
        return isValidEscape(first, second);
      }
      return false;
    }
    function isNumberStart(first, second, third) {
      if (first === 43 || first === 45) {
        if (isDigit(second)) {
          return 2;
        }
        return second === 46 && isDigit(third) ? 3 : 0;
      }
      if (first === 46) {
        return isDigit(second) ? 2 : 0;
      }
      if (isDigit(first)) {
        return 1;
      }
      return 0;
    }
    function isBOM(code) {
      if (code === 65279) {
        return 1;
      }
      if (code === 65534) {
        return 1;
      }
      return 0;
    }
    var CATEGORY = new Array(128);
    var EofCategory = 128;
    var WhiteSpaceCategory = 130;
    var DigitCategory = 131;
    var NameStartCategory = 132;
    var NonPrintableCategory = 133;
    for (let i = 0; i < CATEGORY.length; i++) {
      CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
    }
    function charCodeCategory(code) {
      return code < 128 ? CATEGORY[code] : NameStartCategory;
    }
    exports2.DigitCategory = DigitCategory;
    exports2.EofCategory = EofCategory;
    exports2.NameStartCategory = NameStartCategory;
    exports2.NonPrintableCategory = NonPrintableCategory;
    exports2.WhiteSpaceCategory = WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeCategory;
    exports2.isBOM = isBOM;
    exports2.isDigit = isDigit;
    exports2.isHexDigit = isHexDigit;
    exports2.isIdentifierStart = isIdentifierStart;
    exports2.isLetter = isLetter;
    exports2.isLowercaseLetter = isLowercaseLetter;
    exports2.isName = isName;
    exports2.isNameStart = isNameStart;
    exports2.isNewline = isNewline;
    exports2.isNonAscii = isNonAscii;
    exports2.isNonPrintable = isNonPrintable;
    exports2.isNumberStart = isNumberStart;
    exports2.isUppercaseLetter = isUppercaseLetter;
    exports2.isValidEscape = isValidEscape;
    exports2.isWhiteSpace = isWhiteSpace;
  }
});

// node_modules/css-tree/cjs/tokenizer/utils.cjs
var require_utils = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/utils.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    function getCharCode(source, offset) {
      return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
      if (code === 13 && getCharCode(source, offset + 1) === 10) {
        return 2;
      }
      return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
      let code = testStr.charCodeAt(offset);
      if (charCodeDefinitions.isUppercaseLetter(code)) {
        code = code | 32;
      }
      return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
      if (end - start !== referenceStr.length) {
        return false;
      }
      if (start < 0 || end > testStr.length) {
        return false;
      }
      for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);
        if (charCodeDefinitions.isUppercaseLetter(testCode)) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function findWhiteSpaceStart(source, offset) {
      for (; offset >= 0; offset--) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function findDecimalNumberEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function consumeEscaped(source, offset) {
      offset += 2;
      if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
          if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
            break;
          }
        }
        const code = getCharCode(source, offset);
        if (charCodeDefinitions.isWhiteSpace(code)) {
          offset += getNewlineLength(source, offset, code);
        }
      }
      return offset;
    }
    function consumeName(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (charCodeDefinitions.isName(code)) {
          continue;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset) - 1;
          continue;
        }
        break;
      }
      return offset;
    }
    function consumeNumber(source, offset) {
      let code = source.charCodeAt(offset);
      if (code === 43 || code === 45) {
        code = source.charCodeAt(offset += 1);
      }
      if (charCodeDefinitions.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
      }
      if (code === 46 && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
        offset += 2;
        offset = findDecimalNumberEnd(source, offset);
      }
      if (cmpChar(
        source,
        offset,
        101
        /* e */
      )) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);
        if (code === 45 || code === 43) {
          sign = 1;
          code = source.charCodeAt(offset + 2);
        }
        if (charCodeDefinitions.isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
      }
      return offset;
    }
    function consumeBadUrlRemnants(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (code === 41) {
          offset++;
          break;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset);
        }
      }
      return offset;
    }
    function decodeEscaped(escaped) {
      if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
      }
      let code = parseInt(escaped, 16);
      if (code === 0 || // If this number is zero,
      code >= 55296 && code <= 57343 || // or is for a surrogate,
      code > 1114111) {
        code = 65533;
      }
      return String.fromCodePoint(code);
    }
    exports2.cmpChar = cmpChar;
    exports2.cmpStr = cmpStr;
    exports2.consumeBadUrlRemnants = consumeBadUrlRemnants;
    exports2.consumeEscaped = consumeEscaped;
    exports2.consumeName = consumeName;
    exports2.consumeNumber = consumeNumber;
    exports2.decodeEscaped = decodeEscaped;
    exports2.findDecimalNumberEnd = findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = findWhiteSpaceStart;
    exports2.getNewlineLength = getNewlineLength;
  }
});

// node_modules/css-tree/cjs/tokenizer/names.cjs
var require_names = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/names.cjs"(exports2, module2) {
    "use strict";
    var tokenNames = [
      "EOF-token",
      "ident-token",
      "function-token",
      "at-keyword-token",
      "hash-token",
      "string-token",
      "bad-string-token",
      "url-token",
      "bad-url-token",
      "delim-token",
      "number-token",
      "percentage-token",
      "dimension-token",
      "whitespace-token",
      "CDO-token",
      "CDC-token",
      "colon-token",
      "semicolon-token",
      "comma-token",
      "[-token",
      "]-token",
      "(-token",
      ")-token",
      "{-token",
      "}-token"
    ];
    module2.exports = tokenNames;
  }
});

// node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs
var require_adopt_buffer = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs"(exports2) {
    "use strict";
    var MIN_SIZE = 16 * 1024;
    function adoptBuffer(buffer = null, size) {
      if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
      }
      return buffer;
    }
    exports2.adoptBuffer = adoptBuffer;
  }
});

// node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs
var require_OffsetToLocation = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer();
    var charCodeDefinitions = require_char_code_definitions();
    var N = 10;
    var F = 12;
    var R = 13;
    function computeLinesAndColumns(host) {
      const source = host.source;
      const sourceLength = source.length;
      const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
      const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
      const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
      let line = host.startLine;
      let column = host.startColumn;
      for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);
        lines[i] = line;
        columns[i] = column++;
        if (code === N || code === R || code === F) {
          if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
            i++;
            lines[i] = line;
            columns[i] = column;
          }
          line++;
          column = 1;
        }
      }
      lines[sourceLength] = line;
      columns[sourceLength] = column;
      host.lines = lines;
      host.columns = columns;
      host.computed = true;
    }
    var OffsetToLocation = class {
      constructor() {
        this.lines = null;
        this.columns = null;
        this.computed = false;
      }
      setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
      }
      getLocation(offset, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          offset: this.startOffset + offset,
          line: this.lines[offset],
          column: this.columns[offset]
        };
      }
      getLocationRange(start, end, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
          },
          end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
          }
        };
      }
    };
    exports2.OffsetToLocation = OffsetToLocation;
  }
});

// node_modules/css-tree/cjs/tokenizer/TokenStream.cjs
var require_TokenStream = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/TokenStream.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer();
    var utils = require_utils();
    var names = require_names();
    var types = require_types2();
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    var balancePair = /* @__PURE__ */ new Map([
      [types.Function, types.RightParenthesis],
      [types.LeftParenthesis, types.RightParenthesis],
      [types.LeftSquareBracket, types.RightSquareBracket],
      [types.LeftCurlyBracket, types.RightCurlyBracket]
    ]);
    var TokenStream = class {
      constructor(source, tokenize) {
        this.setSource(source, tokenize);
      }
      reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
      }
      setSource(source = "", tokenize = () => {
      }) {
        source = String(source || "");
        const sourceLength = source.length;
        const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1);
        const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let balanceCloseType = 0;
        let balanceStart = 0;
        let firstCharOffset = -1;
        this.offsetAndType = null;
        this.balance = null;
        tokenize(source, (type, start, end) => {
          switch (type) {
            default:
              balance[tokenCount] = sourceLength;
              break;
            case balanceCloseType: {
              let balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;
              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }
              break;
            }
            case types.LeftParenthesis:
            case types.Function:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = balancePair.get(type);
              balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
              break;
          }
          offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
          if (firstCharOffset === -1) {
            firstCharOffset = start;
          }
        });
        offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength;
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength;
        while (balanceStart !== 0) {
          const balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balance[balancePrev] = sourceLength;
        }
        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;
        this.reset();
        this.next();
      }
      lookupType(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset] >> TYPE_SHIFT;
        }
        return types.EOF;
      }
      lookupOffset(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }
        return this.source.length;
      }
      lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return utils.cmpStr(
            this.source,
            this.offsetAndType[offset - 1] & OFFSET_MASK,
            this.offsetAndType[offset] & OFFSET_MASK,
            referenceStr
          );
        }
        return false;
      }
      getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
          return this.tokenStart;
        }
        if (tokenIndex > 0) {
          return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }
        return this.firstCharOffset;
      }
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      }
      isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
      }
      isDelim(code, offset) {
        if (offset) {
          return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
        }
        return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;
      }
      skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.next();
        }
      }
      next() {
        let next = this.tokenIndex + 1;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.tokenEnd;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.eof = true;
          this.tokenIndex = this.tokenCount;
          this.tokenType = types.EOF;
          this.tokenStart = this.tokenEnd = this.source.length;
        }
      }
      skipSC() {
        while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {
          this.next();
        }
      }
      skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd;
        let offset;
        loop:
          for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
            switch (stopConsume(this.source.charCodeAt(offset))) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
            }
          }
        this.skip(cursor - this.tokenIndex);
      }
      forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
          const start = offset;
          const item = this.offsetAndType[i];
          const end = item & OFFSET_MASK;
          const type = item >> TYPE_SHIFT;
          offset = end;
          fn(type, start, end, i);
        }
      }
      dump() {
        const tokens = new Array(this.tokenCount);
        this.forEachToken((type, start, end, index) => {
          tokens[index] = {
            idx: index,
            type: names[type],
            chunk: this.source.substring(start, end),
            balance: this.balance[index]
          };
        });
        return tokens;
      }
    };
    exports2.TokenStream = TokenStream;
  }
});

// node_modules/css-tree/cjs/tokenizer/index.cjs
var require_tokenizer = __commonJS({
  "node_modules/css-tree/cjs/tokenizer/index.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var names = require_names();
    var OffsetToLocation = require_OffsetToLocation();
    var TokenStream = require_TokenStream();
    function tokenize(source, onToken) {
      function getCharCode(offset2) {
        return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
      }
      function consumeNumericToken() {
        offset = utils.consumeNumber(source, offset);
        if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
          type = types.Dimension;
          offset = utils.consumeName(source, offset);
          return;
        }
        if (getCharCode(offset) === 37) {
          type = types.Percentage;
          offset++;
          return;
        }
        type = types.Number;
      }
      function consumeIdentLikeToken() {
        const nameStartOffset = offset;
        offset = utils.consumeName(source, offset);
        if (utils.cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
          offset = utils.findWhiteSpaceEnd(source, offset + 1);
          if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
            type = types.Function;
            offset = nameStartOffset + 4;
            return;
          }
          consumeUrlToken();
          return;
        }
        if (getCharCode(offset) === 40) {
          type = types.Function;
          offset++;
          return;
        }
        type = types.Ident;
      }
      function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
          endingCodePoint = getCharCode(offset++);
        }
        type = types.String;
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // ending code point
            case endingCodePoint:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <string-token>.
            // return;
            // newline
            case charCodeDefinitions.WhiteSpaceCategory:
              if (charCodeDefinitions.isNewline(code)) {
                offset += utils.getNewlineLength(source, offset, code);
                type = types.BadString;
                return;
              }
              break;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (offset === source.length - 1) {
                break;
              }
              const nextCode = getCharCode(offset + 1);
              if (charCodeDefinitions.isNewline(nextCode)) {
                offset += utils.getNewlineLength(source, offset + 1, nextCode);
              } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
                offset = utils.consumeEscaped(source, offset) - 1;
              }
              break;
          }
        }
      }
      function consumeUrlToken() {
        type = types.Url;
        offset = utils.findWhiteSpaceEnd(source, offset);
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // U+0029 RIGHT PARENTHESIS ())
            case 41:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <url-token>.
            // return;
            // whitespace
            case charCodeDefinitions.WhiteSpaceCategory:
              offset = utils.findWhiteSpaceEnd(source, offset);
              if (getCharCode(offset) === 41 || offset >= source.length) {
                if (offset < source.length) {
                  offset++;
                }
                return;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+0022 QUOTATION MARK (")
            // U+0027 APOSTROPHE (')
            // U+0028 LEFT PARENTHESIS (()
            // non-printable code point
            case 34:
            case 39:
            case 40:
            case charCodeDefinitions.NonPrintableCategory:
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
                offset = utils.consumeEscaped(source, offset) - 1;
                break;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
          }
        }
      }
      source = String(source || "");
      const sourceLength = source.length;
      let start = charCodeDefinitions.isBOM(getCharCode(0));
      let offset = start;
      let type;
      while (offset < sourceLength) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          // whitespace
          case charCodeDefinitions.WhiteSpaceCategory:
            type = types.WhiteSpace;
            offset = utils.findWhiteSpaceEnd(source, offset + 1);
            break;
          // U+0022 QUOTATION MARK (")
          case 34:
            consumeStringToken();
            break;
          // U+0023 NUMBER SIGN (#)
          case 35:
            if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
              type = types.Hash;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0027 APOSTROPHE (')
          case 39:
            consumeStringToken();
            break;
          // U+0028 LEFT PARENTHESIS (()
          case 40:
            type = types.LeftParenthesis;
            offset++;
            break;
          // U+0029 RIGHT PARENTHESIS ())
          case 41:
            type = types.RightParenthesis;
            offset++;
            break;
          // U+002B PLUS SIGN (+)
          case 43:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002C COMMA (,)
          case 44:
            type = types.Comma;
            offset++;
            break;
          // U+002D HYPHEN-MINUS (-)
          case 45:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                type = types.CDC;
                offset = offset + 3;
              } else {
                if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                  consumeIdentLikeToken();
                } else {
                  type = types.Delim;
                  offset++;
                }
              }
            }
            break;
          // U+002E FULL STOP (.)
          case 46:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002F SOLIDUS (/)
          case 47:
            if (getCharCode(offset + 1) === 42) {
              type = types.Comment;
              offset = source.indexOf("*/", offset + 2);
              offset = offset === -1 ? source.length : offset + 2;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+003A COLON (:)
          case 58:
            type = types.Colon;
            offset++;
            break;
          // U+003B SEMICOLON (;)
          case 59:
            type = types.Semicolon;
            offset++;
            break;
          // U+003C LESS-THAN SIGN (<)
          case 60:
            if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
              type = types.CDO;
              offset = offset + 4;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0040 COMMERCIAL AT (@)
          case 64:
            if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
              type = types.AtKeyword;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005B LEFT SQUARE BRACKET ([)
          case 91:
            type = types.LeftSquareBracket;
            offset++;
            break;
          // U+005C REVERSE SOLIDUS (\)
          case 92:
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              consumeIdentLikeToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005D RIGHT SQUARE BRACKET (])
          case 93:
            type = types.RightSquareBracket;
            offset++;
            break;
          // U+007B LEFT CURLY BRACKET ({)
          case 123:
            type = types.LeftCurlyBracket;
            offset++;
            break;
          // U+007D RIGHT CURLY BRACKET (})
          case 125:
            type = types.RightCurlyBracket;
            offset++;
            break;
          // digit
          case charCodeDefinitions.DigitCategory:
            consumeNumericToken();
            break;
          // name-start code point
          case charCodeDefinitions.NameStartCategory:
            consumeIdentLikeToken();
            break;
          // EOF
          // case EofCategory:
          // Return an <EOF-token>.
          // break;
          // anything else
          default:
            type = types.Delim;
            offset++;
        }
        onToken(type, start, start = offset);
      }
    }
    exports2.AtKeyword = types.AtKeyword;
    exports2.BadString = types.BadString;
    exports2.BadUrl = types.BadUrl;
    exports2.CDC = types.CDC;
    exports2.CDO = types.CDO;
    exports2.Colon = types.Colon;
    exports2.Comma = types.Comma;
    exports2.Comment = types.Comment;
    exports2.Delim = types.Delim;
    exports2.Dimension = types.Dimension;
    exports2.EOF = types.EOF;
    exports2.Function = types.Function;
    exports2.Hash = types.Hash;
    exports2.Ident = types.Ident;
    exports2.LeftCurlyBracket = types.LeftCurlyBracket;
    exports2.LeftParenthesis = types.LeftParenthesis;
    exports2.LeftSquareBracket = types.LeftSquareBracket;
    exports2.Number = types.Number;
    exports2.Percentage = types.Percentage;
    exports2.RightCurlyBracket = types.RightCurlyBracket;
    exports2.RightParenthesis = types.RightParenthesis;
    exports2.RightSquareBracket = types.RightSquareBracket;
    exports2.Semicolon = types.Semicolon;
    exports2.String = types.String;
    exports2.Url = types.Url;
    exports2.WhiteSpace = types.WhiteSpace;
    exports2.tokenTypes = types;
    exports2.DigitCategory = charCodeDefinitions.DigitCategory;
    exports2.EofCategory = charCodeDefinitions.EofCategory;
    exports2.NameStartCategory = charCodeDefinitions.NameStartCategory;
    exports2.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
    exports2.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeDefinitions.charCodeCategory;
    exports2.isBOM = charCodeDefinitions.isBOM;
    exports2.isDigit = charCodeDefinitions.isDigit;
    exports2.isHexDigit = charCodeDefinitions.isHexDigit;
    exports2.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    exports2.isLetter = charCodeDefinitions.isLetter;
    exports2.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
    exports2.isName = charCodeDefinitions.isName;
    exports2.isNameStart = charCodeDefinitions.isNameStart;
    exports2.isNewline = charCodeDefinitions.isNewline;
    exports2.isNonAscii = charCodeDefinitions.isNonAscii;
    exports2.isNonPrintable = charCodeDefinitions.isNonPrintable;
    exports2.isNumberStart = charCodeDefinitions.isNumberStart;
    exports2.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
    exports2.isValidEscape = charCodeDefinitions.isValidEscape;
    exports2.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
    exports2.cmpChar = utils.cmpChar;
    exports2.cmpStr = utils.cmpStr;
    exports2.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
    exports2.consumeEscaped = utils.consumeEscaped;
    exports2.consumeName = utils.consumeName;
    exports2.consumeNumber = utils.consumeNumber;
    exports2.decodeEscaped = utils.decodeEscaped;
    exports2.findDecimalNumberEnd = utils.findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = utils.findWhiteSpaceStart;
    exports2.getNewlineLength = utils.getNewlineLength;
    exports2.tokenNames = names;
    exports2.OffsetToLocation = OffsetToLocation.OffsetToLocation;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.tokenize = tokenize;
  }
});

// node_modules/css-tree/cjs/utils/List.cjs
var require_List = __commonJS({
  "node_modules/css-tree/cjs/utils/List.cjs"(exports2) {
    "use strict";
    var releasedCursors = null;
    var List = class _List {
      static createItem(data) {
        return {
          prev: null,
          next: null,
          data
        };
      }
      constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
      }
      createItem(data) {
        return _List.createItem(data);
      }
      // cursor helpers
      allocateCursor(prev, next) {
        let cursor;
        if (releasedCursors !== null) {
          cursor = releasedCursors;
          releasedCursors = releasedCursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = this.cursor;
        } else {
          cursor = {
            prev,
            next,
            cursor: this.cursor
          };
        }
        this.cursor = cursor;
        return cursor;
      }
      releaseCursor() {
        const { cursor } = this;
        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
      }
      updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      }
      *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          yield cursor.data;
        }
      }
      // getters
      get size() {
        let size = 0;
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          size++;
        }
        return size;
      }
      get isEmpty() {
        return this.head === null;
      }
      get first() {
        return this.head && this.head.data;
      }
      get last() {
        return this.tail && this.tail.data;
      }
      // convertors
      fromArray(array) {
        let cursor = null;
        this.head = null;
        for (let data of array) {
          const item = _List.createItem(data);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      }
      toArray() {
        return [...this];
      }
      toJSON() {
        return [...this];
      }
      // array-like methods
      forEach(fn, thisArg = this) {
        const cursor = this.allocateCursor(null, this.head);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      forEachRight(fn, thisArg = this) {
        const cursor = this.allocateCursor(this.tail, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      reduce(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      reduceRight(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            return true;
          }
        }
        return false;
      }
      map(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }
        return result;
      }
      filter(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
        }
        return result;
      }
      nextUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(null, start);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      prevUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(start, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      // mutation
      clear() {
        this.head = null;
        this.tail = null;
      }
      copy() {
        const result = new _List();
        for (let data of this) {
          result.appendData(data);
        }
        return result;
      }
      prepend(item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      }
      prependData(data) {
        return this.prepend(_List.createItem(data));
      }
      append(item) {
        return this.insert(item);
      }
      appendData(data) {
        return this.insert(_List.createItem(data));
      }
      insert(item, before = null) {
        if (before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      }
      insertData(data, before) {
        return this.insert(_List.createItem(data), before);
      }
      remove(item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      }
      push(data) {
        this.insert(_List.createItem(data));
      }
      pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
      }
      unshift(data) {
        this.prepend(_List.createItem(data));
      }
      shift() {
        return this.head !== null ? this.remove(this.head) : null;
      }
      prependList(list) {
        return this.insertList(list, this.head);
      }
      appendList(list) {
        return this.insertList(list);
      }
      insertList(list, before) {
        if (list.head === null) {
          return this;
        }
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, list.tail, before, list.head);
          if (before.prev !== null) {
            before.prev.next = list.head;
            list.head.prev = before.prev;
          } else {
            this.head = list.head;
          }
          before.prev = list.tail;
          list.tail.next = before;
        } else {
          this.updateCursors(this.tail, list.tail, null, list.head);
          if (this.tail !== null) {
            this.tail.next = list.head;
            list.head.prev = this.tail;
          } else {
            this.head = list.head;
          }
          this.tail = list.tail;
        }
        list.head = null;
        list.tail = null;
        return this;
      }
      replace(oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      }
    };
    exports2.List = List;
  }
});

// node_modules/css-tree/cjs/utils/create-custom-error.cjs
var require_create_custom_error = __commonJS({
  "node_modules/css-tree/cjs/utils/create-custom-error.cjs"(exports2) {
    "use strict";
    function createCustomError(name, message) {
      const error = Object.create(SyntaxError.prototype);
      const errorStack = new Error();
      return Object.assign(error, {
        name,
        message,
        get stack() {
          return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
        }
      });
    }
    exports2.createCustomError = createCustomError;
  }
});

// node_modules/css-tree/cjs/parser/SyntaxError.cjs
var require_SyntaxError = __commonJS({
  "node_modules/css-tree/cjs/parser/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    var MAX_LINE_LENGTH = 100;
    var OFFSET_CORRECTION = 60;
    var TAB_REPLACEMENT = "    ";
    function sourceFragment({ source, line, column }, extraLines) {
      function processLines(start, end) {
        return lines.slice(start, end).map(
          (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
        ).join("\n");
      }
      const lines = source.split(/\r\n?|\n|\f/);
      const startLine = Math.max(1, line - extraLines) - 1;
      const endLine = Math.min(line + extraLines, lines.length + 1);
      const maxNumLength = Math.max(4, String(endLine).length) + 1;
      let cutLeft = 0;
      column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
      if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
      }
      for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
          lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
          lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
      }
      return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join("-") + "^",
        processLines(line, endLine)
      ].filter(Boolean).join("\n");
    }
    function SyntaxError2(message, source, offset, line, column) {
      const error = Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
          return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
          return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
        }
      });
      return error;
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/css-tree/cjs/parser/sequence.cjs
var require_sequence = __commonJS({
  "node_modules/css-tree/cjs/parser/sequence.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    function readSequence(recognizer) {
      const children = this.createList();
      let space = false;
      const context = {
        recognizer
      };
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
            this.next();
            continue;
          case types.WhiteSpace:
            space = true;
            this.next();
            continue;
        }
        let child = recognizer.getNode.call(this, context);
        if (child === void 0) {
          break;
        }
        if (space) {
          if (recognizer.onWhiteSpace) {
            recognizer.onWhiteSpace.call(this, child, children, context);
          }
          space = false;
        }
        children.push(child);
      }
      if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
      }
      return children;
    }
    exports2.readSequence = readSequence;
  }
});

// node_modules/css-tree/cjs/parser/create.cjs
var require_create = __commonJS({
  "node_modules/css-tree/cjs/parser/create.cjs"(exports2) {
    "use strict";
    var List = require_List();
    var SyntaxError2 = require_SyntaxError();
    var index = require_tokenizer();
    var sequence = require_sequence();
    var OffsetToLocation = require_OffsetToLocation();
    var TokenStream = require_TokenStream();
    var utils = require_utils();
    var types = require_types2();
    var names = require_names();
    var NOOP = () => {
    };
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var SEMICOLON = 59;
    var LEFTCURLYBRACKET = 123;
    var NULL = 0;
    function createParseContext(name) {
      return function() {
        return this[name]();
      };
    }
    function fetchParseValues(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const name in dict) {
        const item = dict[name];
        const fn = item.parse || item;
        if (fn) {
          result[name] = fn;
        }
      }
      return result;
    }
    function processConfig(config) {
      const parseConfig = {
        context: /* @__PURE__ */ Object.create(null),
        scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
      };
      for (const name in config.parseContext) {
        switch (typeof config.parseContext[name]) {
          case "function":
            parseConfig.context[name] = config.parseContext[name];
            break;
          case "string":
            parseConfig.context[name] = createParseContext(config.parseContext[name]);
            break;
        }
      }
      return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
      };
    }
    function createParser(config) {
      let source = "";
      let filename = "<unknown>";
      let needPositions = false;
      let onParseError = NOOP;
      let onParseErrorThrow = false;
      const locationMap = new OffsetToLocation.OffsetToLocation();
      const parser = Object.assign(new TokenStream.TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: sequence.readSequence,
        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
          return code === LEFTCURLYBRACKET ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
          return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
          return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
          return code === SEMICOLON ? 2 : 0;
        },
        createList() {
          return new List.List();
        },
        createSingleNodeList(node) {
          return new List.List().appendData(node);
        },
        getFirstListNode(list) {
          return list && list.first;
        },
        getLastListNode(list) {
          return list && list.last;
        },
        parseWithFallback(consumer, fallback) {
          const startToken = this.tokenIndex;
          try {
            return consumer.call(this);
          } catch (e) {
            if (onParseErrorThrow) {
              throw e;
            }
            const fallbackNode = fallback.call(this, startToken);
            onParseErrorThrow = true;
            onParseError(e, fallbackNode);
            onParseErrorThrow = false;
            return fallbackNode;
          }
        },
        lookupNonWSType(offset) {
          let type;
          do {
            type = this.lookupType(offset++);
            if (type !== types.WhiteSpace) {
              return type;
            }
          } while (type !== NULL);
          return NULL;
        },
        charCodeAt(offset) {
          return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
          return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
          return this.source.substring(start, this.tokenStart);
        },
        cmpChar(offset, charCode) {
          return utils.cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
          return utils.cmpStr(source, offsetStart, offsetEnd, str);
        },
        consume(tokenType) {
          const start = this.tokenStart;
          this.eat(tokenType);
          return this.substrToCursor(start);
        },
        consumeFunctionName() {
          const name = source.substring(this.tokenStart, this.tokenEnd - 1);
          this.eat(types.Function);
          return name;
        },
        consumeNumber(type) {
          const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));
          this.eat(type);
          return number;
        },
        eat(tokenType) {
          if (this.tokenType !== tokenType) {
            const tokenName = names[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
            let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
            let offset = this.tokenStart;
            switch (tokenType) {
              case types.Ident:
                if (this.tokenType === types.Function || this.tokenType === types.Url) {
                  offset = this.tokenEnd - 1;
                  message = "Identifier is expected but function found";
                } else {
                  message = "Identifier is expected";
                }
                break;
              case types.Hash:
                if (this.isDelim(NUMBERSIGN)) {
                  this.next();
                  offset++;
                  message = "Name is expected";
                }
                break;
              case types.Percentage:
                if (this.tokenType === types.Number) {
                  offset = this.tokenEnd;
                  message = "Percent sign is expected";
                }
                break;
            }
            this.error(message, offset);
          }
          this.next();
        },
        eatIdent(name) {
          if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {
            this.error(`Identifier "${name}" is expected`);
          }
          this.next();
        },
        eatDelim(code) {
          if (!this.isDelim(code)) {
            this.error(`Delim "${String.fromCharCode(code)}" is expected`);
          }
          this.next();
        },
        getLocation(start, end) {
          if (needPositions) {
            return locationMap.getLocationRange(
              start,
              end,
              filename
            );
          }
          return null;
        },
        getLocationFromList(list) {
          if (needPositions) {
            const head = this.getFirstListNode(list);
            const tail = this.getLastListNode(list);
            return locationMap.getLocationRange(
              head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
              tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
              filename
            );
          }
          return null;
        },
        error(message, offset) {
          const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
          throw new SyntaxError2.SyntaxError(
            message || "Unexpected input",
            source,
            location.offset,
            location.line,
            location.column
          );
        }
      });
      const parse = function(source_, options) {
        source = source_;
        options = options || {};
        parser.setSource(source, index.tokenize);
        locationMap.setSource(
          source,
          options.offset,
          options.line,
          options.column
        );
        filename = options.filename || "<unknown>";
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
        onParseErrorThrow = false;
        parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
        const { context = "default", onComment } = options;
        if (context in parser.context === false) {
          throw new Error("Unknown context `" + context + "`");
        }
        if (typeof onComment === "function") {
          parser.forEachToken((type, start, end) => {
            if (type === types.Comment) {
              const loc = parser.getLocation(start, end);
              const value = utils.cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
              onComment(value, loc);
            }
          });
        }
        const ast = parser.context[context].call(parser, options);
        if (!parser.eof) {
          parser.error();
        }
        return ast;
      };
      return Object.assign(parse, {
        SyntaxError: SyntaxError2.SyntaxError,
        config: parser.config
      });
    }
    exports2.createParser = createParser;
  }
});

// node_modules/source-map-js/lib/base64.js
var require_base64 = __commonJS({
  "node_modules/source-map-js/lib/base64.js"(exports2) {
    var intToCharMap = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/".split("");
    exports2.encode = function(number) {
      if (0 <= number && number < intToCharMap.length) {
        return intToCharMap[number];
      }
      throw new TypeError("Must be between 0 and 63: " + number);
    };
    exports2.decode = function(charCode) {
      var bigA = 65;
      var bigZ = 90;
      var littleA = 97;
      var littleZ = 122;
      var zero = 48;
      var nine = 57;
      var plus = 43;
      var slash = 47;
      var littleOffset = 26;
      var numberOffset = 52;
      if (bigA <= charCode && charCode <= bigZ) {
        return charCode - bigA;
      }
      if (littleA <= charCode && charCode <= littleZ) {
        return charCode - littleA + littleOffset;
      }
      if (zero <= charCode && charCode <= nine) {
        return charCode - zero + numberOffset;
      }
      if (charCode == plus) {
        return 62;
      }
      if (charCode == slash) {
        return 63;
      }
      return -1;
    };
  }
});

// node_modules/source-map-js/lib/base64-vlq.js
var require_base64_vlq = __commonJS({
  "node_modules/source-map-js/lib/base64-vlq.js"(exports2) {
    var base64 = require_base64();
    var VLQ_BASE_SHIFT = 5;
    var VLQ_BASE = 1 << VLQ_BASE_SHIFT;
    var VLQ_BASE_MASK = VLQ_BASE - 1;
    var VLQ_CONTINUATION_BIT = VLQ_BASE;
    function toVLQSigned(aValue) {
      return aValue < 0 ? (-aValue << 1) + 1 : (aValue << 1) + 0;
    }
    function fromVLQSigned(aValue) {
      var isNegative = (aValue & 1) === 1;
      var shifted = aValue >> 1;
      return isNegative ? -shifted : shifted;
    }
    exports2.encode = function base64VLQ_encode(aValue) {
      var encoded = "";
      var digit;
      var vlq = toVLQSigned(aValue);
      do {
        digit = vlq & VLQ_BASE_MASK;
        vlq >>>= VLQ_BASE_SHIFT;
        if (vlq > 0) {
          digit |= VLQ_CONTINUATION_BIT;
        }
        encoded += base64.encode(digit);
      } while (vlq > 0);
      return encoded;
    };
    exports2.decode = function base64VLQ_decode(aStr, aIndex, aOutParam) {
      var strLen = aStr.length;
      var result = 0;
      var shift = 0;
      var continuation, digit;
      do {
        if (aIndex >= strLen) {
          throw new Error("Expected more digits in base 64 VLQ value.");
        }
        digit = base64.decode(aStr.charCodeAt(aIndex++));
        if (digit === -1) {
          throw new Error("Invalid base64 digit: " + aStr.charAt(aIndex - 1));
        }
        continuation = !!(digit & VLQ_CONTINUATION_BIT);
        digit &= VLQ_BASE_MASK;
        result = result + (digit << shift);
        shift += VLQ_BASE_SHIFT;
      } while (continuation);
      aOutParam.value = fromVLQSigned(result);
      aOutParam.rest = aIndex;
    };
  }
});

// node_modules/source-map-js/lib/util.js
var require_util = __commonJS({
  "node_modules/source-map-js/lib/util.js"(exports2) {
    function getArg(aArgs, aName, aDefaultValue) {
      if (aName in aArgs) {
        return aArgs[aName];
      } else if (arguments.length === 3) {
        return aDefaultValue;
      } else {
        throw new Error('"' + aName + '" is a required argument.');
      }
    }
    exports2.getArg = getArg;
    var urlRegexp = /^(?:([\w+\-.]+):)?\/\/(?:(\w+:\w+)@)?([\w.-]*)(?::(\d+))?(.*)$/;
    var dataUrlRegexp = /^data:.+\,.+$/;
    function urlParse(aUrl) {
      var match = aUrl.match(urlRegexp);
      if (!match) {
        return null;
      }
      return {
        scheme: match[1],
        auth: match[2],
        host: match[3],
        port: match[4],
        path: match[5]
      };
    }
    exports2.urlParse = urlParse;
    function urlGenerate(aParsedUrl) {
      var url = "";
      if (aParsedUrl.scheme) {
        url += aParsedUrl.scheme + ":";
      }
      url += "//";
      if (aParsedUrl.auth) {
        url += aParsedUrl.auth + "@";
      }
      if (aParsedUrl.host) {
        url += aParsedUrl.host;
      }
      if (aParsedUrl.port) {
        url += ":" + aParsedUrl.port;
      }
      if (aParsedUrl.path) {
        url += aParsedUrl.path;
      }
      return url;
    }
    exports2.urlGenerate = urlGenerate;
    var MAX_CACHED_INPUTS = 32;
    function lruMemoize(f) {
      var cache = [];
      return function(input) {
        for (var i = 0; i < cache.length; i++) {
          if (cache[i].input === input) {
            var temp = cache[0];
            cache[0] = cache[i];
            cache[i] = temp;
            return cache[0].result;
          }
        }
        var result = f(input);
        cache.unshift({
          input,
          result
        });
        if (cache.length > MAX_CACHED_INPUTS) {
          cache.pop();
        }
        return result;
      };
    }
    var normalize = lruMemoize(function normalize2(aPath) {
      var path44 = aPath;
      var url = urlParse(aPath);
      if (url) {
        if (!url.path) {
          return aPath;
        }
        path44 = url.path;
      }
      var isAbsolute3 = exports2.isAbsolute(path44);
      var parts = [];
      var start = 0;
      var i = 0;
      while (true) {
        start = i;
        i = path44.indexOf("/", start);
        if (i === -1) {
          parts.push(path44.slice(start));
          break;
        } else {
          parts.push(path44.slice(start, i));
          while (i < path44.length && path44[i] === "/") {
            i++;
          }
        }
      }
      for (var part, up = 0, i = parts.length - 1; i >= 0; i--) {
        part = parts[i];
        if (part === ".") {
          parts.splice(i, 1);
        } else if (part === "..") {
          up++;
        } else if (up > 0) {
          if (part === "") {
            parts.splice(i + 1, up);
            up = 0;
          } else {
            parts.splice(i, 2);
            up--;
          }
        }
      }
      path44 = parts.join("/");
      if (path44 === "") {
        path44 = isAbsolute3 ? "/" : ".";
      }
      if (url) {
        url.path = path44;
        return urlGenerate(url);
      }
      return path44;
    });
    exports2.normalize = normalize;
    function join35(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      if (aPath === "") {
        aPath = ".";
      }
      var aPathUrl = urlParse(aPath);
      var aRootUrl = urlParse(aRoot);
      if (aRootUrl) {
        aRoot = aRootUrl.path || "/";
      }
      if (aPathUrl && !aPathUrl.scheme) {
        if (aRootUrl) {
          aPathUrl.scheme = aRootUrl.scheme;
        }
        return urlGenerate(aPathUrl);
      }
      if (aPathUrl || aPath.match(dataUrlRegexp)) {
        return aPath;
      }
      if (aRootUrl && !aRootUrl.host && !aRootUrl.path) {
        aRootUrl.host = aPath;
        return urlGenerate(aRootUrl);
      }
      var joined = aPath.charAt(0) === "/" ? aPath : normalize(aRoot.replace(/\/+$/, "") + "/" + aPath);
      if (aRootUrl) {
        aRootUrl.path = joined;
        return urlGenerate(aRootUrl);
      }
      return joined;
    }
    exports2.join = join35;
    exports2.isAbsolute = function(aPath) {
      return aPath.charAt(0) === "/" || urlRegexp.test(aPath);
    };
    function relative10(aRoot, aPath) {
      if (aRoot === "") {
        aRoot = ".";
      }
      aRoot = aRoot.replace(/\/$/, "");
      var level = 0;
      while (aPath.indexOf(aRoot + "/") !== 0) {
        var index = aRoot.lastIndexOf("/");
        if (index < 0) {
          return aPath;
        }
        aRoot = aRoot.slice(0, index);
        if (aRoot.match(/^([^\/]+:\/)?\/*$/)) {
          return aPath;
        }
        ++level;
      }
      return Array(level + 1).join("../") + aPath.substr(aRoot.length + 1);
    }
    exports2.relative = relative10;
    var supportsNullProto = (function() {
      var obj = /* @__PURE__ */ Object.create(null);
      return !("__proto__" in obj);
    })();
    function identity(s) {
      return s;
    }
    function toSetString(aStr) {
      if (isProtoString(aStr)) {
        return "$" + aStr;
      }
      return aStr;
    }
    exports2.toSetString = supportsNullProto ? identity : toSetString;
    function fromSetString(aStr) {
      if (isProtoString(aStr)) {
        return aStr.slice(1);
      }
      return aStr;
    }
    exports2.fromSetString = supportsNullProto ? identity : fromSetString;
    function isProtoString(s) {
      if (!s) {
        return false;
      }
      var length = s.length;
      if (length < 9) {
        return false;
      }
      if (s.charCodeAt(length - 1) !== 95 || s.charCodeAt(length - 2) !== 95 || s.charCodeAt(length - 3) !== 111 || s.charCodeAt(length - 4) !== 116 || s.charCodeAt(length - 5) !== 111 || s.charCodeAt(length - 6) !== 114 || s.charCodeAt(length - 7) !== 112 || s.charCodeAt(length - 8) !== 95 || s.charCodeAt(length - 9) !== 95) {
        return false;
      }
      for (var i = length - 10; i >= 0; i--) {
        if (s.charCodeAt(i) !== 36) {
          return false;
        }
      }
      return true;
    }
    function compareByOriginalPositions(mappingA, mappingB, onlyCompareOriginal) {
      var cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositions = compareByOriginalPositions;
    function compareByOriginalPositionsNoSource(mappingA, mappingB, onlyCompareOriginal) {
      var cmp;
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0 || onlyCompareOriginal) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByOriginalPositionsNoSource = compareByOriginalPositionsNoSource;
    function compareByGeneratedPositionsDeflated(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflated = compareByGeneratedPositionsDeflated;
    function compareByGeneratedPositionsDeflatedNoLine(mappingA, mappingB, onlyCompareGenerated) {
      var cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0 || onlyCompareGenerated) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsDeflatedNoLine = compareByGeneratedPositionsDeflatedNoLine;
    function strcmp(aStr1, aStr2) {
      if (aStr1 === aStr2) {
        return 0;
      }
      if (aStr1 === null) {
        return 1;
      }
      if (aStr2 === null) {
        return -1;
      }
      if (aStr1 > aStr2) {
        return 1;
      }
      return -1;
    }
    function compareByGeneratedPositionsInflated(mappingA, mappingB) {
      var cmp = mappingA.generatedLine - mappingB.generatedLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.generatedColumn - mappingB.generatedColumn;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = strcmp(mappingA.source, mappingB.source);
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalLine - mappingB.originalLine;
      if (cmp !== 0) {
        return cmp;
      }
      cmp = mappingA.originalColumn - mappingB.originalColumn;
      if (cmp !== 0) {
        return cmp;
      }
      return strcmp(mappingA.name, mappingB.name);
    }
    exports2.compareByGeneratedPositionsInflated = compareByGeneratedPositionsInflated;
    function parseSourceMapInput(str) {
      return JSON.parse(str.replace(/^\)]}'[^\n]*\n/, ""));
    }
    exports2.parseSourceMapInput = parseSourceMapInput;
    function computeSourceURL(sourceRoot, sourceURL, sourceMapURL) {
      sourceURL = sourceURL || "";
      if (sourceRoot) {
        if (sourceRoot[sourceRoot.length - 1] !== "/" && sourceURL[0] !== "/") {
          sourceRoot += "/";
        }
        sourceURL = sourceRoot + sourceURL;
      }
      if (sourceMapURL) {
        var parsed = urlParse(sourceMapURL);
        if (!parsed) {
          throw new Error("sourceMapURL could not be parsed");
        }
        if (parsed.path) {
          var index = parsed.path.lastIndexOf("/");
          if (index >= 0) {
            parsed.path = parsed.path.substring(0, index + 1);
          }
        }
        sourceURL = join35(urlGenerate(parsed), sourceURL);
      }
      return normalize(sourceURL);
    }
    exports2.computeSourceURL = computeSourceURL;
  }
});

// node_modules/source-map-js/lib/array-set.js
var require_array_set = __commonJS({
  "node_modules/source-map-js/lib/array-set.js"(exports2) {
    var util = require_util();
    var has = Object.prototype.hasOwnProperty;
    var hasNativeMap = typeof Map !== "undefined";
    function ArraySet() {
      this._array = [];
      this._set = hasNativeMap ? /* @__PURE__ */ new Map() : /* @__PURE__ */ Object.create(null);
    }
    ArraySet.fromArray = function ArraySet_fromArray(aArray, aAllowDuplicates) {
      var set = new ArraySet();
      for (var i = 0, len = aArray.length; i < len; i++) {
        set.add(aArray[i], aAllowDuplicates);
      }
      return set;
    };
    ArraySet.prototype.size = function ArraySet_size() {
      return hasNativeMap ? this._set.size : Object.getOwnPropertyNames(this._set).length;
    };
    ArraySet.prototype.add = function ArraySet_add(aStr, aAllowDuplicates) {
      var sStr = hasNativeMap ? aStr : util.toSetString(aStr);
      var isDuplicate = hasNativeMap ? this.has(aStr) : has.call(this._set, sStr);
      var idx = this._array.length;
      if (!isDuplicate || aAllowDuplicates) {
        this._array.push(aStr);
      }
      if (!isDuplicate) {
        if (hasNativeMap) {
          this._set.set(aStr, idx);
        } else {
          this._set[sStr] = idx;
        }
      }
    };
    ArraySet.prototype.has = function ArraySet_has(aStr) {
      if (hasNativeMap) {
        return this._set.has(aStr);
      } else {
        var sStr = util.toSetString(aStr);
        return has.call(this._set, sStr);
      }
    };
    ArraySet.prototype.indexOf = function ArraySet_indexOf(aStr) {
      if (hasNativeMap) {
        var idx = this._set.get(aStr);
        if (idx >= 0) {
          return idx;
        }
      } else {
        var sStr = util.toSetString(aStr);
        if (has.call(this._set, sStr)) {
          return this._set[sStr];
        }
      }
      throw new Error('"' + aStr + '" is not in the set.');
    };
    ArraySet.prototype.at = function ArraySet_at(aIdx) {
      if (aIdx >= 0 && aIdx < this._array.length) {
        return this._array[aIdx];
      }
      throw new Error("No element indexed by " + aIdx);
    };
    ArraySet.prototype.toArray = function ArraySet_toArray() {
      return this._array.slice();
    };
    exports2.ArraySet = ArraySet;
  }
});

// node_modules/source-map-js/lib/mapping-list.js
var require_mapping_list = __commonJS({
  "node_modules/source-map-js/lib/mapping-list.js"(exports2) {
    var util = require_util();
    function generatedPositionAfter(mappingA, mappingB) {
      var lineA = mappingA.generatedLine;
      var lineB = mappingB.generatedLine;
      var columnA = mappingA.generatedColumn;
      var columnB = mappingB.generatedColumn;
      return lineB > lineA || lineB == lineA && columnB >= columnA || util.compareByGeneratedPositionsInflated(mappingA, mappingB) <= 0;
    }
    function MappingList() {
      this._array = [];
      this._sorted = true;
      this._last = { generatedLine: -1, generatedColumn: 0 };
    }
    MappingList.prototype.unsortedForEach = function MappingList_forEach(aCallback, aThisArg) {
      this._array.forEach(aCallback, aThisArg);
    };
    MappingList.prototype.add = function MappingList_add(aMapping) {
      if (generatedPositionAfter(this._last, aMapping)) {
        this._last = aMapping;
        this._array.push(aMapping);
      } else {
        this._sorted = false;
        this._array.push(aMapping);
      }
    };
    MappingList.prototype.toArray = function MappingList_toArray() {
      if (!this._sorted) {
        this._array.sort(util.compareByGeneratedPositionsInflated);
        this._sorted = true;
      }
      return this._array;
    };
    exports2.MappingList = MappingList;
  }
});

// node_modules/source-map-js/lib/source-map-generator.js
var require_source_map_generator = __commonJS({
  "node_modules/source-map-js/lib/source-map-generator.js"(exports2) {
    var base64VLQ = require_base64_vlq();
    var util = require_util();
    var ArraySet = require_array_set().ArraySet;
    var MappingList = require_mapping_list().MappingList;
    function SourceMapGenerator(aArgs) {
      if (!aArgs) {
        aArgs = {};
      }
      this._file = util.getArg(aArgs, "file", null);
      this._sourceRoot = util.getArg(aArgs, "sourceRoot", null);
      this._skipValidation = util.getArg(aArgs, "skipValidation", false);
      this._ignoreInvalidMapping = util.getArg(aArgs, "ignoreInvalidMapping", false);
      this._sources = new ArraySet();
      this._names = new ArraySet();
      this._mappings = new MappingList();
      this._sourcesContents = null;
    }
    SourceMapGenerator.prototype._version = 3;
    SourceMapGenerator.fromSourceMap = function SourceMapGenerator_fromSourceMap(aSourceMapConsumer, generatorOps) {
      var sourceRoot = aSourceMapConsumer.sourceRoot;
      var generator = new SourceMapGenerator(Object.assign(generatorOps || {}, {
        file: aSourceMapConsumer.file,
        sourceRoot
      }));
      aSourceMapConsumer.eachMapping(function(mapping) {
        var newMapping = {
          generated: {
            line: mapping.generatedLine,
            column: mapping.generatedColumn
          }
        };
        if (mapping.source != null) {
          newMapping.source = mapping.source;
          if (sourceRoot != null) {
            newMapping.source = util.relative(sourceRoot, newMapping.source);
          }
          newMapping.original = {
            line: mapping.originalLine,
            column: mapping.originalColumn
          };
          if (mapping.name != null) {
            newMapping.name = mapping.name;
          }
        }
        generator.addMapping(newMapping);
      });
      aSourceMapConsumer.sources.forEach(function(sourceFile) {
        var sourceRelative = sourceFile;
        if (sourceRoot !== null) {
          sourceRelative = util.relative(sourceRoot, sourceFile);
        }
        if (!generator._sources.has(sourceRelative)) {
          generator._sources.add(sourceRelative);
        }
        var content = aSourceMapConsumer.sourceContentFor(sourceFile);
        if (content != null) {
          generator.setSourceContent(sourceFile, content);
        }
      });
      return generator;
    };
    SourceMapGenerator.prototype.addMapping = function SourceMapGenerator_addMapping(aArgs) {
      var generated = util.getArg(aArgs, "generated");
      var original = util.getArg(aArgs, "original", null);
      var source = util.getArg(aArgs, "source", null);
      var name = util.getArg(aArgs, "name", null);
      if (!this._skipValidation) {
        if (this._validateMapping(generated, original, source, name) === false) {
          return;
        }
      }
      if (source != null) {
        source = String(source);
        if (!this._sources.has(source)) {
          this._sources.add(source);
        }
      }
      if (name != null) {
        name = String(name);
        if (!this._names.has(name)) {
          this._names.add(name);
        }
      }
      this._mappings.add({
        generatedLine: generated.line,
        generatedColumn: generated.column,
        originalLine: original != null && original.line,
        originalColumn: original != null && original.column,
        source,
        name
      });
    };
    SourceMapGenerator.prototype.setSourceContent = function SourceMapGenerator_setSourceContent(aSourceFile, aSourceContent) {
      var source = aSourceFile;
      if (this._sourceRoot != null) {
        source = util.relative(this._sourceRoot, source);
      }
      if (aSourceContent != null) {
        if (!this._sourcesContents) {
          this._sourcesContents = /* @__PURE__ */ Object.create(null);
        }
        this._sourcesContents[util.toSetString(source)] = aSourceContent;
      } else if (this._sourcesContents) {
        delete this._sourcesContents[util.toSetString(source)];
        if (Object.keys(this._sourcesContents).length === 0) {
          this._sourcesContents = null;
        }
      }
    };
    SourceMapGenerator.prototype.applySourceMap = function SourceMapGenerator_applySourceMap(aSourceMapConsumer, aSourceFile, aSourceMapPath) {
      var sourceFile = aSourceFile;
      if (aSourceFile == null) {
        if (aSourceMapConsumer.file == null) {
          throw new Error(
            `SourceMapGenerator.prototype.applySourceMap requires either an explicit source file, or the source map's "file" property. Both were omitted.`
          );
        }
        sourceFile = aSourceMapConsumer.file;
      }
      var sourceRoot = this._sourceRoot;
      if (sourceRoot != null) {
        sourceFile = util.relative(sourceRoot, sourceFile);
      }
      var newSources = new ArraySet();
      var newNames = new ArraySet();
      this._mappings.unsortedForEach(function(mapping) {
        if (mapping.source === sourceFile && mapping.originalLine != null) {
          var original = aSourceMapConsumer.originalPositionFor({
            line: mapping.originalLine,
            column: mapping.originalColumn
          });
          if (original.source != null) {
            mapping.source = original.source;
            if (aSourceMapPath != null) {
              mapping.source = util.join(aSourceMapPath, mapping.source);
            }
            if (sourceRoot != null) {
              mapping.source = util.relative(sourceRoot, mapping.source);
            }
            mapping.originalLine = original.line;
            mapping.originalColumn = original.column;
            if (original.name != null) {
              mapping.name = original.name;
            }
          }
        }
        var source = mapping.source;
        if (source != null && !newSources.has(source)) {
          newSources.add(source);
        }
        var name = mapping.name;
        if (name != null && !newNames.has(name)) {
          newNames.add(name);
        }
      }, this);
      this._sources = newSources;
      this._names = newNames;
      aSourceMapConsumer.sources.forEach(function(sourceFile2) {
        var content = aSourceMapConsumer.sourceContentFor(sourceFile2);
        if (content != null) {
          if (aSourceMapPath != null) {
            sourceFile2 = util.join(aSourceMapPath, sourceFile2);
          }
          if (sourceRoot != null) {
            sourceFile2 = util.relative(sourceRoot, sourceFile2);
          }
          this.setSourceContent(sourceFile2, content);
        }
      }, this);
    };
    SourceMapGenerator.prototype._validateMapping = function SourceMapGenerator_validateMapping(aGenerated, aOriginal, aSource, aName) {
      if (aOriginal && typeof aOriginal.line !== "number" && typeof aOriginal.column !== "number") {
        var message = "original.line and original.column are not numbers -- you probably meant to omit the original mapping entirely and only map the generated position. If so, pass null for the original mapping instead of an object with empty or null values.";
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
      if (aGenerated && "line" in aGenerated && "column" in aGenerated && aGenerated.line > 0 && aGenerated.column >= 0 && !aOriginal && !aSource && !aName) {
        return;
      } else if (aGenerated && "line" in aGenerated && "column" in aGenerated && aOriginal && "line" in aOriginal && "column" in aOriginal && aGenerated.line > 0 && aGenerated.column >= 0 && aOriginal.line > 0 && aOriginal.column >= 0 && aSource) {
        return;
      } else {
        var message = "Invalid mapping: " + JSON.stringify({
          generated: aGenerated,
          source: aSource,
          original: aOriginal,
          name: aName
        });
        if (this._ignoreInvalidMapping) {
          if (typeof console !== "undefined" && console.warn) {
            console.warn(message);
          }
          return false;
        } else {
          throw new Error(message);
        }
      }
    };
    SourceMapGenerator.prototype._serializeMappings = function SourceMapGenerator_serializeMappings() {
      var previousGeneratedColumn = 0;
      var previousGeneratedLine = 1;
      var previousOriginalColumn = 0;
      var previousOriginalLine = 0;
      var previousName = 0;
      var previousSource = 0;
      var result = "";
      var next;
      var mapping;
      var nameIdx;
      var sourceIdx;
      var mappings = this._mappings.toArray();
      for (var i = 0, len = mappings.length; i < len; i++) {
        mapping = mappings[i];
        next = "";
        if (mapping.generatedLine !== previousGeneratedLine) {
          previousGeneratedColumn = 0;
          while (mapping.generatedLine !== previousGeneratedLine) {
            next += ";";
            previousGeneratedLine++;
          }
        } else {
          if (i > 0) {
            if (!util.compareByGeneratedPositionsInflated(mapping, mappings[i - 1])) {
              continue;
            }
            next += ",";
          }
        }
        next += base64VLQ.encode(mapping.generatedColumn - previousGeneratedColumn);
        previousGeneratedColumn = mapping.generatedColumn;
        if (mapping.source != null) {
          sourceIdx = this._sources.indexOf(mapping.source);
          next += base64VLQ.encode(sourceIdx - previousSource);
          previousSource = sourceIdx;
          next += base64VLQ.encode(mapping.originalLine - 1 - previousOriginalLine);
          previousOriginalLine = mapping.originalLine - 1;
          next += base64VLQ.encode(mapping.originalColumn - previousOriginalColumn);
          previousOriginalColumn = mapping.originalColumn;
          if (mapping.name != null) {
            nameIdx = this._names.indexOf(mapping.name);
            next += base64VLQ.encode(nameIdx - previousName);
            previousName = nameIdx;
          }
        }
        result += next;
      }
      return result;
    };
    SourceMapGenerator.prototype._generateSourcesContent = function SourceMapGenerator_generateSourcesContent(aSources, aSourceRoot) {
      return aSources.map(function(source) {
        if (!this._sourcesContents) {
          return null;
        }
        if (aSourceRoot != null) {
          source = util.relative(aSourceRoot, source);
        }
        var key = util.toSetString(source);
        return Object.prototype.hasOwnProperty.call(this._sourcesContents, key) ? this._sourcesContents[key] : null;
      }, this);
    };
    SourceMapGenerator.prototype.toJSON = function SourceMapGenerator_toJSON() {
      var map = {
        version: this._version,
        sources: this._sources.toArray(),
        names: this._names.toArray(),
        mappings: this._serializeMappings()
      };
      if (this._file != null) {
        map.file = this._file;
      }
      if (this._sourceRoot != null) {
        map.sourceRoot = this._sourceRoot;
      }
      if (this._sourcesContents) {
        map.sourcesContent = this._generateSourcesContent(map.sources, map.sourceRoot);
      }
      return map;
    };
    SourceMapGenerator.prototype.toString = function SourceMapGenerator_toString() {
      return JSON.stringify(this.toJSON());
    };
    exports2.SourceMapGenerator = SourceMapGenerator;
  }
});

// node_modules/css-tree/cjs/generator/sourceMap.cjs
var require_sourceMap = __commonJS({
  "node_modules/css-tree/cjs/generator/sourceMap.cjs"(exports2) {
    "use strict";
    var sourceMapGenerator_js = require_source_map_generator();
    var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
    function generateSourceMap(handlers) {
      const map = new sourceMapGenerator_js.SourceMapGenerator();
      const generated = {
        line: 1,
        column: 0
      };
      const original = {
        line: 0,
        // should be zero to add first mapping
        column: 0
      };
      const activatedGenerated = {
        line: 1,
        column: 0
      };
      const activatedMapping = {
        generated: activatedGenerated
      };
      let line = 1;
      let column = 0;
      let sourceMappingActive = false;
      const origHandlersNode = handlers.node;
      handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
          const nodeLine = node.loc.start.line;
          const nodeColumn = node.loc.start.column - 1;
          if (original.line !== nodeLine || original.column !== nodeColumn) {
            original.line = nodeLine;
            original.column = nodeColumn;
            generated.line = line;
            generated.column = column;
            if (sourceMappingActive) {
              sourceMappingActive = false;
              if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                map.addMapping(activatedMapping);
              }
            }
            sourceMappingActive = true;
            map.addMapping({
              source: node.loc.source,
              original,
              generated
            });
          }
        }
        origHandlersNode.call(this, node);
        if (sourceMappingActive && trackNodes.has(node.type)) {
          activatedGenerated.line = line;
          activatedGenerated.column = column;
        }
      };
      const origHandlersEmit = handlers.emit;
      handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
          if (value.charCodeAt(i) === 10) {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        origHandlersEmit(value, type, auto);
      };
      const origHandlersResult = handlers.result;
      handlers.result = function() {
        if (sourceMappingActive) {
          map.addMapping(activatedMapping);
        }
        return {
          css: origHandlersResult(),
          map
        };
      };
      return handlers;
    }
    exports2.generateSourceMap = generateSourceMap;
  }
});

// node_modules/css-tree/cjs/generator/token-before.cjs
var require_token_before = __commonJS({
  "node_modules/css-tree/cjs/generator/token-before.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var code = (type, value) => {
      if (type === types.Delim) {
        type = value;
      }
      if (typeof type === "string") {
        const charCode = type.charCodeAt(0);
        return charCode > 127 ? 32768 : charCode << 8;
      }
      return type;
    };
    var specPairs = [
      [types.Ident, types.Ident],
      [types.Ident, types.Function],
      [types.Ident, types.Url],
      [types.Ident, types.BadUrl],
      [types.Ident, "-"],
      [types.Ident, types.Number],
      [types.Ident, types.Percentage],
      [types.Ident, types.Dimension],
      [types.Ident, types.CDC],
      [types.Ident, types.LeftParenthesis],
      [types.AtKeyword, types.Ident],
      [types.AtKeyword, types.Function],
      [types.AtKeyword, types.Url],
      [types.AtKeyword, types.BadUrl],
      [types.AtKeyword, "-"],
      [types.AtKeyword, types.Number],
      [types.AtKeyword, types.Percentage],
      [types.AtKeyword, types.Dimension],
      [types.AtKeyword, types.CDC],
      [types.Hash, types.Ident],
      [types.Hash, types.Function],
      [types.Hash, types.Url],
      [types.Hash, types.BadUrl],
      [types.Hash, "-"],
      [types.Hash, types.Number],
      [types.Hash, types.Percentage],
      [types.Hash, types.Dimension],
      [types.Hash, types.CDC],
      [types.Dimension, types.Ident],
      [types.Dimension, types.Function],
      [types.Dimension, types.Url],
      [types.Dimension, types.BadUrl],
      [types.Dimension, "-"],
      [types.Dimension, types.Number],
      [types.Dimension, types.Percentage],
      [types.Dimension, types.Dimension],
      [types.Dimension, types.CDC],
      ["#", types.Ident],
      ["#", types.Function],
      ["#", types.Url],
      ["#", types.BadUrl],
      ["#", "-"],
      ["#", types.Number],
      ["#", types.Percentage],
      ["#", types.Dimension],
      ["#", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["-", types.Ident],
      ["-", types.Function],
      ["-", types.Url],
      ["-", types.BadUrl],
      ["-", "-"],
      ["-", types.Number],
      ["-", types.Percentage],
      ["-", types.Dimension],
      ["-", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [types.Number, types.Ident],
      [types.Number, types.Function],
      [types.Number, types.Url],
      [types.Number, types.BadUrl],
      [types.Number, types.Number],
      [types.Number, types.Percentage],
      [types.Number, types.Dimension],
      [types.Number, "%"],
      [types.Number, types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["@", types.Ident],
      ["@", types.Function],
      ["@", types.Url],
      ["@", types.BadUrl],
      ["@", "-"],
      ["@", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [".", types.Number],
      [".", types.Percentage],
      [".", types.Dimension],
      ["+", types.Number],
      ["+", types.Percentage],
      ["+", types.Dimension],
      ["/", "*"]
    ];
    var safePairs = specPairs.concat([
      [types.Ident, types.Hash],
      [types.Dimension, types.Hash],
      [types.Hash, types.Hash],
      [types.AtKeyword, types.LeftParenthesis],
      [types.AtKeyword, types.String],
      [types.AtKeyword, types.Colon],
      [types.Percentage, types.Percentage],
      [types.Percentage, types.Dimension],
      [types.Percentage, types.Function],
      [types.Percentage, "-"],
      [types.RightParenthesis, types.Ident],
      [types.RightParenthesis, types.Function],
      [types.RightParenthesis, types.Percentage],
      [types.RightParenthesis, types.Dimension],
      [types.RightParenthesis, types.Hash],
      [types.RightParenthesis, "-"]
    ]);
    function createMap(pairs) {
      const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => code(prev) << 16 | code(next))
      );
      return function(prevCode, type, value) {
        const nextCode = code(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs = nextCharCode === HYPHENMINUS && type !== types.Ident && type !== types.Function && type !== types.CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
        if (emitWs) {
          this.emit(" ", types.WhiteSpace, true);
        }
        return nextCode;
      };
    }
    var spec = createMap(specPairs);
    var safe = createMap(safePairs);
    exports2.safe = safe;
    exports2.spec = spec;
  }
});

// node_modules/css-tree/cjs/generator/create.cjs
var require_create2 = __commonJS({
  "node_modules/css-tree/cjs/generator/create.cjs"(exports2) {
    "use strict";
    var index = require_tokenizer();
    var sourceMap = require_sourceMap();
    var tokenBefore = require_token_before();
    var types = require_types2();
    var REVERSESOLIDUS = 92;
    function processChildren(node, delimeter) {
      if (typeof delimeter === "function") {
        let prev = null;
        node.children.forEach((node2) => {
          if (prev !== null) {
            delimeter.call(this, prev);
          }
          this.node(node2);
          prev = node2;
        });
        return;
      }
      node.children.forEach(this.node, this);
    }
    function processChunk(chunk) {
      index.tokenize(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
      });
    }
    function createGenerator(config) {
      const types$1 = /* @__PURE__ */ new Map();
      for (let name in config.node) {
        const item = config.node[name];
        const fn = item.generate || item;
        if (typeof fn === "function") {
          types$1.set(name, item.generate || item);
        }
      }
      return function(node, options) {
        let buffer = "";
        let prevCode = 0;
        let handlers = {
          node(node2) {
            if (types$1.has(node2.type)) {
              types$1.get(node2.type).call(publicApi, node2);
            } else {
              throw new Error("Unknown node type: " + node2.type);
            }
          },
          tokenBefore: tokenBefore.safe,
          token(type, value) {
            prevCode = this.tokenBefore(prevCode, type, value);
            this.emit(value, type, false);
            if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
              this.emit("\n", types.WhiteSpace, true);
            }
          },
          emit(value) {
            buffer += value;
          },
          result() {
            return buffer;
          }
        };
        if (options) {
          if (typeof options.decorator === "function") {
            handlers = options.decorator(handlers);
          }
          if (options.sourceMap) {
            handlers = sourceMap.generateSourceMap(handlers);
          }
          if (options.mode in tokenBefore) {
            handlers.tokenBefore = tokenBefore[options.mode];
          }
        }
        const publicApi = {
          node: (node2) => handlers.node(node2),
          children: processChildren,
          token: (type, value) => handlers.token(type, value),
          tokenize: processChunk
        };
        handlers.node(node);
        return handlers.result();
      };
    }
    exports2.createGenerator = createGenerator;
  }
});

// node_modules/css-tree/cjs/convertor/create.cjs
var require_create3 = __commonJS({
  "node_modules/css-tree/cjs/convertor/create.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function createConvertor(walk) {
      return {
        fromPlainObject(ast) {
          walk(ast, {
            enter(node) {
              if (node.children && node.children instanceof List.List === false) {
                node.children = new List.List().fromArray(node.children);
              }
            }
          });
          return ast;
        },
        toPlainObject(ast) {
          walk(ast, {
            leave(node) {
              if (node.children && node.children instanceof List.List) {
                node.children = node.children.toArray();
              }
            }
          });
          return ast;
        }
      };
    }
    exports2.createConvertor = createConvertor;
  }
});

// node_modules/css-tree/cjs/walker/create.cjs
var require_create4 = __commonJS({
  "node_modules/css-tree/cjs/walker/create.cjs"(exports2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function invokeForType(fn, type) {
      return function(node, item, list) {
        if (node.type === type) {
          fn.call(this, node, item, list);
        }
      };
    }
    function getWalkersFromStructure(name, nodeType) {
      const structure = nodeType.structure;
      const walkers = [];
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        let fieldTypes = structure[key];
        const walker = {
          name: key,
          type: false,
          nullable: false
        };
        if (!Array.isArray(fieldTypes)) {
          fieldTypes = [fieldTypes];
        }
        for (const fieldType of fieldTypes) {
          if (fieldType === null) {
            walker.nullable = true;
          } else if (typeof fieldType === "string") {
            walker.type = "node";
          } else if (Array.isArray(fieldType)) {
            walker.type = "list";
          }
        }
        if (walker.type) {
          walkers.push(walker);
        }
      }
      if (walkers.length) {
        return {
          context: nodeType.walkContext,
          fields: walkers
        };
      }
      return null;
    }
    function getTypesFromConfig(config) {
      const types = {};
      for (const name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          const nodeType = config.node[name];
          if (!nodeType.structure) {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
          types[name] = getWalkersFromStructure(name, nodeType);
        }
      }
      return types;
    }
    function createTypeIterator(config, reverse) {
      const fields = config.fields.slice();
      const contextName = config.context;
      const useContext = typeof contextName === "string";
      if (reverse) {
        fields.reverse();
      }
      return function(node, context, walk, walkReducer) {
        let prevContextValue;
        if (useContext) {
          prevContextValue = context[contextName];
          context[contextName] = node;
        }
        for (const field of fields) {
          const ref = node[field.name];
          if (!field.nullable || ref) {
            if (field.type === "list") {
              const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
              if (breakWalk) {
                return true;
              }
            } else if (walk(ref)) {
              return true;
            }
          }
        }
        if (useContext) {
          context[contextName] = prevContextValue;
        }
      };
    }
    function createFastTraveralMap({
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }) {
      return {
        Atrule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Rule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Declaration: {
          StyleSheet,
          Atrule,
          Rule,
          Block,
          DeclarationList
        }
      };
    }
    function createWalker(config) {
      const types = getTypesFromConfig(config);
      const iteratorsNatural = {};
      const iteratorsReverse = {};
      const breakWalk = /* @__PURE__ */ Symbol("break-walk");
      const skipNode = /* @__PURE__ */ Symbol("skip-node");
      for (const name in types) {
        if (hasOwnProperty2.call(types, name) && types[name] !== null) {
          iteratorsNatural[name] = createTypeIterator(types[name], false);
          iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
      }
      const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
      const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
      const walk = function(root, options) {
        function walkNode(node, item, list) {
          const enterRet = enter.call(context, node, item, list);
          if (enterRet === breakWalk) {
            return true;
          }
          if (enterRet === skipNode) {
            return false;
          }
          if (iterators.hasOwnProperty(node.type)) {
            if (iterators[node.type](node, context, walkNode, walkReducer)) {
              return true;
            }
          }
          if (leave.call(context, node, item, list) === breakWalk) {
            return true;
          }
          return false;
        }
        let enter = noop;
        let leave = noop;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
          break: breakWalk,
          skip: skipNode,
          root,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
          if (options.reverse) {
            iterators = iteratorsReverse;
          }
          if (options.visit) {
            if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
              iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
            } else if (!types.hasOwnProperty(options.visit)) {
              throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
            }
            enter = invokeForType(enter, options.visit);
            leave = invokeForType(leave, options.visit);
          }
        }
        if (enter === noop && leave === noop) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walkNode(root);
      };
      walk.break = breakWalk;
      walk.skip = skipNode;
      walk.find = function(ast, fn) {
        let found = null;
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        });
        return found;
      };
      walk.findLast = function(ast, fn) {
        let found = null;
        walk(ast, {
          reverse: true,
          enter(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          }
        });
        return found;
      };
      walk.findAll = function(ast, fn) {
        const found = [];
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found.push(node);
          }
        });
        return found;
      };
      return walk;
    }
    exports2.createWalker = createWalker;
  }
});

// node_modules/css-tree/cjs/definition-syntax/generate.cjs
var require_generate = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/generate.cjs"(exports2) {
    "use strict";
    function noop(value) {
      return value;
    }
    function generateMultiplier(multiplier) {
      const { min, max, comma } = multiplier;
      if (min === 0 && max === 0) {
        return comma ? "#?" : "*";
      }
      if (min === 0 && max === 1) {
        return "?";
      }
      if (min === 1 && max === 0) {
        return comma ? "#" : "+";
      }
      if (min === 1 && max === 1) {
        return "";
      }
      return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
    }
    function generateTypeOpts(node) {
      switch (node.type) {
        case "Range":
          return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
    }
    function generateSequence(node, decorate, forceBraces, compact) {
      const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
      const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
      if (node.explicit || forceBraces) {
        return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
      }
      return result;
    }
    function internalGenerate(node, decorate, forceBraces, compact) {
      let result;
      switch (node.type) {
        case "Group":
          result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
        case "Type":
          result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
          break;
        case "Property":
          result = "<'" + node.name + "'>";
          break;
        case "Keyword":
          result = node.name;
          break;
        case "AtKeyword":
          result = "@" + node.name;
          break;
        case "Function":
          result = node.name + "(";
          break;
        case "String":
        case "Token":
          result = node.value;
          break;
        case "Comma":
          result = ",";
          break;
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
      return decorate(result, node);
    }
    function generate(node, options) {
      let decorate = noop;
      let forceBraces = false;
      let compact = false;
      if (typeof options === "function") {
        decorate = options;
      } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === "function") {
          decorate = options.decorate;
        }
      }
      return internalGenerate(node, decorate, forceBraces, compact);
    }
    exports2.generate = generate;
  }
});

// node_modules/css-tree/cjs/lexer/error.cjs
var require_error = __commonJS({
  "node_modules/css-tree/cjs/lexer/error.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    var generate = require_generate();
    var defaultLoc = { offset: 0, line: 1, column: 1 };
    function locateMismatch(matchResult, node) {
      const tokens = matchResult.tokens;
      const longestMatch = matchResult.longestMatch;
      const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
      const badNode = mismatchNode !== node ? mismatchNode : null;
      let mismatchOffset = 0;
      let mismatchLength = 0;
      let entries = 0;
      let css = "";
      let start;
      let end;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;
        if (i === longestMatch) {
          mismatchLength = token.length;
          mismatchOffset = css.length;
        }
        if (badNode !== null && tokens[i].node === badNode) {
          if (i <= longestMatch) {
            entries++;
          } else {
            entries = 0;
          }
        }
        css += token;
      }
      if (longestMatch === tokens.length || entries > 1) {
        start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
        end = buildLoc(start);
      } else {
        start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
      }
      return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      };
    }
    function fromLoc(node, point) {
      const value = node && node.loc && node.loc[point];
      if (value) {
        return "line" in value ? buildLoc(value) : value;
      }
      return null;
    }
    function buildLoc({ offset, line, column }, extra) {
      const loc = {
        offset,
        line,
        column
      };
      if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);
        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
      }
      return loc;
    }
    var SyntaxReferenceError = function(type, referenceName) {
      const error = createCustomError.createCustomError(
        "SyntaxReferenceError",
        type + (referenceName ? " `" + referenceName + "`" : "")
      );
      error.reference = referenceName;
      return error;
    };
    var SyntaxMatchError = function(message, syntax, node, matchResult) {
      const error = createCustomError.createCustomError("SyntaxMatchError", message);
      const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      } = locateMismatch(matchResult, node);
      error.rawMessage = message;
      error.syntax = syntax ? generate.generate(syntax) : "<generic>";
      error.css = css;
      error.mismatchOffset = mismatchOffset;
      error.mismatchLength = mismatchLength;
      error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
      Object.assign(error, start);
      error.loc = {
        source: node && node.loc && node.loc.source || "<unknown>",
        start,
        end
      };
      return error;
    };
    exports2.SyntaxMatchError = SyntaxMatchError;
    exports2.SyntaxReferenceError = SyntaxReferenceError;
  }
});

// node_modules/css-tree/cjs/utils/names.cjs
var require_names2 = __commonJS({
  "node_modules/css-tree/cjs/utils/names.cjs"(exports2) {
    "use strict";
    var keywords = /* @__PURE__ */ new Map();
    var properties = /* @__PURE__ */ new Map();
    var HYPHENMINUS = 45;
    var keyword = getKeywordDescriptor;
    var property = getPropertyDescriptor;
    var vendorPrefix = getVendorPrefix;
    function isCustomProperty(str, offset) {
      offset = offset || 0;
      return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
    }
    function getVendorPrefix(str, offset) {
      offset = offset || 0;
      if (str.length - offset >= 3) {
        if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
          const secondDashIndex = str.indexOf("-", offset + 2);
          if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
          }
        }
      }
      return "";
    }
    function getKeywordDescriptor(keyword2) {
      if (keywords.has(keyword2)) {
        return keywords.get(keyword2);
      }
      const name = keyword2.toLowerCase();
      let descriptor = keywords.get(name);
      if (descriptor === void 0) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : "";
        descriptor = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          prefix: vendor,
          vendor,
          custom
        });
      }
      keywords.set(keyword2, descriptor);
      return descriptor;
    }
    function getPropertyDescriptor(property2) {
      if (properties.has(property2)) {
        return properties.get(property2);
      }
      let name = property2;
      let hack = property2[0];
      if (hack === "/") {
        hack = property2[1] === "/" ? "//" : "/";
      } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
        hack = "";
      }
      const custom = isCustomProperty(name, hack.length);
      if (!custom) {
        name = name.toLowerCase();
        if (properties.has(name)) {
          const descriptor2 = properties.get(name);
          properties.set(property2, descriptor2);
          return descriptor2;
        }
      }
      const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
      const prefix = name.substr(0, hack.length + vendor.length);
      const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
      });
      properties.set(property2, descriptor);
      return descriptor;
    }
    exports2.isCustomProperty = isCustomProperty;
    exports2.keyword = keyword;
    exports2.property = property;
    exports2.vendorPrefix = vendorPrefix;
  }
});

// node_modules/css-tree/cjs/lexer/generic-const.cjs
var require_generic_const = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-const.cjs"(exports2) {
    "use strict";
    var cssWideKeywords = [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ];
    exports2.cssWideKeywords = cssWideKeywords;
  }
});

// node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs
var require_generic_an_plus_b = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var types = require_types2();
    var utils = require_utils();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function skipSC(token, offset, getNextToken) {
      while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {
        token = getNextToken(++offset);
      }
      return offset;
    }
    function checkInteger(token, valueOffset, disallowSign, offset) {
      if (!token) {
        return 0;
      }
      const code = token.value.charCodeAt(valueOffset);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          return 0;
        }
        valueOffset++;
      }
      for (; valueOffset < token.value.length; valueOffset++) {
        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
          return 0;
        }
      }
      return offset + 1;
    }
    function consumeB(token, offset_, getNextToken) {
      let sign = false;
      let offset = skipSC(token, offset_, getNextToken);
      token = getNextToken(offset);
      if (token === null) {
        return offset_;
      }
      if (token.type !== types.Number) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
          sign = true;
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          if (token === null || token.type !== types.Number) {
            return 0;
          }
        } else {
          return offset_;
        }
      }
      if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
          return 0;
        }
      }
      return checkInteger(token, sign ? 0 : 1, sign, offset);
    }
    function anPlusB(token, getNextToken) {
      let offset = 0;
      if (!token) {
        return 0;
      }
      if (token.type === types.Number) {
        return checkInteger(token, 0, ALLOW_SIGN, offset);
      } else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {
        if (!utils.cmpChar(token.value, 1, N)) {
          return 0;
        }
        switch (token.value.length) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // -n- <signless-integer>
          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // <dashndashdigit-ident>
          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Ident || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident) {
        if (token.type !== types.Ident) {
          token = getNextToken(++offset);
        }
        if (token === null || !utils.cmpChar(token.value, 0, N)) {
          return 0;
        }
        switch (token.value.length) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // '+'? n- <signless-integer>
          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // '+'? <ndashdigit-ident>
          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Dimension) {
        let code = token.value.charCodeAt(0);
        let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
        let i = sign;
        for (; i < token.value.length; i++) {
          if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
            break;
          }
        }
        if (i === sign) {
          return 0;
        }
        if (!utils.cmpChar(token.value, i, N)) {
          return 0;
        }
        if (i + 1 === token.value.length) {
          return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
          if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
            return 0;
          }
          if (i + 2 === token.value.length) {
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          } else {
            return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
          }
        }
      }
      return 0;
    }
    module2.exports = anPlusB;
  }
});

// node_modules/css-tree/cjs/lexer/generic-urange.cjs
var require_generic_urange = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic-urange.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var types = require_types2();
    var utils = require_utils();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function startsWith(token, code) {
      return token.value.charCodeAt(0) === code;
    }
    function hexSequence(token, offset, allowDash) {
      let hexlen = 0;
      for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
          hexSequence(token, offset + hexlen + 1, false);
          return 6;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          return 0;
        }
        if (++hexlen > 6) {
          return 0;
        }
      }
      return hexlen;
    }
    function withQuestionMarkSequence(consumed, length, getNextToken) {
      if (!consumed) {
        return 0;
      }
      while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
          return 0;
        }
        length++;
      }
      return length;
    }
    function urange(token, getNextToken) {
      let length = 0;
      if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (token.type === types.Ident) {
          return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }
        if (isDelim(token, QUESTIONMARK)) {
          return withQuestionMarkSequence(1, ++length, getNextToken);
        }
        return 0;
      }
      if (token.type === types.Number) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return length;
        }
        if (token.type === types.Dimension || token.type === types.Number) {
          if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
            return 0;
          }
          return length + 1;
        }
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
      }
      if (token.type === types.Dimension) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
      }
      return 0;
    }
    module2.exports = urange;
  }
});

// node_modules/css-tree/cjs/lexer/generic.cjs
var require_generic = __commonJS({
  "node_modules/css-tree/cjs/lexer/generic.cjs"(exports2) {
    "use strict";
    var genericConst = require_generic_const();
    var genericAnPlusB = require_generic_an_plus_b();
    var genericUrange = require_generic_urange();
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
    var balancePair = /* @__PURE__ */ new Map([
      [types.Function, types.RightParenthesis],
      [types.LeftParenthesis, types.RightParenthesis],
      [types.LeftSquareBracket, types.RightSquareBracket],
      [types.LeftCurlyBracket, types.RightCurlyBracket]
    ]);
    function charCodeAt(str, index) {
      return index < str.length ? str.charCodeAt(index) : 0;
    }
    function eqStr(actual, expected) {
      return utils.cmpStr(actual, 0, actual.length, expected);
    }
    function eqStrAny(actual, expected) {
      for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
          return true;
        }
      }
      return false;
    }
    function isPostfixIeHack(str, offset) {
      if (offset !== str.length - 2) {
        return false;
      }
      return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
      charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
    }
    function outOfRange(opts, value, numEnd) {
      if (opts && opts.type === "Range") {
        const num = Number(
          numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
        );
        if (isNaN(num)) {
          return true;
        }
        if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
          return true;
        }
        if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
          return true;
        }
      }
      return false;
    }
    function consumeFunction(token, getNextToken) {
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              if (balanceStash.length === 0) {
                length++;
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function calc(next) {
      return function(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {
          return consumeFunction(token, getNextToken);
        }
        return next(token, getNextToken, opts);
      };
    }
    function tokenType(expectedTokenType) {
      return function(token) {
        if (token === null || token.type !== expectedTokenType) {
          return 0;
        }
        return 1;
      };
    }
    function customIdent(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      const name = token.value.toLowerCase();
      if (eqStrAny(name, genericConst.cssWideKeywords)) {
        return 0;
      }
      if (eqStr(name, "default")) {
        return 0;
      }
      return 1;
    }
    function customPropertyName(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
        return 0;
      }
      return 1;
    }
    function hexColor(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      const length = token.value.length;
      if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
      }
      for (let i = 1; i < length; i++) {
        if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      return 1;
    }
    function idSelector(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
      }
      return 1;
    }
    function declarationValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            // ... or top-level <semicolon-token> tokens
            case types.Semicolon:
              if (balanceCloseType === 0) {
                break scan;
              }
              break;
            // ... or <delim-token> tokens with a value of "!"
            case types.Delim:
              if (balanceCloseType === 0 && token.value === "!") {
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function anyValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function dimension(type) {
      if (type) {
        type = new Set(type);
      }
      return function(token, getNextToken, opts) {
        if (token === null || token.type !== types.Dimension) {
          return 0;
        }
        const numberEnd = utils.consumeNumber(token.value, 0);
        if (type !== null) {
          const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
          const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
          if (type.has(unit.toLowerCase()) === false) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      };
    }
    function percentage(token, getNextToken, opts) {
      if (token === null || token.type !== types.Percentage) {
        return 0;
      }
      if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
      }
      return 1;
    }
    function zero(next) {
      if (typeof next !== "function") {
        next = function() {
          return 0;
        };
      }
      return function(token, getNextToken, opts) {
        if (token !== null && token.type === types.Number) {
          if (Number(token.value) === 0) {
            return 1;
          }
        }
        return next(token, getNextToken, opts);
      };
    }
    function number(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      const numberEnd = utils.consumeNumber(token.value, 0);
      const isNumber = numberEnd === token.value.length;
      if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    }
    function integer(token, getNextToken, opts) {
      if (token === null || token.type !== types.Number) {
        return 0;
      }
      let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
      charCodeAt(token.value, 0) === 45 ? 1 : 0;
      for (; i < token.value.length; i++) {
        if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, i)) {
        return 0;
      }
      return 1;
    }
    var tokenTypes = {
      "ident-token": tokenType(types.Ident),
      "function-token": tokenType(types.Function),
      "at-keyword-token": tokenType(types.AtKeyword),
      "hash-token": tokenType(types.Hash),
      "string-token": tokenType(types.String),
      "bad-string-token": tokenType(types.BadString),
      "url-token": tokenType(types.Url),
      "bad-url-token": tokenType(types.BadUrl),
      "delim-token": tokenType(types.Delim),
      "number-token": tokenType(types.Number),
      "percentage-token": tokenType(types.Percentage),
      "dimension-token": tokenType(types.Dimension),
      "whitespace-token": tokenType(types.WhiteSpace),
      "CDO-token": tokenType(types.CDO),
      "CDC-token": tokenType(types.CDC),
      "colon-token": tokenType(types.Colon),
      "semicolon-token": tokenType(types.Semicolon),
      "comma-token": tokenType(types.Comma),
      "[-token": tokenType(types.LeftSquareBracket),
      "]-token": tokenType(types.RightSquareBracket),
      "(-token": tokenType(types.LeftParenthesis),
      ")-token": tokenType(types.RightParenthesis),
      "{-token": tokenType(types.LeftCurlyBracket),
      "}-token": tokenType(types.RightCurlyBracket)
    };
    var productionTypes = {
      // token type aliases
      "string": tokenType(types.String),
      "ident": tokenType(types.Ident),
      // percentage
      "percentage": calc(percentage),
      // numeric
      "zero": zero(),
      "number": calc(number),
      "integer": calc(integer),
      // complex types
      "custom-ident": customIdent,
      "custom-property-name": customPropertyName,
      "hex-color": hexColor,
      "id-selector": idSelector,
      // element( <id-selector> )
      "an-plus-b": genericAnPlusB,
      "urange": genericUrange,
      "declaration-value": declarationValue,
      "any-value": anyValue
    };
    function createDemensionTypes(units) {
      const {
        angle,
        decibel,
        frequency,
        flex,
        length,
        resolution,
        semitones,
        time
      } = units || {};
      return {
        "dimension": calc(dimension(null)),
        "angle": calc(dimension(angle)),
        "decibel": calc(dimension(decibel)),
        "frequency": calc(dimension(frequency)),
        "flex": calc(dimension(flex)),
        "length": calc(zero(dimension(length))),
        "resolution": calc(dimension(resolution)),
        "semitones": calc(dimension(semitones)),
        "time": calc(dimension(time))
      };
    }
    function createGenericTypes(units) {
      return {
        ...tokenTypes,
        ...productionTypes,
        ...createDemensionTypes(units)
      };
    }
    exports2.createDemensionTypes = createDemensionTypes;
    exports2.createGenericTypes = createGenericTypes;
    exports2.productionTypes = productionTypes;
    exports2.tokenTypes = tokenTypes;
  }
});

// node_modules/css-tree/cjs/lexer/units.cjs
var require_units = __commonJS({
  "node_modules/css-tree/cjs/lexer/units.cjs"(exports2) {
    "use strict";
    var length = [
      // absolute length units https://www.w3.org/TR/css-values-3/#lengths
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ];
    var angle = ["deg", "grad", "rad", "turn"];
    var time = ["s", "ms"];
    var frequency = ["hz", "khz"];
    var resolution = ["dpi", "dpcm", "dppx", "x"];
    var flex = ["fr"];
    var decibel = ["db"];
    var semitones = ["st"];
    exports2.angle = angle;
    exports2.decibel = decibel;
    exports2.flex = flex;
    exports2.frequency = frequency;
    exports2.length = length;
    exports2.resolution = resolution;
    exports2.semitones = semitones;
    exports2.time = time;
  }
});

// node_modules/css-tree/cjs/lexer/prepare-tokens.cjs
var require_prepare_tokens = __commonJS({
  "node_modules/css-tree/cjs/lexer/prepare-tokens.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer();
    var astToTokens = {
      decorator(handlers) {
        const tokens = [];
        let curNode = null;
        return {
          ...handlers,
          node(node) {
            const tmp = curNode;
            curNode = node;
            handlers.node.call(this, node);
            curNode = tmp;
          },
          emit(value, type, auto) {
            tokens.push({
              type,
              value,
              node: auto ? null : curNode
            });
          },
          result() {
            return tokens;
          }
        };
      }
    };
    function stringToTokens(str) {
      const tokens = [];
      index.tokenize(
        str,
        (type, start, end) => tokens.push({
          type,
          value: str.slice(start, end),
          node: null
        })
      );
      return tokens;
    }
    function prepareTokens(value, syntax) {
      if (typeof value === "string") {
        return stringToTokens(value);
      }
      return syntax.generate(value, astToTokens);
    }
    module2.exports = prepareTokens;
  }
});

// node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs
var require_SyntaxError2 = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error();
    function SyntaxError2(message, input, offset) {
      return Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        input,
        offset,
        rawMessage: message,
        message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
      });
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs
var require_tokenizer2 = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError2();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var Tokenizer = class {
      constructor(str) {
        this.str = str;
        this.pos = 0;
      }
      charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
      }
      charCode() {
        return this.charCodeAt(this.pos);
      }
      nextCharCode() {
        return this.charCodeAt(this.pos + 1);
      }
      nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
      }
      findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
          const code = this.str.charCodeAt(pos);
          if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
          }
        }
        return pos;
      }
      substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
      }
      eat(code) {
        if (this.charCode() !== code) {
          this.error("Expect `" + String.fromCharCode(code) + "`");
        }
        this.pos++;
      }
      peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      }
      error(message) {
        throw new SyntaxError2.SyntaxError(message, this.str, this.pos);
      }
    };
    exports2.Tokenizer = Tokenizer;
  }
});

// node_modules/css-tree/cjs/definition-syntax/parse.cjs
var require_parse3 = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/parse.cjs"(exports2) {
    "use strict";
    var tokenizer = require_tokenizer2();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var COMMA = 44;
    var HYPERMINUS = 45;
    var LESSTHANSIGN = 60;
    var GREATERTHANSIGN = 62;
    var QUESTIONMARK = 63;
    var COMMERCIALAT = 64;
    var LEFTSQUAREBRACKET = 91;
    var RIGHTSQUAREBRACKET = 93;
    var LEFTCURLYBRACKET = 123;
    var VERTICALLINE = 124;
    var RIGHTCURLYBRACKET = 125;
    var INFINITY = 8734;
    var NAME_CHAR = new Uint8Array(128).map(
      (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
    );
    var COMBINATOR_PRECEDENCE = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function scanSpaces(tokenizer2) {
      return tokenizer2.substringToPos(
        tokenizer2.findWsEnd(tokenizer2.pos)
      );
    }
    function scanWord(tokenizer2) {
      let end = tokenizer2.pos;
      for (; end < tokenizer2.str.length; end++) {
        const code = tokenizer2.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
          break;
        }
      }
      if (tokenizer2.pos === end) {
        tokenizer2.error("Expect a keyword");
      }
      return tokenizer2.substringToPos(end);
    }
    function scanNumber(tokenizer2) {
      let end = tokenizer2.pos;
      for (; end < tokenizer2.str.length; end++) {
        const code = tokenizer2.str.charCodeAt(end);
        if (code < 48 || code > 57) {
          break;
        }
      }
      if (tokenizer2.pos === end) {
        tokenizer2.error("Expect a number");
      }
      return tokenizer2.substringToPos(end);
    }
    function scanString(tokenizer2) {
      const end = tokenizer2.str.indexOf("'", tokenizer2.pos + 1);
      if (end === -1) {
        tokenizer2.pos = tokenizer2.str.length;
        tokenizer2.error("Expect an apostrophe");
      }
      return tokenizer2.substringToPos(end + 1);
    }
    function readMultiplierRange(tokenizer2) {
      let min = null;
      let max = null;
      tokenizer2.eat(LEFTCURLYBRACKET);
      min = scanNumber(tokenizer2);
      if (tokenizer2.charCode() === COMMA) {
        tokenizer2.pos++;
        if (tokenizer2.charCode() !== RIGHTCURLYBRACKET) {
          max = scanNumber(tokenizer2);
        }
      } else {
        max = min;
      }
      tokenizer2.eat(RIGHTCURLYBRACKET);
      return {
        min: Number(min),
        max: max ? Number(max) : 0
      };
    }
    function readMultiplier(tokenizer2) {
      let range = null;
      let comma = false;
      switch (tokenizer2.charCode()) {
        case ASTERISK:
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 0
          };
          break;
        case PLUSSIGN:
          tokenizer2.pos++;
          range = {
            min: 1,
            max: 0
          };
          break;
        case QUESTIONMARK:
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 1
          };
          break;
        case NUMBERSIGN:
          tokenizer2.pos++;
          comma = true;
          if (tokenizer2.charCode() === LEFTCURLYBRACKET) {
            range = readMultiplierRange(tokenizer2);
          } else if (tokenizer2.charCode() === QUESTIONMARK) {
            tokenizer2.pos++;
            range = {
              min: 0,
              max: 0
            };
          } else {
            range = {
              min: 1,
              max: 0
            };
          }
          break;
        case LEFTCURLYBRACKET:
          range = readMultiplierRange(tokenizer2);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma,
        min: range.min,
        max: range.max,
        term: null
      };
    }
    function maybeMultiplied(tokenizer2, node) {
      const multiplier = readMultiplier(tokenizer2);
      if (multiplier !== null) {
        multiplier.term = node;
        if (tokenizer2.charCode() === NUMBERSIGN && tokenizer2.charCodeAt(tokenizer2.pos - 1) === PLUSSIGN) {
          return maybeMultiplied(tokenizer2, multiplier);
        }
        return multiplier;
      }
      return node;
    }
    function maybeToken(tokenizer2) {
      const ch = tokenizer2.peek();
      if (ch === "") {
        return null;
      }
      return {
        type: "Token",
        value: ch
      };
    }
    function readProperty(tokenizer2) {
      let name;
      tokenizer2.eat(LESSTHANSIGN);
      tokenizer2.eat(APOSTROPHE);
      name = scanWord(tokenizer2);
      tokenizer2.eat(APOSTROPHE);
      tokenizer2.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer2, {
        type: "Property",
        name
      });
    }
    function readTypeRange(tokenizer2) {
      let min = null;
      let max = null;
      let sign = 1;
      tokenizer2.eat(LEFTSQUAREBRACKET);
      if (tokenizer2.charCode() === HYPERMINUS) {
        tokenizer2.peek();
        sign = -1;
      }
      if (sign == -1 && tokenizer2.charCode() === INFINITY) {
        tokenizer2.peek();
      } else {
        min = sign * Number(scanNumber(tokenizer2));
        if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
          min += scanWord(tokenizer2);
        }
      }
      scanSpaces(tokenizer2);
      tokenizer2.eat(COMMA);
      scanSpaces(tokenizer2);
      if (tokenizer2.charCode() === INFINITY) {
        tokenizer2.peek();
      } else {
        sign = 1;
        if (tokenizer2.charCode() === HYPERMINUS) {
          tokenizer2.peek();
          sign = -1;
        }
        max = sign * Number(scanNumber(tokenizer2));
        if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
          max += scanWord(tokenizer2);
        }
      }
      tokenizer2.eat(RIGHTSQUAREBRACKET);
      return {
        type: "Range",
        min,
        max
      };
    }
    function readType(tokenizer2) {
      let name;
      let opts = null;
      tokenizer2.eat(LESSTHANSIGN);
      name = scanWord(tokenizer2);
      if (tokenizer2.charCode() === LEFTPARENTHESIS && tokenizer2.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer2.pos += 2;
        name += "()";
      }
      if (tokenizer2.charCodeAt(tokenizer2.findWsEnd(tokenizer2.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer2);
        opts = readTypeRange(tokenizer2);
      }
      tokenizer2.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer2, {
        type: "Type",
        name,
        opts
      });
    }
    function readKeywordOrFunction(tokenizer2) {
      const name = scanWord(tokenizer2);
      if (tokenizer2.charCode() === LEFTPARENTHESIS) {
        tokenizer2.pos++;
        return {
          type: "Function",
          name
        };
      }
      return maybeMultiplied(tokenizer2, {
        type: "Keyword",
        name
      });
    }
    function regroupTerms(terms, combinators) {
      function createGroup(terms2, combinator2) {
        return {
          type: "Group",
          terms: terms2,
          combinator: combinator2,
          disallowEmpty: false,
          explicit: false
        };
      }
      let combinator;
      combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
      while (combinators.length > 0) {
        combinator = combinators.shift();
        let i = 0;
        let subgroupStart = 0;
        for (; i < terms.length; i++) {
          const term = terms[i];
          if (term.type === "Combinator") {
            if (term.value === combinator) {
              if (subgroupStart === -1) {
                subgroupStart = i - 1;
              }
              terms.splice(i, 1);
              i--;
            } else {
              if (subgroupStart !== -1 && i - subgroupStart > 1) {
                terms.splice(
                  subgroupStart,
                  i - subgroupStart,
                  createGroup(terms.slice(subgroupStart, i), combinator)
                );
                i = subgroupStart + 1;
              }
              subgroupStart = -1;
            }
          }
        }
        if (subgroupStart !== -1 && combinators.length) {
          terms.splice(
            subgroupStart,
            i - subgroupStart,
            createGroup(terms.slice(subgroupStart, i), combinator)
          );
        }
      }
      return combinator;
    }
    function readImplicitGroup(tokenizer2) {
      const terms = [];
      const combinators = {};
      let token;
      let prevToken = null;
      let prevTokenPos = tokenizer2.pos;
      while (token = peek(tokenizer2)) {
        if (token.type !== "Spaces") {
          if (token.type === "Combinator") {
            if (prevToken === null || prevToken.type === "Combinator") {
              tokenizer2.pos = prevTokenPos;
              tokenizer2.error("Unexpected combinator");
            }
            combinators[token.value] = true;
          } else if (prevToken !== null && prevToken.type !== "Combinator") {
            combinators[" "] = true;
            terms.push({
              type: "Combinator",
              value: " "
            });
          }
          terms.push(token);
          prevToken = token;
          prevTokenPos = tokenizer2.pos;
        }
      }
      if (prevToken !== null && prevToken.type === "Combinator") {
        tokenizer2.pos -= prevTokenPos;
        tokenizer2.error("Unexpected combinator");
      }
      return {
        type: "Group",
        terms,
        combinator: regroupTerms(terms, combinators) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function readGroup(tokenizer2) {
      let result;
      tokenizer2.eat(LEFTSQUAREBRACKET);
      result = readImplicitGroup(tokenizer2);
      tokenizer2.eat(RIGHTSQUAREBRACKET);
      result.explicit = true;
      if (tokenizer2.charCode() === EXCLAMATIONMARK) {
        tokenizer2.pos++;
        result.disallowEmpty = true;
      }
      return result;
    }
    function peek(tokenizer2) {
      let code = tokenizer2.charCode();
      if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer2);
      }
      switch (code) {
        case RIGHTSQUAREBRACKET:
          break;
        case LEFTSQUAREBRACKET:
          return maybeMultiplied(tokenizer2, readGroup(tokenizer2));
        case LESSTHANSIGN:
          return tokenizer2.nextCharCode() === APOSTROPHE ? readProperty(tokenizer2) : readType(tokenizer2);
        case VERTICALLINE:
          return {
            type: "Combinator",
            value: tokenizer2.substringToPos(
              tokenizer2.pos + (tokenizer2.nextCharCode() === VERTICALLINE ? 2 : 1)
            )
          };
        case AMPERSAND:
          tokenizer2.pos++;
          tokenizer2.eat(AMPERSAND);
          return {
            type: "Combinator",
            value: "&&"
          };
        case COMMA:
          tokenizer2.pos++;
          return {
            type: "Comma"
          };
        case APOSTROPHE:
          return maybeMultiplied(tokenizer2, {
            type: "String",
            value: scanString(tokenizer2)
          });
        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
          return {
            type: "Spaces",
            value: scanSpaces(tokenizer2)
          };
        case COMMERCIALAT:
          code = tokenizer2.nextCharCode();
          if (code < 128 && NAME_CHAR[code] === 1) {
            tokenizer2.pos++;
            return {
              type: "AtKeyword",
              name: scanWord(tokenizer2)
            };
          }
          return maybeToken(tokenizer2);
        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
          break;
        case LEFTCURLYBRACKET:
          code = tokenizer2.nextCharCode();
          if (code < 48 || code > 57) {
            return maybeToken(tokenizer2);
          }
          break;
        default:
          return maybeToken(tokenizer2);
      }
    }
    function parse(source) {
      const tokenizer$1 = new tokenizer.Tokenizer(source);
      const result = readImplicitGroup(tokenizer$1);
      if (tokenizer$1.pos !== source.length) {
        tokenizer$1.error("Unexpected input");
      }
      if (result.terms.length === 1 && result.terms[0].type === "Group") {
        return result.terms[0];
      }
      return result;
    }
    exports2.parse = parse;
  }
});

// node_modules/css-tree/cjs/lexer/match-graph.cjs
var require_match_graph = __commonJS({
  "node_modules/css-tree/cjs/lexer/match-graph.cjs"(exports2) {
    "use strict";
    var parse = require_parse3();
    var MATCH = { type: "Match" };
    var MISMATCH = { type: "Mismatch" };
    var DISALLOW_EMPTY = { type: "DisallowEmpty" };
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function createCondition(match, thenBranch, elseBranch) {
      if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
      }
      if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
      }
      if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
      }
      return {
        type: "If",
        match,
        then: thenBranch,
        else: elseBranch
      };
    }
    function isFunctionType(name) {
      return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
    }
    function isEnumCapatible(term) {
      return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
    }
    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
      switch (combinator) {
        case " ": {
          let result = MATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            result = createCondition(
              term,
              result,
              MISMATCH
            );
          }
          return result;
        }
        case "|": {
          let result = MISMATCH;
          let map = null;
          for (let i = terms.length - 1; i >= 0; i--) {
            let term = terms[i];
            if (isEnumCapatible(term)) {
              if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                map = /* @__PURE__ */ Object.create(null);
                result = createCondition(
                  {
                    type: "Enum",
                    map
                  },
                  MATCH,
                  result
                );
              }
              if (map !== null) {
                const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                if (key in map === false) {
                  map[key] = term;
                  continue;
                }
              }
            }
            map = null;
            result = createCondition(
              term,
              MATCH,
              result
            );
          }
          return result;
        }
        case "&&": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: true
            };
          }
          let result = MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                false
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
        case "||": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: false
            };
          }
          let result = atLeastOneTermMatched ? MATCH : MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                true
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
      }
    }
    function buildMultiplierMatchGraph(node) {
      let result = MATCH;
      let matchTerm = buildMatchGraphInternal(node.term);
      if (node.max === 0) {
        matchTerm = createCondition(
          matchTerm,
          DISALLOW_EMPTY,
          MISMATCH
        );
        result = createCondition(
          matchTerm,
          null,
          // will be a loop
          MISMATCH
        );
        result.then = createCondition(
          MATCH,
          MATCH,
          result
          // make a loop
        );
        if (node.comma) {
          result.then.else = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
      } else {
        for (let i = node.min || 1; i <= node.max; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            createCondition(
              MATCH,
              MATCH,
              result
            ),
            MISMATCH
          );
        }
      }
      if (node.min === 0) {
        result = createCondition(
          MATCH,
          MATCH,
          result
        );
      } else {
        for (let i = 0; i < node.min - 1; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            result,
            MISMATCH
          );
        }
      }
      return result;
    }
    function buildMatchGraphInternal(node) {
      if (typeof node === "function") {
        return {
          type: "Generic",
          fn: node
        };
      }
      switch (node.type) {
        case "Group": {
          let result = buildGroupMatchGraph(
            node.combinator,
            node.terms.map(buildMatchGraphInternal),
            false
          );
          if (node.disallowEmpty) {
            result = createCondition(
              result,
              DISALLOW_EMPTY,
              MISMATCH
            );
          }
          return result;
        }
        case "Multiplier":
          return buildMultiplierMatchGraph(node);
        case "Type":
        case "Property":
          return {
            type: node.type,
            name: node.name,
            syntax: node
          };
        case "Keyword":
          return {
            type: node.type,
            name: node.name.toLowerCase(),
            syntax: node
          };
        case "AtKeyword":
          return {
            type: node.type,
            name: "@" + node.name.toLowerCase(),
            syntax: node
          };
        case "Function":
          return {
            type: node.type,
            name: node.name.toLowerCase() + "(",
            syntax: node
          };
        case "String":
          if (node.value.length === 3) {
            return {
              type: "Token",
              value: node.value.charAt(1),
              syntax: node
            };
          }
          return {
            type: node.type,
            value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
            syntax: node
          };
        case "Token":
          return {
            type: node.type,
            value: node.value,
            syntax: node
          };
        case "Comma":
          return {
            type: node.type,
            syntax: node
          };
        default:
          throw new Error("Unknown node type:", node.type);
      }
    }
    function buildMatchGraph(syntaxTree, ref) {
      if (typeof syntaxTree === "string") {
        syntaxTree = parse.parse(syntaxTree);
      }
      return {
        type: "MatchGraph",
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
      };
    }
    exports2.DISALLOW_EMPTY = DISALLOW_EMPTY;
    exports2.MATCH = MATCH;
    exports2.MISMATCH = MISMATCH;
    exports2.buildMatchGraph = buildMatchGraph;
  }
});

// node_modules/css-tree/cjs/lexer/match.cjs
var require_match = __commonJS({
  "node_modules/css-tree/cjs/lexer/match.cjs"(exports2) {
    "use strict";
    var matchGraph = require_match_graph();
    var types = require_types2();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var STUB = 0;
    var TOKEN = 1;
    var OPEN_SYNTAX = 2;
    var CLOSE_SYNTAX = 3;
    var EXIT_REASON_MATCH = "Match";
    var EXIT_REASON_MISMATCH = "Mismatch";
    var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
    var ITERATION_LIMIT = 15e3;
    function reverseList(list) {
      let prev = null;
      let next = null;
      let item = list;
      while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
      }
      return prev;
    }
    function areStringsEqualCaseInsensitive(testStr, referenceStr) {
      if (testStr.length !== referenceStr.length) {
        return false;
      }
      for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);
        if (testCode >= 65 && testCode <= 90) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function isContextEdgeDelim(token) {
      if (token.type !== types.Delim) {
        return false;
      }
      return token.value !== "?";
    }
    function isCommaContextStart(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);
    }
    function isCommaContextEnd(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === "/";
    }
    function internalMatch(tokens, state, syntaxes) {
      function moveToNextToken() {
        do {
          tokenIndex++;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));
      }
      function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;
        return nextIndex < tokens.length ? tokens[nextIndex] : null;
      }
      function stateSnapshotFromSyntax(nextState, prev) {
        return {
          nextState,
          matchStack,
          syntaxStack,
          thenStack,
          tokenIndex,
          prev
        };
      }
      function pushThenStack(nextState) {
        thenStack = {
          nextState,
          matchStack,
          syntaxStack,
          prev: thenStack
        };
      }
      function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
      }
      function addTokenToMatch() {
        matchStack = {
          type: TOKEN,
          syntax: state.syntax,
          token,
          prev: matchStack
        };
        moveToNextToken();
        syntaxStash = null;
        if (tokenIndex > longestMatch) {
          longestMatch = tokenIndex;
        }
      }
      function openSyntax() {
        syntaxStack = {
          syntax: state.syntax,
          opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
          prev: syntaxStack
        };
        matchStack = {
          type: OPEN_SYNTAX,
          syntax: state.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
          matchStack = matchStack.prev;
        } else {
          matchStack = {
            type: CLOSE_SYNTAX,
            syntax: syntaxStack.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        syntaxStack = syntaxStack.prev;
      }
      let syntaxStack = null;
      let thenStack = null;
      let elseStack = null;
      let syntaxStash = null;
      let iterationCount = 0;
      let exitReason = null;
      let token = null;
      let tokenIndex = -1;
      let longestMatch = 0;
      let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
      };
      moveToNextToken();
      while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        switch (state.type) {
          case "Match":
            if (thenStack === null) {
              if (token !== null) {
                if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                  state = matchGraph.MISMATCH;
                  break;
                }
              }
              exitReason = EXIT_REASON_MATCH;
              break;
            }
            state = thenStack.nextState;
            if (state === matchGraph.DISALLOW_EMPTY) {
              if (thenStack.matchStack === matchStack) {
                state = matchGraph.MISMATCH;
                break;
              } else {
                state = matchGraph.MATCH;
              }
            }
            while (thenStack.syntaxStack !== syntaxStack) {
              closeSyntax();
            }
            thenStack = thenStack.prev;
            break;
          case "Mismatch":
            if (syntaxStash !== null && syntaxStash !== false) {
              if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                elseStack = syntaxStash;
                syntaxStash = false;
              }
            } else if (elseStack === null) {
              exitReason = EXIT_REASON_MISMATCH;
              break;
            }
            state = elseStack.nextState;
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenIndex = elseStack.tokenIndex;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
            elseStack = elseStack.prev;
            break;
          case "MatchGraph":
            state = state.match;
            break;
          case "If":
            if (state.else !== matchGraph.MISMATCH) {
              pushElseStack(state.else);
            }
            if (state.then !== matchGraph.MATCH) {
              pushThenStack(state.then);
            }
            state = state.match;
            break;
          case "MatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer": {
            const terms = state.syntax.terms;
            if (state.index === terms.length) {
              if (state.mask === 0 || state.syntax.all) {
                state = matchGraph.MISMATCH;
                break;
              }
              state = matchGraph.MATCH;
              break;
            }
            if (state.mask === (1 << terms.length) - 1) {
              state = matchGraph.MATCH;
              break;
            }
            for (; state.index < terms.length; state.index++) {
              const matchFlag = 1 << state.index;
              if ((state.mask & matchFlag) === 0) {
                pushElseStack(state);
                pushThenStack({
                  type: "AddMatchOnce",
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                });
                state = terms[state.index++];
                break;
              }
            }
            break;
          }
          case "AddMatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state.syntax,
              index: 0,
              mask: state.mask
            };
            break;
          case "Enum":
            if (token !== null) {
              let name = token.value.toLowerCase();
              if (name.indexOf("\\") !== -1) {
                name = name.replace(/\\[09].*$/, "");
              }
              if (hasOwnProperty2.call(state.map, name)) {
                state = state.map[name];
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          case "Generic": {
            const opts = syntaxStack !== null ? syntaxStack.opts : null;
            const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
            if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
              while (tokenIndex < lastTokenIndex2) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          }
          case "Type":
          case "Property": {
            const syntaxDict = state.type === "Type" ? "types" : "properties";
            const dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
            if (!dictSyntax || !dictSyntax.match) {
              throw new Error(
                "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
              );
            }
            if (syntaxStash !== false && token !== null && state.type === "Type") {
              const lowPriorityMatching = (
                // https://drafts.csswg.org/css-values-4/#custom-idents
                // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                // can only claim the keyword if no other unfulfilled production can claim it.
                state.name === "custom-ident" && token.type === types.Ident || // https://drafts.csswg.org/css-values-4/#lengths
                // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                // it must parse as a <number>
                state.name === "length" && token.value === "0"
              );
              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }
                state = matchGraph.MISMATCH;
                break;
              }
            }
            openSyntax();
            state = dictSyntax.match;
            break;
          }
          case "Keyword": {
            const name = state.name;
            if (token !== null) {
              let keywordName = token.value;
              if (keywordName.indexOf("\\") !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, "");
              }
              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          }
          case "AtKeyword":
          case "Function":
            if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Token":
            if (token !== null && token.value === state.value) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Comma":
            if (token !== null && token.type === types.Comma) {
              if (isCommaContextStart(matchStack.token)) {
                state = matchGraph.MISMATCH;
              } else {
                addTokenToMatch();
                state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
              }
            } else {
              state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
            }
            break;
          case "String":
            let string = "";
            let lastTokenIndex = tokenIndex;
            for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
              string += tokens[lastTokenIndex].value;
            }
            if (areStringsEqualCaseInsensitive(string, state.value)) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          default:
            throw new Error("Unknown node type: " + state.type);
        }
      }
      switch (exitReason) {
        case null:
          console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
          exitReason = EXIT_REASON_ITERATION_LIMIT;
          matchStack = null;
          break;
        case EXIT_REASON_MATCH:
          while (syntaxStack !== null) {
            closeSyntax();
          }
          break;
        default:
          matchStack = null;
      }
      return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
      };
    }
    function matchAsList(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match !== null) {
        let item = reverseList(matchResult.match).prev;
        matchResult.match = [];
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
            case CLOSE_SYNTAX:
              matchResult.match.push({
                type: item.type,
                syntax: item.syntax
              });
              break;
            default:
              matchResult.match.push({
                token: item.token.value,
                node: item.token.node
              });
              break;
          }
          item = item.prev;
        }
      }
      return matchResult;
    }
    function matchAsTree(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match === null) {
        return matchResult;
      }
      let item = matchResult.match;
      let host = matchResult.match = {
        syntax: matchGraph2.syntax || null,
        match: []
      };
      const hostStack = [host];
      item = reverseList(item).prev;
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
            host.match.push(host = {
              syntax: item.syntax,
              match: []
            });
            hostStack.push(host);
            break;
          case CLOSE_SYNTAX:
            hostStack.pop();
            host = hostStack[hostStack.length - 1];
            break;
          default:
            host.match.push({
              syntax: item.syntax || null,
              token: item.token.value,
              node: item.token.node
            });
        }
        item = item.prev;
      }
      return matchResult;
    }
    exports2.matchAsList = matchAsList;
    exports2.matchAsTree = matchAsTree;
  }
});

// node_modules/css-tree/cjs/lexer/trace.cjs
var require_trace = __commonJS({
  "node_modules/css-tree/cjs/lexer/trace.cjs"(exports2) {
    "use strict";
    function getTrace(node) {
      function shouldPutToTrace(syntax) {
        if (syntax === null) {
          return false;
        }
        return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
      }
      function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
          for (let i = 0; i < matchNode.match.length; i++) {
            if (hasMatch(matchNode.match[i])) {
              if (shouldPutToTrace(matchNode.syntax)) {
                result.unshift(matchNode.syntax);
              }
              return true;
            }
          }
        } else if (matchNode.node === node) {
          result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
          return true;
        }
        return false;
      }
      let result = null;
      if (this.matched !== null) {
        hasMatch(this.matched);
      }
      return result;
    }
    function isType(node, type) {
      return testNode(this, node, (match) => match.type === "Type" && match.name === type);
    }
    function isProperty(node, property) {
      return testNode(this, node, (match) => match.type === "Property" && match.name === property);
    }
    function isKeyword(node) {
      return testNode(this, node, (match) => match.type === "Keyword");
    }
    function testNode(match, node, fn) {
      const trace = getTrace.call(match, node);
      if (trace === null) {
        return false;
      }
      return trace.some(fn);
    }
    exports2.getTrace = getTrace;
    exports2.isKeyword = isKeyword;
    exports2.isProperty = isProperty;
    exports2.isType = isType;
  }
});

// node_modules/css-tree/cjs/lexer/search.cjs
var require_search = __commonJS({
  "node_modules/css-tree/cjs/lexer/search.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function getFirstMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getFirstMatchNode(matchNode.match[0]);
    }
    function getLastMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    }
    function matchFragments(lexer, ast, match, type, name) {
      function findFragments(matchNode) {
        if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
          const start = getFirstMatchNode(matchNode);
          const end = getLastMatchNode(matchNode);
          lexer.syntax.walk(ast, function(node, item, list) {
            if (node === start) {
              const nodes = new List.List();
              do {
                nodes.appendData(item.data);
                if (item.data === end) {
                  break;
                }
                item = item.next;
              } while (item !== null);
              fragments.push({
                parent: list,
                nodes
              });
            }
          });
        }
        if (Array.isArray(matchNode.match)) {
          matchNode.match.forEach(findFragments);
        }
      }
      const fragments = [];
      if (match.matched !== null) {
        findFragments(match.matched);
      }
      return fragments;
    }
    exports2.matchFragments = matchFragments;
  }
});

// node_modules/css-tree/cjs/lexer/structure.cjs
var require_structure = __commonJS({
  "node_modules/css-tree/cjs/lexer/structure.cjs"(exports2) {
    "use strict";
    var List = require_List();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function isValidNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
    function isValidLocation(loc) {
      return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
    }
    function createNodeStructureChecker(type, fields) {
      return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
          return warn(node, "Type of node should be an Object");
        }
        for (let key in node) {
          let valid = true;
          if (hasOwnProperty2.call(node, key) === false) {
            continue;
          }
          if (key === "type") {
            if (node.type !== type) {
              warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
            }
          } else if (key === "loc") {
            if (node.loc === null) {
              continue;
            } else if (node.loc && node.loc.constructor === Object) {
              if (typeof node.loc.source !== "string") {
                key += ".source";
              } else if (!isValidLocation(node.loc.start)) {
                key += ".start";
              } else if (!isValidLocation(node.loc.end)) {
                key += ".end";
              } else {
                continue;
              }
            }
            valid = false;
          } else if (fields.hasOwnProperty(key)) {
            valid = false;
            for (let i = 0; !valid && i < fields[key].length; i++) {
              const fieldType = fields[key][i];
              switch (fieldType) {
                case String:
                  valid = typeof node[key] === "string";
                  break;
                case Boolean:
                  valid = typeof node[key] === "boolean";
                  break;
                case null:
                  valid = node[key] === null;
                  break;
                default:
                  if (typeof fieldType === "string") {
                    valid = node[key] && node[key].type === fieldType;
                  } else if (Array.isArray(fieldType)) {
                    valid = node[key] instanceof List.List;
                  }
              }
            }
          } else {
            warn(node, "Unknown field `" + key + "` for " + type + " node type");
          }
          if (!valid) {
            warn(node, "Bad value for `" + type + "." + key + "`");
          }
        }
        for (const key in fields) {
          if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
            warn(node, "Field `" + type + "." + key + "` is missed");
          }
        }
      };
    }
    function processStructure(name, nodeType) {
      const structure = nodeType.structure;
      const fields = {
        type: String,
        loc: true
      };
      const docs = {
        type: '"' + name + '"'
      };
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        const docsTypes = [];
        const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
        for (let i = 0; i < fieldTypes.length; i++) {
          const fieldType = fieldTypes[i];
          if (fieldType === String || fieldType === Boolean) {
            docsTypes.push(fieldType.name);
          } else if (fieldType === null) {
            docsTypes.push("null");
          } else if (typeof fieldType === "string") {
            docsTypes.push("<" + fieldType + ">");
          } else if (Array.isArray(fieldType)) {
            docsTypes.push("List");
          } else {
            throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
          }
        }
        docs[key] = docsTypes.join(" | ");
      }
      return {
        docs,
        check: createNodeStructureChecker(name, fields)
      };
    }
    function getStructureFromConfig(config) {
      const structure = {};
      if (config.node) {
        for (const name in config.node) {
          if (hasOwnProperty2.call(config.node, name)) {
            const nodeType = config.node[name];
            if (nodeType.structure) {
              structure[name] = processStructure(name, nodeType);
            } else {
              throw new Error("Missed `structure` field in `" + name + "` node type definition");
            }
          }
        }
      }
      return structure;
    }
    exports2.getStructureFromConfig = getStructureFromConfig;
  }
});

// node_modules/css-tree/cjs/definition-syntax/walk.cjs
var require_walk = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/walk.cjs"(exports2) {
    "use strict";
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function walk(node, options, context) {
      function walk2(node2) {
        enter.call(context, node2);
        switch (node2.type) {
          case "Group":
            node2.terms.forEach(walk2);
            break;
          case "Multiplier":
            walk2(node2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + node2.type);
        }
        leave.call(context, node2);
      }
      let enter = noop;
      let leave = noop;
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walk2(node);
    }
    exports2.walk = walk;
  }
});

// node_modules/css-tree/cjs/lexer/Lexer.cjs
var require_Lexer = __commonJS({
  "node_modules/css-tree/cjs/lexer/Lexer.cjs"(exports2) {
    "use strict";
    var error = require_error();
    var names = require_names2();
    var genericConst = require_generic_const();
    var generic = require_generic();
    var units = require_units();
    var prepareTokens = require_prepare_tokens();
    var matchGraph = require_match_graph();
    var match = require_match();
    var trace = require_trace();
    var search = require_search();
    var structure = require_structure();
    var parse = require_parse3();
    var generate = require_generate();
    var walk = require_walk();
    var cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(" | "));
    function dumpMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const name in map) {
        if (map[name].syntax) {
          result[name] = syntaxAsAst ? map[name].syntax : generate.generate(map[name].syntax, { compact });
        }
      }
      return result;
    }
    function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
          prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate.generate(atrule.prelude.syntax, { compact })),
          descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
      }
      return result;
    }
    function valueHasVar(tokens) {
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === "var(") {
          return true;
        }
      }
      return false;
    }
    function buildMatchResult(matched, error2, iterations) {
      return {
        matched,
        iterations,
        error: error2,
        ...trace
      };
    }
    function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
      const tokens = prepareTokens(value, lexer.syntax);
      let result;
      if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
      }
      if (useCssWideKeywords) {
        result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
      }
      if (!useCssWideKeywords || !result.match) {
        result = match.matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
          return buildMatchResult(
            null,
            new error.SyntaxMatchError(result.reason, syntax.syntax, value, result),
            result.iterations
          );
        }
      }
      return buildMatchResult(result.match, null, result.iterations);
    }
    var Lexer = class {
      constructor(config, syntax, structure$1) {
        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
        this.syntax = syntax;
        this.generic = false;
        this.units = { ...units };
        this.atrules = /* @__PURE__ */ Object.create(null);
        this.properties = /* @__PURE__ */ Object.create(null);
        this.types = /* @__PURE__ */ Object.create(null);
        this.structure = structure$1 || structure.getStructureFromConfig(config);
        if (config) {
          if (config.units) {
            for (const group of Object.keys(units)) {
              if (Array.isArray(config.units[group])) {
                this.units[group] = config.units[group];
              }
            }
          }
          if (config.types) {
            for (const name in config.types) {
              this.addType_(name, config.types[name]);
            }
          }
          if (config.generic) {
            this.generic = true;
            for (const [name, value] of Object.entries(generic.createGenericTypes(this.units))) {
              this.addType_(name, value);
            }
          }
          if (config.atrules) {
            for (const name in config.atrules) {
              this.addAtrule_(name, config.atrules[name]);
            }
          }
          if (config.properties) {
            for (const name in config.properties) {
              this.addProperty_(name, config.properties[name]);
            }
          }
        }
      }
      checkStructure(ast) {
        function collectWarning(node, message) {
          warns.push({ node, message });
        }
        const structure2 = this.structure;
        const warns = [];
        this.syntax.walk(ast, function(node) {
          if (structure2.hasOwnProperty(node.type)) {
            structure2[node.type].check(node, collectWarning);
          } else {
            collectWarning(node, "Unknown node type `" + node.type + "`");
          }
        });
        return warns.length ? warns : false;
      }
      createDescriptor(syntax, type, name, parent = null) {
        const ref = {
          type,
          name
        };
        const descriptor = {
          type,
          name,
          parent,
          serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
          syntax: null,
          match: null
        };
        if (typeof syntax === "function") {
          descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
        } else {
          if (typeof syntax === "string") {
            Object.defineProperty(descriptor, "syntax", {
              get() {
                Object.defineProperty(descriptor, "syntax", {
                  value: parse.parse(syntax)
                });
                return descriptor.syntax;
              }
            });
          } else {
            descriptor.syntax = syntax;
          }
          Object.defineProperty(descriptor, "match", {
            get() {
              Object.defineProperty(descriptor, "match", {
                value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
              });
              return descriptor.match;
            }
          });
        }
        return descriptor;
      }
      addAtrule_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.atrules[name] = {
          type: "Atrule",
          name,
          prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
          descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
            (map, descName) => {
              map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
              return map;
            },
            /* @__PURE__ */ Object.create(null)
          ) : null
        };
      }
      addProperty_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.properties[name] = this.createDescriptor(syntax, "Property", name);
      }
      addType_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.types[name] = this.createDescriptor(syntax, "Type", name);
      }
      checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
          return new error.SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
        }
      }
      checkAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtruleName(atruleName);
        if (error2) {
          return error2;
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude && prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
        }
        if (atrule.prelude && !prelude) {
          if (!matchSyntax(this, atrule.prelude, "", false).matched) {
            return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
          }
        }
      }
      checkAtruleDescriptorName(atruleName, descriptorName) {
        const error$1 = this.checkAtruleName(atruleName);
        if (error$1) {
          return error$1;
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        if (!atrule.descriptors) {
          return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
        }
        if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
          return new error.SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
        }
      }
      checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
          return new error.SyntaxReferenceError("Unknown property", propertyName);
        }
      }
      matchAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtrulePrelude(atruleName, prelude);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude) {
          return buildMatchResult(null, null);
        }
        return matchSyntax(this, atrule.prelude, prelude || "", false);
      }
      matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
      }
      matchDeclaration(node) {
        if (node.type !== "Declaration") {
          return buildMatchResult(null, new Error("Not a Declaration node"));
        }
        return this.matchProperty(node.property, node.value);
      }
      matchProperty(propertyName, value) {
        if (names.property(propertyName).custom) {
          return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
        }
        const error2 = this.checkPropertyName(propertyName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        return matchSyntax(this, this.getProperty(propertyName), value, true);
      }
      matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);
        if (!typeSyntax) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Unknown type", typeName));
        }
        return matchSyntax(this, typeSyntax, value, false);
      }
      match(syntax, value) {
        if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Bad syntax"));
        }
        if (typeof syntax === "string" || !syntax.match) {
          syntax = this.createDescriptor(syntax, "Type", "anonymous");
        }
        return matchSyntax(this, syntax, value, false);
      }
      findValueFragments(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
      }
      findDeclarationValueFragments(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
      }
      findAllFragments(ast, type, name) {
        const result = [];
        this.syntax.walk(ast, {
          visit: "Declaration",
          enter: (declaration) => {
            result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
          }
        });
        return result;
      }
      getAtrule(atruleName, fallbackBasename = true) {
        const atrule = names.keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
        return atruleEntry || null;
      }
      getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);
        return atrule && atrule.prelude || null;
      }
      getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
      }
      getProperty(propertyName, fallbackBasename = true) {
        const property = names.property(propertyName);
        const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
        return propertyEntry || null;
      }
      getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
      }
      validate() {
        function validate(syntax, name, broken, descriptor) {
          if (broken.has(name)) {
            return broken.get(name);
          }
          broken.set(name, false);
          if (descriptor.syntax !== null) {
            walk.walk(descriptor.syntax, function(node) {
              if (node.type !== "Type" && node.type !== "Property") {
                return;
              }
              const map = node.type === "Type" ? syntax.types : syntax.properties;
              const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
              if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                broken.set(name, true);
              }
            }, this);
          }
        }
        let brokenTypes = /* @__PURE__ */ new Map();
        let brokenProperties = /* @__PURE__ */ new Map();
        for (const key in this.types) {
          validate(this, key, brokenTypes, this.types[key]);
        }
        for (const key in this.properties) {
          validate(this, key, brokenProperties, this.properties[key]);
        }
        brokenTypes = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
        brokenProperties = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
        if (brokenTypes.length || brokenProperties.length) {
          return {
            types: brokenTypes,
            properties: brokenProperties
          };
        }
        return null;
      }
      dump(syntaxAsAst, pretty) {
        return {
          generic: this.generic,
          units: this.units,
          types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
          properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
          atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
      }
      toString() {
        return JSON.stringify(this.dump());
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/css-tree/cjs/syntax/config/mix.cjs
var require_mix = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/mix.cjs"(exports2, module2) {
    "use strict";
    function appendOrSet(a, b) {
      if (typeof b === "string" && /^\s*\|/.test(b)) {
        return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
      }
      return b || null;
    }
    function sliceProps(obj, props) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const [key, value] of Object.entries(obj)) {
        if (value) {
          result[key] = {};
          for (const prop of Object.keys(value)) {
            if (props.includes(prop)) {
              result[key][prop] = value[prop];
            }
          }
        }
      }
      return result;
    }
    function mix(dest, src) {
      const result = { ...dest };
      for (const [prop, value] of Object.entries(src)) {
        switch (prop) {
          case "generic":
            result[prop] = Boolean(value);
            break;
          case "units":
            result[prop] = { ...dest[prop] };
            for (const [name, patch] of Object.entries(value)) {
              result[prop][name] = Array.isArray(patch) ? patch : [];
            }
            break;
          case "atrules":
            result[prop] = { ...dest[prop] };
            for (const [name, atrule] of Object.entries(value)) {
              const exists = result[prop][name] || {};
              const current = result[prop][name] = {
                prelude: exists.prelude || null,
                descriptors: {
                  ...exists.descriptors
                }
              };
              if (!atrule) {
                continue;
              }
              current.prelude = atrule.prelude ? appendOrSet(current.prelude, atrule.prelude) : current.prelude || null;
              for (const [descriptorName, descriptorValue] of Object.entries(atrule.descriptors || {})) {
                current.descriptors[descriptorName] = descriptorValue ? appendOrSet(current.descriptors[descriptorName], descriptorValue) : null;
              }
              if (!Object.keys(current.descriptors).length) {
                current.descriptors = null;
              }
            }
            break;
          case "types":
          case "properties":
            result[prop] = { ...dest[prop] };
            for (const [name, syntax] of Object.entries(value)) {
              result[prop][name] = appendOrSet(result[prop][name], syntax);
            }
            break;
          case "scope":
            result[prop] = { ...dest[prop] };
            for (const [name, props] of Object.entries(value)) {
              result[prop][name] = { ...result[prop][name], ...props };
            }
            break;
          case "parseContext":
            result[prop] = {
              ...dest[prop],
              ...value
            };
            break;
          case "atrule":
          case "pseudo":
            result[prop] = {
              ...dest[prop],
              ...sliceProps(value, ["parse"])
            };
            break;
          case "node":
            result[prop] = {
              ...dest[prop],
              ...sliceProps(value, ["name", "structure", "parse", "generate", "walkContext"])
            };
            break;
        }
      }
      return result;
    }
    module2.exports = mix;
  }
});

// node_modules/css-tree/cjs/syntax/create.cjs
var require_create5 = __commonJS({
  "node_modules/css-tree/cjs/syntax/create.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer();
    var create = require_create();
    var create$2 = require_create2();
    var create$3 = require_create3();
    var create$1 = require_create4();
    var Lexer = require_Lexer();
    var mix = require_mix();
    function createSyntax(config) {
      const parse = create.createParser(config);
      const walk = create$1.createWalker(config);
      const generate = create$2.createGenerator(config);
      const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);
      const syntax = {
        lexer: null,
        createLexer: (config2) => new Lexer.Lexer(config2, syntax, syntax.lexer.structure),
        tokenize: index.tokenize,
        parse,
        generate,
        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,
        fromPlainObject,
        toPlainObject,
        fork(extension) {
          const base = mix({}, config);
          return createSyntax(
            typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
          );
        }
      };
      syntax.lexer = new Lexer.Lexer({
        generic: true,
        units: config.units,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
      }, syntax);
      return syntax;
    }
    var createSyntax$1 = (config) => createSyntax(mix({}, config));
    module2.exports = createSyntax$1;
  }
});

// node_modules/css-tree/data/patch.json
var require_patch = __commonJS({
  "node_modules/css-tree/data/patch.json"(exports2, module2) {
    module2.exports = {
      atrules: {
        charset: {
          prelude: "<string>"
        },
        "font-face": {
          descriptors: {
            "unicode-range": {
              comment: "replaces <unicode-range>, an old production name",
              syntax: "<urange>#"
            }
          }
        },
        nest: {
          prelude: "<complex-selector-list>"
        }
      },
      properties: {
        "-moz-background-clip": {
          comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "padding | border"
        },
        "-moz-border-radius-bottomleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
          syntax: "<'border-bottom-left-radius'>"
        },
        "-moz-border-radius-bottomright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-border-radius-topleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
          syntax: "<'border-top-left-radius'>"
        },
        "-moz-border-radius-topright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-control-character-visibility": {
          comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
          syntax: "visible | hidden"
        },
        "-moz-osx-font-smoothing": {
          comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | grayscale"
        },
        "-moz-user-select": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "none | text | all | -moz-none"
        },
        "-ms-flex-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "start | end | center | baseline | stretch"
        },
        "-ms-flex-item-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "auto | start | end | center | baseline | stretch"
        },
        "-ms-flex-line-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
          syntax: "start | end | center | justify | distribute | stretch"
        },
        "-ms-flex-negative": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-shrink'>"
        },
        "-ms-flex-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
          syntax: "start | end | center | justify | distribute"
        },
        "-ms-flex-order": {
          comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
          syntax: "<integer>"
        },
        "-ms-flex-positive": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-grow'>"
        },
        "-ms-flex-preferred-size": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-basis'>"
        },
        "-ms-interpolation-mode": {
          comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
          syntax: "nearest-neighbor | bicubic"
        },
        "-ms-grid-column-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-grid-row-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-hyphenate-limit-last": {
          comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
          syntax: "none | always | column | page | spread"
        },
        "-webkit-appearance": {
          comment: "webkit specific keywords",
          references: [
            "http://css-infos.net/property/-webkit-appearance"
          ],
          syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
        },
        "-webkit-background-clip": {
          comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "[ <box> | border | padding | content | text ]#"
        },
        "-webkit-column-break-after": {
          comment: "added, http://help.dottoro.com/lcrthhhv.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-before": {
          comment: "added, http://help.dottoro.com/lcxquvkf.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-inside": {
          comment: "added, http://help.dottoro.com/lclhnthl.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-font-smoothing": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | none | antialiased | subpixel-antialiased"
        },
        "-webkit-mask-box-image": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
        },
        "-webkit-print-color-adjust": {
          comment: "missed",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
          ],
          syntax: "economy | exact"
        },
        "-webkit-text-security": {
          comment: "missed; http://help.dottoro.com/lcbkewgt.php",
          syntax: "none | circle | disc | square"
        },
        "-webkit-user-drag": {
          comment: "missed; http://help.dottoro.com/lcbixvwm.php",
          syntax: "none | element | auto"
        },
        "-webkit-user-select": {
          comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "auto | none | text | all"
        },
        "alignment-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
          ],
          syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
        },
        "background-clip": {
          comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
          references: [
            "https://github.com/csstree/csstree/issues/190"
          ],
          syntax: "<bg-clip>#"
        },
        "baseline-shift": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
          ],
          syntax: "baseline | sub | super | <svg-length>"
        },
        behavior: {
          comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
          syntax: "<url>+"
        },
        "clip-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        cue: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'cue-before'> <'cue-after'>?"
        },
        "cue-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        "cue-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        cursor: {
          comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
          references: [
            "https://www.sitepoint.com/css3-cursor-styles/"
          ],
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
        },
        display: {
          comment: "extended with -ms-flexbox",
          syntax: "| <-non-standard-display>"
        },
        position: {
          comment: "extended with -webkit-sticky",
          syntax: "| -webkit-sticky"
        },
        "dominant-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
          ],
          syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
        },
        "image-rendering": {
          comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
            "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
          ],
          syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
        },
        fill: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<paint>"
        },
        "fill-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<number-zero-one>"
        },
        "fill-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        filter: {
          comment: "extend with IE legacy syntaxes",
          syntax: "| <-ms-filter-function-list>"
        },
        "glyph-orientation-horizontal": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
          ],
          syntax: "<angle>"
        },
        "glyph-orientation-vertical": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
          ],
          syntax: "<angle>"
        },
        kerning: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#KerningProperty"
          ],
          syntax: "auto | <svg-length>"
        },
        "letter-spacing": {
          comment: "fix syntax <length> -> <length-percentage>",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
          ],
          syntax: "normal | <length-percentage>"
        },
        marker: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-end": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-mid": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-start": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "max-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
          syntax: "| <-non-standard-width>"
        },
        width: {
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
            "https://github.com/csstree/stylelint-validator/issues/29"
          ],
          syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
        },
        "min-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "| <-non-standard-width>"
        },
        overflow: {
          comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "| <-non-standard-overflow>"
        },
        pause: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'pause-before'> <'pause-after'>?"
        },
        "pause-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "pause-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        rest: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'rest-before'> <'rest-after'>?"
        },
        "rest-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "rest-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "shape-rendering": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
          ],
          syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
        },
        src: {
          comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
        },
        speak: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | none | normal"
        },
        "speak-as": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
        },
        stroke: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<paint>"
        },
        "stroke-dasharray": {
          comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "none | [ <svg-length>+ ]#"
        },
        "stroke-dashoffset": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "stroke-linecap": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "butt | round | square"
        },
        "stroke-linejoin": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "miter | round | bevel"
        },
        "stroke-miterlimit": {
          comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-one-or-greater>"
        },
        "stroke-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-zero-one>"
        },
        "stroke-width": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "text-anchor": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
          ],
          syntax: "start | middle | end"
        },
        "unicode-bidi": {
          comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
          syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
        },
        "unicode-range": {
          comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
          syntax: "<urange>#"
        },
        "voice-balance": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<number> | left | center | right | leftwards | rightwards"
        },
        "voice-duration": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | <time>"
        },
        "voice-family": {
          comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
        },
        "voice-pitch": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-range": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-rate": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
        },
        "voice-stress": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | strong | moderate | none | reduced"
        },
        "voice-volume": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
        },
        "writing-mode": {
          comment: "extend with SVG keywords",
          syntax: "| <svg-writing-mode>"
        }
      },
      types: {
        "-legacy-gradient": {
          comment: "added collection of legacy gradient syntaxes",
          syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
        },
        "-legacy-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-repeating-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-linear-gradient-arguments": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
        },
        "-legacy-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-repeating-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-radial-gradient-arguments": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
        },
        "-legacy-radial-gradient-size": {
          comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
          syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
        },
        "-legacy-radial-gradient-shape": {
          comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
          syntax: "circle | ellipse"
        },
        "-non-standard-font": {
          comment: "non standard fonts",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
        },
        "-non-standard-color": {
          comment: "non standard colors",
          references: [
            "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
            "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
          ],
          syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
        },
        "-non-standard-image-rendering": {
          comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
          syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
        },
        "-non-standard-overflow": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
        },
        "-non-standard-width": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
        },
        "-webkit-gradient()": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
          syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
        },
        "-webkit-gradient-color-stop": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
        },
        "-webkit-gradient-point": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
        },
        "-webkit-gradient-radius": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "<length> | <percentage>"
        },
        "-webkit-gradient-type": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "linear | radial"
        },
        "-webkit-mask-box-repeat": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "repeat | stretch | round"
        },
        "-webkit-mask-clip-style": {
          comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
          syntax: "border | border-box | padding | padding-box | content | content-box | text"
        },
        "-ms-filter-function-list": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function>+"
        },
        "-ms-filter-function": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
        },
        "-ms-filter-function-progid": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
        },
        "-ms-filter-function-legacy": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<ident-token> | <function-token> <any-value>? )"
        },
        "-ms-filter": {
          syntax: "<string>"
        },
        age: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "child | young | old"
        },
        "attr-name": {
          syntax: "<wq-name>"
        },
        "attr-fallback": {
          syntax: "<any-value>"
        },
        "bg-clip": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
          syntax: "<box> | border | text"
        },
        bottom: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "content-list": {
          comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
          syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
        },
        "element()": {
          comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
          syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
        },
        "generic-voice": {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "[ <age>? <gender> <integer>? ]"
        },
        gender: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "male | female | neutral"
        },
        "generic-family": {
          comment: "added -apple-system",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "| -apple-system"
        },
        gradient: {
          comment: "added legacy syntaxes support",
          syntax: "| <-legacy-gradient>"
        },
        left: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "mask-image": {
          comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
          syntax: "<mask-reference>#"
        },
        "named-color": {
          comment: "added non standard color names",
          syntax: "| <-non-standard-color>"
        },
        paint: {
          comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
          syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
        },
        right: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        shape: {
          comment: "missed spaces in function body and add backwards compatible syntax",
          syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
        },
        "scroll-timeline-axis": {
          comment: "missed definition",
          syntax: "block | inline | vertical | horizontal"
        },
        "scroll-timeline-name": {
          comment: "missed definition",
          references: [
            "https://w3c.github.io/csswg-drafts/scroll-animations/#propdef-scroll-timeline-name"
          ],
          syntax: "none | <custom-ident>"
        },
        "single-animation-composition": {
          comment: "missed definition",
          references: [
            "https://w3c.github.io/csswg-drafts/css-animations-2/#typedef-single-animation-composition"
          ],
          syntax: "replace | add | accumulate"
        },
        "svg-length": {
          comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
          references: [
            "https://www.w3.org/TR/SVG11/coords.html#Units"
          ],
          syntax: "<percentage> | <length> | <number>"
        },
        "svg-writing-mode": {
          comment: "SVG specific keywords (deprecated for CSS)",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
            "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
          ],
          syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
        },
        top: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        x: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        y: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        declaration: {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
        },
        "declaration-list": {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "[ <declaration>? ';' ]* <declaration>?"
        },
        url: {
          comment: "https://drafts.csswg.org/css-values-4/#urls",
          syntax: "url( <string> <url-modifier>* ) | <url-token>"
        },
        "url-modifier": {
          comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
          syntax: "<ident> | <function-token> <any-value> )"
        },
        "number-zero-one": {
          syntax: "<number [0,1]>"
        },
        "number-one-or-greater": {
          syntax: "<number [1,\u221E]>"
        },
        "-non-standard-display": {
          syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
        }
      }
    };
  }
});

// node_modules/css-tree/cjs/data-patch.cjs
var require_data_patch = __commonJS({
  "node_modules/css-tree/cjs/data-patch.cjs"(exports2, module2) {
    "use strict";
    var patch = require_patch();
    var patch$1 = patch;
    module2.exports = patch$1;
  }
});

// node_modules/mdn-data/css/at-rules.json
var require_at_rules = __commonJS({
  "node_modules/mdn-data/css/at-rules.json"(exports2, module2) {
    module2.exports = {
      "@charset": {
        syntax: '@charset "<charset>";',
        groups: [
          "CSS Charsets"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
      },
      "@counter-style": {
        syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
        interfaces: [
          "CSSCounterStyleRule"
        ],
        groups: [
          "CSS Counter Styles"
        ],
        descriptors: {
          "additive-symbols": {
            syntax: "[ <integer> && <symbol> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          fallback: {
            syntax: "<counter-style-name>",
            media: "all",
            initial: "decimal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          negative: {
            syntax: "<symbol> <symbol>?",
            media: "all",
            initial: '"-" hyphen-minus',
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          pad: {
            syntax: "<integer> && <symbol>",
            media: "all",
            initial: '0 ""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          prefix: {
            syntax: "<symbol>",
            media: "all",
            initial: '""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          range: {
            syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "speak-as": {
            syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          suffix: {
            syntax: "<symbol>",
            media: "all",
            initial: '". "',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          symbols: {
            syntax: "<symbol>+",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          system: {
            syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
            media: "all",
            initial: "symbolic",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
      },
      "@document": {
        syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
      },
      "@font-face": {
        syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
        interfaces: [
          "CSSFontFaceRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "ascent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "descent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "font-display": {
            syntax: "[ auto | block | swap | fallback | optional ]",
            media: "visual",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "font-family": {
            syntax: "<family-name>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-feature-settings": {
            syntax: "normal | <feature-tag-value>#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-variation-settings": {
            syntax: "normal | [ <string> <number> ]#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-stretch": {
            syntax: "<font-stretch-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-style": {
            syntax: "normal | italic | oblique <angle>{0,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-weight": {
            syntax: "<font-weight-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-variant": {
            syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "line-gap-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "size-adjust": {
            syntax: "<percentage>",
            media: "all",
            initial: "100%",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          src: {
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "unicode-range": {
            syntax: "<unicode-range>#",
            media: "all",
            initial: "U+0-10FFFF",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
      },
      "@font-feature-values": {
        syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
        interfaces: [
          "CSSFontFeatureValuesRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
      },
      "@import": {
        syntax: "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
      },
      "@keyframes": {
        syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
        interfaces: [
          "CSSKeyframeRule",
          "CSSKeyframesRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
      },
      "@layer": {
        syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
        interfaces: [
          "CSSLayerBlockRule",
          "CSSLayerStatementRule"
        ],
        groups: [
          "CSS Cascading and Inheritance"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
      },
      "@media": {
        syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSMediaRule",
          "CSSCustomMediaRule"
        ],
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
      },
      "@namespace": {
        syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
        groups: [
          "CSS Namespaces"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
      },
      "@page": {
        syntax: "@page <page-selector-list> {\n  <page-body>\n}",
        interfaces: [
          "CSSPageRule"
        ],
        groups: [
          "CSS Pages"
        ],
        descriptors: {
          bleed: {
            syntax: "auto | <length>",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          marks: {
            syntax: "none | [ crop || cross ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "none",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          size: {
            syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecifiedRelativeToAbsoluteLengths",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
      },
      "@property": {
        syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
        interfaces: [
          "CSS",
          "CSSPropertyRule"
        ],
        groups: [
          "CSS Houdini"
        ],
        descriptors: {
          syntax: {
            syntax: "<string>",
            media: "all",
            percentages: "no",
            initial: "n/a (required)",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          inherits: {
            syntax: "true | false",
            media: "all",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "initial-value": {
            syntax: "<string>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          }
        },
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
      },
      "@scroll-timeline": {
        syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
        interfaces: [
          "ScrollTimeline"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
      },
      "@supports": {
        syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSSupportsRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
      },
      "@viewport": {
        syntax: "@viewport {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSViewportRule"
        ],
        groups: [
          "CSS Device Adaptation"
        ],
        descriptors: {
          height: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-height",
              "max-height"
            ],
            percentages: [
              "min-height",
              "max-height"
            ],
            computed: [
              "min-height",
              "max-height"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          "max-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          orientation: {
            syntax: "auto | portrait | landscape",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "user-zoom": {
            syntax: "zoom | fixed",
            media: [
              "visual",
              "continuous"
            ],
            initial: "zoom",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "viewport-fit": {
            syntax: "auto | contain | cover",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          width: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-width",
              "max-width"
            ],
            percentages: [
              "min-width",
              "max-width"
            ],
            computed: [
              "min-width",
              "max-width"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          zoom: {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
      }
    };
  }
});

// node_modules/mdn-data/css/properties.json
var require_properties = __commonJS({
  "node_modules/mdn-data/css/properties.json"(exports2, module2) {
    module2.exports = {
      "--*": {
        syntax: "<declaration-value>",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Variables"
        ],
        initial: "seeProse",
        appliesto: "allElements",
        computed: "asSpecifiedWithVarsSubstituted",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
      },
      "-ms-accelerator": {
        syntax: "false | true",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "false",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
      },
      "-ms-block-progression": {
        syntax: "tb | rl | bt | lr",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "tb",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
      },
      "-ms-content-zoom-chaining": {
        syntax: "none | chained",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
      },
      "-ms-content-zooming": {
        syntax: "none | zoom",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "zoomForTheTopLevelNoneForTheRest",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
      },
      "-ms-content-zoom-limit": {
        syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
      },
      "-ms-content-zoom-limit-max": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "maxZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "400%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
      },
      "-ms-content-zoom-limit-min": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "minZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "100%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
      },
      "-ms-content-zoom-snap": {
        syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
      },
      "-ms-content-zoom-snap-points": {
        syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0%, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
      },
      "-ms-content-zoom-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
      },
      "-ms-filter": {
        syntax: "<string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: '""',
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
      },
      "-ms-flow-from": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
      },
      "-ms-flow-into": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "iframeElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
      },
      "-ms-grid-columns": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
      },
      "-ms-grid-rows": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
      },
      "-ms-high-contrast-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
      },
      "-ms-hyphenate-limit-chars": {
        syntax: "auto | <integer>{1,3}",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
      },
      "-ms-hyphenate-limit-lines": {
        syntax: "no-limit | <integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "no-limit",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
      },
      "-ms-hyphenate-limit-zone": {
        syntax: "<percentage> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToLineBoxWidth",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
      },
      "-ms-ime-align": {
        syntax: "auto | after",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
      },
      "-ms-overflow-style": {
        syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
      },
      "-ms-scrollbar-3dlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
      },
      "-ms-scrollbar-arrow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ButtonText",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
      },
      "-ms-scrollbar-base-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
      },
      "-ms-scrollbar-darkshadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
      },
      "-ms-scrollbar-face-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDFace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
      },
      "-ms-scrollbar-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDHighlight",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
      },
      "-ms-scrollbar-shadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
      },
      "-ms-scrollbar-track-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "Scrollbar",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
      },
      "-ms-scroll-chaining": {
        syntax: "chained | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "chained",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
      },
      "-ms-scroll-limit": {
        syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
      },
      "-ms-scroll-limit-x-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
      },
      "-ms-scroll-limit-x-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
      },
      "-ms-scroll-limit-y-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
      },
      "-ms-scroll-limit-y-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
      },
      "-ms-scroll-rails": {
        syntax: "none | railed",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "railed",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
      },
      "-ms-scroll-snap-points-x": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
      },
      "-ms-scroll-snap-points-y": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
      },
      "-ms-scroll-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
      },
      "-ms-scroll-snap-x": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
      },
      "-ms-scroll-snap-y": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
      },
      "-ms-scroll-translation": {
        syntax: "none | vertical-to-horizontal",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
      },
      "-ms-text-autospace": {
        syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
      },
      "-ms-touch-select": {
        syntax: "grippers | none",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "grippers",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
      },
      "-ms-user-select": {
        syntax: "none | element | text",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "text",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
      },
      "-ms-wrap-flow": {
        syntax: "auto | both | start | end | maximum | clear",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
      },
      "-ms-wrap-margin": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "exclusionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
      },
      "-ms-wrap-through": {
        syntax: "wrap | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "wrap",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
      },
      "-moz-appearance": {
        syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-moz-binding": {
        syntax: "<url> | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
      },
      "-moz-border-bottom-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
      },
      "-moz-border-left-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
      },
      "-moz-border-right-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
      },
      "-moz-border-top-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
      },
      "-moz-context-properties": {
        syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsThatCanReferenceImages",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
      },
      "-moz-float-edge": {
        syntax: "border-box | content-box | margin-box | padding-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "content-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
      },
      "-moz-force-broken-image-icon": {
        syntax: "0 | 1",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "images",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
      },
      "-moz-image-region": {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "xulImageElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
      },
      "-moz-orient": {
        syntax: "inline | block | horizontal | vertical",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "inline",
        appliesto: "anyElementEffectOnProgressAndMeter",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
      },
      "-moz-outline-radius": {
        syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        percentages: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        groups: [
          "Mozilla Extensions"
        ],
        initial: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        appliesto: "allElements",
        computed: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
      },
      "-moz-outline-radius-bottomleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
      },
      "-moz-outline-radius-bottomright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
      },
      "-moz-outline-radius-topleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
      },
      "-moz-outline-radius-topright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
      },
      "-moz-stack-sizing": {
        syntax: "ignore | stretch-to-fit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "stretch-to-fit",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
      },
      "-moz-text-blink": {
        syntax: "none | blink",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
      },
      "-moz-user-focus": {
        syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
      },
      "-moz-user-input": {
        syntax: "auto | none | enabled | disabled",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
      },
      "-moz-user-modify": {
        syntax: "read-only | read-write | write-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
      },
      "-moz-window-dragging": {
        syntax: "drag | no-drag",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "drag",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
      },
      "-moz-window-shadow": {
        syntax: "default | menu | tooltip | sheet | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "default",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
      },
      "-webkit-appearance": {
        syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-webkit-border-before": {
        syntax: "<'border-width'> || <'border-style'> || <color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: [
          "-webkit-border-before-width"
        ],
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "color"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
      },
      "-webkit-border-before-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "WebKit Extensions"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-box-reflect": {
        syntax: "[ above | below | right | left ]? <length>? <image>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
      },
      "-webkit-line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "WebKit Extensions",
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
      },
      "-webkit-mask": {
        syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "-webkit-mask-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
      },
      "-webkit-mask-clip": {
        syntax: "[ <box> | border | padding | content | text ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "border",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "-webkit-mask-composite": {
        syntax: "<composite-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "source-over",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
      },
      "-webkit-mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteURIOrNone",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "-webkit-mask-origin": {
        syntax: "[ <box> | border | padding | content ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "padding",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "-webkit-mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "-webkit-mask-position-x": {
        syntax: "[ <length-percentage> | left | center | right ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
      },
      "-webkit-mask-position-y": {
        syntax: "[ <length-percentage> | top | center | bottom ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
      },
      "-webkit-mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "-webkit-mask-repeat-x": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
      },
      "-webkit-mask-repeat-y": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
      },
      "-webkit-mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "-webkit-overflow-scrolling": {
        syntax: "auto | touch",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
      },
      "-webkit-tap-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "black",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
      },
      "-webkit-text-fill-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
      },
      "-webkit-text-stroke": {
        syntax: "<length> || <color>",
        media: "visual",
        inherited: true,
        animationType: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        order: "canonicalOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
      },
      "-webkit-text-stroke-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
      },
      "-webkit-text-stroke-width": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
      },
      "-webkit-touch-callout": {
        syntax: "default | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "default",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
      },
      "-webkit-user-modify": {
        syntax: "read-only | read-write | read-write-plaintext-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "accent-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
      },
      "align-content": {
        syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
      },
      "align-items": {
        syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
      },
      "align-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
        computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
      },
      "align-tracks": {
        syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
      },
      all: {
        syntax: "initial | inherit | unset | revert | revert-layer",
        media: "noPracticalMedia",
        inherited: false,
        animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "noPracticalInitialValue",
        appliesto: "allElements",
        computed: "asSpecifiedAppliesToEachProperty",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
      },
      animation: {
        syntax: "<single-animation>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-direction",
          "animation-iteration-count",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
      },
      "animation-composition": {
        syntax: "<single-animation-composition>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "replace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-composition"
      },
      "animation-delay": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
      },
      "animation-direction": {
        syntax: "<single-animation-direction>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
      },
      "animation-duration": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
      },
      "animation-fill-mode": {
        syntax: "<single-animation-fill-mode>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
      },
      "animation-iteration-count": {
        syntax: "<single-animation-iteration-count>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "1",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
      },
      "animation-name": {
        syntax: "[ none | <keyframes-name> ]#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
      },
      "animation-play-state": {
        syntax: "<single-animation-play-state>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "running",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
      },
      "animation-timing-function": {
        syntax: "<easing-function>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
      },
      "animation-timeline": {
        syntax: "<single-animation-timeline>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "listEachItemIdentifyerOrNoneAuto",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
      },
      appearance: {
        syntax: "none | auto | textfield | menulist-button | <compat-auto>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "aspect-ratio": {
        syntax: "auto | <ratio>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
      },
      azimuth: {
        syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
        media: "aural",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Speech"
        ],
        initial: "center",
        appliesto: "allElements",
        computed: "normalizedAngle",
        order: "orderOfAppearance",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
      },
      "backdrop-filter": {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
      },
      "backface-visibility": {
        syntax: "visible | hidden",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "visible",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
      },
      background: {
        syntax: "[ <bg-layer> , ]* <final-bg-layer>",
        media: "visual",
        inherited: false,
        animationType: [
          "background-color",
          "background-image",
          "background-clip",
          "background-position",
          "background-size",
          "background-repeat",
          "background-attachment"
        ],
        percentages: [
          "background-position",
          "background-size"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        appliesto: "allElements",
        computed: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
      },
      "background-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
      },
      "background-blend-mode": {
        syntax: "<blend-mode>#",
        media: "none",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
      },
      "background-clip": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "border-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
      },
      "background-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "transparent",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
      },
      "background-image": {
        syntax: "<bg-image>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
      },
      "background-origin": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
      },
      "background-position": {
        syntax: "<bg-position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: [
          "background-position-x",
          "background-position-y"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
      },
      "background-position-x": {
        syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
      },
      "background-position-y": {
        syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
      },
      "background-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "listEachItemHasTwoKeywordsOnePerDimension",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
      },
      "background-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
      },
      "block-overflow": {
        syntax: "clip | ellipsis | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "clip",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "block-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
      },
      border: {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-color",
          "border-style",
          "border-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-width",
          "border-style",
          "border-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
      },
      "border-block": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
      },
      "border-block-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
      },
      "border-block-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
      },
      "border-block-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
      },
      "border-block-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
      },
      "border-block-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
      },
      "border-block-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
      },
      "border-block-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
      },
      "border-block-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-block-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
      },
      "border-block-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
      },
      "border-block-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
      },
      "border-block-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
      },
      "border-bottom": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
      },
      "border-bottom-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
      },
      "border-bottom-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
      },
      "border-bottom-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
      },
      "border-bottom-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
      },
      "border-bottom-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
      },
      "border-collapse": {
        syntax: "collapse | separate",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "separate",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
      },
      "border-color": {
        syntax: "<color>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
      },
      "border-end-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
      },
      "border-end-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
      },
      "border-image": {
        syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "border-image-slice",
          "border-image-width"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ],
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
      },
      "border-image-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
      },
      "border-image-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "stretch",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
      },
      "border-image-slice": {
        syntax: "<number-percentage>{1,4} && fill?",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfBorderImage",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "100%",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
        order: "percentagesOrLengthsFollowedByFill",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
      },
      "border-image-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
      },
      "border-image-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToWidthOrHeightOfBorderImageArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "1",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
      },
      "border-inline": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
      },
      "border-inline-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-end-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
      },
      "border-inline-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
      },
      "border-inline-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
      },
      "border-inline-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
      },
      "border-inline-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
      },
      "border-inline-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
      },
      "border-inline-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
      },
      "border-inline-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
      },
      "border-inline-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
      },
      "border-inline-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
      },
      "border-inline-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
      },
      "border-left": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-left-color",
          "border-left-style",
          "border-left-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
      },
      "border-left-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
      },
      "border-left-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
      },
      "border-left-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
      },
      "border-radius": {
        syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: [
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-top-left-radius",
          "border-top-right-radius"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
      },
      "border-right": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-right-color",
          "border-right-style",
          "border-right-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
      },
      "border-right-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
      },
      "border-right-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
      },
      "border-right-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
      },
      "border-spacing": {
        syntax: "<length> <length>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "0",
        appliesto: "tableElements",
        computed: "twoAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
      },
      "border-start-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
      },
      "border-start-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
      },
      "border-style": {
        syntax: "<line-style>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-style",
          "border-left-style",
          "border-right-style",
          "border-top-style"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
      },
      "border-top": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-color",
          "border-top-style",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
      },
      "border-top-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
      },
      "border-top-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
      },
      "border-top-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
      },
      "border-top-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
      },
      "border-top-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
      },
      "border-width": {
        syntax: "<line-width>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
      },
      bottom: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
      },
      "box-align": {
        syntax: "start | center | end | baseline | stretch",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "stretch",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
      },
      "box-decoration-break": {
        syntax: "slice | clone",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "slice",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
      },
      "box-direction": {
        syntax: "normal | reverse | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "normal",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
      },
      "box-flex": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
      },
      "box-flex-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "inFlowChildrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
      },
      "box-lines": {
        syntax: "single | multiple",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "single",
        appliesto: "boxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
      },
      "box-ordinal-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "childrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
      },
      "box-orient": {
        syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "inlineAxisHorizontalInXUL",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
      },
      "box-pack": {
        syntax: "start | center | end | justify",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "start",
        appliesto: "elementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
      },
      "box-shadow": {
        syntax: "none | <shadow>#",
        media: "visual",
        inherited: false,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteLengthsSpecifiedColorAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
      },
      "box-sizing": {
        syntax: "content-box | border-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "content-box",
        appliesto: "allElementsAcceptingWidthOrHeight",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
      },
      "break-after": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
      },
      "break-before": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
      },
      "break-inside": {
        syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
      },
      "caption-side": {
        syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "top",
        appliesto: "tableCaptionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
      },
      caret: {
        syntax: "<'caret-color'> || <'caret-shape'>",
        media: "interactive",
        inherited: true,
        animationType: [
          "caret-color",
          "caret-shape"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "caret-color",
          "caret-shape"
        ],
        appliesto: "elementsThatAcceptInput",
        computed: [
          "caret-color",
          "caret-shape"
        ],
        order: "perGrammar",
        status: "standard"
      },
      "caret-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
      },
      "caret-shape": {
        syntax: "auto | bar | block | underscore",
        media: "interactive",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "elementsThatAcceptInput",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      clear: {
        syntax: "none | left | right | both | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
      },
      clip: {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: false,
        animationType: "rectangle",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "autoOrRectangle",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
      },
      "clip-path": {
        syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
      },
      color: {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "canvastext",
        appliesto: "allElementsAndText",
        computed: "computedColor",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
      },
      "print-color-adjust": {
        syntax: "economy | exact",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "economy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
      },
      "color-scheme": {
        syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
      },
      "column-count": {
        syntax: "<integer> | auto",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
      },
      "column-fill": {
        syntax: "auto | balance | balance-all",
        media: "visualInContinuousMediaNoEffectInOverflowColumns",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "balance",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
      },
      "column-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "column-rule": {
        syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-rule-width",
          "column-rule-style",
          "column-rule-color"
        ],
        appliesto: "multicolElements",
        computed: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
      },
      "column-rule-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "currentcolor",
        appliesto: "multicolElements",
        computed: "computedColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
      },
      "column-rule-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
      },
      "column-rule-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "medium",
        appliesto: "multicolElements",
        computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
      },
      "column-span": {
        syntax: "none | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "inFlowBlockLevelElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
      },
      "column-width": {
        syntax: "<length> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "absoluteLengthZeroOrLarger",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
      },
      columns: {
        syntax: "<'column-width'> || <'column-count'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-width",
          "column-count"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-width",
          "column-count"
        ],
        appliesto: "blockContainersExceptTableWrappers",
        computed: [
          "column-width",
          "column-count"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
      },
      contain: {
        syntax: "none | strict | content | [ [ size || inline-size ] || layout || style || paint ]",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
      },
      "contain-intrinsic-size": {
        syntax: "[ none | <length> | auto <length> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        percentages: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        groups: [
          "CSS Containment"
        ],
        initial: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: [
          "contain-intrinsic-width",
          "contain-intrinsic-height"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-size"
      },
      "contain-intrinsic-block-size": {
        syntax: "none | <length> | auto <length>",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-block-size"
      },
      "contain-intrinsic-height": {
        syntax: "none | <length> | auto <length>",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-height"
      },
      "contain-intrinsic-inline-size": {
        syntax: "none | <length> | auto <length>",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-inline-size"
      },
      "contain-intrinsic-width": {
        syntax: "none | <length> | auto <length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "elementsForWhichSizeContainmentCanApply",
        computed: "asSpecifiedWithLengthValuesComputed",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain-intrinsic-width"
      },
      content: {
        syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "normal",
        appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
        computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
      },
      "content-visibility": {
        syntax: "visible | auto | hidden",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "visible",
        appliesto: "elementsForWhichLayoutContainmentCanApply",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
      },
      "counter-increment": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
      },
      "counter-reset": {
        syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
      },
      "counter-set": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
      },
      cursor: {
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
      },
      direction: {
        syntax: "ltr | rtl",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "ltr",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
      },
      display: {
        syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
        media: "all",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Display"
        ],
        initial: "inline",
        appliesto: "allElements",
        computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
      },
      "empty-cells": {
        syntax: "show | hide",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "show",
        appliesto: "tableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
      },
      filter: {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
      },
      flex: {
        syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        appliesto: "flexItemsAndInFlowPseudos",
        computed: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
      },
      "flex-basis": {
        syntax: "content | <'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToFlexContainersInnerMainSize",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "auto",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
      },
      "flex-direction": {
        syntax: "row | row-reverse | column | column-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "row",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
      },
      "flex-flow": {
        syntax: "<'flex-direction'> || <'flex-wrap'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-direction",
          "flex-wrap"
        ],
        appliesto: "flexContainers",
        computed: [
          "flex-direction",
          "flex-wrap"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
      },
      "flex-grow": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
      },
      "flex-shrink": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "1",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
      },
      "flex-wrap": {
        syntax: "nowrap | wrap | wrap-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "nowrap",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
      },
      float: {
        syntax: "left | right | none | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsNoEffectIfDisplayNone",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
      },
      font: {
        syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
        media: "visual",
        inherited: true,
        animationType: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        percentages: [
          "font-size",
          "line-height"
        ],
        groups: [
          "CSS Fonts"
        ],
        initial: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        appliesto: "allElements",
        computed: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
      },
      "font-family": {
        syntax: "[ <family-name> | <generic-family> ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
      },
      "font-kerning": {
        syntax: "auto | normal | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
      },
      "font-language-override": {
        syntax: "normal | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
      },
      "font-optical-sizing": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "visual",
        inherited: true,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
      },
      "font-size": {
        syntax: "<absolute-size> | <relative-size> | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToParentElementsFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
      },
      "font-size-adjust": {
        syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
        media: "visual",
        inherited: true,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
      },
      "font-smooth": {
        syntax: "auto | never | always | <absolute-size> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>",
        media: "visual",
        inherited: true,
        animationType: "fontStretch",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
      },
      "font-synthesis": {
        syntax: "none | [ weight || style || small-caps ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "weight style",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
      },
      "font-variant": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
      },
      "font-variant-alternates": {
        syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
      },
      "font-variant-caps": {
        syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
      },
      "font-variant-east-asian": {
        syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
      },
      "font-variant-ligatures": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
      },
      "font-variant-numeric": {
        syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
      },
      "font-variant-position": {
        syntax: "normal | sub | super",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
      },
      "font-weight": {
        syntax: "<font-weight-absolute> | bolder | lighter",
        media: "visual",
        inherited: true,
        animationType: "fontWeight",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
      },
      "forced-color-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
      },
      gap: {
        syntax: "<'row-gap'> <'column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "row-gap",
          "column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "row-gap",
          "column-gap"
        ],
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: [
          "row-gap",
          "column-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      grid: {
        syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-auto-rows",
          "grid-auto-columns"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
      },
      "grid-area": {
        syntax: "<grid-line> [ / <grid-line> ]{0,3}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
      },
      "grid-auto-columns": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
      },
      "grid-auto-flow": {
        syntax: "[ row | column ] || dense",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "row",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
      },
      "grid-auto-rows": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
      },
      "grid-column": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-column-start",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-column-start",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
      },
      "grid-column-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
      },
      "grid-column-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "grid-column-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
      },
      "grid-gap": {
        syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      "grid-row": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-row-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-row-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
      },
      "grid-row-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
      },
      "grid-row-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "grid-row-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
      },
      "grid-template": {
        syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-columns",
          "grid-template-rows"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
      },
      "grid-template-areas": {
        syntax: "none | <string>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
      },
      "grid-template-columns": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
      },
      "grid-template-rows": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
      },
      "hanging-punctuation": {
        syntax: "none | [ first || [ force-end | allow-end ] || last ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
      },
      height: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAutoOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
      },
      "hyphenate-character": {
        syntax: "auto | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
      },
      hyphens: {
        syntax: "none | manual | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "manual",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
      },
      "image-orientation": {
        syntax: "from-image | <angle> | [ <angle>? flip ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "from-image",
        appliesto: "allElements",
        computed: "angleRoundedToNextQuarter",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
      },
      "image-rendering": {
        syntax: "auto | crisp-edges | pixelated",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
      },
      "image-resolution": {
        syntax: "[ from-image || <resolution> ] && snap?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "1dppx",
        appliesto: "allElements",
        computed: "asSpecifiedWithExceptionOfResolution",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ime-mode": {
        syntax: "auto | normal | active | inactive | disabled",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "textFields",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
      },
      "initial-letter": {
        syntax: "normal | [ <number> <integer>? ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "normal",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
      },
      "initial-letter-align": {
        syntax: "[ auto | alphabetic | hanging | ideographic ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "auto",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
      },
      "inline-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
      },
      "input-security": {
        syntax: "auto | none",
        media: "interactive",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "sensitiveTextInputs",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      inset: {
        syntax: "<'top'>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOrWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "top",
          "bottom",
          "left",
          "right"
        ],
        appliesto: "positionedElements",
        computed: [
          "top",
          "bottom",
          "left",
          "right"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
      },
      "inset-block": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "inset-block-start",
          "inset-block-end"
        ],
        appliesto: "positionedElements",
        computed: [
          "inset-block-start",
          "inset-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
      },
      "inset-block-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
      },
      "inset-block-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
      },
      "inset-inline": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "inset-inline-start",
          "inset-inline-end"
        ],
        appliesto: "positionedElements",
        computed: [
          "inset-inline-start",
          "inset-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
      },
      "inset-inline-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
      },
      "inset-inline-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
      },
      isolation: {
        syntax: "auto | isolate",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
      },
      "justify-content": {
        syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
      },
      "justify-items": {
        syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "legacy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
      },
      "justify-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
      },
      "justify-tracks": {
        syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
      },
      left: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
      },
      "letter-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumValueOfAbsoluteLengthOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
      },
      "line-break": {
        syntax: "auto | loose | normal | strict | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
      },
      "line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "line-height": {
        syntax: "normal | <number> | <length> | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "numberOrLength",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLengthOrAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
      },
      "line-height-step": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "absoluteLength",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
      },
      "list-style": {
        syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: [
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ],
        appliesto: "listItems",
        computed: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
      },
      "list-style-image": {
        syntax: "<image> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "none",
        appliesto: "listItems",
        computed: "theKeywordListStyleImageNoneOrComputedValue",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
      },
      "list-style-position": {
        syntax: "inside | outside",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "outside",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
      },
      "list-style-type": {
        syntax: "<counter-style> | <string> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "disc",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
      },
      margin: {
        syntax: "[ <length> | <percentage> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
      },
      "margin-block": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "margin-block-start",
          "margin-block-end"
        ],
        appliesto: "sameAsMargin",
        computed: [
          "margin-block-start",
          "margin-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
      },
      "margin-block-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
      },
      "margin-block-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
      },
      "margin-bottom": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
      },
      "margin-inline": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "margin-inline-start",
          "margin-inline-end"
        ],
        appliesto: "sameAsMargin",
        computed: [
          "margin-inline-start",
          "margin-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
      },
      "margin-inline-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
      },
      "margin-inline-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
      },
      "margin-left": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
      },
      "margin-right": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
      },
      "margin-top": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
      },
      "margin-trim": {
        syntax: "none | in-flow | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "blockContainersAndMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
      },
      mask: {
        syntax: "<mask-layer>#",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        percentages: [
          "mask-position"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "mask-border": {
        syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        percentages: [
          "mask-border-slice",
          "mask-border-width"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
      },
      "mask-border-mode": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "alpha",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
      },
      "mask-border-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
      },
      "mask-border-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "stretch",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
      },
      "mask-border-slice": {
        syntax: "<number-percentage>{1,4} fill?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfMaskBorderImage",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
      },
      "mask-border-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
      },
      "mask-border-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToMaskBorderImageArea",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
      },
      "mask-clip": {
        syntax: "[ <geometry-box> | no-clip ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "mask-composite": {
        syntax: "<compositing-operator>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "add",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
      },
      "mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "mask-mode": {
        syntax: "<masking-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "match-source",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
      },
      "mask-origin": {
        syntax: "<geometry-box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfMaskPaintingArea",
        groups: [
          "CSS Masking"
        ],
        initial: "center",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoKeywordsForOriginAndOffsets",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "repeat",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoDimensionKeywords",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "mask-type": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "luminance",
        appliesto: "maskElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
      },
      "masonry-auto-flow": {
        syntax: "[ pack | next ] || [ definite-first | ordered ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "pack",
        appliesto: "gridContainersWithMasonryLayout",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
      },
      "math-depth": {
        syntax: "auto-add | add(<integer>) | <integer>",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-depth"
      },
      "math-shift": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-shift"
      },
      "math-style": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
      },
      "max-block-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
      },
      "max-height": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
      },
      "max-inline-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
      },
      "max-lines": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "max-width": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
      },
      "min-block-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
      },
      "min-height": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
      },
      "min-inline-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
      },
      "min-width": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
      },
      "mix-blend-mode": {
        syntax: "<blend-mode> | plus-lighter",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
      },
      "object-fit": {
        syntax: "fill | contain | cover | none | scale-down",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "fill",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
      },
      "object-position": {
        syntax: "<position>",
        media: "visual",
        inherited: true,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToWidthAndHeightOfElement",
        groups: [
          "CSS Images"
        ],
        initial: "50% 50%",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
      },
      offset: {
        syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        percentages: [
          "offset-position",
          "offset-distance",
          "offset-anchor"
        ],
        groups: [
          "CSS Motion Path"
        ],
        initial: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        appliesto: "transformableElements",
        computed: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
      },
      "offset-anchor": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "relativeToWidthAndHeight",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard"
      },
      "offset-distance": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToTotalPathLength",
        groups: [
          "CSS Motion Path"
        ],
        initial: "0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
      },
      "offset-path": {
        syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
      },
      "offset-position": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "referToSizeOfContainingBlock",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "experimental"
      },
      "offset-rotate": {
        syntax: "[ auto | reverse ] || <angle>",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
      },
      opacity: {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "mapToRange0To1",
        groups: [
          "CSS Color"
        ],
        initial: "1",
        appliesto: "allElements",
        computed: "specifiedValueNumberClipped0To1",
        order: "perGrammar",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
      },
      order: {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
      },
      orphans: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
      },
      outline: {
        syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "outline-color",
          "outline-style",
          "outline-width"
        ],
        appliesto: "allElements",
        computed: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
      },
      "outline-color": {
        syntax: "<color> | invert",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "invertOrCurrentColor",
        appliesto: "allElements",
        computed: "invertForTranslucentColorRGBAOtherwiseRGB",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
      },
      "outline-offset": {
        syntax: "<length>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
      },
      "outline-style": {
        syntax: "auto | <'border-style'>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
      },
      "outline-width": {
        syntax: "<line-width>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLength0ForNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
      },
      overflow: {
        syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: [
          "overflow-x",
          "overflow-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
      },
      "overflow-anchor": {
        syntax: "auto | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Anchoring"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-block": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-clip-box": {
        syntax: "padding-box | content-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
      },
      "overflow-clip-margin": {
        syntax: "<visual-box> || <length [0,\u221E]>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "0px",
        appliesto: "allElements",
        computed: "theComputedLength",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-inline": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-wrap": {
        syntax: "normal | break-word | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "overflow-x": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
      },
      "overflow-y": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
      },
      "overscroll-behavior": {
        syntax: "[ contain | none | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "overscroll-behavior-x",
          "overscroll-behavior-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
      },
      "overscroll-behavior-block": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
      },
      "overscroll-behavior-inline": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
      },
      "overscroll-behavior-x": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
      },
      "overscroll-behavior-y": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
      },
      padding: {
        syntax: "[ <length> | <percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
      },
      "padding-block": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "padding-block-start",
          "padding-block-end"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-block-start",
          "padding-block-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
      },
      "padding-block-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
      },
      "padding-block-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
      },
      "padding-bottom": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
      },
      "padding-inline": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "padding-inline-start",
          "padding-inline-end"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-inline-start",
          "padding-inline-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
      },
      "padding-inline-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
      },
      "padding-inline-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
      },
      "padding-left": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
      },
      "padding-right": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
      },
      "padding-top": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
      },
      "page-break-after": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
      },
      "page-break-before": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
      },
      "page-break-inside": {
        syntax: "auto | avoid",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
      },
      "paint-order": {
        syntax: "normal | [ fill || stroke || markers ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
      },
      perspective: {
        syntax: "none | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "absoluteLengthOrNone",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
      },
      "perspective-origin": {
        syntax: "<position>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50%",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
      },
      "place-content": {
        syntax: "<'align-content'> <'justify-content'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-content",
          "justify-content"
        ],
        appliesto: "multilineFlexContainers",
        computed: [
          "align-content",
          "justify-content"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
      },
      "place-items": {
        syntax: "<'align-items'> <'justify-items'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-items",
          "justify-items"
        ],
        appliesto: "allElements",
        computed: [
          "align-items",
          "justify-items"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
      },
      "place-self": {
        syntax: "<'align-self'> <'justify-self'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-self",
          "justify-self"
        ],
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: [
          "align-self",
          "justify-self"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
      },
      "pointer-events": {
        syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
      },
      position: {
        syntax: "static | relative | absolute | sticky | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "static",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
      },
      quotes: {
        syntax: "none | auto | [ <string> <string> ]+",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
      },
      resize: {
        syntax: "none | both | horizontal | vertical | block | inline",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
      },
      right: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
      },
      rotate: {
        syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
      },
      "row-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "ruby-align": {
        syntax: "start | center | space-between | space-around",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "space-around",
        appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
      },
      "ruby-merge": {
        syntax: "separate | collapse | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "separate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ruby-position": {
        syntax: "[ alternate || [ over | under ] ] | inter-character",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "alternate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
      },
      scale: {
        syntax: "none | <number>{1,3}",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
      },
      "scrollbar-color": {
        syntax: "auto | <color>{2}",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
      },
      "scrollbar-gutter": {
        syntax: "auto | stable && both-edges?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
      },
      "scrollbar-width": {
        syntax: "auto | thin | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
      },
      "scroll-behavior": {
        syntax: "auto | smooth",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSSOM View"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
      },
      "scroll-margin": {
        syntax: "<length>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-bottom",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-bottom",
          "scroll-margin-left",
          "scroll-margin-right",
          "scroll-margin-top"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
      },
      "scroll-margin-block": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-block-start",
          "scroll-margin-block-end"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-block-start",
          "scroll-margin-block-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
      },
      "scroll-margin-block-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
      },
      "scroll-margin-block-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
      },
      "scroll-margin-bottom": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
      },
      "scroll-margin-inline": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-margin-inline-start",
          "scroll-margin-inline-end"
        ],
        appliesto: "allElements",
        computed: [
          "scroll-margin-inline-start",
          "scroll-margin-inline-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
      },
      "scroll-margin-inline-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
      },
      "scroll-margin-inline-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
      },
      "scroll-margin-left": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
      },
      "scroll-margin-right": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
      },
      "scroll-margin-top": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
      },
      "scroll-padding": {
        syntax: "[ auto | <length-percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-bottom",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-bottom",
          "scroll-padding-left",
          "scroll-padding-right",
          "scroll-padding-top"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
      },
      "scroll-padding-block": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-block-start",
          "scroll-padding-block-end"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-block-start",
          "scroll-padding-block-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
      },
      "scroll-padding-block-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
      },
      "scroll-padding-block-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
      },
      "scroll-padding-bottom": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
      },
      "scroll-padding-inline": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: [
          "scroll-padding-inline-start",
          "scroll-padding-inline-end"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-padding-inline-start",
          "scroll-padding-inline-end"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
      },
      "scroll-padding-inline-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
      },
      "scroll-padding-inline-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
      },
      "scroll-padding-left": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
      },
      "scroll-padding-right": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
      },
      "scroll-padding-top": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
      },
      "scroll-snap-align": {
        syntax: "[ none | start | end | center ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
      },
      "scroll-snap-coordinate": {
        syntax: "none | <position>#",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "referToBorderBox",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
      },
      "scroll-snap-destination": {
        syntax: "<position>",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0px 0px",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
      },
      "scroll-snap-points-x": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
      },
      "scroll-snap-points-y": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
      },
      "scroll-snap-stop": {
        syntax: "normal | always",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
      },
      "scroll-snap-type": {
        syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
      },
      "scroll-snap-type-x": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
      },
      "scroll-snap-type-y": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
      },
      "scroll-timeline": {
        syntax: "<scroll-timeline-name> || <scroll-timeline-axis>",
        media: "visual",
        inherited: false,
        animationType: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        appliesto: "scrollContainers",
        computed: [
          "scroll-timeline-name",
          "scroll-timeline-axis"
        ],
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline"
      },
      "scroll-timeline-axis": {
        syntax: "block | inline | vertical | horizontal",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "block",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-axis"
      },
      "scroll-timeline-name": {
        syntax: "none | <custom-ident>",
        media: "interactive",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-timeline-name"
      },
      "shape-image-threshold": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "0.0",
        appliesto: "floats",
        computed: "specifiedValueNumberClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
      },
      "shape-margin": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Shapes"
        ],
        initial: "0",
        appliesto: "floats",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
      },
      "shape-outside": {
        syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "none",
        appliesto: "floats",
        computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
      },
      "tab-size": {
        syntax: "<integer> | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "8",
        appliesto: "blockContainers",
        computed: "specifiedIntegerOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
      },
      "table-layout": {
        syntax: "auto | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "auto",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
      },
      "text-align": {
        syntax: "start | end | left | right | center | justify | match-parent",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "startOrNamelessValueIfLTRRightIfRTL",
        appliesto: "blockContainers",
        computed: "asSpecifiedExceptMatchParent",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
      },
      "text-align-last": {
        syntax: "auto | start | end | left | right | center | justify",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
      },
      "text-combine-upright": {
        syntax: "none | all | [ digits <integer>? ]",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "none",
        appliesto: "nonReplacedInlineElements",
        computed: "keywordPlusIntegerIfDigits",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
      },
      "text-decoration": {
        syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line",
          "text-decoration-thickness"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line"
        ],
        appliesto: "allElements",
        computed: [
          "text-decoration-line",
          "text-decoration-style",
          "text-decoration-color",
          "text-decoration-thickness"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
      },
      "text-decoration-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
      },
      "text-decoration-line": {
        syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
      },
      "text-decoration-skip": {
        syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "objects",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
      },
      "text-decoration-skip-ink": {
        syntax: "auto | all | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
      },
      "text-decoration-style": {
        syntax: "solid | double | dotted | dashed | wavy",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "solid",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
      },
      "text-decoration-thickness": {
        syntax: "auto | from-font | <length> | <percentage> ",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
      },
      "text-emphasis": {
        syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-emphasis-color",
          "text-emphasis-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        appliesto: "allElements",
        computed: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
      },
      "text-emphasis-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
      },
      "text-emphasis-position": {
        syntax: "[ over | under ] && [ right | left ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "over right",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
      },
      "text-emphasis-style": {
        syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
      },
      "text-indent": {
        syntax: "<length-percentage> && hanging? && each-line?",
        media: "visual",
        inherited: true,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Text"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "percentageOrAbsoluteLengthPlusKeywords",
        order: "lengthOrPercentageBeforeKeywords",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
      },
      "text-justify": {
        syntax: "auto | inter-character | inter-word | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
      },
      "text-orientation": {
        syntax: "mixed | upright | sideways",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "mixed",
        appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
      },
      "text-overflow": {
        syntax: "[ clip | ellipsis | <string> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "clip",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
      },
      "text-rendering": {
        syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "auto",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
      },
      "text-shadow": {
        syntax: "none | <shadow-t>#",
        media: "visual",
        inherited: true,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "colorPlusThreeAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
      },
      "text-size-adjust": {
        syntax: "none | auto | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToSizeOfFont",
        groups: [
          "CSS Text"
        ],
        initial: "autoForSmartphoneBrowsersSupportingInflation",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
      },
      "text-transform": {
        syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
      },
      "text-underline-offset": {
        syntax: "auto | <length> | <percentage> ",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
      },
      "text-underline-position": {
        syntax: "auto | from-font | [ under || [ left | right ] ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
      },
      top: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
      },
      "touch-action": {
        syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
      },
      transform: {
        syntax: "none | <transform-list>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
      },
      "transform-box": {
        syntax: "content-box | border-box | fill-box | stroke-box | view-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "view-box",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
      },
      "transform-origin": {
        syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50% 0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
      },
      "transform-style": {
        syntax: "flat | preserve-3d",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "flat",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
      },
      transition: {
        syntax: "<single-transition>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
      },
      "transition-delay": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
      },
      "transition-duration": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
      },
      "transition-property": {
        syntax: "none | <single-transition-property>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "all",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
      },
      "transition-timing-function": {
        syntax: "<easing-function>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
      },
      translate: {
        syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
      },
      "unicode-bidi": {
        syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "normal",
        appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
      },
      "user-select": {
        syntax: "auto | text | none | contain | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
      },
      "vertical-align": {
        syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToLineHeight",
        groups: [
          "CSS Table"
        ],
        initial: "baseline",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "absoluteLengthOrKeyword",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
      },
      visibility: {
        syntax: "visible | hidden | collapse",
        media: "visual",
        inherited: true,
        animationType: "visibility",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "visible",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
      },
      "white-space": {
        syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
      },
      widows: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
      },
      width: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAutoOrAbsoluteLength",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
      },
      "will-change": {
        syntax: "auto | <animateable-feature>#",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Will Change"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
      },
      "word-break": {
        syntax: "normal | break-all | keep-all | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
      },
      "word-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToWidthOfAffectedGlyph",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
      },
      "word-wrap": {
        syntax: "normal | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "writing-mode": {
        syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "horizontal-tb",
        appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
      },
      "z-index": {
        syntax: "auto | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
      },
      zoom: {
        syntax: "normal | reset | <number> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
      }
    };
  }
});

// node_modules/mdn-data/css/syntaxes.json
var require_syntaxes = __commonJS({
  "node_modules/mdn-data/css/syntaxes.json"(exports2, module2) {
    module2.exports = {
      "abs()": {
        syntax: "abs( <calc-sum> )"
      },
      "absolute-size": {
        syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
      },
      "acos()": {
        syntax: "acos( <calc-sum> )"
      },
      "alpha-value": {
        syntax: "<number> | <percentage>"
      },
      "angle-percentage": {
        syntax: "<angle> | <percentage>"
      },
      "angular-color-hint": {
        syntax: "<angle-percentage>"
      },
      "angular-color-stop": {
        syntax: "<color> && <color-stop-angle>?"
      },
      "angular-color-stop-list": {
        syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
      },
      "animateable-feature": {
        syntax: "scroll-position | contents | <custom-ident>"
      },
      "asin()": {
        syntax: "asin( <calc-sum> )"
      },
      "atan()": {
        syntax: "atan( <calc-sum> )"
      },
      "atan2()": {
        syntax: "atan2( <calc-sum>, <calc-sum> )"
      },
      attachment: {
        syntax: "scroll | fixed | local"
      },
      "attr()": {
        syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
      },
      "attr-matcher": {
        syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
      },
      "attr-modifier": {
        syntax: "i | s"
      },
      "attribute-selector": {
        syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
      },
      "auto-repeat": {
        syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "auto-track-list": {
        syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
      },
      axis: {
        syntax: "block | inline | vertical | horizontal"
      },
      "baseline-position": {
        syntax: "[ first | last ]? baseline"
      },
      "basic-shape": {
        syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
      },
      "bg-image": {
        syntax: "none | <image>"
      },
      "bg-layer": {
        syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "bg-position": {
        syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | <calc-constant> | ( <calc-sum> )"
      },
      "calc-constant": {
        syntax: "e | pi | infinity | -infinity | NaN"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      "cos()": {
        syntax: "cos( <calc-sum> )"
      },
      counter: {
        syntax: "<counter()> | <counters()>"
      },
      "counter()": {
        syntax: "counter( <counter-name>, <counter-style>? )"
      },
      "counter-name": {
        syntax: "<custom-ident>"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <counter-name>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "exp()": {
        syntax: "exp( <calc-sum> )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "hwb()": {
        syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
      },
      "hypot()": {
        syntax: "hypot( <calc-sum># )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length-percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage>"
      },
      "lab()": {
        syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
      },
      "layer()": {
        syntax: "layer( <layer-name> )"
      },
      "layer-name": {
        syntax: "<ident> [ '.' <ident> ]*"
      },
      "lch()": {
        syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "log()": {
        syntax: "log( <calc-sum>, <calc-sum>? )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length-percentage> | min-content | max-content | auto ] , [ <length-percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "mod()": {
        syntax: "mod( <calc-sum>, <calc-sum> )"
      },
      "name-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> | auto-fill ], <line-names>+ )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "page-size": {
        syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( [ <length [0,\u221E]> | none ] )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pow()": {
        syntax: "pow( <calc-sum>, <calc-sum> )"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      ratio: {
        syntax: "<number [0,\u221E]> [ / <number [0,\u221E]> ]?"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "rem()": {
        syntax: "rem( <calc-sum>, <calc-sum> )"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-conic-gradient()": {
        syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "reversed-counter-name": {
        syntax: "reversed( <counter-name> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "round()": {
        syntax: "round( <rounding-strategy>?, <calc-sum>, <calc-sum> )"
      },
      "rounding-strategy": {
        syntax: "nearest | up | down | to-zero"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( [ <number> | <percentage> ]#{1,2} )"
      },
      "scale3d()": {
        syntax: "scale3d( [ <number> | <percentage> ]#{3} )"
      },
      "scaleX()": {
        syntax: "scaleX( [ <number> | <percentage> ] )"
      },
      "scaleY()": {
        syntax: "scaleY( [ <number> | <percentage> ] )"
      },
      "scaleZ()": {
        syntax: "scaleZ( [ <number> | <percentage> ] )"
      },
      scroller: {
        syntax: "root | nearest"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "sign()": {
        syntax: "sign( <calc-sum> )"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "sin()": {
        syntax: "sin( <calc-sum> )"
      },
      "single-animation": {
        syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-animation-timeline": {
        syntax: "auto | none | <timeline-name> | scroll(<axis>? <scroller>?)"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "sqrt()": {
        syntax: "sqrt( <calc-sum> )"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      "tan()": {
        syntax: "tan( <calc-sum> )"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timeline-name": {
        syntax: "<custom-ident> | <string>"
      },
      "easing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( <length-percentage> )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "visual-box": {
        syntax: "content-box | padding-box | border-box"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/css-tree/cjs/data.cjs
var require_data = __commonJS({
  "node_modules/css-tree/cjs/data.cjs"(exports2, module2) {
    "use strict";
    var dataPatch = require_data_patch();
    var mdnAtrules = require_at_rules();
    var mdnProperties = require_properties();
    var mdnSyntaxes = require_syntaxes();
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const descriptor in atrule.descriptors) {
            descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
      }
      for (const key in patchDict) {
        if (key in dict) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        const atrulePatch = patchDict[key] || {};
        result[key] = {
          prelude: key in patchDict && "prelude" in atrulePatch ? atrulePatch.prelude : dict[key].prelude || null,
          descriptors: patchDictionary(dict[key].descriptors || {}, atrulePatch.descriptors || {})
        };
      }
      for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
          const atrulePatch = patchDict[key] || {};
          result[key] = {
            prelude: atrulePatch.prelude || null,
            descriptors: atrulePatch.descriptors && patchDictionary({}, atrulePatch.descriptors)
          };
        }
      }
      return result;
    }
    var definitions = {
      types: patchDictionary(mdnSyntaxes, dataPatch.types),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
      properties: patchDictionary(mdnProperties, dataPatch.properties)
    };
    module2.exports = definitions;
  }
});

// node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      let pos = this.tokenStart + offset;
      const code = this.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.tokenEnd; pos++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = "";
        switch (code) {
          case N:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.tokenStart + offset);
      }
    }
    function consumeB() {
      let offset = 0;
      let sign = 0;
      let type = this.tokenType;
      while (type === types.WhiteSpace || type === types.Comment) {
        type = this.lookupType(++offset);
      }
      if (type !== types.Number) {
        if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
          sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.lookupType(++offset);
          } while (type === types.WhiteSpace || type === types.Comment);
          if (type !== types.Number) {
            this.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.skip(offset);
      }
      if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
    }
    var name = "AnPlusB";
    var structure = {
      a: [String, null],
      b: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let a = null;
      let b = null;
      if (this.tokenType === types.Number) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(types.Number);
      } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
        a = "-1";
        expectCharCode.call(this, 1, N);
        switch (this.tokenEnd - this.tokenStart) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            this.next();
            b = consumeB.call(this);
            break;
          // -n- <signless-integer>
          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // <dashndashdigit-ident>
          default:
            expectCharCode.call(this, 2, HYPHENMINUS);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + 2);
        }
      } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
        let sign = 0;
        a = "1";
        if (this.isDelim(PLUSSIGN)) {
          sign = 1;
          this.next();
        }
        expectCharCode.call(this, 0, N);
        switch (this.tokenEnd - this.tokenStart) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            this.next();
            b = consumeB.call(this);
            break;
          // '+'? n- <signless-integer>
          case 2:
            expectCharCode.call(this, 1, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // '+'? <ndashdigit-ident>
          default:
            expectCharCode.call(this, 1, HYPHENMINUS);
            checkInteger.call(this, 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + sign + 1);
        }
      } else if (this.tokenType === types.Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN || code === HYPHENMINUS;
        let i = this.tokenStart + sign;
        for (; i < this.tokenEnd; i++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
            break;
          }
        }
        if (i === this.tokenStart + sign) {
          this.error("Integer is expected", this.tokenStart + sign);
        }
        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);
        if (i + 1 === this.tokenEnd) {
          this.next();
          b = consumeB.call(this);
        } else {
          expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
          if (i + 2 === this.tokenEnd) {
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
          } else {
            checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(i + 1);
          }
        }
      } else {
        this.error();
      }
      if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
        a = a.substr(1);
      }
      if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
        b = b.substr(1);
      }
      return {
        type: "AnPlusB",
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
      };
    }
    function generate(node) {
      if (node.a) {
        const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
        if (node.b) {
          const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
          this.tokenize(a + b);
        } else {
          this.tokenize(a);
        }
      } else {
        this.tokenize(node.b);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Atrule.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === types.RightCurlyBracket) {
          return true;
        }
        if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
          return false;
        }
      }
      return false;
    }
    var name = "Atrule";
    var walkContext = "atrule";
    var structure = {
      name: String,
      prelude: ["AtrulePrelude", "Raw", null],
      block: ["Block", null]
    };
    function parse(isDeclaration = false) {
      const start = this.tokenStart;
      let name2;
      let nameLowerCase;
      let prelude = null;
      let block = null;
      this.eat(types.AtKeyword);
      name2 = this.substrToCursor(start + 1);
      nameLowerCase = name2.toLowerCase();
      this.skipSC();
      if (this.eof === false && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        if (this.parseAtrulePrelude) {
          prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2, isDeclaration), consumeRaw);
        } else {
          prelude = consumeRaw.call(this, this.tokenIndex);
        }
        this.skipSC();
      }
      switch (this.tokenType) {
        case types.Semicolon:
          this.next();
          break;
        case types.LeftCurlyBracket:
          if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
            block = this.atrule[nameLowerCase].block.call(this, isDeclaration);
          } else {
            block = this.Block(isDeclarationBlockAtrule.call(this));
          }
          break;
      }
      return {
        type: "Atrule",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        prelude,
        block
      };
    }
    function generate(node) {
      this.token(types.AtKeyword, "@" + node.name);
      if (node.prelude !== null) {
        this.node(node.prelude);
      }
      if (node.block) {
        this.node(node.block);
      } else {
        this.token(types.Semicolon, ";");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs
var require_AtrulePrelude = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "AtrulePrelude";
    var walkContext = "atrulePrelude";
    var structure = {
      children: [[]]
    };
    function parse(name2) {
      let children = null;
      if (name2 !== null) {
        name2 = name2.toLowerCase();
      }
      this.skipSC();
      if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
        children = this.atrule[name2].prelude.call(this);
      } else {
        children = this.readSequence(this.scope.AtrulePrelude);
      }
      this.skipSC();
      if (this.eof !== true && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        this.error("Semicolon or block is expected");
      }
      return {
        type: "AtrulePrelude",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs
var require_AttributeSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var DOLLARSIGN = 36;
    var ASTERISK = 42;
    var EQUALSSIGN = 61;
    var CIRCUMFLEXACCENT = 94;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getAttributeName() {
      if (this.eof) {
        this.error("Unexpected end of input");
      }
      const start = this.tokenStart;
      let expectIdent = false;
      if (this.isDelim(ASTERISK)) {
        expectIdent = true;
        this.next();
      } else if (!this.isDelim(VERTICALLINE)) {
        this.eat(types.Ident);
      }
      if (this.isDelim(VERTICALLINE)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
          this.next();
          this.eat(types.Ident);
        } else if (expectIdent) {
          this.error("Identifier is expected", this.tokenEnd);
        }
      } else if (expectIdent) {
        this.error("Vertical line is expected");
      }
      return {
        type: "Identifier",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function getOperator() {
      const start = this.tokenStart;
      const code = this.charCodeAt(start);
      if (code !== EQUALSSIGN && // =
      code !== TILDE && // ~=
      code !== CIRCUMFLEXACCENT && // ^=
      code !== DOLLARSIGN && // $=
      code !== ASTERISK && // *=
      code !== VERTICALLINE) {
        this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
      }
      this.next();
      if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
          this.error("Equal sign is expected");
        }
        this.next();
      }
      return this.substrToCursor(start);
    }
    var name = "AttributeSelector";
    var structure = {
      name: "Identifier",
      matcher: [String, null],
      value: ["String", "Identifier", null],
      flags: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let matcher = null;
      let value = null;
      let flags = null;
      this.eat(types.LeftSquareBracket);
      this.skipSC();
      name2 = getAttributeName.call(this);
      this.skipSC();
      if (this.tokenType !== types.RightSquareBracket) {
        if (this.tokenType !== types.Ident) {
          matcher = getOperator.call(this);
          this.skipSC();
          value = this.tokenType === types.String ? this.String() : this.Identifier();
          this.skipSC();
        }
        if (this.tokenType === types.Ident) {
          flags = this.consume(types.Ident);
          this.skipSC();
        }
      }
      this.eat(types.RightSquareBracket);
      return {
        type: "AttributeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        matcher,
        value,
        flags
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.node(node.name);
      if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
      }
      if (node.flags !== null) {
        this.token(types.Ident, node.flags);
      }
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Block.cjs
var require_Block = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Block.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var AMPERSAND = 38;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, true);
    }
    function consumeRule() {
      return this.parseWithFallback(this.Rule, consumeRaw);
    }
    function consumeRawDeclaration(startToken) {
      return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    function consumeDeclaration() {
      if (this.tokenType === types.Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
      }
      const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
      if (this.tokenType === types.Semicolon) {
        this.next();
      }
      return node;
    }
    var name = "Block";
    var walkContext = "block";
    var structure = {
      children: [[
        "Atrule",
        "Rule",
        "Declaration"
      ]]
    };
    function parse(isStyleBlock) {
      const consumer = isStyleBlock ? consumeDeclaration : consumeRule;
      const start = this.tokenStart;
      let children = this.createList();
      this.eat(types.LeftCurlyBracket);
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.RightCurlyBracket:
              break scan;
            case types.WhiteSpace:
            case types.Comment:
              this.next();
              break;
            case types.AtKeyword:
              children.push(this.parseWithFallback(this.Atrule.bind(this, isStyleBlock), consumeRaw));
              break;
            default:
              if (isStyleBlock && this.isDelim(AMPERSAND)) {
                children.push(consumeRule.call(this));
              } else {
                children.push(consumer.call(this));
              }
          }
        }
      if (!this.eof) {
        this.eat(types.RightCurlyBracket);
      }
      return {
        type: "Block",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftCurlyBracket, "{");
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
      this.token(types.RightCurlyBracket, "}");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Brackets.cjs
var require_Brackets = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Brackets.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Brackets";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftSquareBracket);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightSquareBracket);
      }
      return {
        type: "Brackets",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.children(node);
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/CDC.cjs
var require_CDC = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/CDC.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "CDC";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDC);
      return {
        type: "CDC",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDC, "-->");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/CDO.cjs
var require_CDO = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/CDO.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "CDO";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDO);
      return {
        type: "CDO",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDO, "<!--");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs
var require_ClassSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var FULLSTOP = 46;
    var name = "ClassSelector";
    var structure = {
      name: String
    };
    function parse() {
      this.eatDelim(FULLSTOP);
      return {
        type: "ClassSelector",
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Delim, ".");
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Combinator.cjs
var require_Combinator = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Combinator.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var GREATERTHANSIGN = 62;
    var TILDE = 126;
    var name = "Combinator";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      switch (this.tokenType) {
        case types.WhiteSpace:
          name2 = " ";
          break;
        case types.Delim:
          switch (this.charCodeAt(this.tokenStart)) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
              this.next();
              break;
            case SOLIDUS:
              this.next();
              this.eatIdent("deep");
              this.eatDelim(SOLIDUS);
              break;
            default:
              this.error("Combinator is expected");
          }
          name2 = this.substrToCursor(start);
          break;
      }
      return {
        type: "Combinator",
        loc: this.getLocation(start, this.tokenStart),
        name: name2
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Comment.cjs
var require_Comment = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Comment.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var ASTERISK = 42;
    var SOLIDUS = 47;
    var name = "Comment";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let end = this.tokenEnd;
      this.eat(types.Comment);
      if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK && this.charCodeAt(end - 1) === SOLIDUS) {
        end -= 2;
      }
      return {
        type: "Comment",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
      };
    }
    function generate(node) {
      this.token(types.Comment, "/*" + node.value + "*/");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Declaration.cjs
var require_Declaration = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Declaration.cjs"(exports2) {
    "use strict";
    var names = require_names2();
    var types = require_types2();
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var DOLLARSIGN = 36;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    function consumeValueRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
      const startValueToken = this.tokenIndex;
      const value = this.Value();
      if (value.type !== "Raw" && this.eof === false && this.tokenType !== types.Semicolon && this.isDelim(EXCLAMATIONMARK) === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value;
    }
    var name = "Declaration";
    var walkContext = "declaration";
    var structure = {
      important: [Boolean, String],
      property: String,
      value: ["Value", "Raw"]
    };
    function parse() {
      const start = this.tokenStart;
      const startToken = this.tokenIndex;
      const property = readProperty.call(this);
      const customProperty = names.isCustomProperty(property);
      const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
      const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
      let important = false;
      let value;
      this.skipSC();
      this.eat(types.Colon);
      const valueStart = this.tokenIndex;
      if (!customProperty) {
        this.skipSC();
      }
      if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
      } else {
        value = consumeRaw.call(this, this.tokenIndex);
      }
      if (customProperty && value.type === "Value" && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === types.WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      if (this.isDelim(EXCLAMATIONMARK)) {
        important = getImportant.call(this);
        this.skipSC();
      }
      if (this.eof === false && this.tokenType !== types.Semicolon && this.isBalanceEdge(startToken) === false) {
        this.error();
      }
      return {
        type: "Declaration",
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
      };
    }
    function generate(node) {
      this.token(types.Ident, node.property);
      this.token(types.Colon, ":");
      this.node(node.value);
      if (node.important) {
        this.token(types.Delim, "!");
        this.token(types.Ident, node.important === true ? "important" : node.important);
      }
    }
    function readProperty() {
      const start = this.tokenStart;
      if (this.tokenType === types.Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
          case ASTERISK:
          case DOLLARSIGN:
          case PLUSSIGN:
          case NUMBERSIGN:
          case AMPERSAND:
            this.next();
            break;
          // TODO: not sure we should support this hack
          case SOLIDUS:
            this.next();
            if (this.isDelim(SOLIDUS)) {
              this.next();
            }
            break;
        }
      }
      if (this.tokenType === types.Hash) {
        this.eat(types.Hash);
      } else {
        this.eat(types.Ident);
      }
      return this.substrToCursor(start);
    }
    function getImportant() {
      this.eat(types.Delim);
      this.skipSC();
      const important = this.consume(types.Ident);
      return important === "important" ? true : important;
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs
var require_DeclarationList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var AMPERSAND = 38;
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    var name = "DeclarationList";
    var structure = {
      children: [[
        "Declaration",
        "Atrule",
        "Rule"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
          case types.Comment:
          case types.Semicolon:
            this.next();
            break;
          case types.AtKeyword:
            children.push(this.parseWithFallback(this.Atrule.bind(this, true), consumeRaw));
            break;
          default:
            if (this.isDelim(AMPERSAND)) {
              children.push(this.parseWithFallback(this.Rule, consumeRaw));
            } else {
              children.push(this.parseWithFallback(this.Declaration, consumeRaw));
            }
        }
      }
      return {
        type: "DeclarationList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Dimension.cjs
var require_Dimension = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Dimension.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Dimension";
    var structure = {
      value: String,
      unit: String
    };
    function parse() {
      const start = this.tokenStart;
      const value = this.consumeNumber(types.Dimension);
      return {
        type: "Dimension",
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
      };
    }
    function generate(node) {
      this.token(types.Dimension, node.value + node.unit);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Function.cjs
var require_Function = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Function.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Function";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      const name2 = this.consumeFunctionName();
      const nameLowerCase = name2.toLowerCase();
      let children;
      children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Function",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Hash.cjs
var require_Hash = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Hash.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var xxx = "XXX";
    var name = "Hash";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "Hash",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Hash, "#" + node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.xxx = xxx;
  }
});

// node_modules/css-tree/cjs/syntax/node/Identifier.cjs
var require_Identifier = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Identifier.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Identifier";
    var structure = {
      name: String
    };
    function parse() {
      return {
        type: "Identifier",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/IdSelector.cjs
var require_IdSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/IdSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "IdSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "IdSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Delim, "#" + node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs
var require_MediaFeature = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "MediaFeature";
    var structure = {
      name: String,
      value: ["Identifier", "Number", "Dimension", "Ratio", null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let value = null;
      this.eat(types.LeftParenthesis);
      this.skipSC();
      name2 = this.consume(types.Ident);
      this.skipSC();
      if (this.tokenType !== types.RightParenthesis) {
        this.eat(types.Colon);
        this.skipSC();
        switch (this.tokenType) {
          case types.Number:
            if (this.lookupNonWSType(1) === types.Delim) {
              value = this.Ratio();
            } else {
              value = this.Number();
            }
            break;
          case types.Dimension:
            value = this.Dimension();
            break;
          case types.Ident:
            value = this.Identifier();
            break;
          default:
            this.error("Number, dimension, ratio or identifier is expected");
        }
        this.skipSC();
      }
      this.eat(types.RightParenthesis);
      return {
        type: "MediaFeature",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        value
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.token(types.Ident, node.name);
      if (node.value !== null) {
        this.token(types.Colon, ":");
        this.node(node.value);
      }
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs
var require_MediaQuery = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "MediaQuery";
    var structure = {
      children: [[
        "Identifier",
        "MediaFeature",
        "WhiteSpace"
      ]]
    };
    function parse() {
      const children = this.createList();
      let child = null;
      this.skipSC();
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.MediaFeature();
              break;
            default:
              break scan;
          }
          children.push(child);
        }
      if (child === null) {
        this.error("Identifier or parenthesis is expected");
      }
      return {
        type: "MediaQuery",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs
var require_MediaQueryList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "MediaQueryList";
    var structure = {
      children: [[
        "MediaQuery"
      ]]
    };
    function parse() {
      const children = this.createList();
      this.skipSC();
      while (!this.eof) {
        children.push(this.MediaQuery());
        if (this.tokenType !== types.Comma) {
          break;
        }
        this.next();
      }
      return {
        type: "MediaQueryList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs
var require_NestingSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/NestingSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var AMPERSAND = 38;
    var name = "NestingSelector";
    var structure = {};
    function parse() {
      const start = this.tokenStart;
      this.eatDelim(AMPERSAND);
      return {
        type: "NestingSelector",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.Delim, "&");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Nth.cjs
var require_Nth = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Nth.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Nth";
    var structure = {
      nth: ["AnPlusB", "Identifier"],
      selector: ["SelectorList", null]
    };
    function parse() {
      this.skipSC();
      const start = this.tokenStart;
      let end = start;
      let selector = null;
      let nth;
      if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
        nth = this.Identifier();
      } else {
        nth = this.AnPlusB();
      }
      end = this.tokenStart;
      this.skipSC();
      if (this.lookupValue(0, "of")) {
        this.next();
        selector = this.SelectorList();
        end = this.tokenStart;
      }
      return {
        type: "Nth",
        loc: this.getLocation(start, end),
        nth,
        selector
      };
    }
    function generate(node) {
      this.node(node.nth);
      if (node.selector !== null) {
        this.token(types.Ident, "of");
        this.node(node.selector);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Number.cjs
var require_Number = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Number.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Number";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Number",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(types.Number)
      };
    }
    function generate(node) {
      this.token(types.Number, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Operator.cjs
var require_Operator = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Operator.cjs"(exports2) {
    "use strict";
    var name = "Operator";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.next();
      return {
        type: "Operator",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Parentheses.cjs
var require_Parentheses = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Parentheses.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Parentheses";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftParenthesis);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Parentheses",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Percentage.cjs
var require_Percentage = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Percentage.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "Percentage";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Percentage",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(types.Percentage)
      };
    }
    function generate(node) {
      this.token(types.Percentage, node.value + "%");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs
var require_PseudoClassSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "PseudoClassSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(this.tokenIndex, null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoClassSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs
var require_PseudoElementSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "PseudoElementSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(this.tokenIndex, null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoElementSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Ratio.cjs
var require_Ratio = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Ratio.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    function consumeNumber() {
      this.skipSC();
      const value = this.consume(types.Number);
      for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
          this.error("Unsigned number is expected", this.tokenStart - value.length + i);
        }
      }
      if (Number(value) === 0) {
        this.error("Zero number is not allowed", this.tokenStart - value.length);
      }
      return value;
    }
    var name = "Ratio";
    var structure = {
      left: String,
      right: String
    };
    function parse() {
      const start = this.tokenStart;
      const left = consumeNumber.call(this);
      let right;
      this.skipSC();
      this.eatDelim(SOLIDUS);
      right = consumeNumber.call(this);
      return {
        type: "Ratio",
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
      };
    }
    function generate(node) {
      this.token(types.Number, node.left);
      this.token(types.Delim, "/");
      this.token(types.Number, node.right);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Raw.cjs
var require_Raw = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Raw.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    function getOffsetExcludeWS() {
      if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === types.WhiteSpace) {
          return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
        }
      }
      return this.tokenStart;
    }
    var name = "Raw";
    var structure = {
      value: String
    };
    function parse(startToken, consumeUntil, excludeWhiteSpace) {
      const startOffset = this.getTokenStart(startToken);
      let endOffset;
      this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
      if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
      } else {
        endOffset = this.tokenStart;
      }
      return {
        type: "Raw",
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Rule.cjs
var require_Rule = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Rule.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
    }
    function consumePrelude() {
      const prelude = this.SelectorList();
      if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== types.LeftCurlyBracket) {
        this.error();
      }
      return prelude;
    }
    var name = "Rule";
    var walkContext = "rule";
    var structure = {
      prelude: ["SelectorList", "Raw"],
      block: ["Block"]
    };
    function parse() {
      const startToken = this.tokenIndex;
      const startOffset = this.tokenStart;
      let prelude;
      let block;
      if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw);
      } else {
        prelude = consumeRaw.call(this, startToken);
      }
      block = this.Block(true);
      return {
        type: "Rule",
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
      };
    }
    function generate(node) {
      this.node(node.prelude);
      this.node(node.block);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/Selector.cjs
var require_Selector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Selector.cjs"(exports2) {
    "use strict";
    var name = "Selector";
    var structure = {
      children: [[
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator",
        "WhiteSpace"
      ]]
    };
    function parse() {
      const children = this.readSequence(this.scope.Selector);
      if (this.getFirstListNode(children) === null) {
        this.error("Selector is expected");
      }
      return {
        type: "Selector",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/SelectorList.cjs
var require_SelectorList = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/SelectorList.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var name = "SelectorList";
    var walkContext = "selector";
    var structure = {
      children: [[
        "Selector",
        "Raw"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        children.push(this.Selector());
        if (this.tokenType === types.Comma) {
          this.next();
          continue;
        }
        break;
      }
      return {
        type: "SelectorList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/utils/string.cjs
var require_string = __commonJS({
  "node_modules/css-tree/cjs/utils/string.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    function decode(str) {
      const len = str.length;
      const firstChar = str.charCodeAt(0);
      const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
      const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
      let decoded = "";
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str, apostrophe) {
      const quote = apostrophe ? "'" : '"';
      const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === quoteCode || code === REVERSE_SOLIDUS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return quote + encoded + quote;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/syntax/node/String.cjs
var require_String = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/String.cjs"(exports2) {
    "use strict";
    var string = require_string();
    var types = require_types2();
    var name = "String";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "String",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: string.decode(this.consume(types.String))
      };
    }
    function generate(node) {
      this.token(types.String, string.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs
var require_StyleSheet = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var EXCLAMATIONMARK = 33;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, false);
    }
    var name = "StyleSheet";
    var walkContext = "stylesheet";
    var structure = {
      children: [[
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.createList();
      let child;
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Comment:
            if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
              this.next();
              continue;
            }
            child = this.Comment();
            break;
          case types.CDO:
            child = this.CDO();
            break;
          case types.CDC:
            child = this.CDC();
            break;
          // CSS Syntax Module Level 3
          // 2.2 Error handling
          // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
          case types.AtKeyword:
            child = this.parseWithFallback(this.Atrule, consumeRaw);
            break;
          // Anything else starts a qualified rule ...
          default:
            child = this.parseWithFallback(this.Rule, consumeRaw);
        }
        children.push(child);
      }
      return {
        type: "StyleSheet",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs
var require_TypeSelector = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var ASTERISK = 42;
    var VERTICALLINE = 124;
    function eatIdentifierOrAsterisk() {
      if (this.tokenType !== types.Ident && this.isDelim(ASTERISK) === false) {
        this.error("Identifier or asterisk is expected");
      }
      this.next();
    }
    var name = "TypeSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      if (this.isDelim(VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      } else {
        eatIdentifierOrAsterisk.call(this);
        if (this.isDelim(VERTICALLINE)) {
          this.next();
          eatIdentifierOrAsterisk.call(this);
        }
      }
      return {
        type: "TypeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs
var require_UnicodeRange = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var charCodeDefinitions = require_char_code_definitions();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    function eatHexSequence(offset, allowDash) {
      let len = 0;
      for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && len !== 0) {
          eatHexSequence.call(this, offset + len + 1, false);
          return -1;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          this.error(
            allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
            pos
          );
        }
        if (++len > 6) {
          this.error("Too many hex digits", pos);
        }
      }
      this.next();
      return len;
    }
    function eatQuestionMarkSequence(max) {
      let count = 0;
      while (this.isDelim(QUESTIONMARK)) {
        if (++count > max) {
          this.error("Too many question marks");
        }
        this.next();
      }
    }
    function startsWith(code) {
      if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected");
      }
    }
    function scanUnicodeRange() {
      let hexLength = 0;
      switch (this.tokenType) {
        case types.Number:
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            break;
          }
          if (this.tokenType === types.Dimension || this.tokenType === types.Number) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            break;
          }
          break;
        case types.Dimension:
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        default:
          this.eatDelim(PLUSSIGN);
          if (this.tokenType === types.Ident) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            break;
          }
          if (this.isDelim(QUESTIONMARK)) {
            this.next();
            eatQuestionMarkSequence.call(this, 5);
            break;
          }
          this.error("Hex digit or question mark is expected");
      }
    }
    var name = "UnicodeRange";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eatIdent("u");
      scanUnicodeRange.call(this);
      return {
        type: "UnicodeRange",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/utils/url.cjs
var require_url = __commonJS({
  "node_modules/css-tree/cjs/utils/url.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var SPACE = 32;
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function decode(str) {
      const len = str.length;
      let start = 4;
      let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
      let decoded = "";
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
        start++;
      }
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
        end--;
      }
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return "url(" + encoded + ")";
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/syntax/node/Url.cjs
var require_Url = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Url.cjs"(exports2) {
    "use strict";
    var url = require_url();
    var string = require_string();
    var types = require_types2();
    var name = "Url";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let value;
      switch (this.tokenType) {
        case types.Url:
          value = url.decode(this.consume(types.Url));
          break;
        case types.Function:
          if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
            this.error("Function name must be `url`");
          }
          this.eat(types.Function);
          this.skipSC();
          value = string.decode(this.consume(types.String));
          this.skipSC();
          if (!this.eof) {
            this.eat(types.RightParenthesis);
          }
          break;
        default:
          this.error("Url or Function is expected");
      }
      return {
        type: "Url",
        loc: this.getLocation(start, this.tokenStart),
        value
      };
    }
    function generate(node) {
      this.token(types.Url, url.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/Value.cjs
var require_Value = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/Value.cjs"(exports2) {
    "use strict";
    var name = "Value";
    var structure = {
      children: [[]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.readSequence(this.scope.Value);
      return {
        type: "Value",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs
var require_WhiteSpace = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs"(exports2) {
    "use strict";
    var types = require_types2();
    var SPACE = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    });
    var name = "WhiteSpace";
    var structure = {
      value: String
    };
    function parse() {
      this.eat(types.WhiteSpace);
      return SPACE;
    }
    function generate(node) {
      this.token(types.WhiteSpace, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/css-tree/cjs/syntax/node/index.cjs
var require_node2 = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/index.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB();
    var Atrule = require_Atrule();
    var AtrulePrelude = require_AtrulePrelude();
    var AttributeSelector = require_AttributeSelector();
    var Block = require_Block();
    var Brackets = require_Brackets();
    var CDC = require_CDC();
    var CDO = require_CDO();
    var ClassSelector = require_ClassSelector();
    var Combinator = require_Combinator();
    var Comment = require_Comment();
    var Declaration = require_Declaration();
    var DeclarationList = require_DeclarationList();
    var Dimension = require_Dimension();
    var Function2 = require_Function();
    var Hash = require_Hash();
    var Identifier = require_Identifier();
    var IdSelector = require_IdSelector();
    var MediaFeature = require_MediaFeature();
    var MediaQuery = require_MediaQuery();
    var MediaQueryList = require_MediaQueryList();
    var NestingSelector = require_NestingSelector();
    var Nth = require_Nth();
    var Number$1 = require_Number();
    var Operator = require_Operator();
    var Parentheses = require_Parentheses();
    var Percentage = require_Percentage();
    var PseudoClassSelector = require_PseudoClassSelector();
    var PseudoElementSelector = require_PseudoElementSelector();
    var Ratio = require_Ratio();
    var Raw = require_Raw();
    var Rule = require_Rule();
    var Selector = require_Selector();
    var SelectorList = require_SelectorList();
    var String$1 = require_String();
    var StyleSheet = require_StyleSheet();
    var TypeSelector = require_TypeSelector();
    var UnicodeRange = require_UnicodeRange();
    var Url = require_Url();
    var Value = require_Value();
    var WhiteSpace = require_WhiteSpace();
    exports2.AnPlusB = AnPlusB;
    exports2.Atrule = Atrule;
    exports2.AtrulePrelude = AtrulePrelude;
    exports2.AttributeSelector = AttributeSelector;
    exports2.Block = Block;
    exports2.Brackets = Brackets;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.ClassSelector = ClassSelector;
    exports2.Combinator = Combinator;
    exports2.Comment = Comment;
    exports2.Declaration = Declaration;
    exports2.DeclarationList = DeclarationList;
    exports2.Dimension = Dimension;
    exports2.Function = Function2;
    exports2.Hash = Hash;
    exports2.Identifier = Identifier;
    exports2.IdSelector = IdSelector;
    exports2.MediaFeature = MediaFeature;
    exports2.MediaQuery = MediaQuery;
    exports2.MediaQueryList = MediaQueryList;
    exports2.NestingSelector = NestingSelector;
    exports2.Nth = Nth;
    exports2.Number = Number$1;
    exports2.Operator = Operator;
    exports2.Parentheses = Parentheses;
    exports2.Percentage = Percentage;
    exports2.PseudoClassSelector = PseudoClassSelector;
    exports2.PseudoElementSelector = PseudoElementSelector;
    exports2.Ratio = Ratio;
    exports2.Raw = Raw;
    exports2.Rule = Rule;
    exports2.Selector = Selector;
    exports2.SelectorList = SelectorList;
    exports2.String = String$1;
    exports2.StyleSheet = StyleSheet;
    exports2.TypeSelector = TypeSelector;
    exports2.UnicodeRange = UnicodeRange;
    exports2.Url = Url;
    exports2.Value = Value;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/css-tree/cjs/syntax/config/lexer.cjs
var require_lexer = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/lexer.cjs"(exports2, module2) {
    "use strict";
    var data = require_data();
    var index = require_node2();
    var lexerConfig = {
      generic: true,
      ...data,
      node: index
    };
    module2.exports = lexerConfig;
  }
});

// node_modules/css-tree/cjs/syntax/scope/default.cjs
var require_default = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/default.cjs"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var SOLIDUS = 47;
    var U = 117;
    function defaultRecognizer(context) {
      switch (this.tokenType) {
        case types.Hash:
          return this.Hash();
        case types.Comma:
          return this.Operator();
        case types.LeftParenthesis:
          return this.Parentheses(this.readSequence, context.recognizer);
        case types.LeftSquareBracket:
          return this.Brackets(this.readSequence, context.recognizer);
        case types.String:
          return this.String();
        case types.Dimension:
          return this.Dimension();
        case types.Percentage:
          return this.Percentage();
        case types.Number:
          return this.Number();
        case types.Function:
          return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
        case types.Url:
          return this.Url();
        case types.Ident:
          if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {
            return this.UnicodeRange();
          } else {
            return this.Identifier();
          }
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
            return this.Operator();
          }
          if (code === NUMBERSIGN) {
            this.error("Hex or identifier is expected", this.tokenStart + 1);
          }
          break;
        }
      }
    }
    module2.exports = defaultRecognizer;
  }
});

// node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs
var require_atrulePrelude = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default();
    var atrulePrelude = {
      getNode: _default
    };
    module2.exports = atrulePrelude;
  }
});

// node_modules/css-tree/cjs/syntax/scope/selector.cjs
var require_selector = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/selector.cjs"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    var GREATERTHANSIGN = 62;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function onWhiteSpace(next, children) {
      if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
        children.push({
          // FIXME: this.Combinator() should be used instead
          type: "Combinator",
          loc: null,
          name: " "
        });
      }
    }
    function getNode() {
      switch (this.tokenType) {
        case types.LeftSquareBracket:
          return this.AttributeSelector();
        case types.Hash:
          return this.IdSelector();
        case types.Colon:
          if (this.lookupType(1) === types.Colon) {
            return this.PseudoElementSelector();
          } else {
            return this.PseudoClassSelector();
          }
        case types.Ident:
          return this.TypeSelector();
        case types.Number:
        case types.Percentage:
          return this.Percentage();
        case types.Dimension:
          if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
            this.error("Identifier is expected", this.tokenStart + 1);
          }
          break;
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
            case SOLIDUS:
              return this.Combinator();
            case FULLSTOP:
              return this.ClassSelector();
            case ASTERISK:
            case VERTICALLINE:
              return this.TypeSelector();
            case NUMBERSIGN:
              return this.IdSelector();
            case AMPERSAND:
              return this.NestingSelector();
          }
          break;
        }
      }
    }
    var Selector = {
      onWhiteSpace,
      getNode
    };
    module2.exports = Selector;
  }
});

// node_modules/css-tree/cjs/syntax/function/expression.cjs
var require_expression = __commonJS({
  "node_modules/css-tree/cjs/syntax/function/expression.cjs"(exports2, module2) {
    "use strict";
    function expressionFn() {
      return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    module2.exports = expressionFn;
  }
});

// node_modules/css-tree/cjs/syntax/function/var.cjs
var require_var = __commonJS({
  "node_modules/css-tree/cjs/syntax/function/var.cjs"(exports2, module2) {
    "use strict";
    var types = require_types2();
    function varFn() {
      const children = this.createList();
      this.skipSC();
      children.push(this.Identifier());
      this.skipSC();
      if (this.tokenType === types.Comma) {
        children.push(this.Operator());
        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
        if (value.type === "Value" && value.children.isEmpty) {
          for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === types.WhiteSpace) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        children.push(value);
      }
      return children;
    }
    module2.exports = varFn;
  }
});

// node_modules/css-tree/cjs/syntax/scope/value.cjs
var require_value = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/value.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default();
    var expression = require_expression();
    var _var = require_var();
    function isPlusMinusOperator(node) {
      return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
    }
    var value = {
      getNode: _default,
      onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
          next.value = " " + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
          children.last.value += " ";
        }
      },
      "expression": expression,
      "var": _var
    };
    module2.exports = value;
  }
});

// node_modules/css-tree/cjs/syntax/scope/index.cjs
var require_scope = __commonJS({
  "node_modules/css-tree/cjs/syntax/scope/index.cjs"(exports2) {
    "use strict";
    var atrulePrelude = require_atrulePrelude();
    var selector = require_selector();
    var value = require_value();
    exports2.AtrulePrelude = atrulePrelude;
    exports2.Selector = selector;
    exports2.Value = value;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/font-face.cjs
var require_font_face = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/font-face.cjs"(exports2, module2) {
    "use strict";
    var fontFace = {
      parse: {
        prelude: null,
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = fontFace;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/import.cjs
var require_import = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/import.cjs"(exports2, module2) {
    "use strict";
    var types = require_types2();
    var importAtrule = {
      parse: {
        prelude() {
          const children = this.createList();
          this.skipSC();
          switch (this.tokenType) {
            case types.String:
              children.push(this.String());
              break;
            case types.Url:
            case types.Function:
              children.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          if (this.lookupNonWSType(0) === types.Ident || this.lookupNonWSType(0) === types.LeftParenthesis) {
            children.push(this.MediaQueryList());
          }
          return children;
        },
        block: null
      }
    };
    module2.exports = importAtrule;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/media.cjs
var require_media = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/media.cjs"(exports2, module2) {
    "use strict";
    var media = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block(isStyleBlock = false) {
          return this.Block(isStyleBlock);
        }
      }
    };
    module2.exports = media;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/nest.cjs
var require_nest = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/nest.cjs"(exports2, module2) {
    "use strict";
    var nest = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = nest;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/page.cjs
var require_page = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/page.cjs"(exports2, module2) {
    "use strict";
    var page = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = page;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/supports.cjs
var require_supports = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/supports.cjs"(exports2, module2) {
    "use strict";
    var types = require_types2();
    function consumeRaw() {
      return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    function parentheses() {
      this.skipSC();
      if (this.tokenType === types.Ident && this.lookupNonWSType(1) === types.Colon) {
        return this.createSingleNodeList(
          this.Declaration()
        );
      }
      return readSequence.call(this);
    }
    function readSequence() {
      const children = this.createList();
      let child;
      this.skipSC();
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Function:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          children.push(child);
        }
      return children;
    }
    var supports = {
      parse: {
        prelude() {
          const children = readSequence.call(this);
          if (this.getFirstListNode(children) === null) {
            this.error("Condition is expected");
          }
          return children;
        },
        block(isStyleBlock = false) {
          return this.Block(isStyleBlock);
        }
      }
    };
    module2.exports = supports;
  }
});

// node_modules/css-tree/cjs/syntax/atrule/index.cjs
var require_atrule = __commonJS({
  "node_modules/css-tree/cjs/syntax/atrule/index.cjs"(exports2, module2) {
    "use strict";
    var fontFace = require_font_face();
    var _import = require_import();
    var media = require_media();
    var nest = require_nest();
    var page = require_page();
    var supports = require_supports();
    var atrule = {
      "font-face": fontFace,
      "import": _import,
      media,
      nest,
      page,
      supports
    };
    module2.exports = atrule;
  }
});

// node_modules/css-tree/cjs/syntax/pseudo/index.cjs
var require_pseudo = __commonJS({
  "node_modules/css-tree/cjs/syntax/pseudo/index.cjs"(exports2, module2) {
    "use strict";
    var selectorList = {
      parse() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
    var selector = {
      parse() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    };
    var identList = {
      parse() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
    var nth = {
      parse() {
        return this.createSingleNodeList(
          this.Nth()
        );
      }
    };
    var pseudo = {
      "dir": identList,
      "has": selectorList,
      "lang": identList,
      "matches": selectorList,
      "is": selectorList,
      "-moz-any": selectorList,
      "-webkit-any": selectorList,
      "where": selectorList,
      "not": selectorList,
      "nth-child": nth,
      "nth-last-child": nth,
      "nth-last-of-type": nth,
      "nth-of-type": nth,
      "slotted": selector,
      "host": selector,
      "host-context": selector
    };
    module2.exports = pseudo;
  }
});

// node_modules/css-tree/cjs/syntax/node/index-parse.cjs
var require_index_parse = __commonJS({
  "node_modules/css-tree/cjs/syntax/node/index-parse.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB();
    var Atrule = require_Atrule();
    var AtrulePrelude = require_AtrulePrelude();
    var AttributeSelector = require_AttributeSelector();
    var Block = require_Block();
    var Brackets = require_Brackets();
    var CDC = require_CDC();
    var CDO = require_CDO();
    var ClassSelector = require_ClassSelector();
    var Combinator = require_Combinator();
    var Comment = require_Comment();
    var Declaration = require_Declaration();
    var DeclarationList = require_DeclarationList();
    var Dimension = require_Dimension();
    var Function2 = require_Function();
    var Hash = require_Hash();
    var Identifier = require_Identifier();
    var IdSelector = require_IdSelector();
    var MediaFeature = require_MediaFeature();
    var MediaQuery = require_MediaQuery();
    var MediaQueryList = require_MediaQueryList();
    var NestingSelector = require_NestingSelector();
    var Nth = require_Nth();
    var Number2 = require_Number();
    var Operator = require_Operator();
    var Parentheses = require_Parentheses();
    var Percentage = require_Percentage();
    var PseudoClassSelector = require_PseudoClassSelector();
    var PseudoElementSelector = require_PseudoElementSelector();
    var Ratio = require_Ratio();
    var Raw = require_Raw();
    var Rule = require_Rule();
    var Selector = require_Selector();
    var SelectorList = require_SelectorList();
    var String2 = require_String();
    var StyleSheet = require_StyleSheet();
    var TypeSelector = require_TypeSelector();
    var UnicodeRange = require_UnicodeRange();
    var Url = require_Url();
    var Value = require_Value();
    var WhiteSpace = require_WhiteSpace();
    exports2.AnPlusB = AnPlusB.parse;
    exports2.Atrule = Atrule.parse;
    exports2.AtrulePrelude = AtrulePrelude.parse;
    exports2.AttributeSelector = AttributeSelector.parse;
    exports2.Block = Block.parse;
    exports2.Brackets = Brackets.parse;
    exports2.CDC = CDC.parse;
    exports2.CDO = CDO.parse;
    exports2.ClassSelector = ClassSelector.parse;
    exports2.Combinator = Combinator.parse;
    exports2.Comment = Comment.parse;
    exports2.Declaration = Declaration.parse;
    exports2.DeclarationList = DeclarationList.parse;
    exports2.Dimension = Dimension.parse;
    exports2.Function = Function2.parse;
    exports2.Hash = Hash.parse;
    exports2.Identifier = Identifier.parse;
    exports2.IdSelector = IdSelector.parse;
    exports2.MediaFeature = MediaFeature.parse;
    exports2.MediaQuery = MediaQuery.parse;
    exports2.MediaQueryList = MediaQueryList.parse;
    exports2.NestingSelector = NestingSelector.parse;
    exports2.Nth = Nth.parse;
    exports2.Number = Number2.parse;
    exports2.Operator = Operator.parse;
    exports2.Parentheses = Parentheses.parse;
    exports2.Percentage = Percentage.parse;
    exports2.PseudoClassSelector = PseudoClassSelector.parse;
    exports2.PseudoElementSelector = PseudoElementSelector.parse;
    exports2.Ratio = Ratio.parse;
    exports2.Raw = Raw.parse;
    exports2.Rule = Rule.parse;
    exports2.Selector = Selector.parse;
    exports2.SelectorList = SelectorList.parse;
    exports2.String = String2.parse;
    exports2.StyleSheet = StyleSheet.parse;
    exports2.TypeSelector = TypeSelector.parse;
    exports2.UnicodeRange = UnicodeRange.parse;
    exports2.Url = Url.parse;
    exports2.Value = Value.parse;
    exports2.WhiteSpace = WhiteSpace.parse;
  }
});

// node_modules/css-tree/cjs/syntax/config/parser.cjs
var require_parser2 = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/parser.cjs"(exports2, module2) {
    "use strict";
    var index = require_scope();
    var index$1 = require_atrule();
    var index$2 = require_pseudo();
    var indexParse = require_index_parse();
    var config = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude(options) {
          return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      scope: index,
      atrule: index$1,
      pseudo: index$2,
      node: indexParse
    };
    module2.exports = config;
  }
});

// node_modules/css-tree/cjs/syntax/config/walker.cjs
var require_walker = __commonJS({
  "node_modules/css-tree/cjs/syntax/config/walker.cjs"(exports2, module2) {
    "use strict";
    var index = require_node2();
    var config = {
      node: index
    };
    module2.exports = config;
  }
});

// node_modules/css-tree/cjs/syntax/index.cjs
var require_syntax = __commonJS({
  "node_modules/css-tree/cjs/syntax/index.cjs"(exports2, module2) {
    "use strict";
    var create = require_create5();
    var lexer = require_lexer();
    var parser = require_parser2();
    var walker = require_walker();
    var syntax = create({
      ...lexer,
      ...parser,
      ...walker
    });
    module2.exports = syntax;
  }
});

// node_modules/css-tree/package.json
var require_package = __commonJS({
  "node_modules/css-tree/package.json"(exports2, module2) {
    module2.exports = {
      name: "css-tree",
      version: "2.3.1",
      description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
      author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
      license: "MIT",
      repository: "csstree/csstree",
      keywords: [
        "css",
        "ast",
        "tokenizer",
        "parser",
        "walker",
        "lexer",
        "generator",
        "utils",
        "syntax",
        "validation"
      ],
      type: "module",
      module: "./lib/index.js",
      main: "./cjs/index.cjs",
      exports: {
        ".": {
          import: "./lib/index.js",
          require: "./cjs/index.cjs"
        },
        "./dist/*": "./dist/*.js",
        "./package.json": "./package.json",
        "./tokenizer": {
          import: "./lib/tokenizer/index.js",
          require: "./cjs/tokenizer/index.cjs"
        },
        "./parser": {
          import: "./lib/parser/index.js",
          require: "./cjs/parser/index.cjs"
        },
        "./selector-parser": {
          import: "./lib/parser/parse-selector.js",
          require: "./cjs/parser/parse-selector.cjs"
        },
        "./generator": {
          import: "./lib/generator/index.js",
          require: "./cjs/generator/index.cjs"
        },
        "./walker": {
          import: "./lib/walker/index.js",
          require: "./cjs/walker/index.cjs"
        },
        "./convertor": {
          import: "./lib/convertor/index.js",
          require: "./cjs/convertor/index.cjs"
        },
        "./lexer": {
          import: "./lib/lexer/index.js",
          require: "./cjs/lexer/index.cjs"
        },
        "./definition-syntax": {
          import: "./lib/definition-syntax/index.js",
          require: "./cjs/definition-syntax/index.cjs"
        },
        "./definition-syntax-data": {
          import: "./lib/data.js",
          require: "./cjs/data.cjs"
        },
        "./definition-syntax-data-patch": {
          import: "./lib/data-patch.js",
          require: "./cjs/data-patch.cjs"
        },
        "./utils": {
          import: "./lib/utils/index.js",
          require: "./cjs/utils/index.cjs"
        }
      },
      browser: {
        "./cjs/data.cjs": "./dist/data.cjs",
        "./cjs/version.cjs": "./dist/version.cjs",
        "./lib/data.js": "./dist/data.js",
        "./lib/version.js": "./dist/version.js"
      },
      unpkg: "dist/csstree.esm.js",
      jsdelivr: "dist/csstree.esm.js",
      scripts: {
        watch: "npm run build -- --watch",
        build: "npm run bundle && npm run esm-to-cjs --",
        "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
        bundle: "node scripts/bundle",
        "bundle-and-test": "npm run bundle && npm run test:dist",
        "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
        "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
        lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
        "lint-and-test": "npm run lint && npm test",
        "update:docs": "node scripts/update-docs",
        "review:syntax-patch": "node scripts/review-syntax-patch",
        test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
        "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
        "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
        coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
        prepublishOnly: "npm run lint-and-test && npm run build-and-test",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
      },
      dependencies: {
        "mdn-data": "2.0.30",
        "source-map-js": "^1.0.1"
      },
      devDependencies: {
        c8: "^7.12.0",
        clap: "^2.0.1",
        esbuild: "^0.14.53",
        eslint: "^8.4.1",
        "json-to-ast": "^2.1.0",
        mocha: "^9.2.2",
        rollup: "^2.68.0"
      },
      engines: {
        node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0"
      },
      files: [
        "data",
        "dist",
        "cjs",
        "!cjs/__tests",
        "lib",
        "!lib/__tests"
      ]
    };
  }
});

// node_modules/css-tree/cjs/version.cjs
var require_version = __commonJS({
  "node_modules/css-tree/cjs/version.cjs"(exports2) {
    "use strict";
    var { version } = require_package();
    exports2.version = version;
  }
});

// node_modules/css-tree/cjs/definition-syntax/index.cjs
var require_definition_syntax = __commonJS({
  "node_modules/css-tree/cjs/definition-syntax/index.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError2();
    var generate = require_generate();
    var parse = require_parse3();
    var walk = require_walk();
    exports2.SyntaxError = SyntaxError2.SyntaxError;
    exports2.generate = generate.generate;
    exports2.parse = parse.parse;
    exports2.walk = walk.walk;
  }
});

// node_modules/css-tree/cjs/utils/clone.cjs
var require_clone = __commonJS({
  "node_modules/css-tree/cjs/utils/clone.cjs"(exports2) {
    "use strict";
    var List = require_List();
    function clone(node) {
      const result = {};
      for (const key in node) {
        let value = node[key];
        if (value) {
          if (Array.isArray(value) || value instanceof List.List) {
            value = value.map(clone);
          } else if (value.constructor === Object) {
            value = clone(value);
          }
        }
        result[key] = value;
      }
      return result;
    }
    exports2.clone = clone;
  }
});

// node_modules/css-tree/cjs/utils/ident.cjs
var require_ident = __commonJS({
  "node_modules/css-tree/cjs/utils/ident.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions();
    var utils = require_utils();
    var REVERSE_SOLIDUS = 92;
    function decode(str) {
      const end = str.length - 1;
      let decoded = "";
      for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      if (str.length === 1 && str.charCodeAt(0) === 45) {
        return "\\-";
      }
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (
          // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
          // Note: Do not compare with 0x0001 since 0x0000 is precessed before
          code <= 31 || code === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
          code >= 48 && code <= 57 && // If the character is the first character ...
          (i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
          i === 1 && str.charCodeAt(0) === 45)
        ) {
          encoded += "\\" + code.toString(16) + " ";
          continue;
        }
        if (charCodeDefinitions.isName(code)) {
          encoded += str.charAt(i);
        } else {
          encoded += "\\" + str.charAt(i);
        }
      }
      return encoded;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/css-tree/cjs/index.cjs
var require_cjs = __commonJS({
  "node_modules/css-tree/cjs/index.cjs"(exports2) {
    "use strict";
    var index$1 = require_syntax();
    var version = require_version();
    var create = require_create5();
    var List = require_List();
    var Lexer = require_Lexer();
    var index = require_definition_syntax();
    var clone = require_clone();
    var names$1 = require_names2();
    var ident = require_ident();
    var string = require_string();
    var url = require_url();
    var types = require_types2();
    var names = require_names();
    var TokenStream = require_TokenStream();
    var {
      tokenize,
      parse,
      generate,
      lexer,
      createLexer,
      walk,
      find,
      findLast,
      findAll,
      toPlainObject,
      fromPlainObject,
      fork
    } = index$1;
    exports2.version = version.version;
    exports2.createSyntax = create;
    exports2.List = List.List;
    exports2.Lexer = Lexer.Lexer;
    exports2.definitionSyntax = index;
    exports2.clone = clone.clone;
    exports2.isCustomProperty = names$1.isCustomProperty;
    exports2.keyword = names$1.keyword;
    exports2.property = names$1.property;
    exports2.vendorPrefix = names$1.vendorPrefix;
    exports2.ident = ident;
    exports2.string = string;
    exports2.url = url;
    exports2.tokenTypes = types;
    exports2.tokenNames = names;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.createLexer = createLexer;
    exports2.find = find;
    exports2.findAll = findAll;
    exports2.findLast = findLast;
    exports2.fork = fork;
    exports2.fromPlainObject = fromPlainObject;
    exports2.generate = generate;
    exports2.lexer = lexer;
    exports2.parse = parse;
    exports2.toPlainObject = toPlainObject;
    exports2.tokenize = tokenize;
    exports2.walk = walk;
  }
});

// node_modules/csso/package.json
var require_package2 = __commonJS({
  "node_modules/csso/package.json"(exports2, module2) {
    module2.exports = {
      name: "csso",
      version: "5.0.5",
      description: "CSS minifier with structural optimisations",
      author: "Sergey Kryzhanovsky <skryzhanovsky@ya.ru> (https://github.com/afelix)",
      maintainers: [
        {
          name: "Roman Dvornov",
          email: "rdvornov@gmail.com",
          "github-username": "lahmatiy"
        }
      ],
      repository: "css/csso",
      license: "MIT",
      keywords: [
        "css",
        "compress",
        "minifier",
        "minify",
        "optimise",
        "optimisation",
        "csstree"
      ],
      type: "module",
      unpkg: "dist/csso.esm.js",
      jsdelivr: "dist/csso.esm.js",
      browser: {
        "./cjs/version.cjs": "./dist/version.cjs",
        "./lib/version.js": "./dist/version.js"
      },
      main: "./cjs/index.cjs",
      module: "./lib/index.js",
      exports: {
        ".": {
          import: "./lib/index.js",
          require: "./cjs/index.cjs"
        },
        "./syntax": {
          import: "./lib/syntax.js",
          require: "./cjs/syntax.cjs"
        },
        "./dist/*": "./dist/*.js",
        "./package.json": "./package.json"
      },
      scripts: {
        test: "mocha test --reporter ${REPORTER:-progress}",
        "test:cjs": "mocha cjs-test --reporter ${REPORTER:-progress}",
        "test:dist": "mocha dist/test --reporter ${REPORTER:-progress}",
        lint: "eslint lib scripts test",
        "lint-and-test": "npm run lint && npm test",
        build: "npm run bundle && npm run esm-to-cjs",
        "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
        bundle: "node scripts/bundle",
        "bundle-and-test": "npm run bundle && npm run test:dist",
        "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
        "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
        coverage: "c8 --reporter=lcovonly npm test",
        prepublishOnly: "npm run lint-and-test && npm run build-and-test",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/csso --stat -o /dev/null"
      },
      dependencies: {
        "css-tree": "~2.2.0"
      },
      devDependencies: {
        c8: "^7.10.0",
        esbuild: "^0.14.54",
        eslint: "^7.24.0",
        mocha: "^9.2.2",
        rollup: "^2.60.2",
        "source-map-js": "^1.0.1"
      },
      engines: {
        node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        npm: ">=7.0.0"
      },
      files: [
        "dist",
        "!dist/test",
        "cjs",
        "lib"
      ]
    };
  }
});

// node_modules/csso/cjs/version.cjs
var require_version2 = __commonJS({
  "node_modules/csso/cjs/version.cjs"(exports2) {
    "use strict";
    var { version } = require_package2();
    exports2.version = version;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/types.cjs
var require_types3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/types.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    var Ident = 1;
    var Function2 = 2;
    var AtKeyword = 3;
    var Hash = 4;
    var String2 = 5;
    var BadString = 6;
    var Url = 7;
    var BadUrl = 8;
    var Delim = 9;
    var Number2 = 10;
    var Percentage = 11;
    var Dimension = 12;
    var WhiteSpace = 13;
    var CDO = 14;
    var CDC = 15;
    var Colon = 16;
    var Semicolon = 17;
    var Comma = 18;
    var LeftSquareBracket = 19;
    var RightSquareBracket = 20;
    var LeftParenthesis = 21;
    var RightParenthesis = 22;
    var LeftCurlyBracket = 23;
    var RightCurlyBracket = 24;
    var Comment = 25;
    exports2.AtKeyword = AtKeyword;
    exports2.BadString = BadString;
    exports2.BadUrl = BadUrl;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.Colon = Colon;
    exports2.Comma = Comma;
    exports2.Comment = Comment;
    exports2.Delim = Delim;
    exports2.Dimension = Dimension;
    exports2.EOF = EOF;
    exports2.Function = Function2;
    exports2.Hash = Hash;
    exports2.Ident = Ident;
    exports2.LeftCurlyBracket = LeftCurlyBracket;
    exports2.LeftParenthesis = LeftParenthesis;
    exports2.LeftSquareBracket = LeftSquareBracket;
    exports2.Number = Number2;
    exports2.Percentage = Percentage;
    exports2.RightCurlyBracket = RightCurlyBracket;
    exports2.RightParenthesis = RightParenthesis;
    exports2.RightSquareBracket = RightSquareBracket;
    exports2.Semicolon = Semicolon;
    exports2.String = String2;
    exports2.Url = Url;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs
var require_char_code_definitions2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/char-code-definitions.cjs"(exports2) {
    "use strict";
    var EOF = 0;
    function isDigit(code) {
      return code >= 48 && code <= 57;
    }
    function isHexDigit(code) {
      return isDigit(code) || // 0 .. 9
      code >= 65 && code <= 70 || // A .. F
      code >= 97 && code <= 102;
    }
    function isUppercaseLetter(code) {
      return code >= 65 && code <= 90;
    }
    function isLowercaseLetter(code) {
      return code >= 97 && code <= 122;
    }
    function isLetter(code) {
      return isUppercaseLetter(code) || isLowercaseLetter(code);
    }
    function isNonAscii(code) {
      return code >= 128;
    }
    function isNameStart(code) {
      return isLetter(code) || isNonAscii(code) || code === 95;
    }
    function isName(code) {
      return isNameStart(code) || isDigit(code) || code === 45;
    }
    function isNonPrintable(code) {
      return code >= 0 && code <= 8 || code === 11 || code >= 14 && code <= 31 || code === 127;
    }
    function isNewline(code) {
      return code === 10 || code === 13 || code === 12;
    }
    function isWhiteSpace(code) {
      return isNewline(code) || code === 32 || code === 9;
    }
    function isValidEscape(first, second) {
      if (first !== 92) {
        return false;
      }
      if (isNewline(second) || second === EOF) {
        return false;
      }
      return true;
    }
    function isIdentifierStart(first, second, third) {
      if (first === 45) {
        return isNameStart(second) || second === 45 || isValidEscape(second, third);
      }
      if (isNameStart(first)) {
        return true;
      }
      if (first === 92) {
        return isValidEscape(first, second);
      }
      return false;
    }
    function isNumberStart(first, second, third) {
      if (first === 43 || first === 45) {
        if (isDigit(second)) {
          return 2;
        }
        return second === 46 && isDigit(third) ? 3 : 0;
      }
      if (first === 46) {
        return isDigit(second) ? 2 : 0;
      }
      if (isDigit(first)) {
        return 1;
      }
      return 0;
    }
    function isBOM(code) {
      if (code === 65279) {
        return 1;
      }
      if (code === 65534) {
        return 1;
      }
      return 0;
    }
    var CATEGORY = new Array(128);
    var EofCategory = 128;
    var WhiteSpaceCategory = 130;
    var DigitCategory = 131;
    var NameStartCategory = 132;
    var NonPrintableCategory = 133;
    for (let i = 0; i < CATEGORY.length; i++) {
      CATEGORY[i] = isWhiteSpace(i) && WhiteSpaceCategory || isDigit(i) && DigitCategory || isNameStart(i) && NameStartCategory || isNonPrintable(i) && NonPrintableCategory || i || EofCategory;
    }
    function charCodeCategory(code) {
      return code < 128 ? CATEGORY[code] : NameStartCategory;
    }
    exports2.DigitCategory = DigitCategory;
    exports2.EofCategory = EofCategory;
    exports2.NameStartCategory = NameStartCategory;
    exports2.NonPrintableCategory = NonPrintableCategory;
    exports2.WhiteSpaceCategory = WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeCategory;
    exports2.isBOM = isBOM;
    exports2.isDigit = isDigit;
    exports2.isHexDigit = isHexDigit;
    exports2.isIdentifierStart = isIdentifierStart;
    exports2.isLetter = isLetter;
    exports2.isLowercaseLetter = isLowercaseLetter;
    exports2.isName = isName;
    exports2.isNameStart = isNameStart;
    exports2.isNewline = isNewline;
    exports2.isNonAscii = isNonAscii;
    exports2.isNonPrintable = isNonPrintable;
    exports2.isNumberStart = isNumberStart;
    exports2.isUppercaseLetter = isUppercaseLetter;
    exports2.isValidEscape = isValidEscape;
    exports2.isWhiteSpace = isWhiteSpace;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/utils.cjs
var require_utils2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/utils.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    function getCharCode(source, offset) {
      return offset < source.length ? source.charCodeAt(offset) : 0;
    }
    function getNewlineLength(source, offset, code) {
      if (code === 13 && getCharCode(source, offset + 1) === 10) {
        return 2;
      }
      return 1;
    }
    function cmpChar(testStr, offset, referenceCode) {
      let code = testStr.charCodeAt(offset);
      if (charCodeDefinitions.isUppercaseLetter(code)) {
        code = code | 32;
      }
      return code === referenceCode;
    }
    function cmpStr(testStr, start, end, referenceStr) {
      if (end - start !== referenceStr.length) {
        return false;
      }
      if (start < 0 || end > testStr.length) {
        return false;
      }
      for (let i = start; i < end; i++) {
        const referenceCode = referenceStr.charCodeAt(i - start);
        let testCode = testStr.charCodeAt(i);
        if (charCodeDefinitions.isUppercaseLetter(testCode)) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function findWhiteSpaceStart(source, offset) {
      for (; offset >= 0; offset--) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset + 1;
    }
    function findWhiteSpaceEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isWhiteSpace(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function findDecimalNumberEnd(source, offset) {
      for (; offset < source.length; offset++) {
        if (!charCodeDefinitions.isDigit(source.charCodeAt(offset))) {
          break;
        }
      }
      return offset;
    }
    function consumeEscaped(source, offset) {
      offset += 2;
      if (charCodeDefinitions.isHexDigit(getCharCode(source, offset - 1))) {
        for (const maxOffset = Math.min(source.length, offset + 5); offset < maxOffset; offset++) {
          if (!charCodeDefinitions.isHexDigit(getCharCode(source, offset))) {
            break;
          }
        }
        const code = getCharCode(source, offset);
        if (charCodeDefinitions.isWhiteSpace(code)) {
          offset += getNewlineLength(source, offset, code);
        }
      }
      return offset;
    }
    function consumeName(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (charCodeDefinitions.isName(code)) {
          continue;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset) - 1;
          continue;
        }
        break;
      }
      return offset;
    }
    function consumeNumber(source, offset) {
      let code = source.charCodeAt(offset);
      if (code === 43 || code === 45) {
        code = source.charCodeAt(offset += 1);
      }
      if (charCodeDefinitions.isDigit(code)) {
        offset = findDecimalNumberEnd(source, offset + 1);
        code = source.charCodeAt(offset);
      }
      if (code === 46 && charCodeDefinitions.isDigit(source.charCodeAt(offset + 1))) {
        offset += 2;
        offset = findDecimalNumberEnd(source, offset);
      }
      if (cmpChar(
        source,
        offset,
        101
        /* e */
      )) {
        let sign = 0;
        code = source.charCodeAt(offset + 1);
        if (code === 45 || code === 43) {
          sign = 1;
          code = source.charCodeAt(offset + 2);
        }
        if (charCodeDefinitions.isDigit(code)) {
          offset = findDecimalNumberEnd(source, offset + 1 + sign + 1);
        }
      }
      return offset;
    }
    function consumeBadUrlRemnants(source, offset) {
      for (; offset < source.length; offset++) {
        const code = source.charCodeAt(offset);
        if (code === 41) {
          offset++;
          break;
        }
        if (charCodeDefinitions.isValidEscape(code, getCharCode(source, offset + 1))) {
          offset = consumeEscaped(source, offset);
        }
      }
      return offset;
    }
    function decodeEscaped(escaped) {
      if (escaped.length === 1 && !charCodeDefinitions.isHexDigit(escaped.charCodeAt(0))) {
        return escaped[0];
      }
      let code = parseInt(escaped, 16);
      if (code === 0 || // If this number is zero,
      code >= 55296 && code <= 57343 || // or is for a surrogate,
      code > 1114111) {
        code = 65533;
      }
      return String.fromCodePoint(code);
    }
    exports2.cmpChar = cmpChar;
    exports2.cmpStr = cmpStr;
    exports2.consumeBadUrlRemnants = consumeBadUrlRemnants;
    exports2.consumeEscaped = consumeEscaped;
    exports2.consumeName = consumeName;
    exports2.consumeNumber = consumeNumber;
    exports2.decodeEscaped = decodeEscaped;
    exports2.findDecimalNumberEnd = findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = findWhiteSpaceStart;
    exports2.getNewlineLength = getNewlineLength;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/names.cjs
var require_names3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/names.cjs"(exports2, module2) {
    "use strict";
    var tokenNames = [
      "EOF-token",
      "ident-token",
      "function-token",
      "at-keyword-token",
      "hash-token",
      "string-token",
      "bad-string-token",
      "url-token",
      "bad-url-token",
      "delim-token",
      "number-token",
      "percentage-token",
      "dimension-token",
      "whitespace-token",
      "CDO-token",
      "CDC-token",
      "colon-token",
      "semicolon-token",
      "comma-token",
      "[-token",
      "]-token",
      "(-token",
      ")-token",
      "{-token",
      "}-token"
    ];
    module2.exports = tokenNames;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs
var require_adopt_buffer2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/adopt-buffer.cjs"(exports2) {
    "use strict";
    var MIN_SIZE = 16 * 1024;
    function adoptBuffer(buffer = null, size) {
      if (buffer === null || buffer.length < size) {
        return new Uint32Array(Math.max(size + 1024, MIN_SIZE));
      }
      return buffer;
    }
    exports2.adoptBuffer = adoptBuffer;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs
var require_OffsetToLocation2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/OffsetToLocation.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer2();
    var charCodeDefinitions = require_char_code_definitions2();
    var N = 10;
    var F = 12;
    var R = 13;
    function computeLinesAndColumns(host) {
      const source = host.source;
      const sourceLength = source.length;
      const startOffset = source.length > 0 ? charCodeDefinitions.isBOM(source.charCodeAt(0)) : 0;
      const lines = adoptBuffer.adoptBuffer(host.lines, sourceLength);
      const columns = adoptBuffer.adoptBuffer(host.columns, sourceLength);
      let line = host.startLine;
      let column = host.startColumn;
      for (let i = startOffset; i < sourceLength; i++) {
        const code = source.charCodeAt(i);
        lines[i] = line;
        columns[i] = column++;
        if (code === N || code === R || code === F) {
          if (code === R && i + 1 < sourceLength && source.charCodeAt(i + 1) === N) {
            i++;
            lines[i] = line;
            columns[i] = column;
          }
          line++;
          column = 1;
        }
      }
      lines[sourceLength] = line;
      columns[sourceLength] = column;
      host.lines = lines;
      host.columns = columns;
      host.computed = true;
    }
    var OffsetToLocation = class {
      constructor() {
        this.lines = null;
        this.columns = null;
        this.computed = false;
      }
      setSource(source, startOffset = 0, startLine = 1, startColumn = 1) {
        this.source = source;
        this.startOffset = startOffset;
        this.startLine = startLine;
        this.startColumn = startColumn;
        this.computed = false;
      }
      getLocation(offset, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          offset: this.startOffset + offset,
          line: this.lines[offset],
          column: this.columns[offset]
        };
      }
      getLocationRange(start, end, filename) {
        if (!this.computed) {
          computeLinesAndColumns(this);
        }
        return {
          source: filename,
          start: {
            offset: this.startOffset + start,
            line: this.lines[start],
            column: this.columns[start]
          },
          end: {
            offset: this.startOffset + end,
            line: this.lines[end],
            column: this.columns[end]
          }
        };
      }
    };
    exports2.OffsetToLocation = OffsetToLocation;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/TokenStream.cjs
var require_TokenStream2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/TokenStream.cjs"(exports2) {
    "use strict";
    var adoptBuffer = require_adopt_buffer2();
    var utils = require_utils2();
    var names = require_names3();
    var types = require_types3();
    var OFFSET_MASK = 16777215;
    var TYPE_SHIFT = 24;
    var balancePair = /* @__PURE__ */ new Map([
      [types.Function, types.RightParenthesis],
      [types.LeftParenthesis, types.RightParenthesis],
      [types.LeftSquareBracket, types.RightSquareBracket],
      [types.LeftCurlyBracket, types.RightCurlyBracket]
    ]);
    var TokenStream = class {
      constructor(source, tokenize) {
        this.setSource(source, tokenize);
      }
      reset() {
        this.eof = false;
        this.tokenIndex = -1;
        this.tokenType = 0;
        this.tokenStart = this.firstCharOffset;
        this.tokenEnd = this.firstCharOffset;
      }
      setSource(source = "", tokenize = () => {
      }) {
        source = String(source || "");
        const sourceLength = source.length;
        const offsetAndType = adoptBuffer.adoptBuffer(this.offsetAndType, source.length + 1);
        const balance = adoptBuffer.adoptBuffer(this.balance, source.length + 1);
        let tokenCount = 0;
        let balanceCloseType = 0;
        let balanceStart = 0;
        let firstCharOffset = -1;
        this.offsetAndType = null;
        this.balance = null;
        tokenize(source, (type, start, end) => {
          switch (type) {
            default:
              balance[tokenCount] = sourceLength;
              break;
            case balanceCloseType: {
              let balancePrev = balanceStart & OFFSET_MASK;
              balanceStart = balance[balancePrev];
              balanceCloseType = balanceStart >> TYPE_SHIFT;
              balance[tokenCount] = balancePrev;
              balance[balancePrev++] = tokenCount;
              for (; balancePrev < tokenCount; balancePrev++) {
                if (balance[balancePrev] === sourceLength) {
                  balance[balancePrev] = tokenCount;
                }
              }
              break;
            }
            case types.LeftParenthesis:
            case types.Function:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balance[tokenCount] = balanceStart;
              balanceCloseType = balancePair.get(type);
              balanceStart = balanceCloseType << TYPE_SHIFT | tokenCount;
              break;
          }
          offsetAndType[tokenCount++] = type << TYPE_SHIFT | end;
          if (firstCharOffset === -1) {
            firstCharOffset = start;
          }
        });
        offsetAndType[tokenCount] = types.EOF << TYPE_SHIFT | sourceLength;
        balance[tokenCount] = sourceLength;
        balance[sourceLength] = sourceLength;
        while (balanceStart !== 0) {
          const balancePrev = balanceStart & OFFSET_MASK;
          balanceStart = balance[balancePrev];
          balance[balancePrev] = sourceLength;
        }
        this.source = source;
        this.firstCharOffset = firstCharOffset === -1 ? 0 : firstCharOffset;
        this.tokenCount = tokenCount;
        this.offsetAndType = offsetAndType;
        this.balance = balance;
        this.reset();
        this.next();
      }
      lookupType(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset] >> TYPE_SHIFT;
        }
        return types.EOF;
      }
      lookupOffset(offset) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return this.offsetAndType[offset - 1] & OFFSET_MASK;
        }
        return this.source.length;
      }
      lookupValue(offset, referenceStr) {
        offset += this.tokenIndex;
        if (offset < this.tokenCount) {
          return utils.cmpStr(
            this.source,
            this.offsetAndType[offset - 1] & OFFSET_MASK,
            this.offsetAndType[offset] & OFFSET_MASK,
            referenceStr
          );
        }
        return false;
      }
      getTokenStart(tokenIndex) {
        if (tokenIndex === this.tokenIndex) {
          return this.tokenStart;
        }
        if (tokenIndex > 0) {
          return tokenIndex < this.tokenCount ? this.offsetAndType[tokenIndex - 1] & OFFSET_MASK : this.offsetAndType[this.tokenCount] & OFFSET_MASK;
        }
        return this.firstCharOffset;
      }
      substrToCursor(start) {
        return this.source.substring(start, this.tokenStart);
      }
      isBalanceEdge(pos) {
        return this.balance[this.tokenIndex] < pos;
      }
      isDelim(code, offset) {
        if (offset) {
          return this.lookupType(offset) === types.Delim && this.source.charCodeAt(this.lookupOffset(offset)) === code;
        }
        return this.tokenType === types.Delim && this.source.charCodeAt(this.tokenStart) === code;
      }
      skip(tokenCount) {
        let next = this.tokenIndex + tokenCount;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.offsetAndType[next - 1] & OFFSET_MASK;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.tokenIndex = this.tokenCount;
          this.next();
        }
      }
      next() {
        let next = this.tokenIndex + 1;
        if (next < this.tokenCount) {
          this.tokenIndex = next;
          this.tokenStart = this.tokenEnd;
          next = this.offsetAndType[next];
          this.tokenType = next >> TYPE_SHIFT;
          this.tokenEnd = next & OFFSET_MASK;
        } else {
          this.eof = true;
          this.tokenIndex = this.tokenCount;
          this.tokenType = types.EOF;
          this.tokenStart = this.tokenEnd = this.source.length;
        }
      }
      skipSC() {
        while (this.tokenType === types.WhiteSpace || this.tokenType === types.Comment) {
          this.next();
        }
      }
      skipUntilBalanced(startToken, stopConsume) {
        let cursor = startToken;
        let balanceEnd;
        let offset;
        loop:
          for (; cursor < this.tokenCount; cursor++) {
            balanceEnd = this.balance[cursor];
            if (balanceEnd < startToken) {
              break loop;
            }
            offset = cursor > 0 ? this.offsetAndType[cursor - 1] & OFFSET_MASK : this.firstCharOffset;
            switch (stopConsume(this.source.charCodeAt(offset))) {
              case 1:
                break loop;
              case 2:
                cursor++;
                break loop;
              default:
                if (this.balance[balanceEnd] === cursor) {
                  cursor = balanceEnd;
                }
            }
          }
        this.skip(cursor - this.tokenIndex);
      }
      forEachToken(fn) {
        for (let i = 0, offset = this.firstCharOffset; i < this.tokenCount; i++) {
          const start = offset;
          const item = this.offsetAndType[i];
          const end = item & OFFSET_MASK;
          const type = item >> TYPE_SHIFT;
          offset = end;
          fn(type, start, end, i);
        }
      }
      dump() {
        const tokens = new Array(this.tokenCount);
        this.forEachToken((type, start, end, index) => {
          tokens[index] = {
            idx: index,
            type: names[type],
            chunk: this.source.substring(start, end),
            balance: this.balance[index]
          };
        });
        return tokens;
      }
    };
    exports2.TokenStream = TokenStream;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/tokenizer/index.cjs
var require_tokenizer3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/tokenizer/index.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var charCodeDefinitions = require_char_code_definitions2();
    var utils = require_utils2();
    var names = require_names3();
    var OffsetToLocation = require_OffsetToLocation2();
    var TokenStream = require_TokenStream2();
    function tokenize(source, onToken) {
      function getCharCode(offset2) {
        return offset2 < sourceLength ? source.charCodeAt(offset2) : 0;
      }
      function consumeNumericToken() {
        offset = utils.consumeNumber(source, offset);
        if (charCodeDefinitions.isIdentifierStart(getCharCode(offset), getCharCode(offset + 1), getCharCode(offset + 2))) {
          type = types.Dimension;
          offset = utils.consumeName(source, offset);
          return;
        }
        if (getCharCode(offset) === 37) {
          type = types.Percentage;
          offset++;
          return;
        }
        type = types.Number;
      }
      function consumeIdentLikeToken() {
        const nameStartOffset = offset;
        offset = utils.consumeName(source, offset);
        if (utils.cmpStr(source, nameStartOffset, offset, "url") && getCharCode(offset) === 40) {
          offset = utils.findWhiteSpaceEnd(source, offset + 1);
          if (getCharCode(offset) === 34 || getCharCode(offset) === 39) {
            type = types.Function;
            offset = nameStartOffset + 4;
            return;
          }
          consumeUrlToken();
          return;
        }
        if (getCharCode(offset) === 40) {
          type = types.Function;
          offset++;
          return;
        }
        type = types.Ident;
      }
      function consumeStringToken(endingCodePoint) {
        if (!endingCodePoint) {
          endingCodePoint = getCharCode(offset++);
        }
        type = types.String;
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // ending code point
            case endingCodePoint:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <string-token>.
            // return;
            // newline
            case charCodeDefinitions.WhiteSpaceCategory:
              if (charCodeDefinitions.isNewline(code)) {
                offset += utils.getNewlineLength(source, offset, code);
                type = types.BadString;
                return;
              }
              break;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (offset === source.length - 1) {
                break;
              }
              const nextCode = getCharCode(offset + 1);
              if (charCodeDefinitions.isNewline(nextCode)) {
                offset += utils.getNewlineLength(source, offset + 1, nextCode);
              } else if (charCodeDefinitions.isValidEscape(code, nextCode)) {
                offset = utils.consumeEscaped(source, offset) - 1;
              }
              break;
          }
        }
      }
      function consumeUrlToken() {
        type = types.Url;
        offset = utils.findWhiteSpaceEnd(source, offset);
        for (; offset < source.length; offset++) {
          const code = source.charCodeAt(offset);
          switch (charCodeDefinitions.charCodeCategory(code)) {
            // U+0029 RIGHT PARENTHESIS ())
            case 41:
              offset++;
              return;
            // EOF
            // case EofCategory:
            // This is a parse error. Return the <url-token>.
            // return;
            // whitespace
            case charCodeDefinitions.WhiteSpaceCategory:
              offset = utils.findWhiteSpaceEnd(source, offset);
              if (getCharCode(offset) === 41 || offset >= source.length) {
                if (offset < source.length) {
                  offset++;
                }
                return;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+0022 QUOTATION MARK (")
            // U+0027 APOSTROPHE (')
            // U+0028 LEFT PARENTHESIS (()
            // non-printable code point
            case 34:
            case 39:
            case 40:
            case charCodeDefinitions.NonPrintableCategory:
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
            // U+005C REVERSE SOLIDUS (\)
            case 92:
              if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
                offset = utils.consumeEscaped(source, offset) - 1;
                break;
              }
              offset = utils.consumeBadUrlRemnants(source, offset);
              type = types.BadUrl;
              return;
          }
        }
      }
      source = String(source || "");
      const sourceLength = source.length;
      let start = charCodeDefinitions.isBOM(getCharCode(0));
      let offset = start;
      let type;
      while (offset < sourceLength) {
        const code = source.charCodeAt(offset);
        switch (charCodeDefinitions.charCodeCategory(code)) {
          // whitespace
          case charCodeDefinitions.WhiteSpaceCategory:
            type = types.WhiteSpace;
            offset = utils.findWhiteSpaceEnd(source, offset + 1);
            break;
          // U+0022 QUOTATION MARK (")
          case 34:
            consumeStringToken();
            break;
          // U+0023 NUMBER SIGN (#)
          case 35:
            if (charCodeDefinitions.isName(getCharCode(offset + 1)) || charCodeDefinitions.isValidEscape(getCharCode(offset + 1), getCharCode(offset + 2))) {
              type = types.Hash;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0027 APOSTROPHE (')
          case 39:
            consumeStringToken();
            break;
          // U+0028 LEFT PARENTHESIS (()
          case 40:
            type = types.LeftParenthesis;
            offset++;
            break;
          // U+0029 RIGHT PARENTHESIS ())
          case 41:
            type = types.RightParenthesis;
            offset++;
            break;
          // U+002B PLUS SIGN (+)
          case 43:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002C COMMA (,)
          case 44:
            type = types.Comma;
            offset++;
            break;
          // U+002D HYPHEN-MINUS (-)
          case 45:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              if (getCharCode(offset + 1) === 45 && getCharCode(offset + 2) === 62) {
                type = types.CDC;
                offset = offset + 3;
              } else {
                if (charCodeDefinitions.isIdentifierStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
                  consumeIdentLikeToken();
                } else {
                  type = types.Delim;
                  offset++;
                }
              }
            }
            break;
          // U+002E FULL STOP (.)
          case 46:
            if (charCodeDefinitions.isNumberStart(code, getCharCode(offset + 1), getCharCode(offset + 2))) {
              consumeNumericToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+002F SOLIDUS (/)
          case 47:
            if (getCharCode(offset + 1) === 42) {
              type = types.Comment;
              offset = source.indexOf("*/", offset + 2);
              offset = offset === -1 ? source.length : offset + 2;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+003A COLON (:)
          case 58:
            type = types.Colon;
            offset++;
            break;
          // U+003B SEMICOLON (;)
          case 59:
            type = types.Semicolon;
            offset++;
            break;
          // U+003C LESS-THAN SIGN (<)
          case 60:
            if (getCharCode(offset + 1) === 33 && getCharCode(offset + 2) === 45 && getCharCode(offset + 3) === 45) {
              type = types.CDO;
              offset = offset + 4;
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+0040 COMMERCIAL AT (@)
          case 64:
            if (charCodeDefinitions.isIdentifierStart(getCharCode(offset + 1), getCharCode(offset + 2), getCharCode(offset + 3))) {
              type = types.AtKeyword;
              offset = utils.consumeName(source, offset + 1);
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005B LEFT SQUARE BRACKET ([)
          case 91:
            type = types.LeftSquareBracket;
            offset++;
            break;
          // U+005C REVERSE SOLIDUS (\)
          case 92:
            if (charCodeDefinitions.isValidEscape(code, getCharCode(offset + 1))) {
              consumeIdentLikeToken();
            } else {
              type = types.Delim;
              offset++;
            }
            break;
          // U+005D RIGHT SQUARE BRACKET (])
          case 93:
            type = types.RightSquareBracket;
            offset++;
            break;
          // U+007B LEFT CURLY BRACKET ({)
          case 123:
            type = types.LeftCurlyBracket;
            offset++;
            break;
          // U+007D RIGHT CURLY BRACKET (})
          case 125:
            type = types.RightCurlyBracket;
            offset++;
            break;
          // digit
          case charCodeDefinitions.DigitCategory:
            consumeNumericToken();
            break;
          // name-start code point
          case charCodeDefinitions.NameStartCategory:
            consumeIdentLikeToken();
            break;
          // EOF
          // case EofCategory:
          // Return an <EOF-token>.
          // break;
          // anything else
          default:
            type = types.Delim;
            offset++;
        }
        onToken(type, start, start = offset);
      }
    }
    exports2.AtKeyword = types.AtKeyword;
    exports2.BadString = types.BadString;
    exports2.BadUrl = types.BadUrl;
    exports2.CDC = types.CDC;
    exports2.CDO = types.CDO;
    exports2.Colon = types.Colon;
    exports2.Comma = types.Comma;
    exports2.Comment = types.Comment;
    exports2.Delim = types.Delim;
    exports2.Dimension = types.Dimension;
    exports2.EOF = types.EOF;
    exports2.Function = types.Function;
    exports2.Hash = types.Hash;
    exports2.Ident = types.Ident;
    exports2.LeftCurlyBracket = types.LeftCurlyBracket;
    exports2.LeftParenthesis = types.LeftParenthesis;
    exports2.LeftSquareBracket = types.LeftSquareBracket;
    exports2.Number = types.Number;
    exports2.Percentage = types.Percentage;
    exports2.RightCurlyBracket = types.RightCurlyBracket;
    exports2.RightParenthesis = types.RightParenthesis;
    exports2.RightSquareBracket = types.RightSquareBracket;
    exports2.Semicolon = types.Semicolon;
    exports2.String = types.String;
    exports2.Url = types.Url;
    exports2.WhiteSpace = types.WhiteSpace;
    exports2.tokenTypes = types;
    exports2.DigitCategory = charCodeDefinitions.DigitCategory;
    exports2.EofCategory = charCodeDefinitions.EofCategory;
    exports2.NameStartCategory = charCodeDefinitions.NameStartCategory;
    exports2.NonPrintableCategory = charCodeDefinitions.NonPrintableCategory;
    exports2.WhiteSpaceCategory = charCodeDefinitions.WhiteSpaceCategory;
    exports2.charCodeCategory = charCodeDefinitions.charCodeCategory;
    exports2.isBOM = charCodeDefinitions.isBOM;
    exports2.isDigit = charCodeDefinitions.isDigit;
    exports2.isHexDigit = charCodeDefinitions.isHexDigit;
    exports2.isIdentifierStart = charCodeDefinitions.isIdentifierStart;
    exports2.isLetter = charCodeDefinitions.isLetter;
    exports2.isLowercaseLetter = charCodeDefinitions.isLowercaseLetter;
    exports2.isName = charCodeDefinitions.isName;
    exports2.isNameStart = charCodeDefinitions.isNameStart;
    exports2.isNewline = charCodeDefinitions.isNewline;
    exports2.isNonAscii = charCodeDefinitions.isNonAscii;
    exports2.isNonPrintable = charCodeDefinitions.isNonPrintable;
    exports2.isNumberStart = charCodeDefinitions.isNumberStart;
    exports2.isUppercaseLetter = charCodeDefinitions.isUppercaseLetter;
    exports2.isValidEscape = charCodeDefinitions.isValidEscape;
    exports2.isWhiteSpace = charCodeDefinitions.isWhiteSpace;
    exports2.cmpChar = utils.cmpChar;
    exports2.cmpStr = utils.cmpStr;
    exports2.consumeBadUrlRemnants = utils.consumeBadUrlRemnants;
    exports2.consumeEscaped = utils.consumeEscaped;
    exports2.consumeName = utils.consumeName;
    exports2.consumeNumber = utils.consumeNumber;
    exports2.decodeEscaped = utils.decodeEscaped;
    exports2.findDecimalNumberEnd = utils.findDecimalNumberEnd;
    exports2.findWhiteSpaceEnd = utils.findWhiteSpaceEnd;
    exports2.findWhiteSpaceStart = utils.findWhiteSpaceStart;
    exports2.getNewlineLength = utils.getNewlineLength;
    exports2.tokenNames = names;
    exports2.OffsetToLocation = OffsetToLocation.OffsetToLocation;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.tokenize = tokenize;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/List.cjs
var require_List2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/List.cjs"(exports2) {
    "use strict";
    var releasedCursors = null;
    var List = class _List {
      static createItem(data) {
        return {
          prev: null,
          next: null,
          data
        };
      }
      constructor() {
        this.head = null;
        this.tail = null;
        this.cursor = null;
      }
      createItem(data) {
        return _List.createItem(data);
      }
      // cursor helpers
      allocateCursor(prev, next) {
        let cursor;
        if (releasedCursors !== null) {
          cursor = releasedCursors;
          releasedCursors = releasedCursors.cursor;
          cursor.prev = prev;
          cursor.next = next;
          cursor.cursor = this.cursor;
        } else {
          cursor = {
            prev,
            next,
            cursor: this.cursor
          };
        }
        this.cursor = cursor;
        return cursor;
      }
      releaseCursor() {
        const { cursor } = this;
        this.cursor = cursor.cursor;
        cursor.prev = null;
        cursor.next = null;
        cursor.cursor = releasedCursors;
        releasedCursors = cursor;
      }
      updateCursors(prevOld, prevNew, nextOld, nextNew) {
        let { cursor } = this;
        while (cursor !== null) {
          if (cursor.prev === prevOld) {
            cursor.prev = prevNew;
          }
          if (cursor.next === nextOld) {
            cursor.next = nextNew;
          }
          cursor = cursor.cursor;
        }
      }
      *[Symbol.iterator]() {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          yield cursor.data;
        }
      }
      // getters
      get size() {
        let size = 0;
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          size++;
        }
        return size;
      }
      get isEmpty() {
        return this.head === null;
      }
      get first() {
        return this.head && this.head.data;
      }
      get last() {
        return this.tail && this.tail.data;
      }
      // convertors
      fromArray(array) {
        let cursor = null;
        this.head = null;
        for (let data of array) {
          const item = _List.createItem(data);
          if (cursor !== null) {
            cursor.next = item;
          } else {
            this.head = item;
          }
          item.prev = cursor;
          cursor = item;
        }
        this.tail = cursor;
        return this;
      }
      toArray() {
        return [...this];
      }
      toJSON() {
        return [...this];
      }
      // array-like methods
      forEach(fn, thisArg = this) {
        const cursor = this.allocateCursor(null, this.head);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      forEachRight(fn, thisArg = this) {
        const cursor = this.allocateCursor(this.tail, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          fn.call(thisArg, item.data, item, this);
        }
        this.releaseCursor();
      }
      reduce(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(null, this.head);
        let acc = initialValue;
        let item;
        while (cursor.next !== null) {
          item = cursor.next;
          cursor.next = item.next;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      reduceRight(fn, initialValue, thisArg = this) {
        let cursor = this.allocateCursor(this.tail, null);
        let acc = initialValue;
        let item;
        while (cursor.prev !== null) {
          item = cursor.prev;
          cursor.prev = item.prev;
          acc = fn.call(thisArg, acc, item.data, item, this);
        }
        this.releaseCursor();
        return acc;
      }
      some(fn, thisArg = this) {
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            return true;
          }
        }
        return false;
      }
      map(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          result.appendData(fn.call(thisArg, cursor.data, cursor, this));
        }
        return result;
      }
      filter(fn, thisArg = this) {
        const result = new _List();
        for (let cursor = this.head; cursor !== null; cursor = cursor.next) {
          if (fn.call(thisArg, cursor.data, cursor, this)) {
            result.appendData(cursor.data);
          }
        }
        return result;
      }
      nextUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(null, start);
        while (cursor.next !== null) {
          const item = cursor.next;
          cursor.next = item.next;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      prevUntil(start, fn, thisArg = this) {
        if (start === null) {
          return;
        }
        const cursor = this.allocateCursor(start, null);
        while (cursor.prev !== null) {
          const item = cursor.prev;
          cursor.prev = item.prev;
          if (fn.call(thisArg, item.data, item, this)) {
            break;
          }
        }
        this.releaseCursor();
      }
      // mutation
      clear() {
        this.head = null;
        this.tail = null;
      }
      copy() {
        const result = new _List();
        for (let data of this) {
          result.appendData(data);
        }
        return result;
      }
      prepend(item) {
        this.updateCursors(null, item, this.head, item);
        if (this.head !== null) {
          this.head.prev = item;
          item.next = this.head;
        } else {
          this.tail = item;
        }
        this.head = item;
        return this;
      }
      prependData(data) {
        return this.prepend(_List.createItem(data));
      }
      append(item) {
        return this.insert(item);
      }
      appendData(data) {
        return this.insert(_List.createItem(data));
      }
      insert(item, before = null) {
        if (before !== null) {
          this.updateCursors(before.prev, item, before, item);
          if (before.prev === null) {
            if (this.head !== before) {
              throw new Error("before doesn't belong to list");
            }
            this.head = item;
            before.prev = item;
            item.next = before;
            this.updateCursors(null, item);
          } else {
            before.prev.next = item;
            item.prev = before.prev;
            before.prev = item;
            item.next = before;
          }
        } else {
          this.updateCursors(this.tail, item, null, item);
          if (this.tail !== null) {
            this.tail.next = item;
            item.prev = this.tail;
          } else {
            this.head = item;
          }
          this.tail = item;
        }
        return this;
      }
      insertData(data, before) {
        return this.insert(_List.createItem(data), before);
      }
      remove(item) {
        this.updateCursors(item, item.prev, item, item.next);
        if (item.prev !== null) {
          item.prev.next = item.next;
        } else {
          if (this.head !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.head = item.next;
        }
        if (item.next !== null) {
          item.next.prev = item.prev;
        } else {
          if (this.tail !== item) {
            throw new Error("item doesn't belong to list");
          }
          this.tail = item.prev;
        }
        item.prev = null;
        item.next = null;
        return item;
      }
      push(data) {
        this.insert(_List.createItem(data));
      }
      pop() {
        return this.tail !== null ? this.remove(this.tail) : null;
      }
      unshift(data) {
        this.prepend(_List.createItem(data));
      }
      shift() {
        return this.head !== null ? this.remove(this.head) : null;
      }
      prependList(list) {
        return this.insertList(list, this.head);
      }
      appendList(list) {
        return this.insertList(list);
      }
      insertList(list, before) {
        if (list.head === null) {
          return this;
        }
        if (before !== void 0 && before !== null) {
          this.updateCursors(before.prev, list.tail, before, list.head);
          if (before.prev !== null) {
            before.prev.next = list.head;
            list.head.prev = before.prev;
          } else {
            this.head = list.head;
          }
          before.prev = list.tail;
          list.tail.next = before;
        } else {
          this.updateCursors(this.tail, list.tail, null, list.head);
          if (this.tail !== null) {
            this.tail.next = list.head;
            list.head.prev = this.tail;
          } else {
            this.head = list.head;
          }
          this.tail = list.tail;
        }
        list.head = null;
        list.tail = null;
        return this;
      }
      replace(oldItem, newItemOrList) {
        if ("head" in newItemOrList) {
          this.insertList(newItemOrList, oldItem);
        } else {
          this.insert(newItemOrList, oldItem);
        }
        this.remove(oldItem);
      }
    };
    exports2.List = List;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/create-custom-error.cjs
var require_create_custom_error2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/create-custom-error.cjs"(exports2) {
    "use strict";
    function createCustomError(name, message) {
      const error = Object.create(SyntaxError.prototype);
      const errorStack = new Error();
      return Object.assign(error, {
        name,
        message,
        get stack() {
          return (errorStack.stack || "").replace(/^(.+\n){1,3}/, `${name}: ${message}
`);
        }
      });
    }
    exports2.createCustomError = createCustomError;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/parser/SyntaxError.cjs
var require_SyntaxError3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/parser/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error2();
    var MAX_LINE_LENGTH = 100;
    var OFFSET_CORRECTION = 60;
    var TAB_REPLACEMENT = "    ";
    function sourceFragment({ source, line, column }, extraLines) {
      function processLines(start, end) {
        return lines.slice(start, end).map(
          (line2, idx) => String(start + idx + 1).padStart(maxNumLength) + " |" + line2
        ).join("\n");
      }
      const lines = source.split(/\r\n?|\n|\f/);
      const startLine = Math.max(1, line - extraLines) - 1;
      const endLine = Math.min(line + extraLines, lines.length + 1);
      const maxNumLength = Math.max(4, String(endLine).length) + 1;
      let cutLeft = 0;
      column += (TAB_REPLACEMENT.length - 1) * (lines[line - 1].substr(0, column - 1).match(/\t/g) || []).length;
      if (column > MAX_LINE_LENGTH) {
        cutLeft = column - OFFSET_CORRECTION + 3;
        column = OFFSET_CORRECTION - 2;
      }
      for (let i = startLine; i <= endLine; i++) {
        if (i >= 0 && i < lines.length) {
          lines[i] = lines[i].replace(/\t/g, TAB_REPLACEMENT);
          lines[i] = (cutLeft > 0 && lines[i].length > cutLeft ? "\u2026" : "") + lines[i].substr(cutLeft, MAX_LINE_LENGTH - 2) + (lines[i].length > cutLeft + MAX_LINE_LENGTH - 1 ? "\u2026" : "");
        }
      }
      return [
        processLines(startLine, line),
        new Array(column + maxNumLength + 2).join("-") + "^",
        processLines(line, endLine)
      ].filter(Boolean).join("\n");
    }
    function SyntaxError2(message, source, offset, line, column) {
      const error = Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        source,
        offset,
        line,
        column,
        sourceFragment(extraLines) {
          return sourceFragment({ source, line, column }, isNaN(extraLines) ? 0 : extraLines);
        },
        get formattedMessage() {
          return `Parse error: ${message}
` + sourceFragment({ source, line, column }, 2);
        }
      });
      return error;
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/parser/sequence.cjs
var require_sequence2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/parser/sequence.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function readSequence(recognizer) {
      const children = this.createList();
      let space = false;
      const context = {
        recognizer
      };
      while (!this.eof) {
        switch (this.tokenType) {
          case types.Comment:
            this.next();
            continue;
          case types.WhiteSpace:
            space = true;
            this.next();
            continue;
        }
        let child = recognizer.getNode.call(this, context);
        if (child === void 0) {
          break;
        }
        if (space) {
          if (recognizer.onWhiteSpace) {
            recognizer.onWhiteSpace.call(this, child, children, context);
          }
          space = false;
        }
        children.push(child);
      }
      if (space && recognizer.onWhiteSpace) {
        recognizer.onWhiteSpace.call(this, null, children, context);
      }
      return children;
    }
    exports2.readSequence = readSequence;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/parser/create.cjs
var require_create6 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/parser/create.cjs"(exports2) {
    "use strict";
    var List = require_List2();
    var SyntaxError2 = require_SyntaxError3();
    var index = require_tokenizer3();
    var sequence = require_sequence2();
    var OffsetToLocation = require_OffsetToLocation2();
    var TokenStream = require_TokenStream2();
    var utils = require_utils2();
    var types = require_types3();
    var names = require_names3();
    var NOOP = () => {
    };
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var SEMICOLON = 59;
    var LEFTCURLYBRACKET = 123;
    var NULL = 0;
    function createParseContext(name) {
      return function() {
        return this[name]();
      };
    }
    function fetchParseValues(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const name in dict) {
        const item = dict[name];
        const fn = item.parse || item;
        if (fn) {
          result[name] = fn;
        }
      }
      return result;
    }
    function processConfig(config) {
      const parseConfig = {
        context: /* @__PURE__ */ Object.create(null),
        scope: Object.assign(/* @__PURE__ */ Object.create(null), config.scope),
        atrule: fetchParseValues(config.atrule),
        pseudo: fetchParseValues(config.pseudo),
        node: fetchParseValues(config.node)
      };
      for (const name in config.parseContext) {
        switch (typeof config.parseContext[name]) {
          case "function":
            parseConfig.context[name] = config.parseContext[name];
            break;
          case "string":
            parseConfig.context[name] = createParseContext(config.parseContext[name]);
            break;
        }
      }
      return {
        config: parseConfig,
        ...parseConfig,
        ...parseConfig.node
      };
    }
    function createParser(config) {
      let source = "";
      let filename = "<unknown>";
      let needPositions = false;
      let onParseError = NOOP;
      let onParseErrorThrow = false;
      const locationMap = new OffsetToLocation.OffsetToLocation();
      const parser = Object.assign(new TokenStream.TokenStream(), processConfig(config || {}), {
        parseAtrulePrelude: true,
        parseRulePrelude: true,
        parseValue: true,
        parseCustomProperty: false,
        readSequence: sequence.readSequence,
        consumeUntilBalanceEnd: () => 0,
        consumeUntilLeftCurlyBracket(code) {
          return code === LEFTCURLYBRACKET ? 1 : 0;
        },
        consumeUntilLeftCurlyBracketOrSemicolon(code) {
          return code === LEFTCURLYBRACKET || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilExclamationMarkOrSemicolon(code) {
          return code === EXCLAMATIONMARK || code === SEMICOLON ? 1 : 0;
        },
        consumeUntilSemicolonIncluded(code) {
          return code === SEMICOLON ? 2 : 0;
        },
        createList() {
          return new List.List();
        },
        createSingleNodeList(node) {
          return new List.List().appendData(node);
        },
        getFirstListNode(list) {
          return list && list.first;
        },
        getLastListNode(list) {
          return list && list.last;
        },
        parseWithFallback(consumer, fallback) {
          const startToken = this.tokenIndex;
          try {
            return consumer.call(this);
          } catch (e) {
            if (onParseErrorThrow) {
              throw e;
            }
            const fallbackNode = fallback.call(this, startToken);
            onParseErrorThrow = true;
            onParseError(e, fallbackNode);
            onParseErrorThrow = false;
            return fallbackNode;
          }
        },
        lookupNonWSType(offset) {
          let type;
          do {
            type = this.lookupType(offset++);
            if (type !== types.WhiteSpace) {
              return type;
            }
          } while (type !== NULL);
          return NULL;
        },
        charCodeAt(offset) {
          return offset >= 0 && offset < source.length ? source.charCodeAt(offset) : 0;
        },
        substring(offsetStart, offsetEnd) {
          return source.substring(offsetStart, offsetEnd);
        },
        substrToCursor(start) {
          return this.source.substring(start, this.tokenStart);
        },
        cmpChar(offset, charCode) {
          return utils.cmpChar(source, offset, charCode);
        },
        cmpStr(offsetStart, offsetEnd, str) {
          return utils.cmpStr(source, offsetStart, offsetEnd, str);
        },
        consume(tokenType) {
          const start = this.tokenStart;
          this.eat(tokenType);
          return this.substrToCursor(start);
        },
        consumeFunctionName() {
          const name = source.substring(this.tokenStart, this.tokenEnd - 1);
          this.eat(types.Function);
          return name;
        },
        consumeNumber(type) {
          const number = source.substring(this.tokenStart, utils.consumeNumber(source, this.tokenStart));
          this.eat(type);
          return number;
        },
        eat(tokenType) {
          if (this.tokenType !== tokenType) {
            const tokenName = names[tokenType].slice(0, -6).replace(/-/g, " ").replace(/^./, (m) => m.toUpperCase());
            let message = `${/[[\](){}]/.test(tokenName) ? `"${tokenName}"` : tokenName} is expected`;
            let offset = this.tokenStart;
            switch (tokenType) {
              case types.Ident:
                if (this.tokenType === types.Function || this.tokenType === types.Url) {
                  offset = this.tokenEnd - 1;
                  message = "Identifier is expected but function found";
                } else {
                  message = "Identifier is expected";
                }
                break;
              case types.Hash:
                if (this.isDelim(NUMBERSIGN)) {
                  this.next();
                  offset++;
                  message = "Name is expected";
                }
                break;
              case types.Percentage:
                if (this.tokenType === types.Number) {
                  offset = this.tokenEnd;
                  message = "Percent sign is expected";
                }
                break;
            }
            this.error(message, offset);
          }
          this.next();
        },
        eatIdent(name) {
          if (this.tokenType !== types.Ident || this.lookupValue(0, name) === false) {
            this.error(`Identifier "${name}" is expected`);
          }
          this.next();
        },
        eatDelim(code) {
          if (!this.isDelim(code)) {
            this.error(`Delim "${String.fromCharCode(code)}" is expected`);
          }
          this.next();
        },
        getLocation(start, end) {
          if (needPositions) {
            return locationMap.getLocationRange(
              start,
              end,
              filename
            );
          }
          return null;
        },
        getLocationFromList(list) {
          if (needPositions) {
            const head = this.getFirstListNode(list);
            const tail = this.getLastListNode(list);
            return locationMap.getLocationRange(
              head !== null ? head.loc.start.offset - locationMap.startOffset : this.tokenStart,
              tail !== null ? tail.loc.end.offset - locationMap.startOffset : this.tokenStart,
              filename
            );
          }
          return null;
        },
        error(message, offset) {
          const location = typeof offset !== "undefined" && offset < source.length ? locationMap.getLocation(offset) : this.eof ? locationMap.getLocation(utils.findWhiteSpaceStart(source, source.length - 1)) : locationMap.getLocation(this.tokenStart);
          throw new SyntaxError2.SyntaxError(
            message || "Unexpected input",
            source,
            location.offset,
            location.line,
            location.column
          );
        }
      });
      const parse = function(source_, options) {
        source = source_;
        options = options || {};
        parser.setSource(source, index.tokenize);
        locationMap.setSource(
          source,
          options.offset,
          options.line,
          options.column
        );
        filename = options.filename || "<unknown>";
        needPositions = Boolean(options.positions);
        onParseError = typeof options.onParseError === "function" ? options.onParseError : NOOP;
        onParseErrorThrow = false;
        parser.parseAtrulePrelude = "parseAtrulePrelude" in options ? Boolean(options.parseAtrulePrelude) : true;
        parser.parseRulePrelude = "parseRulePrelude" in options ? Boolean(options.parseRulePrelude) : true;
        parser.parseValue = "parseValue" in options ? Boolean(options.parseValue) : true;
        parser.parseCustomProperty = "parseCustomProperty" in options ? Boolean(options.parseCustomProperty) : false;
        const { context = "default", onComment } = options;
        if (context in parser.context === false) {
          throw new Error("Unknown context `" + context + "`");
        }
        if (typeof onComment === "function") {
          parser.forEachToken((type, start, end) => {
            if (type === types.Comment) {
              const loc = parser.getLocation(start, end);
              const value = utils.cmpStr(source, end - 2, end, "*/") ? source.slice(start + 2, end - 2) : source.slice(start + 2, end);
              onComment(value, loc);
            }
          });
        }
        const ast = parser.context[context].call(parser, options);
        if (!parser.eof) {
          parser.error();
        }
        return ast;
      };
      return Object.assign(parse, {
        SyntaxError: SyntaxError2.SyntaxError,
        config: parser.config
      });
    }
    exports2.createParser = createParser;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/generator/sourceMap.cjs
var require_sourceMap2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/generator/sourceMap.cjs"(exports2) {
    "use strict";
    var sourceMapGenerator_js = require_source_map_generator();
    var trackNodes = /* @__PURE__ */ new Set(["Atrule", "Selector", "Declaration"]);
    function generateSourceMap(handlers) {
      const map = new sourceMapGenerator_js.SourceMapGenerator();
      const generated = {
        line: 1,
        column: 0
      };
      const original = {
        line: 0,
        // should be zero to add first mapping
        column: 0
      };
      const activatedGenerated = {
        line: 1,
        column: 0
      };
      const activatedMapping = {
        generated: activatedGenerated
      };
      let line = 1;
      let column = 0;
      let sourceMappingActive = false;
      const origHandlersNode = handlers.node;
      handlers.node = function(node) {
        if (node.loc && node.loc.start && trackNodes.has(node.type)) {
          const nodeLine = node.loc.start.line;
          const nodeColumn = node.loc.start.column - 1;
          if (original.line !== nodeLine || original.column !== nodeColumn) {
            original.line = nodeLine;
            original.column = nodeColumn;
            generated.line = line;
            generated.column = column;
            if (sourceMappingActive) {
              sourceMappingActive = false;
              if (generated.line !== activatedGenerated.line || generated.column !== activatedGenerated.column) {
                map.addMapping(activatedMapping);
              }
            }
            sourceMappingActive = true;
            map.addMapping({
              source: node.loc.source,
              original,
              generated
            });
          }
        }
        origHandlersNode.call(this, node);
        if (sourceMappingActive && trackNodes.has(node.type)) {
          activatedGenerated.line = line;
          activatedGenerated.column = column;
        }
      };
      const origHandlersEmit = handlers.emit;
      handlers.emit = function(value, type, auto) {
        for (let i = 0; i < value.length; i++) {
          if (value.charCodeAt(i) === 10) {
            line++;
            column = 0;
          } else {
            column++;
          }
        }
        origHandlersEmit(value, type, auto);
      };
      const origHandlersResult = handlers.result;
      handlers.result = function() {
        if (sourceMappingActive) {
          map.addMapping(activatedMapping);
        }
        return {
          css: origHandlersResult(),
          map
        };
      };
      return handlers;
    }
    exports2.generateSourceMap = generateSourceMap;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/generator/token-before.cjs
var require_token_before2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/generator/token-before.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var code = (type, value) => {
      if (type === types.Delim) {
        type = value;
      }
      if (typeof type === "string") {
        const charCode = type.charCodeAt(0);
        return charCode > 127 ? 32768 : charCode << 8;
      }
      return type;
    };
    var specPairs = [
      [types.Ident, types.Ident],
      [types.Ident, types.Function],
      [types.Ident, types.Url],
      [types.Ident, types.BadUrl],
      [types.Ident, "-"],
      [types.Ident, types.Number],
      [types.Ident, types.Percentage],
      [types.Ident, types.Dimension],
      [types.Ident, types.CDC],
      [types.Ident, types.LeftParenthesis],
      [types.AtKeyword, types.Ident],
      [types.AtKeyword, types.Function],
      [types.AtKeyword, types.Url],
      [types.AtKeyword, types.BadUrl],
      [types.AtKeyword, "-"],
      [types.AtKeyword, types.Number],
      [types.AtKeyword, types.Percentage],
      [types.AtKeyword, types.Dimension],
      [types.AtKeyword, types.CDC],
      [types.Hash, types.Ident],
      [types.Hash, types.Function],
      [types.Hash, types.Url],
      [types.Hash, types.BadUrl],
      [types.Hash, "-"],
      [types.Hash, types.Number],
      [types.Hash, types.Percentage],
      [types.Hash, types.Dimension],
      [types.Hash, types.CDC],
      [types.Dimension, types.Ident],
      [types.Dimension, types.Function],
      [types.Dimension, types.Url],
      [types.Dimension, types.BadUrl],
      [types.Dimension, "-"],
      [types.Dimension, types.Number],
      [types.Dimension, types.Percentage],
      [types.Dimension, types.Dimension],
      [types.Dimension, types.CDC],
      ["#", types.Ident],
      ["#", types.Function],
      ["#", types.Url],
      ["#", types.BadUrl],
      ["#", "-"],
      ["#", types.Number],
      ["#", types.Percentage],
      ["#", types.Dimension],
      ["#", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["-", types.Ident],
      ["-", types.Function],
      ["-", types.Url],
      ["-", types.BadUrl],
      ["-", "-"],
      ["-", types.Number],
      ["-", types.Percentage],
      ["-", types.Dimension],
      ["-", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [types.Number, types.Ident],
      [types.Number, types.Function],
      [types.Number, types.Url],
      [types.Number, types.BadUrl],
      [types.Number, types.Number],
      [types.Number, types.Percentage],
      [types.Number, types.Dimension],
      [types.Number, "%"],
      [types.Number, types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      ["@", types.Ident],
      ["@", types.Function],
      ["@", types.Url],
      ["@", types.BadUrl],
      ["@", "-"],
      ["@", types.CDC],
      // https://github.com/w3c/csswg-drafts/pull/6874
      [".", types.Number],
      [".", types.Percentage],
      [".", types.Dimension],
      ["+", types.Number],
      ["+", types.Percentage],
      ["+", types.Dimension],
      ["/", "*"]
    ];
    var safePairs = specPairs.concat([
      [types.Ident, types.Hash],
      [types.Dimension, types.Hash],
      [types.Hash, types.Hash],
      [types.AtKeyword, types.LeftParenthesis],
      [types.AtKeyword, types.String],
      [types.AtKeyword, types.Colon],
      [types.Percentage, types.Percentage],
      [types.Percentage, types.Dimension],
      [types.Percentage, types.Function],
      [types.Percentage, "-"],
      [types.RightParenthesis, types.Ident],
      [types.RightParenthesis, types.Function],
      [types.RightParenthesis, types.Percentage],
      [types.RightParenthesis, types.Dimension],
      [types.RightParenthesis, types.Hash],
      [types.RightParenthesis, "-"]
    ]);
    function createMap(pairs) {
      const isWhiteSpaceRequired = new Set(
        pairs.map(([prev, next]) => code(prev) << 16 | code(next))
      );
      return function(prevCode, type, value) {
        const nextCode = code(type, value);
        const nextCharCode = value.charCodeAt(0);
        const emitWs = nextCharCode === HYPHENMINUS && type !== types.Ident && type !== types.Function && type !== types.CDC || nextCharCode === PLUSSIGN ? isWhiteSpaceRequired.has(prevCode << 16 | nextCharCode << 8) : isWhiteSpaceRequired.has(prevCode << 16 | nextCode);
        if (emitWs) {
          this.emit(" ", types.WhiteSpace, true);
        }
        return nextCode;
      };
    }
    var spec = createMap(specPairs);
    var safe = createMap(safePairs);
    exports2.safe = safe;
    exports2.spec = spec;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/generator/create.cjs
var require_create7 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/generator/create.cjs"(exports2) {
    "use strict";
    var index = require_tokenizer3();
    var sourceMap = require_sourceMap2();
    var tokenBefore = require_token_before2();
    var types = require_types3();
    var REVERSESOLIDUS = 92;
    function processChildren(node, delimeter) {
      if (typeof delimeter === "function") {
        let prev = null;
        node.children.forEach((node2) => {
          if (prev !== null) {
            delimeter.call(this, prev);
          }
          this.node(node2);
          prev = node2;
        });
        return;
      }
      node.children.forEach(this.node, this);
    }
    function processChunk(chunk) {
      index.tokenize(chunk, (type, start, end) => {
        this.token(type, chunk.slice(start, end));
      });
    }
    function createGenerator(config) {
      const types$1 = /* @__PURE__ */ new Map();
      for (let name in config.node) {
        const item = config.node[name];
        const fn = item.generate || item;
        if (typeof fn === "function") {
          types$1.set(name, item.generate || item);
        }
      }
      return function(node, options) {
        let buffer = "";
        let prevCode = 0;
        let handlers = {
          node(node2) {
            if (types$1.has(node2.type)) {
              types$1.get(node2.type).call(publicApi, node2);
            } else {
              throw new Error("Unknown node type: " + node2.type);
            }
          },
          tokenBefore: tokenBefore.safe,
          token(type, value) {
            prevCode = this.tokenBefore(prevCode, type, value);
            this.emit(value, type, false);
            if (type === types.Delim && value.charCodeAt(0) === REVERSESOLIDUS) {
              this.emit("\n", types.WhiteSpace, true);
            }
          },
          emit(value) {
            buffer += value;
          },
          result() {
            return buffer;
          }
        };
        if (options) {
          if (typeof options.decorator === "function") {
            handlers = options.decorator(handlers);
          }
          if (options.sourceMap) {
            handlers = sourceMap.generateSourceMap(handlers);
          }
          if (options.mode in tokenBefore) {
            handlers.tokenBefore = tokenBefore[options.mode];
          }
        }
        const publicApi = {
          node: (node2) => handlers.node(node2),
          children: processChildren,
          token: (type, value) => handlers.token(type, value),
          tokenize: processChunk
        };
        handlers.node(node);
        return handlers.result();
      };
    }
    exports2.createGenerator = createGenerator;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/convertor/create.cjs
var require_create8 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/convertor/create.cjs"(exports2) {
    "use strict";
    var List = require_List2();
    function createConvertor(walk) {
      return {
        fromPlainObject(ast) {
          walk(ast, {
            enter(node) {
              if (node.children && node.children instanceof List.List === false) {
                node.children = new List.List().fromArray(node.children);
              }
            }
          });
          return ast;
        },
        toPlainObject(ast) {
          walk(ast, {
            leave(node) {
              if (node.children && node.children instanceof List.List) {
                node.children = node.children.toArray();
              }
            }
          });
          return ast;
        }
      };
    }
    exports2.createConvertor = createConvertor;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/walker/create.cjs
var require_create9 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/walker/create.cjs"(exports2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function invokeForType(fn, type) {
      return function(node, item, list) {
        if (node.type === type) {
          fn.call(this, node, item, list);
        }
      };
    }
    function getWalkersFromStructure(name, nodeType) {
      const structure = nodeType.structure;
      const walkers = [];
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        let fieldTypes = structure[key];
        const walker = {
          name: key,
          type: false,
          nullable: false
        };
        if (!Array.isArray(fieldTypes)) {
          fieldTypes = [fieldTypes];
        }
        for (const fieldType of fieldTypes) {
          if (fieldType === null) {
            walker.nullable = true;
          } else if (typeof fieldType === "string") {
            walker.type = "node";
          } else if (Array.isArray(fieldType)) {
            walker.type = "list";
          }
        }
        if (walker.type) {
          walkers.push(walker);
        }
      }
      if (walkers.length) {
        return {
          context: nodeType.walkContext,
          fields: walkers
        };
      }
      return null;
    }
    function getTypesFromConfig(config) {
      const types = {};
      for (const name in config.node) {
        if (hasOwnProperty2.call(config.node, name)) {
          const nodeType = config.node[name];
          if (!nodeType.structure) {
            throw new Error("Missed `structure` field in `" + name + "` node type definition");
          }
          types[name] = getWalkersFromStructure(name, nodeType);
        }
      }
      return types;
    }
    function createTypeIterator(config, reverse) {
      const fields = config.fields.slice();
      const contextName = config.context;
      const useContext = typeof contextName === "string";
      if (reverse) {
        fields.reverse();
      }
      return function(node, context, walk, walkReducer) {
        let prevContextValue;
        if (useContext) {
          prevContextValue = context[contextName];
          context[contextName] = node;
        }
        for (const field of fields) {
          const ref = node[field.name];
          if (!field.nullable || ref) {
            if (field.type === "list") {
              const breakWalk = reverse ? ref.reduceRight(walkReducer, false) : ref.reduce(walkReducer, false);
              if (breakWalk) {
                return true;
              }
            } else if (walk(ref)) {
              return true;
            }
          }
        }
        if (useContext) {
          context[contextName] = prevContextValue;
        }
      };
    }
    function createFastTraveralMap({
      StyleSheet,
      Atrule,
      Rule,
      Block,
      DeclarationList
    }) {
      return {
        Atrule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Rule: {
          StyleSheet,
          Atrule,
          Rule,
          Block
        },
        Declaration: {
          StyleSheet,
          Atrule,
          Rule,
          Block,
          DeclarationList
        }
      };
    }
    function createWalker(config) {
      const types = getTypesFromConfig(config);
      const iteratorsNatural = {};
      const iteratorsReverse = {};
      const breakWalk = /* @__PURE__ */ Symbol("break-walk");
      const skipNode = /* @__PURE__ */ Symbol("skip-node");
      for (const name in types) {
        if (hasOwnProperty2.call(types, name) && types[name] !== null) {
          iteratorsNatural[name] = createTypeIterator(types[name], false);
          iteratorsReverse[name] = createTypeIterator(types[name], true);
        }
      }
      const fastTraversalIteratorsNatural = createFastTraveralMap(iteratorsNatural);
      const fastTraversalIteratorsReverse = createFastTraveralMap(iteratorsReverse);
      const walk = function(root, options) {
        function walkNode(node, item, list) {
          const enterRet = enter.call(context, node, item, list);
          if (enterRet === breakWalk) {
            return true;
          }
          if (enterRet === skipNode) {
            return false;
          }
          if (iterators.hasOwnProperty(node.type)) {
            if (iterators[node.type](node, context, walkNode, walkReducer)) {
              return true;
            }
          }
          if (leave.call(context, node, item, list) === breakWalk) {
            return true;
          }
          return false;
        }
        let enter = noop;
        let leave = noop;
        let iterators = iteratorsNatural;
        let walkReducer = (ret, data, item, list) => ret || walkNode(data, item, list);
        const context = {
          break: breakWalk,
          skip: skipNode,
          root,
          stylesheet: null,
          atrule: null,
          atrulePrelude: null,
          rule: null,
          selector: null,
          block: null,
          declaration: null,
          function: null
        };
        if (typeof options === "function") {
          enter = options;
        } else if (options) {
          enter = ensureFunction(options.enter);
          leave = ensureFunction(options.leave);
          if (options.reverse) {
            iterators = iteratorsReverse;
          }
          if (options.visit) {
            if (fastTraversalIteratorsNatural.hasOwnProperty(options.visit)) {
              iterators = options.reverse ? fastTraversalIteratorsReverse[options.visit] : fastTraversalIteratorsNatural[options.visit];
            } else if (!types.hasOwnProperty(options.visit)) {
              throw new Error("Bad value `" + options.visit + "` for `visit` option (should be: " + Object.keys(types).sort().join(", ") + ")");
            }
            enter = invokeForType(enter, options.visit);
            leave = invokeForType(leave, options.visit);
          }
        }
        if (enter === noop && leave === noop) {
          throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
        }
        walkNode(root);
      };
      walk.break = breakWalk;
      walk.skip = skipNode;
      walk.find = function(ast, fn) {
        let found = null;
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found = node;
            return breakWalk;
          }
        });
        return found;
      };
      walk.findLast = function(ast, fn) {
        let found = null;
        walk(ast, {
          reverse: true,
          enter(node, item, list) {
            if (fn.call(this, node, item, list)) {
              found = node;
              return breakWalk;
            }
          }
        });
        return found;
      };
      walk.findAll = function(ast, fn) {
        const found = [];
        walk(ast, function(node, item, list) {
          if (fn.call(this, node, item, list)) {
            found.push(node);
          }
        });
        return found;
      };
      return walk;
    }
    exports2.createWalker = createWalker;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/generate.cjs
var require_generate2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/generate.cjs"(exports2) {
    "use strict";
    function noop(value) {
      return value;
    }
    function generateMultiplier(multiplier) {
      const { min, max, comma } = multiplier;
      if (min === 0 && max === 0) {
        return comma ? "#?" : "*";
      }
      if (min === 0 && max === 1) {
        return "?";
      }
      if (min === 1 && max === 0) {
        return comma ? "#" : "+";
      }
      if (min === 1 && max === 1) {
        return "";
      }
      return (comma ? "#" : "") + (min === max ? "{" + min + "}" : "{" + min + "," + (max !== 0 ? max : "") + "}");
    }
    function generateTypeOpts(node) {
      switch (node.type) {
        case "Range":
          return " [" + (node.min === null ? "-\u221E" : node.min) + "," + (node.max === null ? "\u221E" : node.max) + "]";
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
    }
    function generateSequence(node, decorate, forceBraces, compact) {
      const combinator = node.combinator === " " || compact ? node.combinator : " " + node.combinator + " ";
      const result = node.terms.map((term) => internalGenerate(term, decorate, forceBraces, compact)).join(combinator);
      if (node.explicit || forceBraces) {
        return (compact || result[0] === "," ? "[" : "[ ") + result + (compact ? "]" : " ]");
      }
      return result;
    }
    function internalGenerate(node, decorate, forceBraces, compact) {
      let result;
      switch (node.type) {
        case "Group":
          result = generateSequence(node, decorate, forceBraces, compact) + (node.disallowEmpty ? "!" : "");
          break;
        case "Multiplier":
          return internalGenerate(node.term, decorate, forceBraces, compact) + decorate(generateMultiplier(node), node);
        case "Type":
          result = "<" + node.name + (node.opts ? decorate(generateTypeOpts(node.opts), node.opts) : "") + ">";
          break;
        case "Property":
          result = "<'" + node.name + "'>";
          break;
        case "Keyword":
          result = node.name;
          break;
        case "AtKeyword":
          result = "@" + node.name;
          break;
        case "Function":
          result = node.name + "(";
          break;
        case "String":
        case "Token":
          result = node.value;
          break;
        case "Comma":
          result = ",";
          break;
        default:
          throw new Error("Unknown node type `" + node.type + "`");
      }
      return decorate(result, node);
    }
    function generate(node, options) {
      let decorate = noop;
      let forceBraces = false;
      let compact = false;
      if (typeof options === "function") {
        decorate = options;
      } else if (options) {
        forceBraces = Boolean(options.forceBraces);
        compact = Boolean(options.compact);
        if (typeof options.decorate === "function") {
          decorate = options.decorate;
        }
      }
      return internalGenerate(node, decorate, forceBraces, compact);
    }
    exports2.generate = generate;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/error.cjs
var require_error2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/error.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error2();
    var generate = require_generate2();
    var defaultLoc = { offset: 0, line: 1, column: 1 };
    function locateMismatch(matchResult, node) {
      const tokens = matchResult.tokens;
      const longestMatch = matchResult.longestMatch;
      const mismatchNode = longestMatch < tokens.length ? tokens[longestMatch].node || null : null;
      const badNode = mismatchNode !== node ? mismatchNode : null;
      let mismatchOffset = 0;
      let mismatchLength = 0;
      let entries = 0;
      let css = "";
      let start;
      let end;
      for (let i = 0; i < tokens.length; i++) {
        const token = tokens[i].value;
        if (i === longestMatch) {
          mismatchLength = token.length;
          mismatchOffset = css.length;
        }
        if (badNode !== null && tokens[i].node === badNode) {
          if (i <= longestMatch) {
            entries++;
          } else {
            entries = 0;
          }
        }
        css += token;
      }
      if (longestMatch === tokens.length || entries > 1) {
        start = fromLoc(badNode || node, "end") || buildLoc(defaultLoc, css);
        end = buildLoc(start);
      } else {
        start = fromLoc(badNode, "start") || buildLoc(fromLoc(node, "start") || defaultLoc, css.slice(0, mismatchOffset));
        end = fromLoc(badNode, "end") || buildLoc(start, css.substr(mismatchOffset, mismatchLength));
      }
      return {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      };
    }
    function fromLoc(node, point) {
      const value = node && node.loc && node.loc[point];
      if (value) {
        return "line" in value ? buildLoc(value) : value;
      }
      return null;
    }
    function buildLoc({ offset, line, column }, extra) {
      const loc = {
        offset,
        line,
        column
      };
      if (extra) {
        const lines = extra.split(/\n|\r\n?|\f/);
        loc.offset += extra.length;
        loc.line += lines.length - 1;
        loc.column = lines.length === 1 ? loc.column + extra.length : lines.pop().length + 1;
      }
      return loc;
    }
    var SyntaxReferenceError = function(type, referenceName) {
      const error = createCustomError.createCustomError(
        "SyntaxReferenceError",
        type + (referenceName ? " `" + referenceName + "`" : "")
      );
      error.reference = referenceName;
      return error;
    };
    var SyntaxMatchError = function(message, syntax, node, matchResult) {
      const error = createCustomError.createCustomError("SyntaxMatchError", message);
      const {
        css,
        mismatchOffset,
        mismatchLength,
        start,
        end
      } = locateMismatch(matchResult, node);
      error.rawMessage = message;
      error.syntax = syntax ? generate.generate(syntax) : "<generic>";
      error.css = css;
      error.mismatchOffset = mismatchOffset;
      error.mismatchLength = mismatchLength;
      error.message = message + "\n  syntax: " + error.syntax + "\n   value: " + (css || "<empty string>") + "\n  --------" + new Array(error.mismatchOffset + 1).join("-") + "^";
      Object.assign(error, start);
      error.loc = {
        source: node && node.loc && node.loc.source || "<unknown>",
        start,
        end
      };
      return error;
    };
    exports2.SyntaxMatchError = SyntaxMatchError;
    exports2.SyntaxReferenceError = SyntaxReferenceError;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/names.cjs
var require_names4 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/names.cjs"(exports2) {
    "use strict";
    var keywords = /* @__PURE__ */ new Map();
    var properties = /* @__PURE__ */ new Map();
    var HYPHENMINUS = 45;
    var keyword = getKeywordDescriptor;
    var property = getPropertyDescriptor;
    var vendorPrefix = getVendorPrefix;
    function isCustomProperty(str, offset) {
      offset = offset || 0;
      return str.length - offset >= 2 && str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) === HYPHENMINUS;
    }
    function getVendorPrefix(str, offset) {
      offset = offset || 0;
      if (str.length - offset >= 3) {
        if (str.charCodeAt(offset) === HYPHENMINUS && str.charCodeAt(offset + 1) !== HYPHENMINUS) {
          const secondDashIndex = str.indexOf("-", offset + 2);
          if (secondDashIndex !== -1) {
            return str.substring(offset, secondDashIndex + 1);
          }
        }
      }
      return "";
    }
    function getKeywordDescriptor(keyword2) {
      if (keywords.has(keyword2)) {
        return keywords.get(keyword2);
      }
      const name = keyword2.toLowerCase();
      let descriptor = keywords.get(name);
      if (descriptor === void 0) {
        const custom = isCustomProperty(name, 0);
        const vendor = !custom ? getVendorPrefix(name, 0) : "";
        descriptor = Object.freeze({
          basename: name.substr(vendor.length),
          name,
          prefix: vendor,
          vendor,
          custom
        });
      }
      keywords.set(keyword2, descriptor);
      return descriptor;
    }
    function getPropertyDescriptor(property2) {
      if (properties.has(property2)) {
        return properties.get(property2);
      }
      let name = property2;
      let hack = property2[0];
      if (hack === "/") {
        hack = property2[1] === "/" ? "//" : "/";
      } else if (hack !== "_" && hack !== "*" && hack !== "$" && hack !== "#" && hack !== "+" && hack !== "&") {
        hack = "";
      }
      const custom = isCustomProperty(name, hack.length);
      if (!custom) {
        name = name.toLowerCase();
        if (properties.has(name)) {
          const descriptor2 = properties.get(name);
          properties.set(property2, descriptor2);
          return descriptor2;
        }
      }
      const vendor = !custom ? getVendorPrefix(name, hack.length) : "";
      const prefix = name.substr(0, hack.length + vendor.length);
      const descriptor = Object.freeze({
        basename: name.substr(prefix.length),
        name: name.substr(hack.length),
        hack,
        vendor,
        prefix,
        custom
      });
      properties.set(property2, descriptor);
      return descriptor;
    }
    exports2.isCustomProperty = isCustomProperty;
    exports2.keyword = keyword;
    exports2.property = property;
    exports2.vendorPrefix = vendorPrefix;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/generic-const.cjs
var require_generic_const2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/generic-const.cjs"(exports2) {
    "use strict";
    var cssWideKeywords = [
      "initial",
      "inherit",
      "unset",
      "revert",
      "revert-layer"
    ];
    exports2.cssWideKeywords = cssWideKeywords;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs
var require_generic_an_plus_b2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/generic-an-plus-b.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    var types = require_types3();
    var utils = require_utils2();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function skipSC(token, offset, getNextToken) {
      while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment)) {
        token = getNextToken(++offset);
      }
      return offset;
    }
    function checkInteger(token, valueOffset, disallowSign, offset) {
      if (!token) {
        return 0;
      }
      const code = token.value.charCodeAt(valueOffset);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          return 0;
        }
        valueOffset++;
      }
      for (; valueOffset < token.value.length; valueOffset++) {
        if (!charCodeDefinitions.isDigit(token.value.charCodeAt(valueOffset))) {
          return 0;
        }
      }
      return offset + 1;
    }
    function consumeB(token, offset_, getNextToken) {
      let sign = false;
      let offset = skipSC(token, offset_, getNextToken);
      token = getNextToken(offset);
      if (token === null) {
        return offset_;
      }
      if (token.type !== types.Number) {
        if (isDelim(token, PLUSSIGN) || isDelim(token, HYPHENMINUS)) {
          sign = true;
          offset = skipSC(getNextToken(++offset), offset, getNextToken);
          token = getNextToken(offset);
          if (token === null || token.type !== types.Number) {
            return 0;
          }
        } else {
          return offset_;
        }
      }
      if (!sign) {
        const code = token.value.charCodeAt(0);
        if (code !== PLUSSIGN && code !== HYPHENMINUS) {
          return 0;
        }
      }
      return checkInteger(token, sign ? 0 : 1, sign, offset);
    }
    function anPlusB(token, getNextToken) {
      let offset = 0;
      if (!token) {
        return 0;
      }
      if (token.type === types.Number) {
        return checkInteger(token, 0, ALLOW_SIGN, offset);
      } else if (token.type === types.Ident && token.value.charCodeAt(0) === HYPHENMINUS) {
        if (!utils.cmpChar(token.value, 1, N)) {
          return 0;
        }
        switch (token.value.length) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // -n- <signless-integer>
          case 3:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // <dashndashdigit-ident>
          default:
            if (token.value.charCodeAt(2) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 3, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Ident || isDelim(token, PLUSSIGN) && getNextToken(offset + 1).type === types.Ident) {
        if (token.type !== types.Ident) {
          token = getNextToken(++offset);
        }
        if (token === null || !utils.cmpChar(token.value, 0, N)) {
          return 0;
        }
        switch (token.value.length) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            return consumeB(getNextToken(++offset), offset, getNextToken);
          // '+'? n- <signless-integer>
          case 2:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          // '+'? <ndashdigit-ident>
          default:
            if (token.value.charCodeAt(1) !== HYPHENMINUS) {
              return 0;
            }
            return checkInteger(token, 2, DISALLOW_SIGN, offset);
        }
      } else if (token.type === types.Dimension) {
        let code = token.value.charCodeAt(0);
        let sign = code === PLUSSIGN || code === HYPHENMINUS ? 1 : 0;
        let i = sign;
        for (; i < token.value.length; i++) {
          if (!charCodeDefinitions.isDigit(token.value.charCodeAt(i))) {
            break;
          }
        }
        if (i === sign) {
          return 0;
        }
        if (!utils.cmpChar(token.value, i, N)) {
          return 0;
        }
        if (i + 1 === token.value.length) {
          return consumeB(getNextToken(++offset), offset, getNextToken);
        } else {
          if (token.value.charCodeAt(i + 1) !== HYPHENMINUS) {
            return 0;
          }
          if (i + 2 === token.value.length) {
            offset = skipSC(getNextToken(++offset), offset, getNextToken);
            token = getNextToken(offset);
            return checkInteger(token, 0, DISALLOW_SIGN, offset);
          } else {
            return checkInteger(token, i + 2, DISALLOW_SIGN, offset);
          }
        }
      }
      return 0;
    }
    module2.exports = anPlusB;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/generic-urange.cjs
var require_generic_urange2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/generic-urange.cjs"(exports2, module2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    var types = require_types3();
    var utils = require_utils2();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    var U = 117;
    function isDelim(token, code) {
      return token !== null && token.type === types.Delim && token.value.charCodeAt(0) === code;
    }
    function startsWith(token, code) {
      return token.value.charCodeAt(0) === code;
    }
    function hexSequence(token, offset, allowDash) {
      let hexlen = 0;
      for (let pos = offset; pos < token.value.length; pos++) {
        const code = token.value.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && hexlen !== 0) {
          hexSequence(token, offset + hexlen + 1, false);
          return 6;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          return 0;
        }
        if (++hexlen > 6) {
          return 0;
        }
      }
      return hexlen;
    }
    function withQuestionMarkSequence(consumed, length, getNextToken) {
      if (!consumed) {
        return 0;
      }
      while (isDelim(getNextToken(length), QUESTIONMARK)) {
        if (++consumed > 6) {
          return 0;
        }
        length++;
      }
      return length;
    }
    function urange(token, getNextToken) {
      let length = 0;
      if (token === null || token.type !== types.Ident || !utils.cmpChar(token.value, 0, U)) {
        return 0;
      }
      token = getNextToken(++length);
      if (token === null) {
        return 0;
      }
      if (isDelim(token, PLUSSIGN)) {
        token = getNextToken(++length);
        if (token === null) {
          return 0;
        }
        if (token.type === types.Ident) {
          return withQuestionMarkSequence(hexSequence(token, 0, true), ++length, getNextToken);
        }
        if (isDelim(token, QUESTIONMARK)) {
          return withQuestionMarkSequence(1, ++length, getNextToken);
        }
        return 0;
      }
      if (token.type === types.Number) {
        const consumedHexLength = hexSequence(token, 1, true);
        if (consumedHexLength === 0) {
          return 0;
        }
        token = getNextToken(++length);
        if (token === null) {
          return length;
        }
        if (token.type === types.Dimension || token.type === types.Number) {
          if (!startsWith(token, HYPHENMINUS) || !hexSequence(token, 1, false)) {
            return 0;
          }
          return length + 1;
        }
        return withQuestionMarkSequence(consumedHexLength, length, getNextToken);
      }
      if (token.type === types.Dimension) {
        return withQuestionMarkSequence(hexSequence(token, 1, true), ++length, getNextToken);
      }
      return 0;
    }
    module2.exports = urange;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/generic.cjs
var require_generic2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/generic.cjs"(exports2, module2) {
    "use strict";
    var genericConst = require_generic_const2();
    var genericAnPlusB = require_generic_an_plus_b2();
    var genericUrange = require_generic_urange2();
    var types = require_types3();
    var charCodeDefinitions = require_char_code_definitions2();
    var utils = require_utils2();
    var calcFunctionNames = ["calc(", "-moz-calc(", "-webkit-calc("];
    var balancePair = /* @__PURE__ */ new Map([
      [types.Function, types.RightParenthesis],
      [types.LeftParenthesis, types.RightParenthesis],
      [types.LeftSquareBracket, types.RightSquareBracket],
      [types.LeftCurlyBracket, types.RightCurlyBracket]
    ]);
    var LENGTH = [
      // absolute length units https://www.w3.org/TR/css-values-3/#lengths
      "cm",
      "mm",
      "q",
      "in",
      "pt",
      "pc",
      "px",
      // font-relative length units https://drafts.csswg.org/css-values-4/#font-relative-lengths
      "em",
      "rem",
      "ex",
      "rex",
      "cap",
      "rcap",
      "ch",
      "rch",
      "ic",
      "ric",
      "lh",
      "rlh",
      // viewport-percentage lengths https://drafts.csswg.org/css-values-4/#viewport-relative-lengths
      "vw",
      "svw",
      "lvw",
      "dvw",
      "vh",
      "svh",
      "lvh",
      "dvh",
      "vi",
      "svi",
      "lvi",
      "dvi",
      "vb",
      "svb",
      "lvb",
      "dvb",
      "vmin",
      "svmin",
      "lvmin",
      "dvmin",
      "vmax",
      "svmax",
      "lvmax",
      "dvmax",
      // container relative lengths https://drafts.csswg.org/css-contain-3/#container-lengths
      "cqw",
      "cqh",
      "cqi",
      "cqb",
      "cqmin",
      "cqmax"
    ];
    var ANGLE = ["deg", "grad", "rad", "turn"];
    var TIME = ["s", "ms"];
    var FREQUENCY = ["hz", "khz"];
    var RESOLUTION = ["dpi", "dpcm", "dppx", "x"];
    var FLEX = ["fr"];
    var DECIBEL = ["db"];
    var SEMITONES = ["st"];
    function charCodeAt(str, index) {
      return index < str.length ? str.charCodeAt(index) : 0;
    }
    function eqStr(actual, expected) {
      return utils.cmpStr(actual, 0, actual.length, expected);
    }
    function eqStrAny(actual, expected) {
      for (let i = 0; i < expected.length; i++) {
        if (eqStr(actual, expected[i])) {
          return true;
        }
      }
      return false;
    }
    function isPostfixIeHack(str, offset) {
      if (offset !== str.length - 2) {
        return false;
      }
      return charCodeAt(str, offset) === 92 && // U+005C REVERSE SOLIDUS (\)
      charCodeDefinitions.isDigit(charCodeAt(str, offset + 1));
    }
    function outOfRange(opts, value, numEnd) {
      if (opts && opts.type === "Range") {
        const num = Number(
          numEnd !== void 0 && numEnd !== value.length ? value.substr(0, numEnd) : value
        );
        if (isNaN(num)) {
          return true;
        }
        if (opts.min !== null && num < opts.min && typeof opts.min !== "string") {
          return true;
        }
        if (opts.max !== null && num > opts.max && typeof opts.max !== "string") {
          return true;
        }
      }
      return false;
    }
    function consumeFunction(token, getNextToken) {
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              if (balanceStash.length === 0) {
                length++;
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function calc(next) {
      return function(token, getNextToken, opts) {
        if (token === null) {
          return 0;
        }
        if (token.type === types.Function && eqStrAny(token.value, calcFunctionNames)) {
          return consumeFunction(token, getNextToken);
        }
        return next(token, getNextToken, opts);
      };
    }
    function tokenType(expectedTokenType) {
      return function(token) {
        if (token === null || token.type !== expectedTokenType) {
          return 0;
        }
        return 1;
      };
    }
    function customIdent(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      const name = token.value.toLowerCase();
      if (eqStrAny(name, genericConst.cssWideKeywords)) {
        return 0;
      }
      if (eqStr(name, "default")) {
        return 0;
      }
      return 1;
    }
    function customPropertyName(token) {
      if (token === null || token.type !== types.Ident) {
        return 0;
      }
      if (charCodeAt(token.value, 0) !== 45 || charCodeAt(token.value, 1) !== 45) {
        return 0;
      }
      return 1;
    }
    function hexColor(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      const length = token.value.length;
      if (length !== 4 && length !== 5 && length !== 7 && length !== 9) {
        return 0;
      }
      for (let i = 1; i < length; i++) {
        if (!charCodeDefinitions.isHexDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      return 1;
    }
    function idSelector(token) {
      if (token === null || token.type !== types.Hash) {
        return 0;
      }
      if (!charCodeDefinitions.isIdentifierStart(charCodeAt(token.value, 1), charCodeAt(token.value, 2), charCodeAt(token.value, 3))) {
        return 0;
      }
      return 1;
    }
    function declarationValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            // ... or top-level <semicolon-token> tokens
            case types.Semicolon:
              if (balanceCloseType === 0) {
                break scan;
              }
              break;
            // ... or <delim-token> tokens with a value of "!"
            case types.Delim:
              if (balanceCloseType === 0 && token.value === "!") {
                break scan;
              }
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function anyValue(token, getNextToken) {
      if (!token) {
        return 0;
      }
      let balanceCloseType = 0;
      let balanceStash = [];
      let length = 0;
      scan:
        do {
          switch (token.type) {
            // ... does not contain <bad-string-token>, <bad-url-token>,
            case types.BadString:
            case types.BadUrl:
              break scan;
            // ... unmatched <)-token>, <]-token>, or <}-token>,
            case types.RightCurlyBracket:
            case types.RightParenthesis:
            case types.RightSquareBracket:
              if (token.type !== balanceCloseType) {
                break scan;
              }
              balanceCloseType = balanceStash.pop();
              break;
            case types.Function:
            case types.LeftParenthesis:
            case types.LeftSquareBracket:
            case types.LeftCurlyBracket:
              balanceStash.push(balanceCloseType);
              balanceCloseType = balancePair.get(token.type);
              break;
          }
          length++;
        } while (token = getNextToken(length));
      return length;
    }
    function dimension(type) {
      if (type) {
        type = new Set(type);
      }
      return function(token, getNextToken, opts) {
        if (token === null || token.type !== types.Dimension) {
          return 0;
        }
        const numberEnd = utils.consumeNumber(token.value, 0);
        if (type !== null) {
          const reverseSolidusOffset = token.value.indexOf("\\", numberEnd);
          const unit = reverseSolidusOffset === -1 || !isPostfixIeHack(token.value, reverseSolidusOffset) ? token.value.substr(numberEnd) : token.value.substring(numberEnd, reverseSolidusOffset);
          if (type.has(unit.toLowerCase()) === false) {
            return 0;
          }
        }
        if (outOfRange(opts, token.value, numberEnd)) {
          return 0;
        }
        return 1;
      };
    }
    function percentage(token, getNextToken, opts) {
      if (token === null || token.type !== types.Percentage) {
        return 0;
      }
      if (outOfRange(opts, token.value, token.value.length - 1)) {
        return 0;
      }
      return 1;
    }
    function zero(next) {
      if (typeof next !== "function") {
        next = function() {
          return 0;
        };
      }
      return function(token, getNextToken, opts) {
        if (token !== null && token.type === types.Number) {
          if (Number(token.value) === 0) {
            return 1;
          }
        }
        return next(token, getNextToken, opts);
      };
    }
    function number(token, getNextToken, opts) {
      if (token === null) {
        return 0;
      }
      const numberEnd = utils.consumeNumber(token.value, 0);
      const isNumber = numberEnd === token.value.length;
      if (!isNumber && !isPostfixIeHack(token.value, numberEnd)) {
        return 0;
      }
      if (outOfRange(opts, token.value, numberEnd)) {
        return 0;
      }
      return 1;
    }
    function integer(token, getNextToken, opts) {
      if (token === null || token.type !== types.Number) {
        return 0;
      }
      let i = charCodeAt(token.value, 0) === 43 || // U+002B PLUS SIGN (+)
      charCodeAt(token.value, 0) === 45 ? 1 : 0;
      for (; i < token.value.length; i++) {
        if (!charCodeDefinitions.isDigit(charCodeAt(token.value, i))) {
          return 0;
        }
      }
      if (outOfRange(opts, token.value, i)) {
        return 0;
      }
      return 1;
    }
    var genericSyntaxes = {
      // token types
      "ident-token": tokenType(types.Ident),
      "function-token": tokenType(types.Function),
      "at-keyword-token": tokenType(types.AtKeyword),
      "hash-token": tokenType(types.Hash),
      "string-token": tokenType(types.String),
      "bad-string-token": tokenType(types.BadString),
      "url-token": tokenType(types.Url),
      "bad-url-token": tokenType(types.BadUrl),
      "delim-token": tokenType(types.Delim),
      "number-token": tokenType(types.Number),
      "percentage-token": tokenType(types.Percentage),
      "dimension-token": tokenType(types.Dimension),
      "whitespace-token": tokenType(types.WhiteSpace),
      "CDO-token": tokenType(types.CDO),
      "CDC-token": tokenType(types.CDC),
      "colon-token": tokenType(types.Colon),
      "semicolon-token": tokenType(types.Semicolon),
      "comma-token": tokenType(types.Comma),
      "[-token": tokenType(types.LeftSquareBracket),
      "]-token": tokenType(types.RightSquareBracket),
      "(-token": tokenType(types.LeftParenthesis),
      ")-token": tokenType(types.RightParenthesis),
      "{-token": tokenType(types.LeftCurlyBracket),
      "}-token": tokenType(types.RightCurlyBracket),
      // token type aliases
      "string": tokenType(types.String),
      "ident": tokenType(types.Ident),
      // complex types
      "custom-ident": customIdent,
      "custom-property-name": customPropertyName,
      "hex-color": hexColor,
      "id-selector": idSelector,
      // element( <id-selector> )
      "an-plus-b": genericAnPlusB,
      "urange": genericUrange,
      "declaration-value": declarationValue,
      "any-value": anyValue,
      // dimensions
      "dimension": calc(dimension(null)),
      "angle": calc(dimension(ANGLE)),
      "decibel": calc(dimension(DECIBEL)),
      "frequency": calc(dimension(FREQUENCY)),
      "flex": calc(dimension(FLEX)),
      "length": calc(zero(dimension(LENGTH))),
      "resolution": calc(dimension(RESOLUTION)),
      "semitones": calc(dimension(SEMITONES)),
      "time": calc(dimension(TIME)),
      // percentage
      "percentage": calc(percentage),
      // numeric
      "zero": zero(),
      "number": calc(number),
      "integer": calc(integer)
    };
    module2.exports = genericSyntaxes;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/prepare-tokens.cjs
var require_prepare_tokens2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/prepare-tokens.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer3();
    var astToTokens = {
      decorator(handlers) {
        const tokens = [];
        let curNode = null;
        return {
          ...handlers,
          node(node) {
            const tmp = curNode;
            curNode = node;
            handlers.node.call(this, node);
            curNode = tmp;
          },
          emit(value, type, auto) {
            tokens.push({
              type,
              value,
              node: auto ? null : curNode
            });
          },
          result() {
            return tokens;
          }
        };
      }
    };
    function stringToTokens(str) {
      const tokens = [];
      index.tokenize(
        str,
        (type, start, end) => tokens.push({
          type,
          value: str.slice(start, end),
          node: null
        })
      );
      return tokens;
    }
    function prepareTokens(value, syntax) {
      if (typeof value === "string") {
        return stringToTokens(value);
      }
      return syntax.generate(value, astToTokens);
    }
    module2.exports = prepareTokens;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs
var require_SyntaxError4 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/SyntaxError.cjs"(exports2) {
    "use strict";
    var createCustomError = require_create_custom_error2();
    function SyntaxError2(message, input, offset) {
      return Object.assign(createCustomError.createCustomError("SyntaxError", message), {
        input,
        offset,
        rawMessage: message,
        message: message + "\n  " + input + "\n--" + new Array((offset || input.length) + 1).join("-") + "^"
      });
    }
    exports2.SyntaxError = SyntaxError2;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs
var require_tokenizer4 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/tokenizer.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError4();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var Tokenizer = class {
      constructor(str) {
        this.str = str;
        this.pos = 0;
      }
      charCodeAt(pos) {
        return pos < this.str.length ? this.str.charCodeAt(pos) : 0;
      }
      charCode() {
        return this.charCodeAt(this.pos);
      }
      nextCharCode() {
        return this.charCodeAt(this.pos + 1);
      }
      nextNonWsCode(pos) {
        return this.charCodeAt(this.findWsEnd(pos));
      }
      findWsEnd(pos) {
        for (; pos < this.str.length; pos++) {
          const code = this.str.charCodeAt(pos);
          if (code !== R && code !== N && code !== F && code !== SPACE && code !== TAB) {
            break;
          }
        }
        return pos;
      }
      substringToPos(end) {
        return this.str.substring(this.pos, this.pos = end);
      }
      eat(code) {
        if (this.charCode() !== code) {
          this.error("Expect `" + String.fromCharCode(code) + "`");
        }
        this.pos++;
      }
      peek() {
        return this.pos < this.str.length ? this.str.charAt(this.pos++) : "";
      }
      error(message) {
        throw new SyntaxError2.SyntaxError(message, this.str, this.pos);
      }
    };
    exports2.Tokenizer = Tokenizer;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/parse.cjs
var require_parse4 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/parse.cjs"(exports2) {
    "use strict";
    var tokenizer = require_tokenizer4();
    var TAB = 9;
    var N = 10;
    var F = 12;
    var R = 13;
    var SPACE = 32;
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var AMPERSAND = 38;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var COMMA = 44;
    var HYPERMINUS = 45;
    var LESSTHANSIGN = 60;
    var GREATERTHANSIGN = 62;
    var QUESTIONMARK = 63;
    var COMMERCIALAT = 64;
    var LEFTSQUAREBRACKET = 91;
    var RIGHTSQUAREBRACKET = 93;
    var LEFTCURLYBRACKET = 123;
    var VERTICALLINE = 124;
    var RIGHTCURLYBRACKET = 125;
    var INFINITY = 8734;
    var NAME_CHAR = new Uint8Array(128).map(
      (_, idx) => /[a-zA-Z0-9\-]/.test(String.fromCharCode(idx)) ? 1 : 0
    );
    var COMBINATOR_PRECEDENCE = {
      " ": 1,
      "&&": 2,
      "||": 3,
      "|": 4
    };
    function scanSpaces(tokenizer2) {
      return tokenizer2.substringToPos(
        tokenizer2.findWsEnd(tokenizer2.pos)
      );
    }
    function scanWord(tokenizer2) {
      let end = tokenizer2.pos;
      for (; end < tokenizer2.str.length; end++) {
        const code = tokenizer2.str.charCodeAt(end);
        if (code >= 128 || NAME_CHAR[code] === 0) {
          break;
        }
      }
      if (tokenizer2.pos === end) {
        tokenizer2.error("Expect a keyword");
      }
      return tokenizer2.substringToPos(end);
    }
    function scanNumber(tokenizer2) {
      let end = tokenizer2.pos;
      for (; end < tokenizer2.str.length; end++) {
        const code = tokenizer2.str.charCodeAt(end);
        if (code < 48 || code > 57) {
          break;
        }
      }
      if (tokenizer2.pos === end) {
        tokenizer2.error("Expect a number");
      }
      return tokenizer2.substringToPos(end);
    }
    function scanString(tokenizer2) {
      const end = tokenizer2.str.indexOf("'", tokenizer2.pos + 1);
      if (end === -1) {
        tokenizer2.pos = tokenizer2.str.length;
        tokenizer2.error("Expect an apostrophe");
      }
      return tokenizer2.substringToPos(end + 1);
    }
    function readMultiplierRange(tokenizer2) {
      let min = null;
      let max = null;
      tokenizer2.eat(LEFTCURLYBRACKET);
      min = scanNumber(tokenizer2);
      if (tokenizer2.charCode() === COMMA) {
        tokenizer2.pos++;
        if (tokenizer2.charCode() !== RIGHTCURLYBRACKET) {
          max = scanNumber(tokenizer2);
        }
      } else {
        max = min;
      }
      tokenizer2.eat(RIGHTCURLYBRACKET);
      return {
        min: Number(min),
        max: max ? Number(max) : 0
      };
    }
    function readMultiplier(tokenizer2) {
      let range = null;
      let comma = false;
      switch (tokenizer2.charCode()) {
        case ASTERISK:
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 0
          };
          break;
        case PLUSSIGN:
          tokenizer2.pos++;
          range = {
            min: 1,
            max: 0
          };
          break;
        case QUESTIONMARK:
          tokenizer2.pos++;
          range = {
            min: 0,
            max: 1
          };
          break;
        case NUMBERSIGN:
          tokenizer2.pos++;
          comma = true;
          if (tokenizer2.charCode() === LEFTCURLYBRACKET) {
            range = readMultiplierRange(tokenizer2);
          } else if (tokenizer2.charCode() === QUESTIONMARK) {
            tokenizer2.pos++;
            range = {
              min: 0,
              max: 0
            };
          } else {
            range = {
              min: 1,
              max: 0
            };
          }
          break;
        case LEFTCURLYBRACKET:
          range = readMultiplierRange(tokenizer2);
          break;
        default:
          return null;
      }
      return {
        type: "Multiplier",
        comma,
        min: range.min,
        max: range.max,
        term: null
      };
    }
    function maybeMultiplied(tokenizer2, node) {
      const multiplier = readMultiplier(tokenizer2);
      if (multiplier !== null) {
        multiplier.term = node;
        if (tokenizer2.charCode() === NUMBERSIGN && tokenizer2.charCodeAt(tokenizer2.pos - 1) === PLUSSIGN) {
          return maybeMultiplied(tokenizer2, multiplier);
        }
        return multiplier;
      }
      return node;
    }
    function maybeToken(tokenizer2) {
      const ch = tokenizer2.peek();
      if (ch === "") {
        return null;
      }
      return {
        type: "Token",
        value: ch
      };
    }
    function readProperty(tokenizer2) {
      let name;
      tokenizer2.eat(LESSTHANSIGN);
      tokenizer2.eat(APOSTROPHE);
      name = scanWord(tokenizer2);
      tokenizer2.eat(APOSTROPHE);
      tokenizer2.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer2, {
        type: "Property",
        name
      });
    }
    function readTypeRange(tokenizer2) {
      let min = null;
      let max = null;
      let sign = 1;
      tokenizer2.eat(LEFTSQUAREBRACKET);
      if (tokenizer2.charCode() === HYPERMINUS) {
        tokenizer2.peek();
        sign = -1;
      }
      if (sign == -1 && tokenizer2.charCode() === INFINITY) {
        tokenizer2.peek();
      } else {
        min = sign * Number(scanNumber(tokenizer2));
        if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
          min += scanWord(tokenizer2);
        }
      }
      scanSpaces(tokenizer2);
      tokenizer2.eat(COMMA);
      scanSpaces(tokenizer2);
      if (tokenizer2.charCode() === INFINITY) {
        tokenizer2.peek();
      } else {
        sign = 1;
        if (tokenizer2.charCode() === HYPERMINUS) {
          tokenizer2.peek();
          sign = -1;
        }
        max = sign * Number(scanNumber(tokenizer2));
        if (NAME_CHAR[tokenizer2.charCode()] !== 0) {
          max += scanWord(tokenizer2);
        }
      }
      tokenizer2.eat(RIGHTSQUAREBRACKET);
      return {
        type: "Range",
        min,
        max
      };
    }
    function readType(tokenizer2) {
      let name;
      let opts = null;
      tokenizer2.eat(LESSTHANSIGN);
      name = scanWord(tokenizer2);
      if (tokenizer2.charCode() === LEFTPARENTHESIS && tokenizer2.nextCharCode() === RIGHTPARENTHESIS) {
        tokenizer2.pos += 2;
        name += "()";
      }
      if (tokenizer2.charCodeAt(tokenizer2.findWsEnd(tokenizer2.pos)) === LEFTSQUAREBRACKET) {
        scanSpaces(tokenizer2);
        opts = readTypeRange(tokenizer2);
      }
      tokenizer2.eat(GREATERTHANSIGN);
      return maybeMultiplied(tokenizer2, {
        type: "Type",
        name,
        opts
      });
    }
    function readKeywordOrFunction(tokenizer2) {
      const name = scanWord(tokenizer2);
      if (tokenizer2.charCode() === LEFTPARENTHESIS) {
        tokenizer2.pos++;
        return {
          type: "Function",
          name
        };
      }
      return maybeMultiplied(tokenizer2, {
        type: "Keyword",
        name
      });
    }
    function regroupTerms(terms, combinators) {
      function createGroup(terms2, combinator2) {
        return {
          type: "Group",
          terms: terms2,
          combinator: combinator2,
          disallowEmpty: false,
          explicit: false
        };
      }
      let combinator;
      combinators = Object.keys(combinators).sort((a, b) => COMBINATOR_PRECEDENCE[a] - COMBINATOR_PRECEDENCE[b]);
      while (combinators.length > 0) {
        combinator = combinators.shift();
        let i = 0;
        let subgroupStart = 0;
        for (; i < terms.length; i++) {
          const term = terms[i];
          if (term.type === "Combinator") {
            if (term.value === combinator) {
              if (subgroupStart === -1) {
                subgroupStart = i - 1;
              }
              terms.splice(i, 1);
              i--;
            } else {
              if (subgroupStart !== -1 && i - subgroupStart > 1) {
                terms.splice(
                  subgroupStart,
                  i - subgroupStart,
                  createGroup(terms.slice(subgroupStart, i), combinator)
                );
                i = subgroupStart + 1;
              }
              subgroupStart = -1;
            }
          }
        }
        if (subgroupStart !== -1 && combinators.length) {
          terms.splice(
            subgroupStart,
            i - subgroupStart,
            createGroup(terms.slice(subgroupStart, i), combinator)
          );
        }
      }
      return combinator;
    }
    function readImplicitGroup(tokenizer2) {
      const terms = [];
      const combinators = {};
      let token;
      let prevToken = null;
      let prevTokenPos = tokenizer2.pos;
      while (token = peek(tokenizer2)) {
        if (token.type !== "Spaces") {
          if (token.type === "Combinator") {
            if (prevToken === null || prevToken.type === "Combinator") {
              tokenizer2.pos = prevTokenPos;
              tokenizer2.error("Unexpected combinator");
            }
            combinators[token.value] = true;
          } else if (prevToken !== null && prevToken.type !== "Combinator") {
            combinators[" "] = true;
            terms.push({
              type: "Combinator",
              value: " "
            });
          }
          terms.push(token);
          prevToken = token;
          prevTokenPos = tokenizer2.pos;
        }
      }
      if (prevToken !== null && prevToken.type === "Combinator") {
        tokenizer2.pos -= prevTokenPos;
        tokenizer2.error("Unexpected combinator");
      }
      return {
        type: "Group",
        terms,
        combinator: regroupTerms(terms, combinators) || " ",
        disallowEmpty: false,
        explicit: false
      };
    }
    function readGroup(tokenizer2) {
      let result;
      tokenizer2.eat(LEFTSQUAREBRACKET);
      result = readImplicitGroup(tokenizer2);
      tokenizer2.eat(RIGHTSQUAREBRACKET);
      result.explicit = true;
      if (tokenizer2.charCode() === EXCLAMATIONMARK) {
        tokenizer2.pos++;
        result.disallowEmpty = true;
      }
      return result;
    }
    function peek(tokenizer2) {
      let code = tokenizer2.charCode();
      if (code < 128 && NAME_CHAR[code] === 1) {
        return readKeywordOrFunction(tokenizer2);
      }
      switch (code) {
        case RIGHTSQUAREBRACKET:
          break;
        case LEFTSQUAREBRACKET:
          return maybeMultiplied(tokenizer2, readGroup(tokenizer2));
        case LESSTHANSIGN:
          return tokenizer2.nextCharCode() === APOSTROPHE ? readProperty(tokenizer2) : readType(tokenizer2);
        case VERTICALLINE:
          return {
            type: "Combinator",
            value: tokenizer2.substringToPos(
              tokenizer2.pos + (tokenizer2.nextCharCode() === VERTICALLINE ? 2 : 1)
            )
          };
        case AMPERSAND:
          tokenizer2.pos++;
          tokenizer2.eat(AMPERSAND);
          return {
            type: "Combinator",
            value: "&&"
          };
        case COMMA:
          tokenizer2.pos++;
          return {
            type: "Comma"
          };
        case APOSTROPHE:
          return maybeMultiplied(tokenizer2, {
            type: "String",
            value: scanString(tokenizer2)
          });
        case SPACE:
        case TAB:
        case N:
        case R:
        case F:
          return {
            type: "Spaces",
            value: scanSpaces(tokenizer2)
          };
        case COMMERCIALAT:
          code = tokenizer2.nextCharCode();
          if (code < 128 && NAME_CHAR[code] === 1) {
            tokenizer2.pos++;
            return {
              type: "AtKeyword",
              name: scanWord(tokenizer2)
            };
          }
          return maybeToken(tokenizer2);
        case ASTERISK:
        case PLUSSIGN:
        case QUESTIONMARK:
        case NUMBERSIGN:
        case EXCLAMATIONMARK:
          break;
        case LEFTCURLYBRACKET:
          code = tokenizer2.nextCharCode();
          if (code < 48 || code > 57) {
            return maybeToken(tokenizer2);
          }
          break;
        default:
          return maybeToken(tokenizer2);
      }
    }
    function parse(source) {
      const tokenizer$1 = new tokenizer.Tokenizer(source);
      const result = readImplicitGroup(tokenizer$1);
      if (tokenizer$1.pos !== source.length) {
        tokenizer$1.error("Unexpected input");
      }
      if (result.terms.length === 1 && result.terms[0].type === "Group") {
        return result.terms[0];
      }
      return result;
    }
    exports2.parse = parse;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/match-graph.cjs
var require_match_graph2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/match-graph.cjs"(exports2) {
    "use strict";
    var parse = require_parse4();
    var MATCH = { type: "Match" };
    var MISMATCH = { type: "Mismatch" };
    var DISALLOW_EMPTY = { type: "DisallowEmpty" };
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function createCondition(match, thenBranch, elseBranch) {
      if (thenBranch === MATCH && elseBranch === MISMATCH) {
        return match;
      }
      if (match === MATCH && thenBranch === MATCH && elseBranch === MATCH) {
        return match;
      }
      if (match.type === "If" && match.else === MISMATCH && thenBranch === MATCH) {
        thenBranch = match.then;
        match = match.match;
      }
      return {
        type: "If",
        match,
        then: thenBranch,
        else: elseBranch
      };
    }
    function isFunctionType(name) {
      return name.length > 2 && name.charCodeAt(name.length - 2) === LEFTPARENTHESIS && name.charCodeAt(name.length - 1) === RIGHTPARENTHESIS;
    }
    function isEnumCapatible(term) {
      return term.type === "Keyword" || term.type === "AtKeyword" || term.type === "Function" || term.type === "Type" && isFunctionType(term.name);
    }
    function buildGroupMatchGraph(combinator, terms, atLeastOneTermMatched) {
      switch (combinator) {
        case " ": {
          let result = MATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            result = createCondition(
              term,
              result,
              MISMATCH
            );
          }
          return result;
        }
        case "|": {
          let result = MISMATCH;
          let map = null;
          for (let i = terms.length - 1; i >= 0; i--) {
            let term = terms[i];
            if (isEnumCapatible(term)) {
              if (map === null && i > 0 && isEnumCapatible(terms[i - 1])) {
                map = /* @__PURE__ */ Object.create(null);
                result = createCondition(
                  {
                    type: "Enum",
                    map
                  },
                  MATCH,
                  result
                );
              }
              if (map !== null) {
                const key = (isFunctionType(term.name) ? term.name.slice(0, -1) : term.name).toLowerCase();
                if (key in map === false) {
                  map[key] = term;
                  continue;
                }
              }
            }
            map = null;
            result = createCondition(
              term,
              MATCH,
              result
            );
          }
          return result;
        }
        case "&&": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: true
            };
          }
          let result = MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                false
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
        case "||": {
          if (terms.length > 5) {
            return {
              type: "MatchOnce",
              terms,
              all: false
            };
          }
          let result = atLeastOneTermMatched ? MATCH : MISMATCH;
          for (let i = terms.length - 1; i >= 0; i--) {
            const term = terms[i];
            let thenClause;
            if (terms.length > 1) {
              thenClause = buildGroupMatchGraph(
                combinator,
                terms.filter(function(newGroupTerm) {
                  return newGroupTerm !== term;
                }),
                true
              );
            } else {
              thenClause = MATCH;
            }
            result = createCondition(
              term,
              thenClause,
              result
            );
          }
          return result;
        }
      }
    }
    function buildMultiplierMatchGraph(node) {
      let result = MATCH;
      let matchTerm = buildMatchGraphInternal(node.term);
      if (node.max === 0) {
        matchTerm = createCondition(
          matchTerm,
          DISALLOW_EMPTY,
          MISMATCH
        );
        result = createCondition(
          matchTerm,
          null,
          // will be a loop
          MISMATCH
        );
        result.then = createCondition(
          MATCH,
          MATCH,
          result
          // make a loop
        );
        if (node.comma) {
          result.then.else = createCondition(
            { type: "Comma", syntax: node },
            result,
            MISMATCH
          );
        }
      } else {
        for (let i = node.min || 1; i <= node.max; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            createCondition(
              MATCH,
              MATCH,
              result
            ),
            MISMATCH
          );
        }
      }
      if (node.min === 0) {
        result = createCondition(
          MATCH,
          MATCH,
          result
        );
      } else {
        for (let i = 0; i < node.min - 1; i++) {
          if (node.comma && result !== MATCH) {
            result = createCondition(
              { type: "Comma", syntax: node },
              result,
              MISMATCH
            );
          }
          result = createCondition(
            matchTerm,
            result,
            MISMATCH
          );
        }
      }
      return result;
    }
    function buildMatchGraphInternal(node) {
      if (typeof node === "function") {
        return {
          type: "Generic",
          fn: node
        };
      }
      switch (node.type) {
        case "Group": {
          let result = buildGroupMatchGraph(
            node.combinator,
            node.terms.map(buildMatchGraphInternal),
            false
          );
          if (node.disallowEmpty) {
            result = createCondition(
              result,
              DISALLOW_EMPTY,
              MISMATCH
            );
          }
          return result;
        }
        case "Multiplier":
          return buildMultiplierMatchGraph(node);
        case "Type":
        case "Property":
          return {
            type: node.type,
            name: node.name,
            syntax: node
          };
        case "Keyword":
          return {
            type: node.type,
            name: node.name.toLowerCase(),
            syntax: node
          };
        case "AtKeyword":
          return {
            type: node.type,
            name: "@" + node.name.toLowerCase(),
            syntax: node
          };
        case "Function":
          return {
            type: node.type,
            name: node.name.toLowerCase() + "(",
            syntax: node
          };
        case "String":
          if (node.value.length === 3) {
            return {
              type: "Token",
              value: node.value.charAt(1),
              syntax: node
            };
          }
          return {
            type: node.type,
            value: node.value.substr(1, node.value.length - 2).replace(/\\'/g, "'"),
            syntax: node
          };
        case "Token":
          return {
            type: node.type,
            value: node.value,
            syntax: node
          };
        case "Comma":
          return {
            type: node.type,
            syntax: node
          };
        default:
          throw new Error("Unknown node type:", node.type);
      }
    }
    function buildMatchGraph(syntaxTree, ref) {
      if (typeof syntaxTree === "string") {
        syntaxTree = parse.parse(syntaxTree);
      }
      return {
        type: "MatchGraph",
        match: buildMatchGraphInternal(syntaxTree),
        syntax: ref || null,
        source: syntaxTree
      };
    }
    exports2.DISALLOW_EMPTY = DISALLOW_EMPTY;
    exports2.MATCH = MATCH;
    exports2.MISMATCH = MISMATCH;
    exports2.buildMatchGraph = buildMatchGraph;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/match.cjs
var require_match2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/match.cjs"(exports2) {
    "use strict";
    var matchGraph = require_match_graph2();
    var types = require_types3();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var STUB = 0;
    var TOKEN = 1;
    var OPEN_SYNTAX = 2;
    var CLOSE_SYNTAX = 3;
    var EXIT_REASON_MATCH = "Match";
    var EXIT_REASON_MISMATCH = "Mismatch";
    var EXIT_REASON_ITERATION_LIMIT = "Maximum iteration number exceeded (please fill an issue on https://github.com/csstree/csstree/issues)";
    var ITERATION_LIMIT = 15e3;
    function reverseList(list) {
      let prev = null;
      let next = null;
      let item = list;
      while (item !== null) {
        next = item.prev;
        item.prev = prev;
        prev = item;
        item = next;
      }
      return prev;
    }
    function areStringsEqualCaseInsensitive(testStr, referenceStr) {
      if (testStr.length !== referenceStr.length) {
        return false;
      }
      for (let i = 0; i < testStr.length; i++) {
        const referenceCode = referenceStr.charCodeAt(i);
        let testCode = testStr.charCodeAt(i);
        if (testCode >= 65 && testCode <= 90) {
          testCode = testCode | 32;
        }
        if (testCode !== referenceCode) {
          return false;
        }
      }
      return true;
    }
    function isContextEdgeDelim(token) {
      if (token.type !== types.Delim) {
        return false;
      }
      return token.value !== "?";
    }
    function isCommaContextStart(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.Comma || token.type === types.Function || token.type === types.LeftParenthesis || token.type === types.LeftSquareBracket || token.type === types.LeftCurlyBracket || isContextEdgeDelim(token);
    }
    function isCommaContextEnd(token) {
      if (token === null) {
        return true;
      }
      return token.type === types.RightParenthesis || token.type === types.RightSquareBracket || token.type === types.RightCurlyBracket || token.type === types.Delim && token.value === "/";
    }
    function internalMatch(tokens, state, syntaxes) {
      function moveToNextToken() {
        do {
          tokenIndex++;
          token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
        } while (token !== null && (token.type === types.WhiteSpace || token.type === types.Comment));
      }
      function getNextToken(offset) {
        const nextIndex = tokenIndex + offset;
        return nextIndex < tokens.length ? tokens[nextIndex] : null;
      }
      function stateSnapshotFromSyntax(nextState, prev) {
        return {
          nextState,
          matchStack,
          syntaxStack,
          thenStack,
          tokenIndex,
          prev
        };
      }
      function pushThenStack(nextState) {
        thenStack = {
          nextState,
          matchStack,
          syntaxStack,
          prev: thenStack
        };
      }
      function pushElseStack(nextState) {
        elseStack = stateSnapshotFromSyntax(nextState, elseStack);
      }
      function addTokenToMatch() {
        matchStack = {
          type: TOKEN,
          syntax: state.syntax,
          token,
          prev: matchStack
        };
        moveToNextToken();
        syntaxStash = null;
        if (tokenIndex > longestMatch) {
          longestMatch = tokenIndex;
        }
      }
      function openSyntax() {
        syntaxStack = {
          syntax: state.syntax,
          opts: state.syntax.opts || syntaxStack !== null && syntaxStack.opts || null,
          prev: syntaxStack
        };
        matchStack = {
          type: OPEN_SYNTAX,
          syntax: state.syntax,
          token: matchStack.token,
          prev: matchStack
        };
      }
      function closeSyntax() {
        if (matchStack.type === OPEN_SYNTAX) {
          matchStack = matchStack.prev;
        } else {
          matchStack = {
            type: CLOSE_SYNTAX,
            syntax: syntaxStack.syntax,
            token: matchStack.token,
            prev: matchStack
          };
        }
        syntaxStack = syntaxStack.prev;
      }
      let syntaxStack = null;
      let thenStack = null;
      let elseStack = null;
      let syntaxStash = null;
      let iterationCount = 0;
      let exitReason = null;
      let token = null;
      let tokenIndex = -1;
      let longestMatch = 0;
      let matchStack = {
        type: STUB,
        syntax: null,
        token: null,
        prev: null
      };
      moveToNextToken();
      while (exitReason === null && ++iterationCount < ITERATION_LIMIT) {
        switch (state.type) {
          case "Match":
            if (thenStack === null) {
              if (token !== null) {
                if (tokenIndex !== tokens.length - 1 || token.value !== "\\0" && token.value !== "\\9") {
                  state = matchGraph.MISMATCH;
                  break;
                }
              }
              exitReason = EXIT_REASON_MATCH;
              break;
            }
            state = thenStack.nextState;
            if (state === matchGraph.DISALLOW_EMPTY) {
              if (thenStack.matchStack === matchStack) {
                state = matchGraph.MISMATCH;
                break;
              } else {
                state = matchGraph.MATCH;
              }
            }
            while (thenStack.syntaxStack !== syntaxStack) {
              closeSyntax();
            }
            thenStack = thenStack.prev;
            break;
          case "Mismatch":
            if (syntaxStash !== null && syntaxStash !== false) {
              if (elseStack === null || tokenIndex > elseStack.tokenIndex) {
                elseStack = syntaxStash;
                syntaxStash = false;
              }
            } else if (elseStack === null) {
              exitReason = EXIT_REASON_MISMATCH;
              break;
            }
            state = elseStack.nextState;
            thenStack = elseStack.thenStack;
            syntaxStack = elseStack.syntaxStack;
            matchStack = elseStack.matchStack;
            tokenIndex = elseStack.tokenIndex;
            token = tokenIndex < tokens.length ? tokens[tokenIndex] : null;
            elseStack = elseStack.prev;
            break;
          case "MatchGraph":
            state = state.match;
            break;
          case "If":
            if (state.else !== matchGraph.MISMATCH) {
              pushElseStack(state.else);
            }
            if (state.then !== matchGraph.MATCH) {
              pushThenStack(state.then);
            }
            state = state.match;
            break;
          case "MatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state,
              index: 0,
              mask: 0
            };
            break;
          case "MatchOnceBuffer": {
            const terms = state.syntax.terms;
            if (state.index === terms.length) {
              if (state.mask === 0 || state.syntax.all) {
                state = matchGraph.MISMATCH;
                break;
              }
              state = matchGraph.MATCH;
              break;
            }
            if (state.mask === (1 << terms.length) - 1) {
              state = matchGraph.MATCH;
              break;
            }
            for (; state.index < terms.length; state.index++) {
              const matchFlag = 1 << state.index;
              if ((state.mask & matchFlag) === 0) {
                pushElseStack(state);
                pushThenStack({
                  type: "AddMatchOnce",
                  syntax: state.syntax,
                  mask: state.mask | matchFlag
                });
                state = terms[state.index++];
                break;
              }
            }
            break;
          }
          case "AddMatchOnce":
            state = {
              type: "MatchOnceBuffer",
              syntax: state.syntax,
              index: 0,
              mask: state.mask
            };
            break;
          case "Enum":
            if (token !== null) {
              let name = token.value.toLowerCase();
              if (name.indexOf("\\") !== -1) {
                name = name.replace(/\\[09].*$/, "");
              }
              if (hasOwnProperty2.call(state.map, name)) {
                state = state.map[name];
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          case "Generic": {
            const opts = syntaxStack !== null ? syntaxStack.opts : null;
            const lastTokenIndex2 = tokenIndex + Math.floor(state.fn(token, getNextToken, opts));
            if (!isNaN(lastTokenIndex2) && lastTokenIndex2 > tokenIndex) {
              while (tokenIndex < lastTokenIndex2) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          }
          case "Type":
          case "Property": {
            const syntaxDict = state.type === "Type" ? "types" : "properties";
            const dictSyntax = hasOwnProperty2.call(syntaxes, syntaxDict) ? syntaxes[syntaxDict][state.name] : null;
            if (!dictSyntax || !dictSyntax.match) {
              throw new Error(
                "Bad syntax reference: " + (state.type === "Type" ? "<" + state.name + ">" : "<'" + state.name + "'>")
              );
            }
            if (syntaxStash !== false && token !== null && state.type === "Type") {
              const lowPriorityMatching = (
                // https://drafts.csswg.org/css-values-4/#custom-idents
                // When parsing positionally-ambiguous keywords in a property value, a <custom-ident> production
                // can only claim the keyword if no other unfulfilled production can claim it.
                state.name === "custom-ident" && token.type === types.Ident || // https://drafts.csswg.org/css-values-4/#lengths
                // ... if a `0` could be parsed as either a <number> or a <length> in a property (such as line-height),
                // it must parse as a <number>
                state.name === "length" && token.value === "0"
              );
              if (lowPriorityMatching) {
                if (syntaxStash === null) {
                  syntaxStash = stateSnapshotFromSyntax(state, elseStack);
                }
                state = matchGraph.MISMATCH;
                break;
              }
            }
            openSyntax();
            state = dictSyntax.match;
            break;
          }
          case "Keyword": {
            const name = state.name;
            if (token !== null) {
              let keywordName = token.value;
              if (keywordName.indexOf("\\") !== -1) {
                keywordName = keywordName.replace(/\\[09].*$/, "");
              }
              if (areStringsEqualCaseInsensitive(keywordName, name)) {
                addTokenToMatch();
                state = matchGraph.MATCH;
                break;
              }
            }
            state = matchGraph.MISMATCH;
            break;
          }
          case "AtKeyword":
          case "Function":
            if (token !== null && areStringsEqualCaseInsensitive(token.value, state.name)) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Token":
            if (token !== null && token.value === state.value) {
              addTokenToMatch();
              state = matchGraph.MATCH;
              break;
            }
            state = matchGraph.MISMATCH;
            break;
          case "Comma":
            if (token !== null && token.type === types.Comma) {
              if (isCommaContextStart(matchStack.token)) {
                state = matchGraph.MISMATCH;
              } else {
                addTokenToMatch();
                state = isCommaContextEnd(token) ? matchGraph.MISMATCH : matchGraph.MATCH;
              }
            } else {
              state = isCommaContextStart(matchStack.token) || isCommaContextEnd(token) ? matchGraph.MATCH : matchGraph.MISMATCH;
            }
            break;
          case "String":
            let string = "";
            let lastTokenIndex = tokenIndex;
            for (; lastTokenIndex < tokens.length && string.length < state.value.length; lastTokenIndex++) {
              string += tokens[lastTokenIndex].value;
            }
            if (areStringsEqualCaseInsensitive(string, state.value)) {
              while (tokenIndex < lastTokenIndex) {
                addTokenToMatch();
              }
              state = matchGraph.MATCH;
            } else {
              state = matchGraph.MISMATCH;
            }
            break;
          default:
            throw new Error("Unknown node type: " + state.type);
        }
      }
      switch (exitReason) {
        case null:
          console.warn("[csstree-match] BREAK after " + ITERATION_LIMIT + " iterations");
          exitReason = EXIT_REASON_ITERATION_LIMIT;
          matchStack = null;
          break;
        case EXIT_REASON_MATCH:
          while (syntaxStack !== null) {
            closeSyntax();
          }
          break;
        default:
          matchStack = null;
      }
      return {
        tokens,
        reason: exitReason,
        iterations: iterationCount,
        match: matchStack,
        longestMatch
      };
    }
    function matchAsList(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match !== null) {
        let item = reverseList(matchResult.match).prev;
        matchResult.match = [];
        while (item !== null) {
          switch (item.type) {
            case OPEN_SYNTAX:
            case CLOSE_SYNTAX:
              matchResult.match.push({
                type: item.type,
                syntax: item.syntax
              });
              break;
            default:
              matchResult.match.push({
                token: item.token.value,
                node: item.token.node
              });
              break;
          }
          item = item.prev;
        }
      }
      return matchResult;
    }
    function matchAsTree(tokens, matchGraph2, syntaxes) {
      const matchResult = internalMatch(tokens, matchGraph2, syntaxes || {});
      if (matchResult.match === null) {
        return matchResult;
      }
      let item = matchResult.match;
      let host = matchResult.match = {
        syntax: matchGraph2.syntax || null,
        match: []
      };
      const hostStack = [host];
      item = reverseList(item).prev;
      while (item !== null) {
        switch (item.type) {
          case OPEN_SYNTAX:
            host.match.push(host = {
              syntax: item.syntax,
              match: []
            });
            hostStack.push(host);
            break;
          case CLOSE_SYNTAX:
            hostStack.pop();
            host = hostStack[hostStack.length - 1];
            break;
          default:
            host.match.push({
              syntax: item.syntax || null,
              token: item.token.value,
              node: item.token.node
            });
        }
        item = item.prev;
      }
      return matchResult;
    }
    exports2.matchAsList = matchAsList;
    exports2.matchAsTree = matchAsTree;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/trace.cjs
var require_trace2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/trace.cjs"(exports2) {
    "use strict";
    function getTrace(node) {
      function shouldPutToTrace(syntax) {
        if (syntax === null) {
          return false;
        }
        return syntax.type === "Type" || syntax.type === "Property" || syntax.type === "Keyword";
      }
      function hasMatch(matchNode) {
        if (Array.isArray(matchNode.match)) {
          for (let i = 0; i < matchNode.match.length; i++) {
            if (hasMatch(matchNode.match[i])) {
              if (shouldPutToTrace(matchNode.syntax)) {
                result.unshift(matchNode.syntax);
              }
              return true;
            }
          }
        } else if (matchNode.node === node) {
          result = shouldPutToTrace(matchNode.syntax) ? [matchNode.syntax] : [];
          return true;
        }
        return false;
      }
      let result = null;
      if (this.matched !== null) {
        hasMatch(this.matched);
      }
      return result;
    }
    function isType(node, type) {
      return testNode(this, node, (match) => match.type === "Type" && match.name === type);
    }
    function isProperty(node, property) {
      return testNode(this, node, (match) => match.type === "Property" && match.name === property);
    }
    function isKeyword(node) {
      return testNode(this, node, (match) => match.type === "Keyword");
    }
    function testNode(match, node, fn) {
      const trace = getTrace.call(match, node);
      if (trace === null) {
        return false;
      }
      return trace.some(fn);
    }
    exports2.getTrace = getTrace;
    exports2.isKeyword = isKeyword;
    exports2.isProperty = isProperty;
    exports2.isType = isType;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/search.cjs
var require_search2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/search.cjs"(exports2) {
    "use strict";
    var List = require_List2();
    function getFirstMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getFirstMatchNode(matchNode.match[0]);
    }
    function getLastMatchNode(matchNode) {
      if ("node" in matchNode) {
        return matchNode.node;
      }
      return getLastMatchNode(matchNode.match[matchNode.match.length - 1]);
    }
    function matchFragments(lexer, ast, match, type, name) {
      function findFragments(matchNode) {
        if (matchNode.syntax !== null && matchNode.syntax.type === type && matchNode.syntax.name === name) {
          const start = getFirstMatchNode(matchNode);
          const end = getLastMatchNode(matchNode);
          lexer.syntax.walk(ast, function(node, item, list) {
            if (node === start) {
              const nodes = new List.List();
              do {
                nodes.appendData(item.data);
                if (item.data === end) {
                  break;
                }
                item = item.next;
              } while (item !== null);
              fragments.push({
                parent: list,
                nodes
              });
            }
          });
        }
        if (Array.isArray(matchNode.match)) {
          matchNode.match.forEach(findFragments);
        }
      }
      const fragments = [];
      if (match.matched !== null) {
        findFragments(match.matched);
      }
      return fragments;
    }
    exports2.matchFragments = matchFragments;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/structure.cjs
var require_structure2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/structure.cjs"(exports2) {
    "use strict";
    var List = require_List2();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function isValidNumber(value) {
      return typeof value === "number" && isFinite(value) && Math.floor(value) === value && value >= 0;
    }
    function isValidLocation(loc) {
      return Boolean(loc) && isValidNumber(loc.offset) && isValidNumber(loc.line) && isValidNumber(loc.column);
    }
    function createNodeStructureChecker(type, fields) {
      return function checkNode(node, warn) {
        if (!node || node.constructor !== Object) {
          return warn(node, "Type of node should be an Object");
        }
        for (let key in node) {
          let valid = true;
          if (hasOwnProperty2.call(node, key) === false) {
            continue;
          }
          if (key === "type") {
            if (node.type !== type) {
              warn(node, "Wrong node type `" + node.type + "`, expected `" + type + "`");
            }
          } else if (key === "loc") {
            if (node.loc === null) {
              continue;
            } else if (node.loc && node.loc.constructor === Object) {
              if (typeof node.loc.source !== "string") {
                key += ".source";
              } else if (!isValidLocation(node.loc.start)) {
                key += ".start";
              } else if (!isValidLocation(node.loc.end)) {
                key += ".end";
              } else {
                continue;
              }
            }
            valid = false;
          } else if (fields.hasOwnProperty(key)) {
            valid = false;
            for (let i = 0; !valid && i < fields[key].length; i++) {
              const fieldType = fields[key][i];
              switch (fieldType) {
                case String:
                  valid = typeof node[key] === "string";
                  break;
                case Boolean:
                  valid = typeof node[key] === "boolean";
                  break;
                case null:
                  valid = node[key] === null;
                  break;
                default:
                  if (typeof fieldType === "string") {
                    valid = node[key] && node[key].type === fieldType;
                  } else if (Array.isArray(fieldType)) {
                    valid = node[key] instanceof List.List;
                  }
              }
            }
          } else {
            warn(node, "Unknown field `" + key + "` for " + type + " node type");
          }
          if (!valid) {
            warn(node, "Bad value for `" + type + "." + key + "`");
          }
        }
        for (const key in fields) {
          if (hasOwnProperty2.call(fields, key) && hasOwnProperty2.call(node, key) === false) {
            warn(node, "Field `" + type + "." + key + "` is missed");
          }
        }
      };
    }
    function processStructure(name, nodeType) {
      const structure = nodeType.structure;
      const fields = {
        type: String,
        loc: true
      };
      const docs = {
        type: '"' + name + '"'
      };
      for (const key in structure) {
        if (hasOwnProperty2.call(structure, key) === false) {
          continue;
        }
        const docsTypes = [];
        const fieldTypes = fields[key] = Array.isArray(structure[key]) ? structure[key].slice() : [structure[key]];
        for (let i = 0; i < fieldTypes.length; i++) {
          const fieldType = fieldTypes[i];
          if (fieldType === String || fieldType === Boolean) {
            docsTypes.push(fieldType.name);
          } else if (fieldType === null) {
            docsTypes.push("null");
          } else if (typeof fieldType === "string") {
            docsTypes.push("<" + fieldType + ">");
          } else if (Array.isArray(fieldType)) {
            docsTypes.push("List");
          } else {
            throw new Error("Wrong value `" + fieldType + "` in `" + name + "." + key + "` structure definition");
          }
        }
        docs[key] = docsTypes.join(" | ");
      }
      return {
        docs,
        check: createNodeStructureChecker(name, fields)
      };
    }
    function getStructureFromConfig(config) {
      const structure = {};
      if (config.node) {
        for (const name in config.node) {
          if (hasOwnProperty2.call(config.node, name)) {
            const nodeType = config.node[name];
            if (nodeType.structure) {
              structure[name] = processStructure(name, nodeType);
            } else {
              throw new Error("Missed `structure` field in `" + name + "` node type definition");
            }
          }
        }
      }
      return structure;
    }
    exports2.getStructureFromConfig = getStructureFromConfig;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/walk.cjs
var require_walk2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/walk.cjs"(exports2) {
    "use strict";
    var noop = function() {
    };
    function ensureFunction(value) {
      return typeof value === "function" ? value : noop;
    }
    function walk(node, options, context) {
      function walk2(node2) {
        enter.call(context, node2);
        switch (node2.type) {
          case "Group":
            node2.terms.forEach(walk2);
            break;
          case "Multiplier":
            walk2(node2.term);
            break;
          case "Type":
          case "Property":
          case "Keyword":
          case "AtKeyword":
          case "Function":
          case "String":
          case "Token":
          case "Comma":
            break;
          default:
            throw new Error("Unknown type: " + node2.type);
        }
        leave.call(context, node2);
      }
      let enter = noop;
      let leave = noop;
      if (typeof options === "function") {
        enter = options;
      } else if (options) {
        enter = ensureFunction(options.enter);
        leave = ensureFunction(options.leave);
      }
      if (enter === noop && leave === noop) {
        throw new Error("Neither `enter` nor `leave` walker handler is set or both aren't a function");
      }
      walk2(node);
    }
    exports2.walk = walk;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/lexer/Lexer.cjs
var require_Lexer2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/lexer/Lexer.cjs"(exports2) {
    "use strict";
    var error = require_error2();
    var names = require_names4();
    var genericConst = require_generic_const2();
    var generic = require_generic2();
    var prepareTokens = require_prepare_tokens2();
    var matchGraph = require_match_graph2();
    var match = require_match2();
    var trace = require_trace2();
    var search = require_search2();
    var structure = require_structure2();
    var parse = require_parse4();
    var generate = require_generate2();
    var walk = require_walk2();
    var cssWideKeywordsSyntax = matchGraph.buildMatchGraph(genericConst.cssWideKeywords.join(" | "));
    function dumpMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const name in map) {
        if (map[name].syntax) {
          result[name] = syntaxAsAst ? map[name].syntax : generate.generate(map[name].syntax, { compact });
        }
      }
      return result;
    }
    function dumpAtruleMapSyntax(map, compact, syntaxAsAst) {
      const result = {};
      for (const [name, atrule] of Object.entries(map)) {
        result[name] = {
          prelude: atrule.prelude && (syntaxAsAst ? atrule.prelude.syntax : generate.generate(atrule.prelude.syntax, { compact })),
          descriptors: atrule.descriptors && dumpMapSyntax(atrule.descriptors, compact, syntaxAsAst)
        };
      }
      return result;
    }
    function valueHasVar(tokens) {
      for (let i = 0; i < tokens.length; i++) {
        if (tokens[i].value.toLowerCase() === "var(") {
          return true;
        }
      }
      return false;
    }
    function buildMatchResult(matched, error2, iterations) {
      return {
        matched,
        iterations,
        error: error2,
        ...trace
      };
    }
    function matchSyntax(lexer, syntax, value, useCssWideKeywords) {
      const tokens = prepareTokens(value, lexer.syntax);
      let result;
      if (valueHasVar(tokens)) {
        return buildMatchResult(null, new Error("Matching for a tree with var() is not supported"));
      }
      if (useCssWideKeywords) {
        result = match.matchAsTree(tokens, lexer.cssWideKeywordsSyntax, lexer);
      }
      if (!useCssWideKeywords || !result.match) {
        result = match.matchAsTree(tokens, syntax.match, lexer);
        if (!result.match) {
          return buildMatchResult(
            null,
            new error.SyntaxMatchError(result.reason, syntax.syntax, value, result),
            result.iterations
          );
        }
      }
      return buildMatchResult(result.match, null, result.iterations);
    }
    var Lexer = class {
      constructor(config, syntax, structure$1) {
        this.cssWideKeywordsSyntax = cssWideKeywordsSyntax;
        this.syntax = syntax;
        this.generic = false;
        this.atrules = /* @__PURE__ */ Object.create(null);
        this.properties = /* @__PURE__ */ Object.create(null);
        this.types = /* @__PURE__ */ Object.create(null);
        this.structure = structure$1 || structure.getStructureFromConfig(config);
        if (config) {
          if (config.types) {
            for (const name in config.types) {
              this.addType_(name, config.types[name]);
            }
          }
          if (config.generic) {
            this.generic = true;
            for (const name in generic) {
              this.addType_(name, generic[name]);
            }
          }
          if (config.atrules) {
            for (const name in config.atrules) {
              this.addAtrule_(name, config.atrules[name]);
            }
          }
          if (config.properties) {
            for (const name in config.properties) {
              this.addProperty_(name, config.properties[name]);
            }
          }
        }
      }
      checkStructure(ast) {
        function collectWarning(node, message) {
          warns.push({ node, message });
        }
        const structure2 = this.structure;
        const warns = [];
        this.syntax.walk(ast, function(node) {
          if (structure2.hasOwnProperty(node.type)) {
            structure2[node.type].check(node, collectWarning);
          } else {
            collectWarning(node, "Unknown node type `" + node.type + "`");
          }
        });
        return warns.length ? warns : false;
      }
      createDescriptor(syntax, type, name, parent = null) {
        const ref = {
          type,
          name
        };
        const descriptor = {
          type,
          name,
          parent,
          serializable: typeof syntax === "string" || syntax && typeof syntax.type === "string",
          syntax: null,
          match: null
        };
        if (typeof syntax === "function") {
          descriptor.match = matchGraph.buildMatchGraph(syntax, ref);
        } else {
          if (typeof syntax === "string") {
            Object.defineProperty(descriptor, "syntax", {
              get() {
                Object.defineProperty(descriptor, "syntax", {
                  value: parse.parse(syntax)
                });
                return descriptor.syntax;
              }
            });
          } else {
            descriptor.syntax = syntax;
          }
          Object.defineProperty(descriptor, "match", {
            get() {
              Object.defineProperty(descriptor, "match", {
                value: matchGraph.buildMatchGraph(descriptor.syntax, ref)
              });
              return descriptor.match;
            }
          });
        }
        return descriptor;
      }
      addAtrule_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.atrules[name] = {
          type: "Atrule",
          name,
          prelude: syntax.prelude ? this.createDescriptor(syntax.prelude, "AtrulePrelude", name) : null,
          descriptors: syntax.descriptors ? Object.keys(syntax.descriptors).reduce(
            (map, descName) => {
              map[descName] = this.createDescriptor(syntax.descriptors[descName], "AtruleDescriptor", descName, name);
              return map;
            },
            /* @__PURE__ */ Object.create(null)
          ) : null
        };
      }
      addProperty_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.properties[name] = this.createDescriptor(syntax, "Property", name);
      }
      addType_(name, syntax) {
        if (!syntax) {
          return;
        }
        this.types[name] = this.createDescriptor(syntax, "Type", name);
      }
      checkAtruleName(atruleName) {
        if (!this.getAtrule(atruleName)) {
          return new error.SyntaxReferenceError("Unknown at-rule", "@" + atruleName);
        }
      }
      checkAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtruleName(atruleName);
        if (error2) {
          return error2;
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude && prelude) {
          return new SyntaxError("At-rule `@" + atruleName + "` should not contain a prelude");
        }
        if (atrule.prelude && !prelude) {
          if (!matchSyntax(this, atrule.prelude, "", false).matched) {
            return new SyntaxError("At-rule `@" + atruleName + "` should contain a prelude");
          }
        }
      }
      checkAtruleDescriptorName(atruleName, descriptorName) {
        const error$1 = this.checkAtruleName(atruleName);
        if (error$1) {
          return error$1;
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        if (!atrule.descriptors) {
          return new SyntaxError("At-rule `@" + atruleName + "` has no known descriptors");
        }
        if (!atrule.descriptors[descriptor.name] && !atrule.descriptors[descriptor.basename]) {
          return new error.SyntaxReferenceError("Unknown at-rule descriptor", descriptorName);
        }
      }
      checkPropertyName(propertyName) {
        if (!this.getProperty(propertyName)) {
          return new error.SyntaxReferenceError("Unknown property", propertyName);
        }
      }
      matchAtrulePrelude(atruleName, prelude) {
        const error2 = this.checkAtrulePrelude(atruleName, prelude);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        if (!atrule.prelude) {
          return buildMatchResult(null, null);
        }
        return matchSyntax(this, atrule.prelude, prelude || "", false);
      }
      matchAtruleDescriptor(atruleName, descriptorName, value) {
        const error2 = this.checkAtruleDescriptorName(atruleName, descriptorName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        const atrule = this.getAtrule(atruleName);
        const descriptor = names.keyword(descriptorName);
        return matchSyntax(this, atrule.descriptors[descriptor.name] || atrule.descriptors[descriptor.basename], value, false);
      }
      matchDeclaration(node) {
        if (node.type !== "Declaration") {
          return buildMatchResult(null, new Error("Not a Declaration node"));
        }
        return this.matchProperty(node.property, node.value);
      }
      matchProperty(propertyName, value) {
        if (names.property(propertyName).custom) {
          return buildMatchResult(null, new Error("Lexer matching doesn't applicable for custom properties"));
        }
        const error2 = this.checkPropertyName(propertyName);
        if (error2) {
          return buildMatchResult(null, error2);
        }
        return matchSyntax(this, this.getProperty(propertyName), value, true);
      }
      matchType(typeName, value) {
        const typeSyntax = this.getType(typeName);
        if (!typeSyntax) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Unknown type", typeName));
        }
        return matchSyntax(this, typeSyntax, value, false);
      }
      match(syntax, value) {
        if (typeof syntax !== "string" && (!syntax || !syntax.type)) {
          return buildMatchResult(null, new error.SyntaxReferenceError("Bad syntax"));
        }
        if (typeof syntax === "string" || !syntax.match) {
          syntax = this.createDescriptor(syntax, "Type", "anonymous");
        }
        return matchSyntax(this, syntax, value, false);
      }
      findValueFragments(propertyName, value, type, name) {
        return search.matchFragments(this, value, this.matchProperty(propertyName, value), type, name);
      }
      findDeclarationValueFragments(declaration, type, name) {
        return search.matchFragments(this, declaration.value, this.matchDeclaration(declaration), type, name);
      }
      findAllFragments(ast, type, name) {
        const result = [];
        this.syntax.walk(ast, {
          visit: "Declaration",
          enter: (declaration) => {
            result.push.apply(result, this.findDeclarationValueFragments(declaration, type, name));
          }
        });
        return result;
      }
      getAtrule(atruleName, fallbackBasename = true) {
        const atrule = names.keyword(atruleName);
        const atruleEntry = atrule.vendor && fallbackBasename ? this.atrules[atrule.name] || this.atrules[atrule.basename] : this.atrules[atrule.name];
        return atruleEntry || null;
      }
      getAtrulePrelude(atruleName, fallbackBasename = true) {
        const atrule = this.getAtrule(atruleName, fallbackBasename);
        return atrule && atrule.prelude || null;
      }
      getAtruleDescriptor(atruleName, name) {
        return this.atrules.hasOwnProperty(atruleName) && this.atrules.declarators ? this.atrules[atruleName].declarators[name] || null : null;
      }
      getProperty(propertyName, fallbackBasename = true) {
        const property = names.property(propertyName);
        const propertyEntry = property.vendor && fallbackBasename ? this.properties[property.name] || this.properties[property.basename] : this.properties[property.name];
        return propertyEntry || null;
      }
      getType(name) {
        return hasOwnProperty.call(this.types, name) ? this.types[name] : null;
      }
      validate() {
        function validate(syntax, name, broken, descriptor) {
          if (broken.has(name)) {
            return broken.get(name);
          }
          broken.set(name, false);
          if (descriptor.syntax !== null) {
            walk.walk(descriptor.syntax, function(node) {
              if (node.type !== "Type" && node.type !== "Property") {
                return;
              }
              const map = node.type === "Type" ? syntax.types : syntax.properties;
              const brokenMap = node.type === "Type" ? brokenTypes : brokenProperties;
              if (!hasOwnProperty.call(map, node.name) || validate(syntax, node.name, brokenMap, map[node.name])) {
                broken.set(name, true);
              }
            }, this);
          }
        }
        let brokenTypes = /* @__PURE__ */ new Map();
        let brokenProperties = /* @__PURE__ */ new Map();
        for (const key in this.types) {
          validate(this, key, brokenTypes, this.types[key]);
        }
        for (const key in this.properties) {
          validate(this, key, brokenProperties, this.properties[key]);
        }
        brokenTypes = [...brokenTypes.keys()].filter((name) => brokenTypes.get(name));
        brokenProperties = [...brokenProperties.keys()].filter((name) => brokenProperties.get(name));
        if (brokenTypes.length || brokenProperties.length) {
          return {
            types: brokenTypes,
            properties: brokenProperties
          };
        }
        return null;
      }
      dump(syntaxAsAst, pretty) {
        return {
          generic: this.generic,
          types: dumpMapSyntax(this.types, !pretty, syntaxAsAst),
          properties: dumpMapSyntax(this.properties, !pretty, syntaxAsAst),
          atrules: dumpAtruleMapSyntax(this.atrules, !pretty, syntaxAsAst)
        };
      }
      toString() {
        return JSON.stringify(this.dump());
      }
    };
    exports2.Lexer = Lexer;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/config/mix.cjs
var require_mix2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/config/mix.cjs"(exports2, module2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var shape = {
      generic: true,
      types: appendOrAssign,
      atrules: {
        prelude: appendOrAssignOrNull,
        descriptors: appendOrAssignOrNull
      },
      properties: appendOrAssign,
      parseContext: assign,
      scope: deepAssign,
      atrule: ["parse"],
      pseudo: ["parse"],
      node: ["name", "structure", "parse", "generate", "walkContext"]
    };
    function isObject(value) {
      return value && value.constructor === Object;
    }
    function copy(value) {
      return isObject(value) ? { ...value } : value;
    }
    function assign(dest, src) {
      return Object.assign(dest, src);
    }
    function deepAssign(dest, src) {
      for (const key in src) {
        if (hasOwnProperty2.call(src, key)) {
          if (isObject(dest[key])) {
            deepAssign(dest[key], src[key]);
          } else {
            dest[key] = copy(src[key]);
          }
        }
      }
      return dest;
    }
    function append(a, b) {
      if (typeof b === "string" && /^\s*\|/.test(b)) {
        return typeof a === "string" ? a + b : b.replace(/^\s*\|\s*/, "");
      }
      return b || null;
    }
    function appendOrAssign(a, b) {
      if (typeof b === "string") {
        return append(a, b);
      }
      const result = { ...a };
      for (let key in b) {
        if (hasOwnProperty2.call(b, key)) {
          result[key] = append(hasOwnProperty2.call(a, key) ? a[key] : void 0, b[key]);
        }
      }
      return result;
    }
    function appendOrAssignOrNull(a, b) {
      const result = appendOrAssign(a, b);
      return !isObject(result) || Object.keys(result).length ? result : null;
    }
    function mix(dest, src, shape2) {
      for (const key in shape2) {
        if (hasOwnProperty2.call(shape2, key) === false) {
          continue;
        }
        if (shape2[key] === true) {
          if (hasOwnProperty2.call(src, key)) {
            dest[key] = copy(src[key]);
          }
        } else if (shape2[key]) {
          if (typeof shape2[key] === "function") {
            const fn = shape2[key];
            dest[key] = fn({}, dest[key]);
            dest[key] = fn(dest[key] || {}, src[key]);
          } else if (isObject(shape2[key])) {
            const result = {};
            for (let name in dest[key]) {
              result[name] = mix({}, dest[key][name], shape2[key]);
            }
            for (let name in src[key]) {
              result[name] = mix(result[name] || {}, src[key][name], shape2[key]);
            }
            dest[key] = result;
          } else if (Array.isArray(shape2[key])) {
            const res = {};
            const innerShape = shape2[key].reduce(function(s, k) {
              s[k] = true;
              return s;
            }, {});
            for (const [name, value] of Object.entries(dest[key] || {})) {
              res[name] = {};
              if (value) {
                mix(res[name], value, innerShape);
              }
            }
            for (const name in src[key]) {
              if (hasOwnProperty2.call(src[key], name)) {
                if (!res[name]) {
                  res[name] = {};
                }
                if (src[key] && src[key][name]) {
                  mix(res[name], src[key][name], innerShape);
                }
              }
            }
            dest[key] = res;
          }
        }
      }
      return dest;
    }
    var mix$1 = (dest, src) => mix(dest, src, shape);
    module2.exports = mix$1;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/create.cjs
var require_create10 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/create.cjs"(exports2, module2) {
    "use strict";
    var index = require_tokenizer3();
    var create = require_create6();
    var create$2 = require_create7();
    var create$3 = require_create8();
    var create$1 = require_create9();
    var Lexer = require_Lexer2();
    var mix = require_mix2();
    function createSyntax(config) {
      const parse = create.createParser(config);
      const walk = create$1.createWalker(config);
      const generate = create$2.createGenerator(config);
      const { fromPlainObject, toPlainObject } = create$3.createConvertor(walk);
      const syntax = {
        lexer: null,
        createLexer: (config2) => new Lexer.Lexer(config2, syntax, syntax.lexer.structure),
        tokenize: index.tokenize,
        parse,
        generate,
        walk,
        find: walk.find,
        findLast: walk.findLast,
        findAll: walk.findAll,
        fromPlainObject,
        toPlainObject,
        fork(extension) {
          const base = mix({}, config);
          return createSyntax(
            typeof extension === "function" ? extension(base, Object.assign) : mix(base, extension)
          );
        }
      };
      syntax.lexer = new Lexer.Lexer({
        generic: true,
        types: config.types,
        atrules: config.atrules,
        properties: config.properties,
        node: config.node
      }, syntax);
      return syntax;
    }
    var createSyntax$1 = (config) => createSyntax(mix({}, config));
    module2.exports = createSyntax$1;
  }
});

// node_modules/csso/node_modules/css-tree/data/patch.json
var require_patch2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/data/patch.json"(exports2, module2) {
    module2.exports = {
      atrules: {
        charset: {
          prelude: "<string>"
        },
        "font-face": {
          descriptors: {
            "unicode-range": {
              comment: "replaces <unicode-range>, an old production name",
              syntax: "<urange>#"
            }
          }
        }
      },
      properties: {
        "-moz-background-clip": {
          comment: "deprecated syntax in old Firefox, https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "padding | border"
        },
        "-moz-border-radius-bottomleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-left-radius",
          syntax: "<'border-bottom-left-radius'>"
        },
        "-moz-border-radius-bottomright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-border-radius-topleft": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-top-left-radius",
          syntax: "<'border-top-left-radius'>"
        },
        "-moz-border-radius-topright": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/border-bottom-right-radius",
          syntax: "<'border-bottom-right-radius'>"
        },
        "-moz-control-character-visibility": {
          comment: "firefox specific keywords, https://bugzilla.mozilla.org/show_bug.cgi?id=947588",
          syntax: "visible | hidden"
        },
        "-moz-osx-font-smoothing": {
          comment: "misssed old syntax https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | grayscale"
        },
        "-moz-user-select": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "none | text | all | -moz-none"
        },
        "-ms-flex-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "start | end | center | baseline | stretch"
        },
        "-ms-flex-item-align": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-align",
          syntax: "auto | start | end | center | baseline | stretch"
        },
        "-ms-flex-line-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-line-pack",
          syntax: "start | end | center | justify | distribute | stretch"
        },
        "-ms-flex-negative": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-shrink'>"
        },
        "-ms-flex-pack": {
          comment: "misssed old syntax implemented in IE, https://www.w3.org/TR/2012/WD-css3-flexbox-20120322/#flex-pack",
          syntax: "start | end | center | justify | distribute"
        },
        "-ms-flex-order": {
          comment: "misssed old syntax implemented in IE; https://msdn.microsoft.com/en-us/library/jj127303(v=vs.85).aspx",
          syntax: "<integer>"
        },
        "-ms-flex-positive": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-grow'>"
        },
        "-ms-flex-preferred-size": {
          comment: "misssed old syntax implemented in IE; TODO: find references for comfirmation",
          syntax: "<'flex-basis'>"
        },
        "-ms-interpolation-mode": {
          comment: "https://msdn.microsoft.com/en-us/library/ff521095(v=vs.85).aspx",
          syntax: "nearest-neighbor | bicubic"
        },
        "-ms-grid-column-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466338.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-grid-row-align": {
          comment: "add this property first since it uses as fallback for flexbox, https://msdn.microsoft.com/en-us/library/windows/apps/hh466348.aspx",
          syntax: "start | end | center | stretch"
        },
        "-ms-hyphenate-limit-last": {
          comment: "misssed old syntax implemented in IE; https://www.w3.org/TR/css-text-4/#hyphenate-line-limits",
          syntax: "none | always | column | page | spread"
        },
        "-webkit-appearance": {
          comment: "webkit specific keywords",
          references: [
            "http://css-infos.net/property/-webkit-appearance"
          ],
          syntax: "none | button | button-bevel | caps-lock-indicator | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbargripper-horizontal | scrollbargripper-vertical | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button"
        },
        "-webkit-background-clip": {
          comment: "https://developer.mozilla.org/en/docs/Web/CSS/background-clip",
          syntax: "[ <box> | border | padding | content | text ]#"
        },
        "-webkit-column-break-after": {
          comment: "added, http://help.dottoro.com/lcrthhhv.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-before": {
          comment: "added, http://help.dottoro.com/lcxquvkf.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-column-break-inside": {
          comment: "added, http://help.dottoro.com/lclhnthl.php",
          syntax: "always | auto | avoid"
        },
        "-webkit-font-smoothing": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/font-smooth",
          syntax: "auto | none | antialiased | subpixel-antialiased"
        },
        "-webkit-mask-box-image": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "[ <url> | <gradient> | none ] [ <length-percentage>{4} <-webkit-mask-box-repeat>{2} ]?"
        },
        "-webkit-print-color-adjust": {
          comment: "missed",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/-webkit-print-color-adjust"
          ],
          syntax: "economy | exact"
        },
        "-webkit-text-security": {
          comment: "missed; http://help.dottoro.com/lcbkewgt.php",
          syntax: "none | circle | disc | square"
        },
        "-webkit-user-drag": {
          comment: "missed; http://help.dottoro.com/lcbixvwm.php",
          syntax: "none | element | auto"
        },
        "-webkit-user-select": {
          comment: "auto is supported by old webkit, https://developer.mozilla.org/en-US/docs/Web/CSS/user-select",
          syntax: "auto | none | text | all"
        },
        "alignment-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#AlignmentBaselineProperty"
          ],
          syntax: "auto | baseline | before-edge | text-before-edge | middle | central | after-edge | text-after-edge | ideographic | alphabetic | hanging | mathematical"
        },
        "background-clip": {
          comment: "used <bg-clip> from CSS Backgrounds and Borders 4 since it adds new values",
          references: [
            "https://github.com/csstree/csstree/issues/190"
          ],
          syntax: "<bg-clip>#"
        },
        "baseline-shift": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#BaselineShiftProperty"
          ],
          syntax: "baseline | sub | super | <svg-length>"
        },
        behavior: {
          comment: "added old IE property https://msdn.microsoft.com/en-us/library/ms530723(v=vs.85).aspx",
          syntax: "<url>+"
        },
        "clip-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/masking.html#ClipRuleProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        cue: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'cue-before'> <'cue-after'>?"
        },
        "cue-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        "cue-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<url> <decibel>? | none"
        },
        cursor: {
          comment: "added legacy keywords: hand, -webkit-grab. -webkit-grabbing, -webkit-zoom-in, -webkit-zoom-out, -moz-grab, -moz-grabbing, -moz-zoom-in, -moz-zoom-out",
          references: [
            "https://www.sitepoint.com/css3-cursor-styles/"
          ],
          syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing | hand | -webkit-grab | -webkit-grabbing | -webkit-zoom-in | -webkit-zoom-out | -moz-grab | -moz-grabbing | -moz-zoom-in | -moz-zoom-out ] ]"
        },
        display: {
          comment: "extended with -ms-flexbox",
          syntax: "| <-non-standard-display>"
        },
        position: {
          comment: "extended with -webkit-sticky",
          syntax: "| -webkit-sticky"
        },
        "dominant-baseline": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#DominantBaselineProperty"
          ],
          syntax: "auto | use-script | no-change | reset-size | ideographic | alphabetic | hanging | mathematical | central | middle | text-after-edge | text-before-edge"
        },
        "image-rendering": {
          comment: "extended with <-non-standard-image-rendering>, added SVG keywords optimizeSpeed and optimizeQuality",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/image-rendering",
            "https://www.w3.org/TR/SVG/painting.html#ImageRenderingProperty"
          ],
          syntax: "| optimizeSpeed | optimizeQuality | <-non-standard-image-rendering>"
        },
        fill: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<paint>"
        },
        "fill-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "<number-zero-one>"
        },
        "fill-rule": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#FillProperty"
          ],
          syntax: "nonzero | evenodd"
        },
        filter: {
          comment: "extend with IE legacy syntaxes",
          syntax: "| <-ms-filter-function-list>"
        },
        "glyph-orientation-horizontal": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationHorizontalProperty"
          ],
          syntax: "<angle>"
        },
        "glyph-orientation-vertical": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#GlyphOrientationVerticalProperty"
          ],
          syntax: "<angle>"
        },
        kerning: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#KerningProperty"
          ],
          syntax: "auto | <svg-length>"
        },
        "letter-spacing": {
          comment: "fix syntax <length> -> <length-percentage>",
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/SVG/Attribute/letter-spacing"
          ],
          syntax: "normal | <length-percentage>"
        },
        marker: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-end": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-mid": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "marker-start": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#MarkerProperties"
          ],
          syntax: "none | <url>"
        },
        "max-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/max-width",
          syntax: "| <-non-standard-width>"
        },
        width: {
          references: [
            "https://developer.mozilla.org/en-US/docs/Web/CSS/width",
            "https://github.com/csstree/stylelint-validator/issues/29"
          ],
          syntax: "| fill | stretch | intrinsic | -moz-max-content | -webkit-max-content | -moz-fit-content | -webkit-fit-content"
        },
        "min-width": {
          comment: "extend by non-standard width keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "| <-non-standard-width>"
        },
        overflow: {
          comment: "extend by vendor keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "| <-non-standard-overflow>"
        },
        pause: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'pause-before'> <'pause-after'>?"
        },
        "pause-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "pause-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        rest: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<'rest-before'> <'rest-after'>?"
        },
        "rest-after": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "rest-before": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<time> | none | x-weak | weak | medium | strong | x-strong"
        },
        "shape-rendering": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#ShapeRenderingPropert"
          ],
          syntax: "auto | optimizeSpeed | crispEdges | geometricPrecision"
        },
        src: {
          comment: "added @font-face's src property https://developer.mozilla.org/en-US/docs/Web/CSS/@font-face/src",
          syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#"
        },
        speak: {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | none | normal"
        },
        "speak-as": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | spell-out || digits || [ literal-punctuation | no-punctuation ]"
        },
        stroke: {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<paint>"
        },
        "stroke-dasharray": {
          comment: "added SVG property; a list of comma and/or white space separated <length>s and <percentage>s",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "none | [ <svg-length>+ ]#"
        },
        "stroke-dashoffset": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "stroke-linecap": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "butt | round | square"
        },
        "stroke-linejoin": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "miter | round | bevel"
        },
        "stroke-miterlimit": {
          comment: "added SVG property (<miterlimit> = <number-one-or-greater>) ",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-one-or-greater>"
        },
        "stroke-opacity": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<number-zero-one>"
        },
        "stroke-width": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/painting.html#StrokeProperties"
          ],
          syntax: "<svg-length>"
        },
        "text-anchor": {
          comment: "added SVG property",
          references: [
            "https://www.w3.org/TR/SVG/text.html#TextAlignmentProperties"
          ],
          syntax: "start | middle | end"
        },
        "unicode-bidi": {
          comment: "added prefixed keywords https://developer.mozilla.org/en-US/docs/Web/CSS/unicode-bidi",
          syntax: "| -moz-isolate | -moz-isolate-override | -moz-plaintext | -webkit-isolate | -webkit-isolate-override | -webkit-plaintext"
        },
        "unicode-range": {
          comment: "added missed property https://developer.mozilla.org/en-US/docs/Web/CSS/%40font-face/unicode-range",
          syntax: "<urange>#"
        },
        "voice-balance": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<number> | left | center | right | leftwards | rightwards"
        },
        "voice-duration": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "auto | <time>"
        },
        "voice-family": {
          comment: "<name> -> <family-name>, https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ [ <family-name> | <generic-voice> ] , ]* [ <family-name> | <generic-voice> ] | preserve"
        },
        "voice-pitch": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-range": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "<frequency> && absolute | [ [ x-low | low | medium | high | x-high ] || [ <frequency> | <semitones> | <percentage> ] ]"
        },
        "voice-rate": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "[ normal | x-slow | slow | medium | fast | x-fast ] || <percentage>"
        },
        "voice-stress": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "normal | strong | moderate | none | reduced"
        },
        "voice-volume": {
          comment: "https://www.w3.org/TR/css3-speech/#property-index",
          syntax: "silent | [ [ x-soft | soft | medium | loud | x-loud ] || <decibel> ]"
        },
        "writing-mode": {
          comment: "extend with SVG keywords",
          syntax: "| <svg-writing-mode>"
        }
      },
      types: {
        "-legacy-gradient": {
          comment: "added collection of legacy gradient syntaxes",
          syntax: "<-webkit-gradient()> | <-legacy-linear-gradient> | <-legacy-repeating-linear-gradient> | <-legacy-radial-gradient> | <-legacy-repeating-radial-gradient>"
        },
        "-legacy-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-repeating-linear-gradient": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "-moz-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -webkit-repeating-linear-gradient( <-legacy-linear-gradient-arguments> ) | -o-repeating-linear-gradient( <-legacy-linear-gradient-arguments> )"
        },
        "-legacy-linear-gradient-arguments": {
          comment: "like standard syntax but w/o `to` keyword https://developer.mozilla.org/en-US/docs/Web/CSS/linear-gradient",
          syntax: "[ <angle> | <side-or-corner> ]? , <color-stop-list>"
        },
        "-legacy-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-repeating-radial-gradient": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "-moz-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -webkit-repeating-radial-gradient( <-legacy-radial-gradient-arguments> ) | -o-repeating-radial-gradient( <-legacy-radial-gradient-arguments> )"
        },
        "-legacy-radial-gradient-arguments": {
          comment: "deprecated syntax that implemented by some browsers https://www.w3.org/TR/2011/WD-css3-images-20110908/#radial-gradients",
          syntax: "[ <position> , ]? [ [ [ <-legacy-radial-gradient-shape> || <-legacy-radial-gradient-size> ] | [ <length> | <percentage> ]{2} ] , ]? <color-stop-list>"
        },
        "-legacy-radial-gradient-size": {
          comment: "before a standard it contains 2 extra keywords (`contain` and `cover`) https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltsize",
          syntax: "closest-side | closest-corner | farthest-side | farthest-corner | contain | cover"
        },
        "-legacy-radial-gradient-shape": {
          comment: "define to double sure it doesn't extends in future https://www.w3.org/TR/2011/WD-css3-images-20110908/#ltshape",
          syntax: "circle | ellipse"
        },
        "-non-standard-font": {
          comment: "non standard fonts",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "-apple-system-body | -apple-system-headline | -apple-system-subheadline | -apple-system-caption1 | -apple-system-caption2 | -apple-system-footnote | -apple-system-short-body | -apple-system-short-headline | -apple-system-short-subheadline | -apple-system-short-caption1 | -apple-system-short-footnote | -apple-system-tall-body"
        },
        "-non-standard-color": {
          comment: "non standard colors",
          references: [
            "http://cssdot.ru/%D0%A1%D0%BF%D1%80%D0%B0%D0%B2%D0%BE%D1%87%D0%BD%D0%B8%D0%BA_CSS/color-i305.html",
            "https://developer.mozilla.org/en-US/docs/Web/CSS/color_value#Mozilla_Color_Preference_Extensions"
          ],
          syntax: "-moz-ButtonDefault | -moz-ButtonHoverFace | -moz-ButtonHoverText | -moz-CellHighlight | -moz-CellHighlightText | -moz-Combobox | -moz-ComboboxText | -moz-Dialog | -moz-DialogText | -moz-dragtargetzone | -moz-EvenTreeRow | -moz-Field | -moz-FieldText | -moz-html-CellHighlight | -moz-html-CellHighlightText | -moz-mac-accentdarkestshadow | -moz-mac-accentdarkshadow | -moz-mac-accentface | -moz-mac-accentlightesthighlight | -moz-mac-accentlightshadow | -moz-mac-accentregularhighlight | -moz-mac-accentregularshadow | -moz-mac-chrome-active | -moz-mac-chrome-inactive | -moz-mac-focusring | -moz-mac-menuselect | -moz-mac-menushadow | -moz-mac-menutextselect | -moz-MenuHover | -moz-MenuHoverText | -moz-MenuBarText | -moz-MenuBarHoverText | -moz-nativehyperlinktext | -moz-OddTreeRow | -moz-win-communicationstext | -moz-win-mediatext | -moz-activehyperlinktext | -moz-default-background-color | -moz-default-color | -moz-hyperlinktext | -moz-visitedhyperlinktext | -webkit-activelink | -webkit-focus-ring-color | -webkit-link | -webkit-text"
        },
        "-non-standard-image-rendering": {
          comment: "non-standard keywords http://phrogz.net/tmp/canvas_image_zoom.html",
          syntax: "optimize-contrast | -moz-crisp-edges | -o-crisp-edges | -webkit-optimize-contrast"
        },
        "-non-standard-overflow": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/overflow",
          syntax: "-moz-scrollbars-none | -moz-scrollbars-horizontal | -moz-scrollbars-vertical | -moz-hidden-unscrollable"
        },
        "-non-standard-width": {
          comment: "non-standard keywords https://developer.mozilla.org/en-US/docs/Web/CSS/width",
          syntax: "fill-available | min-intrinsic | intrinsic | -moz-available | -moz-fit-content | -moz-min-content | -moz-max-content | -webkit-min-content | -webkit-max-content"
        },
        "-webkit-gradient()": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/ - TODO: simplify when after match algorithm improvement ( [, point, radius | , point] -> [, radius]? , point )",
          syntax: "-webkit-gradient( <-webkit-gradient-type>, <-webkit-gradient-point> [, <-webkit-gradient-point> | , <-webkit-gradient-radius>, <-webkit-gradient-point> ] [, <-webkit-gradient-radius>]? [, <-webkit-gradient-color-stop>]* )"
        },
        "-webkit-gradient-color-stop": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "from( <color> ) | color-stop( [ <number-zero-one> | <percentage> ] , <color> ) | to( <color> )"
        },
        "-webkit-gradient-point": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "[ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]"
        },
        "-webkit-gradient-radius": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "<length> | <percentage>"
        },
        "-webkit-gradient-type": {
          comment: "first Apple proposal gradient syntax https://webkit.org/blog/175/introducing-css-gradients/",
          syntax: "linear | radial"
        },
        "-webkit-mask-box-repeat": {
          comment: "missed; https://developer.mozilla.org/en-US/docs/Web/CSS/-webkit-mask-box-image",
          syntax: "repeat | stretch | round"
        },
        "-webkit-mask-clip-style": {
          comment: "missed; there is no enough information about `-webkit-mask-clip` property, but looks like all those keywords are working",
          syntax: "border | border-box | padding | padding-box | content | content-box | text"
        },
        "-ms-filter-function-list": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function>+"
        },
        "-ms-filter-function": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<-ms-filter-function-progid> | <-ms-filter-function-legacy>"
        },
        "-ms-filter-function-progid": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "'progid:' [ <ident-token> '.' ]* [ <ident-token> | <function-token> <any-value>? ) ]"
        },
        "-ms-filter-function-legacy": {
          comment: "https://developer.mozilla.org/en-US/docs/Web/CSS/-ms-filter",
          syntax: "<ident-token> | <function-token> <any-value>? )"
        },
        "-ms-filter": {
          syntax: "<string>"
        },
        age: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "child | young | old"
        },
        "attr-name": {
          syntax: "<wq-name>"
        },
        "attr-fallback": {
          syntax: "<any-value>"
        },
        "bg-clip": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-4/#typedef-bg-clip",
          syntax: "<box> | border | text"
        },
        "border-radius": {
          comment: "missed, https://drafts.csswg.org/css-backgrounds-3/#the-border-radius",
          syntax: "<length-percentage>{1,2}"
        },
        bottom: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "content-list": {
          comment: "added attr(), see https://github.com/csstree/csstree/issues/201",
          syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> | <attr()> ]+"
        },
        "element()": {
          comment: "https://drafts.csswg.org/css-gcpm/#element-syntax & https://drafts.csswg.org/css-images-4/#element-notation",
          syntax: "element( <custom-ident> , [ first | start | last | first-except ]? ) | element( <id-selector> )"
        },
        "generic-voice": {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "[ <age>? <gender> <integer>? ]"
        },
        gender: {
          comment: "https://www.w3.org/TR/css3-speech/#voice-family",
          syntax: "male | female | neutral"
        },
        "generic-family": {
          comment: "added -apple-system",
          references: [
            "https://webkit.org/blog/3709/using-the-system-font-in-web-content/"
          ],
          syntax: "| -apple-system"
        },
        gradient: {
          comment: "added legacy syntaxes support",
          syntax: "| <-legacy-gradient>"
        },
        "lab()": {
          comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
          syntax: "lab( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <percentage> | <number> | none] [ / [<alpha-value> | none] ]? )"
        },
        "lch()": {
          comment: "missed; https://www.w3.org/TR/css-color-4/#specifying-lab-lch",
          syntax: "lch( [<percentage> | <number> | none] [ <percentage> | <number> | none] [ <hue> | none] [ / [<alpha-value> | none] ]? )"
        },
        left: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "mask-image": {
          comment: "missed; https://drafts.fxtf.org/css-masking-1/#the-mask-image",
          syntax: "<mask-reference>#"
        },
        "named-color": {
          comment: "added non standard color names",
          syntax: "| <-non-standard-color>"
        },
        paint: {
          comment: "used by SVG https://www.w3.org/TR/SVG/painting.html#SpecifyingPaint",
          syntax: "none | <color> | <url> [ none | <color> ]? | context-fill | context-stroke"
        },
        ratio: {
          comment: "missed, https://drafts.csswg.org/css-values-4/#ratio-value",
          syntax: "<number [0,\u221E]> [ / <number [0,\u221E]> ]?"
        },
        "reversed-counter-name": {
          comment: "missed; https://drafts.csswg.org/css-lists/#typedef-reversed-counter-name",
          syntax: "reversed( <counter-name> )"
        },
        right: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        shape: {
          comment: "missed spaces in function body and add backwards compatible syntax",
          syntax: "rect( <top>, <right>, <bottom>, <left> ) | rect( <top> <right> <bottom> <left> )"
        },
        "svg-length": {
          comment: "All coordinates and lengths in SVG can be specified with or without a unit identifier",
          references: [
            "https://www.w3.org/TR/SVG11/coords.html#Units"
          ],
          syntax: "<percentage> | <length> | <number>"
        },
        "svg-writing-mode": {
          comment: "SVG specific keywords (deprecated for CSS)",
          references: [
            "https://developer.mozilla.org/en/docs/Web/CSS/writing-mode",
            "https://www.w3.org/TR/SVG/text.html#WritingModeProperty"
          ],
          syntax: "lr-tb | rl-tb | tb-rl | lr | rl | tb"
        },
        top: {
          comment: "missed; not sure we should add it, but no others except `shape` is using it so it's ok for now; https://drafts.fxtf.org/css-masking-1/#funcdef-clip-rect",
          syntax: "<length> | auto"
        },
        "track-group": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "'(' [ <string>* <track-minmax> <string>* ]+ ')' [ '[' <positive-integer> ']' ]? | <track-minmax>"
        },
        "track-list-v0": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "[ <string>* <track-group> <string>* ]+ | none"
        },
        "track-minmax": {
          comment: "used by old grid-columns and grid-rows syntax v0",
          syntax: "minmax( <track-breadth> , <track-breadth> ) | auto | <track-breadth> | fit-content"
        },
        x: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using it so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        y: {
          comment: "missed; not sure we should add it, but no others except `cursor` is using so it's ok for now; https://drafts.csswg.org/css-ui-3/#cursor",
          syntax: "<number>"
        },
        declaration: {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "<ident-token> : <declaration-value>? [ '!' important ]?"
        },
        "declaration-list": {
          comment: "missed, restored by https://drafts.csswg.org/css-syntax",
          syntax: "[ <declaration>? ';' ]* <declaration>?"
        },
        url: {
          comment: "https://drafts.csswg.org/css-values-4/#urls",
          syntax: "url( <string> <url-modifier>* ) | <url-token>"
        },
        "url-modifier": {
          comment: "https://drafts.csswg.org/css-values-4/#typedef-url-modifier",
          syntax: "<ident> | <function-token> <any-value> )"
        },
        "number-zero-one": {
          syntax: "<number [0,1]>"
        },
        "number-one-or-greater": {
          syntax: "<number [1,\u221E]>"
        },
        "positive-integer": {
          syntax: "<integer [0,\u221E]>"
        },
        "-non-standard-display": {
          syntax: "-ms-inline-flexbox | -ms-grid | -ms-inline-grid | -webkit-flex | -webkit-inline-flex | -webkit-box | -webkit-inline-box | -moz-inline-stack | -moz-box | -moz-inline-box"
        }
      }
    };
  }
});

// node_modules/csso/node_modules/css-tree/cjs/data-patch.cjs
var require_data_patch2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/data-patch.cjs"(exports2, module2) {
    "use strict";
    var patch = require_patch2();
    var patch$1 = patch;
    module2.exports = patch$1;
  }
});

// node_modules/csso/node_modules/mdn-data/css/at-rules.json
var require_at_rules2 = __commonJS({
  "node_modules/csso/node_modules/mdn-data/css/at-rules.json"(exports2, module2) {
    module2.exports = {
      "@charset": {
        syntax: '@charset "<charset>";',
        groups: [
          "CSS Charsets"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@charset"
      },
      "@counter-style": {
        syntax: "@counter-style <counter-style-name> {\n  [ system: <counter-system>; ] ||\n  [ symbols: <counter-symbols>; ] ||\n  [ additive-symbols: <additive-symbols>; ] ||\n  [ negative: <negative-symbol>; ] ||\n  [ prefix: <prefix>; ] ||\n  [ suffix: <suffix>; ] ||\n  [ range: <range>; ] ||\n  [ pad: <padding>; ] ||\n  [ speak-as: <speak-as>; ] ||\n  [ fallback: <counter-style-name>; ]\n}",
        interfaces: [
          "CSSCounterStyleRule"
        ],
        groups: [
          "CSS Counter Styles"
        ],
        descriptors: {
          "additive-symbols": {
            syntax: "[ <integer> && <symbol> ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          fallback: {
            syntax: "<counter-style-name>",
            media: "all",
            initial: "decimal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          negative: {
            syntax: "<symbol> <symbol>?",
            media: "all",
            initial: '"-" hyphen-minus',
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          pad: {
            syntax: "<integer> && <symbol>",
            media: "all",
            initial: '0 ""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          prefix: {
            syntax: "<symbol>",
            media: "all",
            initial: '""',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          range: {
            syntax: "[ [ <integer> | infinite ]{2} ]# | auto",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "speak-as": {
            syntax: "auto | bullets | numbers | words | spell-out | <counter-style-name>",
            media: "all",
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          suffix: {
            syntax: "<symbol>",
            media: "all",
            initial: '". "',
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          symbols: {
            syntax: "<symbol>+",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          system: {
            syntax: "cyclic | numeric | alphabetic | symbolic | additive | [ fixed <integer>? ] | [ extends <counter-style-name> ]",
            media: "all",
            initial: "symbolic",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@counter-style"
      },
      "@document": {
        syntax: "@document [ <url> | url-prefix(<string>) | domain(<string>) | media-document(<string>) | regexp(<string>) ]# {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@document"
      },
      "@font-face": {
        syntax: "@font-face {\n  [ font-family: <family-name>; ] ||\n  [ src: <src>; ] ||\n  [ unicode-range: <unicode-range>; ] ||\n  [ font-variant: <font-variant>; ] ||\n  [ font-feature-settings: <font-feature-settings>; ] ||\n  [ font-variation-settings: <font-variation-settings>; ] ||\n  [ font-stretch: <font-stretch>; ] ||\n  [ font-weight: <font-weight>; ] ||\n  [ font-style: <font-style>; ] ||\n  [ size-adjust: <size-adjust>; ] ||\n  [ ascent-override: <ascent-override>; ] ||\n  [ descent-override: <descent-override>; ] ||\n  [ line-gap-override: <line-gap-override>; ]\n}",
        interfaces: [
          "CSSFontFaceRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        descriptors: {
          "ascent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "descent-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "font-display": {
            syntax: "[ auto | block | swap | fallback | optional ]",
            media: "visual",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "font-family": {
            syntax: "<family-name>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-feature-settings": {
            syntax: "normal | <feature-tag-value>#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-variation-settings": {
            syntax: "normal | [ <string> <number> ]#",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "font-stretch": {
            syntax: "<font-stretch-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-style": {
            syntax: "normal | italic | oblique <angle>{0,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-weight": {
            syntax: "<font-weight-absolute>{1,2}",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "font-variant": {
            syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic(<feature-value-name>) || historical-forms || styleset(<feature-value-name>#) || character-variant(<feature-value-name>#) || swash(<feature-value-name>) || ornaments(<feature-value-name>) || annotation(<feature-value-name>) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
            media: "all",
            initial: "normal",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "line-gap-override": {
            syntax: "normal | <percentage>",
            media: "all",
            initial: "normal",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          "size-adjust": {
            syntax: "<percentage>",
            media: "all",
            initial: "100%",
            percentages: "asSpecified",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "experimental"
          },
          src: {
            syntax: "[ <url> [ format( <string># ) ]? | local( <family-name> ) ]#",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          "unicode-range": {
            syntax: "<unicode-range>#",
            media: "all",
            initial: "U+0-10FFFF",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-face"
      },
      "@font-feature-values": {
        syntax: "@font-feature-values <family-name># {\n  <feature-value-block-list>\n}",
        interfaces: [
          "CSSFontFeatureValuesRule"
        ],
        groups: [
          "CSS Fonts"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@font-feature-values"
      },
      "@import": {
        syntax: "@import [ <string> | <url> ]\n        [ layer | layer(<layer-name>) ]?\n        [ supports( [ <supports-condition> | <declaration> ] ) ]?\n        <media-query-list>? ;",
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@import"
      },
      "@keyframes": {
        syntax: "@keyframes <keyframes-name> {\n  <keyframe-block-list>\n}",
        interfaces: [
          "CSSKeyframeRule",
          "CSSKeyframesRule"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@keyframes"
      },
      "@layer": {
        syntax: "@layer [ <layer-name># | <layer-name>?  {\n  <stylesheet>\n} ]",
        interfaces: [
          "CSSLayerBlockRule",
          "CSSLayerStatementRule"
        ],
        groups: [
          "CSS Cascading and Inheritance"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@layer"
      },
      "@media": {
        syntax: "@media <media-query-list> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSMediaRule",
          "CSSCustomMediaRule"
        ],
        groups: [
          "CSS Conditional Rules",
          "Media Queries"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@media"
      },
      "@namespace": {
        syntax: "@namespace <namespace-prefix>? [ <string> | <url> ];",
        groups: [
          "CSS Namespaces"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@namespace"
      },
      "@page": {
        syntax: "@page <page-selector-list> {\n  <page-body>\n}",
        interfaces: [
          "CSSPageRule"
        ],
        groups: [
          "CSS Pages"
        ],
        descriptors: {
          bleed: {
            syntax: "auto | <length>",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          marks: {
            syntax: "none | [ crop || cross ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "none",
            percentages: "no",
            computed: "asSpecified",
            order: "orderOfAppearance",
            status: "standard"
          },
          size: {
            syntax: "<length>{1,2} | auto | [ <page-size> || [ portrait | landscape ] ]",
            media: [
              "visual",
              "paged"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecifiedRelativeToAbsoluteLengths",
            order: "orderOfAppearance",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@page"
      },
      "@property": {
        syntax: "@property <custom-property-name> {\n  <declaration-list>\n}",
        interfaces: [
          "CSS",
          "CSSPropertyRule"
        ],
        groups: [
          "CSS Houdini"
        ],
        descriptors: {
          syntax: {
            syntax: "<string>",
            media: "all",
            percentages: "no",
            initial: "n/a (required)",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          inherits: {
            syntax: "true | false",
            media: "all",
            percentages: "no",
            initial: "auto",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          },
          "initial-value": {
            syntax: "<string>",
            media: "all",
            initial: "n/a (required)",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "experimental"
          }
        },
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@property"
      },
      "@scroll-timeline": {
        syntax: "@scroll-timeline <timeline-name> { <declaration-list> }",
        interfaces: [
          "ScrollTimeline"
        ],
        groups: [
          "CSS Animations"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@scroll-timeline"
      },
      "@supports": {
        syntax: "@supports <supports-condition> {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSGroupingRule",
          "CSSConditionRule",
          "CSSSupportsRule"
        ],
        groups: [
          "CSS Conditional Rules"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@supports"
      },
      "@viewport": {
        syntax: "@viewport {\n  <group-rule-body>\n}",
        interfaces: [
          "CSSViewportRule"
        ],
        groups: [
          "CSS Device Adaptation"
        ],
        descriptors: {
          height: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-height",
              "max-height"
            ],
            percentages: [
              "min-height",
              "max-height"
            ],
            computed: [
              "min-height",
              "max-height"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          "max-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "max-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-height": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToHeightOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-width": {
            syntax: "<viewport-length>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToWidthOfInitialViewport",
            computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
            order: "uniqueOrder",
            status: "standard"
          },
          "min-zoom": {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          },
          orientation: {
            syntax: "auto | portrait | landscape",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "user-zoom": {
            syntax: "zoom | fixed",
            media: [
              "visual",
              "continuous"
            ],
            initial: "zoom",
            percentages: "referToSizeOfBoundingBox",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          "viewport-fit": {
            syntax: "auto | contain | cover",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "no",
            computed: "asSpecified",
            order: "uniqueOrder",
            status: "standard"
          },
          width: {
            syntax: "<viewport-length>{1,2}",
            media: [
              "visual",
              "continuous"
            ],
            initial: [
              "min-width",
              "max-width"
            ],
            percentages: [
              "min-width",
              "max-width"
            ],
            computed: [
              "min-width",
              "max-width"
            ],
            order: "orderOfAppearance",
            status: "standard"
          },
          zoom: {
            syntax: "auto | <number> | <percentage>",
            media: [
              "visual",
              "continuous"
            ],
            initial: "auto",
            percentages: "the zoom factor itself",
            computed: "autoNonNegativeOrPercentage",
            order: "uniqueOrder",
            status: "standard"
          }
        },
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/@viewport"
      }
    };
  }
});

// node_modules/csso/node_modules/mdn-data/css/properties.json
var require_properties2 = __commonJS({
  "node_modules/csso/node_modules/mdn-data/css/properties.json"(exports2, module2) {
    module2.exports = {
      "--*": {
        syntax: "<declaration-value>",
        media: "all",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Variables"
        ],
        initial: "seeProse",
        appliesto: "allElements",
        computed: "asSpecifiedWithVarsSubstituted",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/--*"
      },
      "-ms-accelerator": {
        syntax: "false | true",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "false",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-accelerator"
      },
      "-ms-block-progression": {
        syntax: "tb | rl | bt | lr",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "tb",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-block-progression"
      },
      "-ms-content-zoom-chaining": {
        syntax: "none | chained",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-chaining"
      },
      "-ms-content-zooming": {
        syntax: "none | zoom",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "zoomForTheTopLevelNoneForTheRest",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zooming"
      },
      "-ms-content-zoom-limit": {
        syntax: "<'-ms-content-zoom-limit-min'> <'-ms-content-zoom-limit-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-limit-max",
          "-ms-content-zoom-limit-min"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit"
      },
      "-ms-content-zoom-limit-max": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "maxZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "400%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-max"
      },
      "-ms-content-zoom-limit-min": {
        syntax: "<percentage>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "minZoomFactor",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "100%",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-limit-min"
      },
      "-ms-content-zoom-snap": {
        syntax: "<'-ms-content-zoom-snap-type'> || <'-ms-content-zoom-snap-points'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-content-zoom-snap-type",
          "-ms-content-zoom-snap-points"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap"
      },
      "-ms-content-zoom-snap-points": {
        syntax: "snapInterval( <percentage>, <percentage> ) | snapList( <percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0%, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-points"
      },
      "-ms-content-zoom-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-content-zoom-snap-type"
      },
      "-ms-filter": {
        syntax: "<string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: '""',
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-filter"
      },
      "-ms-flow-from": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-from"
      },
      "-ms-flow-into": {
        syntax: "[ none | <custom-ident> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "iframeElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-flow-into"
      },
      "-ms-grid-columns": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-columns"
      },
      "-ms-grid-rows": {
        syntax: "none | <track-list> | <auto-track-list>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-grid-rows"
      },
      "-ms-high-contrast-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-high-contrast-adjust"
      },
      "-ms-hyphenate-limit-chars": {
        syntax: "auto | <integer>{1,3}",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-chars"
      },
      "-ms-hyphenate-limit-lines": {
        syntax: "no-limit | <integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "no-limit",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-lines"
      },
      "-ms-hyphenate-limit-zone": {
        syntax: "<percentage> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToLineBoxWidth",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-hyphenate-limit-zone"
      },
      "-ms-ime-align": {
        syntax: "auto | after",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-ime-align"
      },
      "-ms-overflow-style": {
        syntax: "auto | none | scrollbar | -ms-autohiding-scrollbar",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-overflow-style"
      },
      "-ms-scrollbar-3dlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-3dlight-color"
      },
      "-ms-scrollbar-arrow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ButtonText",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-arrow-color"
      },
      "-ms-scrollbar-base-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-base-color"
      },
      "-ms-scrollbar-darkshadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-darkshadow-color"
      },
      "-ms-scrollbar-face-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDFace",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-face-color"
      },
      "-ms-scrollbar-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDHighlight",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-highlight-color"
      },
      "-ms-scrollbar-shadow-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "ThreeDDarkShadow",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-shadow-color"
      },
      "-ms-scrollbar-track-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "Scrollbar",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scrollbar-track-color"
      },
      "-ms-scroll-chaining": {
        syntax: "chained | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "chained",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-chaining"
      },
      "-ms-scroll-limit": {
        syntax: "<'-ms-scroll-limit-x-min'> <'-ms-scroll-limit-y-min'> <'-ms-scroll-limit-x-max'> <'-ms-scroll-limit-y-max'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-limit-x-min",
          "-ms-scroll-limit-y-min",
          "-ms-scroll-limit-x-max",
          "-ms-scroll-limit-y-max"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit"
      },
      "-ms-scroll-limit-x-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-max"
      },
      "-ms-scroll-limit-x-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-x-min"
      },
      "-ms-scroll-limit-y-max": {
        syntax: "auto | <length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-max"
      },
      "-ms-scroll-limit-y-min": {
        syntax: "<length>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-limit-y-min"
      },
      "-ms-scroll-rails": {
        syntax: "none | railed",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "railed",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-rails"
      },
      "-ms-scroll-snap-points-x": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-x"
      },
      "-ms-scroll-snap-points-y": {
        syntax: "snapInterval( <length-percentage>, <length-percentage> ) | snapList( <length-percentage># )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "snapInterval(0px, 100%)",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-points-y"
      },
      "-ms-scroll-snap-type": {
        syntax: "none | proximity | mandatory",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-type"
      },
      "-ms-scroll-snap-x": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-x'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-x"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-x"
      },
      "-ms-scroll-snap-y": {
        syntax: "<'-ms-scroll-snap-type'> <'-ms-scroll-snap-points-y'>",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "-ms-scroll-snap-type",
          "-ms-scroll-snap-points-y"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-snap-y"
      },
      "-ms-scroll-translation": {
        syntax: "none | vertical-to-horizontal",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-scroll-translation"
      },
      "-ms-text-autospace": {
        syntax: "none | ideograph-alpha | ideograph-numeric | ideograph-parenthesis | ideograph-space",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-text-autospace"
      },
      "-ms-touch-select": {
        syntax: "grippers | none",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "grippers",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-touch-select"
      },
      "-ms-user-select": {
        syntax: "none | element | text",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "text",
        appliesto: "nonReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-user-select"
      },
      "-ms-wrap-flow": {
        syntax: "auto | both | start | end | maximum | clear",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-flow"
      },
      "-ms-wrap-margin": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "0",
        appliesto: "exclusionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-margin"
      },
      "-ms-wrap-through": {
        syntax: "wrap | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "wrap",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-ms-wrap-through"
      },
      "-moz-appearance": {
        syntax: "none | button | button-arrow-down | button-arrow-next | button-arrow-previous | button-arrow-up | button-bevel | button-focus | caret | checkbox | checkbox-container | checkbox-label | checkmenuitem | dualbutton | groupbox | listbox | listitem | menuarrow | menubar | menucheckbox | menuimage | menuitem | menuitemtext | menulist | menulist-button | menulist-text | menulist-textfield | menupopup | menuradio | menuseparator | meterbar | meterchunk | progressbar | progressbar-vertical | progresschunk | progresschunk-vertical | radio | radio-container | radio-label | radiomenuitem | range | range-thumb | resizer | resizerpanel | scale-horizontal | scalethumbend | scalethumb-horizontal | scalethumbstart | scalethumbtick | scalethumb-vertical | scale-vertical | scrollbarbutton-down | scrollbarbutton-left | scrollbarbutton-right | scrollbarbutton-up | scrollbarthumb-horizontal | scrollbarthumb-vertical | scrollbartrack-horizontal | scrollbartrack-vertical | searchfield | separator | sheet | spinner | spinner-downbutton | spinner-textfield | spinner-upbutton | splitter | statusbar | statusbarpanel | tab | tabpanel | tabpanels | tab-scroll-arrow-back | tab-scroll-arrow-forward | textfield | textfield-multiline | toolbar | toolbarbutton | toolbarbutton-dropdown | toolbargripper | toolbox | tooltip | treeheader | treeheadercell | treeheadersortarrow | treeitem | treeline | treetwisty | treetwistyopen | treeview | -moz-mac-unified-toolbar | -moz-win-borderless-glass | -moz-win-browsertabbar-toolbox | -moz-win-communicationstext | -moz-win-communications-toolbox | -moz-win-exclude-glass | -moz-win-glass | -moz-win-mediatext | -moz-win-media-toolbox | -moz-window-button-box | -moz-window-button-box-maximized | -moz-window-button-close | -moz-window-button-maximize | -moz-window-button-minimize | -moz-window-button-restore | -moz-window-frame-bottom | -moz-window-frame-left | -moz-window-frame-right | -moz-window-titlebar | -moz-window-titlebar-maximized",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-moz-binding": {
        syntax: "<url> | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsExceptGeneratedContentOrPseudoElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-binding"
      },
      "-moz-border-bottom-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-bottom-colors"
      },
      "-moz-border-left-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-left-colors"
      },
      "-moz-border-right-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-right-colors"
      },
      "-moz-border-top-colors": {
        syntax: "<color>+ | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-border-top-colors"
      },
      "-moz-context-properties": {
        syntax: "none | [ fill | fill-opacity | stroke | stroke-opacity ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElementsThatCanReferenceImages",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-context-properties"
      },
      "-moz-float-edge": {
        syntax: "border-box | content-box | margin-box | padding-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "content-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-float-edge"
      },
      "-moz-force-broken-image-icon": {
        syntax: "0 | 1",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "images",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-force-broken-image-icon"
      },
      "-moz-image-region": {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "xulImageElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-image-region"
      },
      "-moz-orient": {
        syntax: "inline | block | horizontal | vertical",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "inline",
        appliesto: "anyElementEffectOnProgressAndMeter",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-orient"
      },
      "-moz-outline-radius": {
        syntax: "<outline-radius>{1,4} [ / <outline-radius>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        percentages: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        groups: [
          "Mozilla Extensions"
        ],
        initial: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        appliesto: "allElements",
        computed: [
          "-moz-outline-radius-topleft",
          "-moz-outline-radius-topright",
          "-moz-outline-radius-bottomright",
          "-moz-outline-radius-bottomleft"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius"
      },
      "-moz-outline-radius-bottomleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomleft"
      },
      "-moz-outline-radius-bottomright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-bottomright"
      },
      "-moz-outline-radius-topleft": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topleft"
      },
      "-moz-outline-radius-topright": {
        syntax: "<outline-radius>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-outline-radius-topright"
      },
      "-moz-stack-sizing": {
        syntax: "ignore | stretch-to-fit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "stretch-to-fit",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-stack-sizing"
      },
      "-moz-text-blink": {
        syntax: "none | blink",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-text-blink"
      },
      "-moz-user-focus": {
        syntax: "ignore | normal | select-after | select-before | select-menu | select-same | select-all | none",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-focus"
      },
      "-moz-user-input": {
        syntax: "auto | none | enabled | disabled",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-input"
      },
      "-moz-user-modify": {
        syntax: "read-only | read-write | write-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-user-modify"
      },
      "-moz-window-dragging": {
        syntax: "drag | no-drag",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "drag",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-dragging"
      },
      "-moz-window-shadow": {
        syntax: "default | menu | tooltip | sheet | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "default",
        appliesto: "allElementsCreatingNativeWindows",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-moz-window-shadow"
      },
      "-webkit-appearance": {
        syntax: "none | button | button-bevel | caret | checkbox | default-button | inner-spin-button | listbox | listitem | media-controls-background | media-controls-fullscreen-background | media-current-time-display | media-enter-fullscreen-button | media-exit-fullscreen-button | media-fullscreen-button | media-mute-button | media-overlay-play-button | media-play-button | media-seek-back-button | media-seek-forward-button | media-slider | media-sliderthumb | media-time-remaining-display | media-toggle-closed-captions-button | media-volume-slider | media-volume-slider-container | media-volume-sliderthumb | menulist | menulist-button | menulist-text | menulist-textfield | meter | progress-bar | progress-bar-value | push-button | radio | searchfield | searchfield-cancel-button | searchfield-decoration | searchfield-results-button | searchfield-results-decoration | slider-horizontal | slider-vertical | sliderthumb-horizontal | sliderthumb-vertical | square-button | textarea | textfield | -apple-pay-button",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "noneButOverriddenInUserAgentCSS",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "-webkit-border-before": {
        syntax: "<'border-width'> || <'border-style'> || <color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: [
          "-webkit-border-before-width"
        ],
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "color"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-border-before"
      },
      "-webkit-border-before-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-border-before-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "WebKit Extensions"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "-webkit-box-reflect": {
        syntax: "[ above | below | right | left ]? <length>? <image>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-box-reflect"
      },
      "-webkit-line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "WebKit Extensions",
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-line-clamp"
      },
      "-webkit-mask": {
        syntax: "[ <mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || [ <box> | border | padding | content | text ] || [ <box> | border | padding | content ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-mask-image",
          "-webkit-mask-repeat",
          "-webkit-mask-attachment",
          "-webkit-mask-position",
          "-webkit-mask-origin",
          "-webkit-mask-clip"
        ],
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "-webkit-mask-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-attachment"
      },
      "-webkit-mask-clip": {
        syntax: "[ <box> | border | padding | content | text ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "border",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "-webkit-mask-composite": {
        syntax: "<composite-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "source-over",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-composite"
      },
      "-webkit-mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteURIOrNone",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "-webkit-mask-origin": {
        syntax: "[ <box> | border | padding | content ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "padding",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "-webkit-mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "-webkit-mask-position-x": {
        syntax: "[ <length-percentage> | left | center | right ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-x"
      },
      "-webkit-mask-position-y": {
        syntax: "[ <length-percentage> | top | center | bottom ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfElement",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-position-y"
      },
      "-webkit-mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "-webkit-mask-repeat-x": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-x"
      },
      "-webkit-mask-repeat-y": {
        syntax: "repeat | no-repeat | space | round",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "absoluteLengthOrPercentage",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-mask-repeat-y"
      },
      "-webkit-mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "-webkit-overflow-scrolling": {
        syntax: "auto | touch",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-overflow-scrolling"
      },
      "-webkit-tap-highlight-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "black",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-tap-highlight-color"
      },
      "-webkit-text-fill-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-fill-color"
      },
      "-webkit-text-stroke": {
        syntax: "<length> || <color>",
        media: "visual",
        inherited: true,
        animationType: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        appliesto: "allElements",
        computed: [
          "-webkit-text-stroke-width",
          "-webkit-text-stroke-color"
        ],
        order: "canonicalOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke"
      },
      "-webkit-text-stroke-color": {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-color"
      },
      "-webkit-text-stroke-width": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "absoluteLength",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-text-stroke-width"
      },
      "-webkit-touch-callout": {
        syntax: "default | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "default",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/-webkit-touch-callout"
      },
      "-webkit-user-modify": {
        syntax: "read-only | read-write | read-write-plaintext-only",
        media: "interactive",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "WebKit Extensions"
        ],
        initial: "read-only",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard"
      },
      "accent-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/accent-color"
      },
      "align-content": {
        syntax: "normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-content"
      },
      "align-items": {
        syntax: "normal | stretch | <baseline-position> | [ <overflow-position>? <self-position> ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-items"
      },
      "align-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? <self-position>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "flexItemsGridItemsAndAbsolutelyPositionedBoxes",
        computed: "autoOnAbsolutelyPositionedElementsValueOfAlignItemsOnParent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-self"
      },
      "align-tracks": {
        syntax: "[ normal | <baseline-position> | <content-distribution> | <overflow-position>? <content-position> ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirBlockAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/align-tracks"
      },
      all: {
        syntax: "initial | inherit | unset | revert | revert-layer",
        media: "noPracticalMedia",
        inherited: false,
        animationType: "eachOfShorthandPropertiesExceptUnicodeBiDiAndDirection",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "noPracticalInitialValue",
        appliesto: "allElements",
        computed: "asSpecifiedAppliesToEachProperty",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/all"
      },
      animation: {
        syntax: "<single-animation>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-iteration-count",
          "animation-direction",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "animation-name",
          "animation-duration",
          "animation-timing-function",
          "animation-delay",
          "animation-direction",
          "animation-iteration-count",
          "animation-fill-mode",
          "animation-play-state",
          "animation-timeline"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation"
      },
      "animation-delay": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-delay"
      },
      "animation-direction": {
        syntax: "<single-animation-direction>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "normal",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-direction"
      },
      "animation-duration": {
        syntax: "<time>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-duration"
      },
      "animation-fill-mode": {
        syntax: "<single-animation-fill-mode>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-fill-mode"
      },
      "animation-iteration-count": {
        syntax: "<single-animation-iteration-count>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "1",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-iteration-count"
      },
      "animation-name": {
        syntax: "[ none | <keyframes-name> ]#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "none",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-name"
      },
      "animation-play-state": {
        syntax: "<single-animation-play-state>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "running",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-play-state"
      },
      "animation-timing-function": {
        syntax: "<easing-function>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timing-function"
      },
      "animation-timeline": {
        syntax: "<single-animation-timeline>#",
        media: "visual",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Animations"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "listEachItemIdentifyerOrNoneAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/animation-timeline"
      },
      appearance: {
        syntax: "none | auto | textfield | menulist-button | <compat-auto>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/appearance"
      },
      "aspect-ratio": {
        syntax: "auto | <ratio>",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElementsExceptInlineBoxesAndInternalRubyOrTableBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/aspect-ratio"
      },
      azimuth: {
        syntax: "<angle> | [ [ left-side | far-left | left | center-left | center | center-right | right | far-right | right-side ] || behind ] | leftwards | rightwards",
        media: "aural",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Speech"
        ],
        initial: "center",
        appliesto: "allElements",
        computed: "normalizedAngle",
        order: "orderOfAppearance",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/azimuth"
      },
      "backdrop-filter": {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backdrop-filter"
      },
      "backface-visibility": {
        syntax: "visible | hidden",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "visible",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/backface-visibility"
      },
      background: {
        syntax: "[ <bg-layer> , ]* <final-bg-layer>",
        media: "visual",
        inherited: false,
        animationType: [
          "background-color",
          "background-image",
          "background-clip",
          "background-position",
          "background-size",
          "background-repeat",
          "background-attachment"
        ],
        percentages: [
          "background-position",
          "background-size"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        appliesto: "allElements",
        computed: [
          "background-image",
          "background-position",
          "background-size",
          "background-repeat",
          "background-origin",
          "background-clip",
          "background-attachment",
          "background-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background"
      },
      "background-attachment": {
        syntax: "<attachment>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "scroll",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-attachment"
      },
      "background-blend-mode": {
        syntax: "<blend-mode>#",
        media: "none",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-blend-mode"
      },
      "background-clip": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "border-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-clip"
      },
      "background-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "transparent",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-color"
      },
      "background-image": {
        syntax: "<bg-image>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-image"
      },
      "background-origin": {
        syntax: "<box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-origin"
      },
      "background-position": {
        syntax: "<bg-position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfBackgroundPositioningAreaMinusBackgroundImageSize",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0% 0%",
        appliesto: "allElements",
        computed: [
          "background-position-x",
          "background-position-y"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position"
      },
      "background-position-x": {
        syntax: "[ center | [ [ left | right | x-start | x-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToWidthOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-x"
      },
      "background-position-y": {
        syntax: "[ center | [ [ top | bottom | y-start | y-end ]? <length-percentage>? ]! ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToHeightOfBackgroundPositioningAreaMinusBackgroundImageHeight",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0%",
        appliesto: "allElements",
        computed: "listEachItemConsistingOfAbsoluteLengthPercentageAndOrigin",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-position-y"
      },
      "background-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "repeat",
        appliesto: "allElements",
        computed: "listEachItemHasTwoKeywordsOnePerDimension",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-repeat"
      },
      "background-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "relativeToBackgroundPositioningArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "auto auto",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/background-size"
      },
      "block-overflow": {
        syntax: "clip | ellipsis | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "clip",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "block-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/block-size"
      },
      border: {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-color",
          "border-style",
          "border-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-width",
          "border-style",
          "border-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border"
      },
      "border-block": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block"
      },
      "border-block-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-color"
      },
      "border-block-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-style"
      },
      "border-block-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-width"
      },
      "border-block-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-end-color",
          "border-block-end-style",
          "border-block-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end"
      },
      "border-block-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-color"
      },
      "border-block-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-style"
      },
      "border-block-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-end-width"
      },
      "border-block-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-block-start-color",
          "border-block-start-style",
          "border-block-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-block-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start"
      },
      "border-block-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-color"
      },
      "border-block-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-style"
      },
      "border-block-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-block-start-width"
      },
      "border-bottom": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-bottom-style",
          "border-bottom-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-bottom-style",
          "border-bottom-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom"
      },
      "border-bottom-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-color"
      },
      "border-bottom-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-left-radius"
      },
      "border-bottom-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-right-radius"
      },
      "border-bottom-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-style"
      },
      "border-bottom-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderBottomStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-bottom-width"
      },
      "border-collapse": {
        syntax: "collapse | separate",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "separate",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-collapse"
      },
      "border-color": {
        syntax: "<color>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-color",
          "border-right-color",
          "border-bottom-color",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-color",
          "border-left-color",
          "border-right-color",
          "border-top-color"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-color"
      },
      "border-end-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-end-radius"
      },
      "border-end-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-end-start-radius"
      },
      "border-image": {
        syntax: "<'border-image-source'> || <'border-image-slice'> [ / <'border-image-width'> | / <'border-image-width'>? / <'border-image-outset'> ]? || <'border-image-repeat'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "border-image-slice",
          "border-image-width"
        ],
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-image-source",
          "border-image-slice",
          "border-image-width",
          "border-image-outset",
          "border-image-repeat"
        ],
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: [
          "border-image-outset",
          "border-image-repeat",
          "border-image-slice",
          "border-image-source",
          "border-image-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image"
      },
      "border-image-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-outset"
      },
      "border-image-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "stretch",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-repeat"
      },
      "border-image-slice": {
        syntax: "<number-percentage>{1,4} && fill?",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToSizeOfBorderImage",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "100%",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "oneToFourPercentagesOrAbsoluteLengthsPlusFill",
        order: "percentagesOrLengthsFollowedByFill",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-slice"
      },
      "border-image-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "noneOrImageWithAbsoluteURI",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-source"
      },
      "border-image-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToWidthOrHeightOfBorderImageArea",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "1",
        appliesto: "allElementsExceptTableElementsWhenCollapse",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-image-width"
      },
      "border-inline": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline"
      },
      "border-inline-end": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-end-color",
          "border-inline-end-style",
          "border-inline-end-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-end-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end"
      },
      "border-inline-color": {
        syntax: "<'border-top-color'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-color"
      },
      "border-inline-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-style"
      },
      "border-inline-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-width"
      },
      "border-inline-end-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-color"
      },
      "border-inline-end-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-style"
      },
      "border-inline-end-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-end-width"
      },
      "border-inline-start": {
        syntax: "<'border-top-width'> || <'border-top-style'> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-inline-start-color",
          "border-inline-start-style",
          "border-inline-start-width"
        ],
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: [
          "border-width",
          "border-style",
          "color"
        ],
        appliesto: "allElements",
        computed: [
          "border-width",
          "border-style",
          "border-inline-start-color"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start"
      },
      "border-inline-start-color": {
        syntax: "<'border-top-color'>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-color"
      },
      "border-inline-start-style": {
        syntax: "<'border-top-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-style"
      },
      "border-inline-start-width": {
        syntax: "<'border-top-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthZeroIfBorderStyleNoneOrHidden",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-inline-start-width"
      },
      "border-left": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-left-color",
          "border-left-style",
          "border-left-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-left-width",
          "border-left-style",
          "border-left-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left"
      },
      "border-left-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-color"
      },
      "border-left-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-style"
      },
      "border-left-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderLeftStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-left-width"
      },
      "border-radius": {
        syntax: "<length-percentage>{1,4} [ / <length-percentage>{1,4} ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-left-radius",
          "border-top-right-radius",
          "border-bottom-right-radius",
          "border-bottom-left-radius"
        ],
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: [
          "border-bottom-left-radius",
          "border-bottom-right-radius",
          "border-top-left-radius",
          "border-top-right-radius"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-radius"
      },
      "border-right": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-right-color",
          "border-right-style",
          "border-right-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-right-width",
          "border-right-style",
          "border-right-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right"
      },
      "border-right-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-color"
      },
      "border-right-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-style"
      },
      "border-right-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderRightStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-right-width"
      },
      "border-spacing": {
        syntax: "<length> <length>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "0",
        appliesto: "tableElements",
        computed: "twoAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-spacing"
      },
      "border-start-end-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-end-radius"
      },
      "border-start-start-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-start-start-radius"
      },
      "border-style": {
        syntax: "<line-style>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-style",
          "border-right-style",
          "border-bottom-style",
          "border-left-style"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-style",
          "border-left-style",
          "border-right-style",
          "border-top-style"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-style"
      },
      "border-top": {
        syntax: "<line-width> || <line-style> || <color>",
        media: "visual",
        inherited: false,
        animationType: [
          "border-top-color",
          "border-top-style",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        appliesto: "allElements",
        computed: [
          "border-top-width",
          "border-top-style",
          "border-top-color"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top"
      },
      "border-top-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-color"
      },
      "border-top-left-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-left-radius"
      },
      "border-top-right-radius": {
        syntax: "<length-percentage>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfBorderBox",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "0",
        appliesto: "allElementsUAsNotRequiredWhenCollapse",
        computed: "twoAbsoluteLengthOrPercentages",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-right-radius"
      },
      "border-top-style": {
        syntax: "<line-style>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-style"
      },
      "border-top-width": {
        syntax: "<line-width>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLengthOr0IfBorderTopStyleNoneOrHidden",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-top-width"
      },
      "border-width": {
        syntax: "<line-width>{1,4}",
        media: "visual",
        inherited: false,
        animationType: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: [
          "border-top-width",
          "border-right-width",
          "border-bottom-width",
          "border-left-width"
        ],
        appliesto: "allElements",
        computed: [
          "border-bottom-width",
          "border-left-width",
          "border-right-width",
          "border-top-width"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/border-width"
      },
      bottom: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/bottom"
      },
      "box-align": {
        syntax: "start | center | end | baseline | stretch",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "stretch",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-align"
      },
      "box-decoration-break": {
        syntax: "slice | clone",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "slice",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-decoration-break"
      },
      "box-direction": {
        syntax: "normal | reverse | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "normal",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-direction"
      },
      "box-flex": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "0",
        appliesto: "directChildrenOfElementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex"
      },
      "box-flex-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "inFlowChildrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-flex-group"
      },
      "box-lines": {
        syntax: "single | multiple",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "single",
        appliesto: "boxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-lines"
      },
      "box-ordinal-group": {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "1",
        appliesto: "childrenOfBoxElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-ordinal-group"
      },
      "box-orient": {
        syntax: "horizontal | vertical | inline-axis | block-axis | inherit",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "inlineAxisHorizontalInXUL",
        appliesto: "elementsWithDisplayBoxOrInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-orient"
      },
      "box-pack": {
        syntax: "start | center | end | justify",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions",
          "WebKit Extensions"
        ],
        initial: "start",
        appliesto: "elementsWithDisplayMozBoxMozInlineBox",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-pack"
      },
      "box-shadow": {
        syntax: "none | <shadow>#",
        media: "visual",
        inherited: false,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Backgrounds and Borders"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "absoluteLengthsSpecifiedColorAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-shadow"
      },
      "box-sizing": {
        syntax: "content-box | border-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "content-box",
        appliesto: "allElementsAcceptingWidthOrHeight",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/box-sizing"
      },
      "break-after": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-after"
      },
      "break-before": {
        syntax: "auto | avoid | always | all | avoid-page | page | left | right | recto | verso | avoid-column | column | avoid-region | region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-before"
      },
      "break-inside": {
        syntax: "auto | avoid | avoid-page | avoid-column | avoid-region",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "auto",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/break-inside"
      },
      "caption-side": {
        syntax: "top | bottom | block-start | block-end | inline-start | inline-end",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "top",
        appliesto: "tableCaptionElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caption-side"
      },
      "caret-color": {
        syntax: "auto | <color>",
        media: "interactive",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asAutoOrColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/caret-color"
      },
      clear: {
        syntax: "none | left | right | both | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "blockLevelElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clear"
      },
      clip: {
        syntax: "<shape> | auto",
        media: "visual",
        inherited: false,
        animationType: "rectangle",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "absolutelyPositionedElements",
        computed: "autoOrRectangle",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip"
      },
      "clip-path": {
        syntax: "<clip-source> | [ <basic-shape> || <geometry-box> ] | none",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "referToReferenceBoxWhenSpecifiedOtherwiseBorderBox",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/clip-path"
      },
      color: {
        syntax: "<color>",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "canvastext",
        appliesto: "allElementsAndText",
        computed: "computedColor",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color"
      },
      "print-color-adjust": {
        syntax: "economy | exact",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "economy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/print-color-adjust"
      },
      "color-scheme": {
        syntax: "normal | [ light | dark | <custom-ident> ]+ && only?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "normal",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/color-scheme"
      },
      "column-count": {
        syntax: "<integer> | auto",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-count"
      },
      "column-fill": {
        syntax: "auto | balance | balance-all",
        media: "visualInContinuousMediaNoEffectInOverflowColumns",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "balance",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-fill"
      },
      "column-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "column-rule": {
        syntax: "<'column-rule-width'> || <'column-rule-style'> || <'column-rule-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-rule-width",
          "column-rule-style",
          "column-rule-color"
        ],
        appliesto: "multicolElements",
        computed: [
          "column-rule-color",
          "column-rule-style",
          "column-rule-width"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule"
      },
      "column-rule-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "currentcolor",
        appliesto: "multicolElements",
        computed: "computedColor",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-color"
      },
      "column-rule-style": {
        syntax: "<'border-style'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "multicolElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-style"
      },
      "column-rule-width": {
        syntax: "<'border-width'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "medium",
        appliesto: "multicolElements",
        computed: "absoluteLength0IfColumnRuleStyleNoneOrHidden",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-rule-width"
      },
      "column-span": {
        syntax: "none | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "none",
        appliesto: "inFlowBlockLevelElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-span"
      },
      "column-width": {
        syntax: "<length> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: "auto",
        appliesto: "blockContainersExceptTableWrappers",
        computed: "absoluteLengthZeroOrLarger",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-width"
      },
      columns: {
        syntax: "<'column-width'> || <'column-count'>",
        media: "visual",
        inherited: false,
        animationType: [
          "column-width",
          "column-count"
        ],
        percentages: "no",
        groups: [
          "CSS Columns"
        ],
        initial: [
          "column-width",
          "column-count"
        ],
        appliesto: "blockContainersExceptTableWrappers",
        computed: [
          "column-width",
          "column-count"
        ],
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/columns"
      },
      contain: {
        syntax: "none | strict | content | [ size || layout || style || paint ]",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/contain"
      },
      content: {
        syntax: "normal | none | [ <content-replacement> | <content-list> ] [/ [ <string> | <counter> ]+ ]?",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "normal",
        appliesto: "allElementsTreeAbidingPseudoElementsPageMarginBoxes",
        computed: "normalOnElementsForPseudosNoneAbsoluteURIStringOrAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content"
      },
      "content-visibility": {
        syntax: "visible | auto | hidden",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Containment"
        ],
        initial: "visible",
        appliesto: "elementsForWhichLayoutContainmentCanApply",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/content-visibility"
      },
      "counter-increment": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-increment"
      },
      "counter-reset": {
        syntax: "[ <counter-name> <integer>? | <reversed-counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-reset"
      },
      "counter-set": {
        syntax: "[ <counter-name> <integer>? ]+ | none",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Counter Styles"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/counter-set"
      },
      cursor: {
        syntax: "[ [ <url> [ <x> <y> ]? , ]* [ auto | default | none | context-menu | help | pointer | progress | wait | cell | crosshair | text | vertical-text | alias | copy | move | no-drop | not-allowed | e-resize | n-resize | ne-resize | nw-resize | s-resize | se-resize | sw-resize | w-resize | ew-resize | ns-resize | nesw-resize | nwse-resize | col-resize | row-resize | all-scroll | zoom-in | zoom-out | grab | grabbing ] ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/cursor"
      },
      direction: {
        syntax: "ltr | rtl",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "ltr",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/direction"
      },
      display: {
        syntax: "[ <display-outside> || <display-inside> ] | <display-listitem> | <display-internal> | <display-box> | <display-legacy>",
        media: "all",
        inherited: false,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Display"
        ],
        initial: "inline",
        appliesto: "allElements",
        computed: "asSpecifiedExceptPositionedFloatingAndRootElementsKeywordMaybeDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/display"
      },
      "empty-cells": {
        syntax: "show | hide",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "show",
        appliesto: "tableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/empty-cells"
      },
      filter: {
        syntax: "none | <filter-function-list>",
        media: "visual",
        inherited: false,
        animationType: "filterList",
        percentages: "no",
        groups: [
          "Filter Effects"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/filter"
      },
      flex: {
        syntax: "none | [ <'flex-grow'> <'flex-shrink'>? || <'flex-basis'> ]",
        media: "visual",
        inherited: false,
        animationType: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        appliesto: "flexItemsAndInFlowPseudos",
        computed: [
          "flex-grow",
          "flex-shrink",
          "flex-basis"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex"
      },
      "flex-basis": {
        syntax: "content | <'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToFlexContainersInnerMainSize",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "auto",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-basis"
      },
      "flex-direction": {
        syntax: "row | row-reverse | column | column-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "row",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-direction"
      },
      "flex-flow": {
        syntax: "<'flex-direction'> || <'flex-wrap'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: [
          "flex-direction",
          "flex-wrap"
        ],
        appliesto: "flexContainers",
        computed: [
          "flex-direction",
          "flex-wrap"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-flow"
      },
      "flex-grow": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-grow"
      },
      "flex-shrink": {
        syntax: "<number>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "1",
        appliesto: "flexItemsAndInFlowPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-shrink"
      },
      "flex-wrap": {
        syntax: "nowrap | wrap | wrap-reverse",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "nowrap",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/flex-wrap"
      },
      float: {
        syntax: "left | right | none | inline-start | inline-end",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "none",
        appliesto: "allElementsNoEffectIfDisplayNone",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/float"
      },
      font: {
        syntax: "[ [ <'font-style'> || <font-variant-css21> || <'font-weight'> || <'font-stretch'> ]? <'font-size'> [ / <'line-height'> ]? <'font-family'> ] | caption | icon | menu | message-box | small-caption | status-bar",
        media: "visual",
        inherited: true,
        animationType: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        percentages: [
          "font-size",
          "line-height"
        ],
        groups: [
          "CSS Fonts"
        ],
        initial: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        appliesto: "allElements",
        computed: [
          "font-style",
          "font-variant",
          "font-weight",
          "font-stretch",
          "font-size",
          "line-height",
          "font-family"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font"
      },
      "font-family": {
        syntax: "[ <family-name> | <generic-family> ]#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-family"
      },
      "font-feature-settings": {
        syntax: "normal | <feature-tag-value>#",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-feature-settings"
      },
      "font-kerning": {
        syntax: "auto | normal | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-kerning"
      },
      "font-language-override": {
        syntax: "normal | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-language-override"
      },
      "font-optical-sizing": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-optical-sizing"
      },
      "font-variation-settings": {
        syntax: "normal | [ <string> <number> ]#",
        media: "visual",
        inherited: true,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variation-settings"
      },
      "font-size": {
        syntax: "<absolute-size> | <relative-size> | <length-percentage>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToParentElementsFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size"
      },
      "font-size-adjust": {
        syntax: "none | [ ex-height | cap-height | ch-width | ic-width | ic-height ]? [ from-font | <number> ]",
        media: "visual",
        inherited: true,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-size-adjust"
      },
      "font-smooth": {
        syntax: "auto | never | always | <absolute-size> | <length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-smooth"
      },
      "font-stretch": {
        syntax: "<font-stretch-absolute>",
        media: "visual",
        inherited: true,
        animationType: "fontStretch",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-stretch"
      },
      "font-style": {
        syntax: "normal | italic | oblique <angle>?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-style"
      },
      "font-synthesis": {
        syntax: "none | [ weight || style || small-caps ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "weight style",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-synthesis"
      },
      "font-variant": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> || stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) || [ small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps ] || <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero || <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant"
      },
      "font-variant-alternates": {
        syntax: "normal | [ stylistic( <feature-value-name> ) || historical-forms || styleset( <feature-value-name># ) || character-variant( <feature-value-name># ) || swash( <feature-value-name> ) || ornaments( <feature-value-name> ) || annotation( <feature-value-name> ) ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-alternates"
      },
      "font-variant-caps": {
        syntax: "normal | small-caps | all-small-caps | petite-caps | all-petite-caps | unicase | titling-caps",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-caps"
      },
      "font-variant-east-asian": {
        syntax: "normal | [ <east-asian-variant-values> || <east-asian-width-values> || ruby ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-east-asian"
      },
      "font-variant-ligatures": {
        syntax: "normal | none | [ <common-lig-values> || <discretionary-lig-values> || <historical-lig-values> || <contextual-alt-values> ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-ligatures"
      },
      "font-variant-numeric": {
        syntax: "normal | [ <numeric-figure-values> || <numeric-spacing-values> || <numeric-fraction-values> || ordinal || slashed-zero ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-numeric"
      },
      "font-variant-position": {
        syntax: "normal | sub | super",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-variant-position"
      },
      "font-weight": {
        syntax: "<font-weight-absolute> | bolder | lighter",
        media: "visual",
        inherited: true,
        animationType: "fontWeight",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "keywordOrNumericalValueBolderLighterTransformedToRealValue",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/font-weight"
      },
      "forced-color-adjust": {
        syntax: "auto | none",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Color"
        ],
        initial: "auto",
        appliesto: "allElementsAndText",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/forced-color-adjust"
      },
      gap: {
        syntax: "<'row-gap'> <'column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "row-gap",
          "column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "row-gap",
          "column-gap"
        ],
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: [
          "row-gap",
          "column-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      grid: {
        syntax: "<'grid-template'> | <'grid-template-rows'> / [ auto-flow && dense? ] <'grid-auto-columns'>? | [ auto-flow && dense? ] <'grid-auto-rows'>? / <'grid-template-columns'>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-auto-rows",
          "grid-auto-columns"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-rows",
          "grid-template-columns",
          "grid-template-areas",
          "grid-auto-rows",
          "grid-auto-columns",
          "grid-auto-flow",
          "grid-column-gap",
          "grid-row-gap",
          "column-gap",
          "row-gap"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid"
      },
      "grid-area": {
        syntax: "<grid-line> [ / <grid-line> ]{0,3}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-column-start",
          "grid-row-end",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-area"
      },
      "grid-auto-columns": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-columns"
      },
      "grid-auto-flow": {
        syntax: "[ row | column ] || dense",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "row",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-flow"
      },
      "grid-auto-rows": {
        syntax: "<track-size>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-auto-rows"
      },
      "grid-column": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-column-start",
          "grid-column-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-column-start",
          "grid-column-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column"
      },
      "grid-column-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-end"
      },
      "grid-column-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/column-gap"
      },
      "grid-column-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-column-start"
      },
      "grid-gap": {
        syntax: "<'grid-row-gap'> <'grid-column-gap'>?",
        media: "visual",
        inherited: false,
        animationType: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-row-gap",
          "grid-column-gap"
        ],
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/gap"
      },
      "grid-row": {
        syntax: "<grid-line> [ / <grid-line> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-row-start",
          "grid-row-end"
        ],
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: [
          "grid-row-start",
          "grid-row-end"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row"
      },
      "grid-row-end": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-end"
      },
      "grid-row-gap": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "0",
        appliesto: "gridContainers",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "grid-row-start": {
        syntax: "<grid-line>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "auto",
        appliesto: "gridItemsAndBoxesWithinGridContainer",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-row-start"
      },
      "grid-template": {
        syntax: "none | [ <'grid-template-rows'> / <'grid-template-columns'> ] | [ <line-names>? <string> <track-size>? <line-names>? ]+ [ / <explicit-track-list> ]?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: [
          "grid-template-columns",
          "grid-template-rows"
        ],
        groups: [
          "CSS Grid Layout"
        ],
        initial: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        appliesto: "gridContainers",
        computed: [
          "grid-template-columns",
          "grid-template-rows",
          "grid-template-areas"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template"
      },
      "grid-template-areas": {
        syntax: "none | <string>+",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-areas"
      },
      "grid-template-columns": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-columns"
      },
      "grid-template-rows": {
        syntax: "none | <track-list> | <auto-track-list> | subgrid <line-name-list>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpcDifferenceLpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "none",
        appliesto: "gridContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/grid-template-rows"
      },
      "hanging-punctuation": {
        syntax: "none | [ first || [ force-end | allow-end ] || last ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hanging-punctuation"
      },
      height: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesRelativeToContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAutoOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/height"
      },
      "hyphenate-character": {
        syntax: "auto | <string>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphenate-character"
      },
      hyphens: {
        syntax: "none | manual | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "manual",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/hyphens"
      },
      "image-orientation": {
        syntax: "from-image | <angle> | [ <angle>? flip ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "from-image",
        appliesto: "allElements",
        computed: "angleRoundedToNextQuarter",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-orientation"
      },
      "image-rendering": {
        syntax: "auto | crisp-edges | pixelated",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/image-rendering"
      },
      "image-resolution": {
        syntax: "[ from-image || <resolution> ] && snap?",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "1dppx",
        appliesto: "allElements",
        computed: "asSpecifiedWithExceptionOfResolution",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ime-mode": {
        syntax: "auto | normal | active | inactive | disabled",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "textFields",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ime-mode"
      },
      "initial-letter": {
        syntax: "normal | [ <number> <integer>? ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "normal",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter"
      },
      "initial-letter-align": {
        syntax: "[ auto | alphabetic | hanging | ideographic ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Inline"
        ],
        initial: "auto",
        appliesto: "firstLetterPseudoElementsAndInlineLevelFirstChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/initial-letter-align"
      },
      "inline-size": {
        syntax: "<'width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsWidthAndHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inline-size"
      },
      "input-security": {
        syntax: "auto | none",
        media: "interactive",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "sensitiveTextInputs",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      inset: {
        syntax: "<'top'>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOrWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset"
      },
      "inset-block": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block"
      },
      "inset-block-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-end"
      },
      "inset-block-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalHeightOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-block-start"
      },
      "inset-inline": {
        syntax: "<'top'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline"
      },
      "inset-inline-end": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-end"
      },
      "inset-inline-start": {
        syntax: "<'top'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "sameAsBoxOffsets",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/inset-inline-start"
      },
      isolation: {
        syntax: "auto | isolate",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerGraphicsAndGraphicsReferencingElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/isolation"
      },
      "justify-content": {
        syntax: "normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "flexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-content"
      },
      "justify-items": {
        syntax: "normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ] | legacy | legacy && [ left | right | center ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "legacy",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-items"
      },
      "justify-self": {
        syntax: "auto | normal | stretch | <baseline-position> | <overflow-position>? [ <self-position> | left | right ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "auto",
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-self"
      },
      "justify-tracks": {
        syntax: "[ normal | <content-distribution> | <overflow-position>? [ <content-position> | left | right ] ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "normal",
        appliesto: "gridContainersWithMasonryLayoutInTheirInlineAxis",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/justify-tracks"
      },
      left: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/left"
      },
      "letter-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumValueOfAbsoluteLengthOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/letter-spacing"
      },
      "line-break": {
        syntax: "auto | loose | normal | strict | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-break"
      },
      "line-clamp": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "line-height": {
        syntax: "normal | <number> | <length> | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "numberOrLength",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Fonts"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "absoluteLengthOrAsSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height"
      },
      "line-height-step": {
        syntax: "<length>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fonts"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "absoluteLength",
        order: "perGrammar",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/line-height-step"
      },
      "list-style": {
        syntax: "<'list-style-type'> || <'list-style-position'> || <'list-style-image'>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: [
          "list-style-type",
          "list-style-position",
          "list-style-image"
        ],
        appliesto: "listItems",
        computed: [
          "list-style-image",
          "list-style-position",
          "list-style-type"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style"
      },
      "list-style-image": {
        syntax: "<image> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "none",
        appliesto: "listItems",
        computed: "theKeywordListStyleImageNoneOrComputedValue",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-image"
      },
      "list-style-position": {
        syntax: "inside | outside",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "outside",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-position"
      },
      "list-style-type": {
        syntax: "<counter-style> | <string> | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Lists and Counters"
        ],
        initial: "disc",
        appliesto: "listItems",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/list-style-type"
      },
      margin: {
        syntax: "[ <length> | <percentage> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: [
          "margin-bottom",
          "margin-left",
          "margin-right",
          "margin-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin"
      },
      "margin-block": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block"
      },
      "margin-block-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-end"
      },
      "margin-block-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-block-start"
      },
      "margin-bottom": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-bottom"
      },
      "margin-inline": {
        syntax: "<'margin-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline"
      },
      "margin-inline-end": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-end"
      },
      "margin-inline-start": {
        syntax: "<'margin-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "dependsOnLayoutModel",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsMargin",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-inline-start"
      },
      "margin-left": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-left"
      },
      "margin-right": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-right"
      },
      "margin-top": {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-top"
      },
      "margin-trim": {
        syntax: "none | in-flow | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "blockContainersAndMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/margin-trim"
      },
      mask: {
        syntax: "<mask-layer>#",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        percentages: [
          "mask-position"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-image",
          "mask-mode",
          "mask-repeat",
          "mask-position",
          "mask-clip",
          "mask-origin",
          "mask-size",
          "mask-composite"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask"
      },
      "mask-border": {
        syntax: "<'mask-border-source'> || <'mask-border-slice'> [ / <'mask-border-width'>? [ / <'mask-border-outset'> ]? ]? || <'mask-border-repeat'> || <'mask-border-mode'>",
        media: "visual",
        inherited: false,
        animationType: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        percentages: [
          "mask-border-slice",
          "mask-border-width"
        ],
        groups: [
          "CSS Masking"
        ],
        initial: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        appliesto: "allElementsSVGContainerElements",
        computed: [
          "mask-border-mode",
          "mask-border-outset",
          "mask-border-repeat",
          "mask-border-slice",
          "mask-border-source",
          "mask-border-width"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border"
      },
      "mask-border-mode": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "alpha",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-mode"
      },
      "mask-border-outset": {
        syntax: "[ <length> | <number> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-outset"
      },
      "mask-border-repeat": {
        syntax: "[ stretch | repeat | round | space ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "stretch",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-repeat"
      },
      "mask-border-slice": {
        syntax: "<number-percentage>{1,4} fill?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "referToSizeOfMaskBorderImage",
        groups: [
          "CSS Masking"
        ],
        initial: "0",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-slice"
      },
      "mask-border-source": {
        syntax: "none | <image>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-source"
      },
      "mask-border-width": {
        syntax: "[ <length-percentage> | <number> | auto ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToMaskBorderImageArea",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-border-width"
      },
      "mask-clip": {
        syntax: "[ <geometry-box> | no-clip ]#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-clip"
      },
      "mask-composite": {
        syntax: "<compositing-operator>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "add",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-composite"
      },
      "mask-image": {
        syntax: "<mask-reference>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "none",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedURLsAbsolute",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-image"
      },
      "mask-mode": {
        syntax: "<masking-mode>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "match-source",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-mode"
      },
      "mask-origin": {
        syntax: "<geometry-box>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "border-box",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-origin"
      },
      "mask-position": {
        syntax: "<position>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToSizeOfMaskPaintingArea",
        groups: [
          "CSS Masking"
        ],
        initial: "center",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoKeywordsForOriginAndOffsets",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-position"
      },
      "mask-repeat": {
        syntax: "<repeat-style>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "no-repeat",
        appliesto: "allElementsSVGContainerElements",
        computed: "consistsOfTwoDimensionKeywords",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-repeat"
      },
      "mask-size": {
        syntax: "<bg-size>#",
        media: "visual",
        inherited: false,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "auto",
        appliesto: "allElementsSVGContainerElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-size"
      },
      "mask-type": {
        syntax: "luminance | alpha",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Masking"
        ],
        initial: "luminance",
        appliesto: "maskElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mask-type"
      },
      "masonry-auto-flow": {
        syntax: "[ pack | next ] || [ definite-first | ordered ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Grid Layout"
        ],
        initial: "pack",
        appliesto: "gridContainersWithMasonryLayout",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/masonry-auto-flow"
      },
      "math-style": {
        syntax: "normal | compact",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "MathML"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/math-style"
      },
      "max-block-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-block-size"
      },
      "max-height": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentagesNone",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-height"
      },
      "max-inline-size": {
        syntax: "<'max-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "none",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMaxWidthAndMaxHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-inline-size"
      },
      "max-lines": {
        syntax: "none | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "none",
        appliesto: "blockContainersExceptMultiColumnContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "experimental"
      },
      "max-width": {
        syntax: "none | <length-percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "none",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedAbsoluteLengthOrNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/max-width"
      },
      "min-block-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "blockSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-block-size"
      },
      "min-height": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "regardingHeightOfGeneratedBoxContainingBlockPercentages0",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableColumns",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-height"
      },
      "min-inline-size": {
        syntax: "<'min-width'>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "inlineSizeOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "sameAsWidthAndHeight",
        computed: "sameAsMinWidthAndMinHeight",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-inline-size"
      },
      "min-width": {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/min-width"
      },
      "mix-blend-mode": {
        syntax: "<blend-mode> | plus-lighter",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Compositing and Blending"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/mix-blend-mode"
      },
      "object-fit": {
        syntax: "fill | contain | cover | none | scale-down",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Images"
        ],
        initial: "fill",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-fit"
      },
      "object-position": {
        syntax: "<position>",
        media: "visual",
        inherited: true,
        animationType: "repeatableListOfSimpleListOfLpc",
        percentages: "referToWidthAndHeightOfElement",
        groups: [
          "CSS Images"
        ],
        initial: "50% 50%",
        appliesto: "replacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/object-position"
      },
      offset: {
        syntax: "[ <'offset-position'>? [ <'offset-path'> [ <'offset-distance'> || <'offset-rotate'> ]? ]? ]! [ / <'offset-anchor'> ]?",
        media: "visual",
        inherited: false,
        animationType: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        percentages: [
          "offset-position",
          "offset-distance",
          "offset-anchor"
        ],
        groups: [
          "CSS Motion Path"
        ],
        initial: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        appliesto: "transformableElements",
        computed: [
          "offset-position",
          "offset-path",
          "offset-distance",
          "offset-anchor",
          "offset-rotate"
        ],
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset"
      },
      "offset-anchor": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "relativeToWidthAndHeight",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard"
      },
      "offset-distance": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToTotalPathLength",
        groups: [
          "CSS Motion Path"
        ],
        initial: "0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-distance"
      },
      "offset-path": {
        syntax: "none | ray( [ <angle> && <size> && contain? ] ) | <path()> | <url> | [ <basic-shape> || <geometry-box> ]",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-path"
      },
      "offset-position": {
        syntax: "auto | <position>",
        media: "visual",
        inherited: false,
        animationType: "position",
        percentages: "referToSizeOfContainingBlock",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "perGrammar",
        status: "experimental"
      },
      "offset-rotate": {
        syntax: "[ auto | reverse ] || <angle>",
        media: "visual",
        inherited: false,
        animationType: "angleOrBasicShapeOrPath",
        percentages: "no",
        groups: [
          "CSS Motion Path"
        ],
        initial: "auto",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/offset-rotate"
      },
      opacity: {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "mapToRange0To1",
        groups: [
          "CSS Color"
        ],
        initial: "1",
        appliesto: "allElements",
        computed: "specifiedValueNumberClipped0To1",
        order: "perGrammar",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/opacity"
      },
      order: {
        syntax: "<integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Flexible Box Layout"
        ],
        initial: "0",
        appliesto: "flexItemsGridItemsAbsolutelyPositionedContainerChildren",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/order"
      },
      orphans: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/orphans"
      },
      outline: {
        syntax: "[ <'outline-color'> || <'outline-style'> || <'outline-width'> ]",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: [
          "outline-color",
          "outline-style",
          "outline-width"
        ],
        appliesto: "allElements",
        computed: [
          "outline-color",
          "outline-width",
          "outline-style"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline"
      },
      "outline-color": {
        syntax: "<color> | invert",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "invertOrCurrentColor",
        appliesto: "allElements",
        computed: "invertForTranslucentColorRGBAOtherwiseRGB",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-color"
      },
      "outline-offset": {
        syntax: "<length>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-offset"
      },
      "outline-style": {
        syntax: "auto | <'border-style'>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-style"
      },
      "outline-width": {
        syntax: "<line-width>",
        media: [
          "visual",
          "interactive"
        ],
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "medium",
        appliesto: "allElements",
        computed: "absoluteLength0ForNone",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/outline-width"
      },
      overflow: {
        syntax: "[ visible | hidden | clip | scroll | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: [
          "overflow-x",
          "overflow-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow"
      },
      "overflow-anchor": {
        syntax: "auto | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Anchoring"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-block": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-clip-box": {
        syntax: "padding-box | content-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Mozilla Extensions"
        ],
        initial: "padding-box",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Mozilla/CSS/overflow-clip-box"
      },
      "overflow-clip-margin": {
        syntax: "<visual-box> || <length [0,\u221E]>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "0px",
        appliesto: "allElements",
        computed: "theComputedLength",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-inline": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "perGrammar",
        status: "standard"
      },
      "overflow-wrap": {
        syntax: "normal | break-word | anywhere",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "overflow-x": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-x"
      },
      "overflow-y": {
        syntax: "visible | hidden | clip | scroll | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "visible",
        appliesto: "blockContainersFlexContainersGridContainers",
        computed: "asSpecifiedButVisibleOrClipReplacedToAutoOrHiddenIfOtherValueDifferent",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-y"
      },
      "overscroll-behavior": {
        syntax: "[ contain | none | auto ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: [
          "overscroll-behavior-x",
          "overscroll-behavior-y"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior"
      },
      "overscroll-behavior-block": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-block"
      },
      "overscroll-behavior-inline": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-inline"
      },
      "overscroll-behavior-x": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-x"
      },
      "overscroll-behavior-y": {
        syntax: "contain | none | auto",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "nonReplacedBlockAndInlineBlockElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overscroll-behavior-y"
      },
      padding: {
        syntax: "[ <length> | <percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: [
          "padding-bottom",
          "padding-left",
          "padding-right",
          "padding-top"
        ],
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding"
      },
      "padding-block": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block"
      },
      "padding-block-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-end"
      },
      "padding-block-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-block-start"
      },
      "padding-bottom": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-bottom"
      },
      "padding-inline": {
        syntax: "<'padding-left'>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline"
      },
      "padding-inline-end": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-end"
      },
      "padding-inline-start": {
        syntax: "<'padding-left'>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "logicalWidthOfContainingBlock",
        groups: [
          "CSS Logical Properties"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-inline-start"
      },
      "padding-left": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-left"
      },
      "padding-right": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-right"
      },
      "padding-top": {
        syntax: "<length> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "0",
        appliesto: "allElementsExceptInternalTableDisplayTypes",
        computed: "percentageAsSpecifiedOrAbsoluteLength",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/padding-top"
      },
      "page-break-after": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-after"
      },
      "page-break-before": {
        syntax: "auto | always | avoid | left | right | recto | verso",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-before"
      },
      "page-break-inside": {
        syntax: "auto | avoid",
        media: [
          "visual",
          "paged"
        ],
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Pages"
        ],
        initial: "auto",
        appliesto: "blockElementsInNormalFlow",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/page-break-inside"
      },
      "paint-order": {
        syntax: "normal | [ fill || stroke || markers ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/paint-order"
      },
      perspective: {
        syntax: "none | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "absoluteLengthOrNone",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective"
      },
      "perspective-origin": {
        syntax: "<position>",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50%",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/perspective-origin"
      },
      "place-content": {
        syntax: "<'align-content'> <'justify-content'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multilineFlexContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-content"
      },
      "place-items": {
        syntax: "<'align-items'> <'justify-items'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-items",
          "justify-items"
        ],
        appliesto: "allElements",
        computed: [
          "align-items",
          "justify-items"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-items"
      },
      "place-self": {
        syntax: "<'align-self'> <'justify-self'>?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Box Alignment"
        ],
        initial: [
          "align-self",
          "justify-self"
        ],
        appliesto: "blockLevelBoxesAndAbsolutelyPositionedBoxesAndGridItems",
        computed: [
          "align-self",
          "justify-self"
        ],
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/place-self"
      },
      "pointer-events": {
        syntax: "auto | none | visiblePainted | visibleFill | visibleStroke | visible | painted | fill | stroke | all | inherit",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/pointer-events"
      },
      position: {
        syntax: "static | relative | absolute | sticky | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "static",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/position"
      },
      quotes: {
        syntax: "none | auto | [ <string> <string> ]+",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Generated Content"
        ],
        initial: "dependsOnUserAgent",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/quotes"
      },
      resize: {
        syntax: "none | both | horizontal | vertical | block | inline",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "none",
        appliesto: "elementsWithOverflowNotVisibleAndReplacedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/resize"
      },
      right: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/right"
      },
      rotate: {
        syntax: "none | <angle> | [ x | y | z | <number>{3} ] && <angle>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/rotate"
      },
      "row-gap": {
        syntax: "normal | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToDimensionOfContentArea",
        groups: [
          "CSS Box Alignment"
        ],
        initial: "normal",
        appliesto: "multiColumnElementsFlexContainersGridContainers",
        computed: "asSpecifiedWithLengthsAbsoluteAndNormalComputingToZeroExceptMultiColumn",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/row-gap"
      },
      "ruby-align": {
        syntax: "start | center | space-between | space-around",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "space-around",
        appliesto: "rubyBasesAnnotationsBaseAnnotationContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-align"
      },
      "ruby-merge": {
        syntax: "separate | collapse | auto",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "separate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental"
      },
      "ruby-position": {
        syntax: "[ alternate || [ over | under ] ] | inter-character",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Ruby"
        ],
        initial: "alternate",
        appliesto: "rubyAnnotationsContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/ruby-position"
      },
      scale: {
        syntax: "none | <number>{1,3}",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scale"
      },
      "scrollbar-color": {
        syntax: "auto | <color>{2}",
        media: "visual",
        inherited: true,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-color"
      },
      "scrollbar-gutter": {
        syntax: "auto | stable && both-edges?",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Overflow"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-gutter"
      },
      "scrollbar-width": {
        syntax: "auto | thin | none",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scrollbars"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scrollbar-width"
      },
      "scroll-behavior": {
        syntax: "auto | smooth",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSSOM View"
        ],
        initial: "auto",
        appliesto: "scrollingBoxes",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-behavior"
      },
      "scroll-margin": {
        syntax: "<length>{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin"
      },
      "scroll-margin-block": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block"
      },
      "scroll-margin-block-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-start"
      },
      "scroll-margin-block-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-block-end"
      },
      "scroll-margin-bottom": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-bottom"
      },
      "scroll-margin-inline": {
        syntax: "<length>{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline"
      },
      "scroll-margin-inline-start": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-start"
      },
      "scroll-margin-inline-end": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-inline-end"
      },
      "scroll-margin-left": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-left"
      },
      "scroll-margin-right": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-right"
      },
      "scroll-margin-top": {
        syntax: "<length>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-margin-top"
      },
      "scroll-padding": {
        syntax: "[ auto | <length-percentage> ]{1,4}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding"
      },
      "scroll-padding-block": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block"
      },
      "scroll-padding-block-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-start"
      },
      "scroll-padding-block-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-block-end"
      },
      "scroll-padding-bottom": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-bottom"
      },
      "scroll-padding-inline": {
        syntax: "[ auto | <length-percentage> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline"
      },
      "scroll-padding-inline-start": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-start"
      },
      "scroll-padding-inline-end": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-inline-end"
      },
      "scroll-padding-left": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-left"
      },
      "scroll-padding-right": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-right"
      },
      "scroll-padding-top": {
        syntax: "auto | <length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "relativeToTheScrollContainersScrollport",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "auto",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-padding-top"
      },
      "scroll-snap-align": {
        syntax: "[ none | start | end | center ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-align"
      },
      "scroll-snap-coordinate": {
        syntax: "none | <position>#",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "referToBorderBox",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-coordinate"
      },
      "scroll-snap-destination": {
        syntax: "<position>",
        media: "interactive",
        inherited: false,
        animationType: "position",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "0px 0px",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-destination"
      },
      "scroll-snap-points-x": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-x"
      },
      "scroll-snap-points-y": {
        syntax: "none | repeat( <length-percentage> )",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "relativeToScrollContainerPaddingBoxAxis",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-points-y"
      },
      "scroll-snap-stop": {
        syntax: "normal | always",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-stop"
      },
      "scroll-snap-type": {
        syntax: "none | [ x | y | block | inline | both ] [ mandatory | proximity ]?",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type"
      },
      "scroll-snap-type-x": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-x"
      },
      "scroll-snap-type-y": {
        syntax: "none | mandatory | proximity",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Scroll Snap"
        ],
        initial: "none",
        appliesto: "scrollContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "obsolete",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/scroll-snap-type-y"
      },
      "shape-image-threshold": {
        syntax: "<alpha-value>",
        media: "visual",
        inherited: false,
        animationType: "number",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "0.0",
        appliesto: "floats",
        computed: "specifiedValueNumberClipped0To1",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-image-threshold"
      },
      "shape-margin": {
        syntax: "<length-percentage>",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Shapes"
        ],
        initial: "0",
        appliesto: "floats",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-margin"
      },
      "shape-outside": {
        syntax: "none | [ <shape-box> || <basic-shape> ] | <image>",
        media: "visual",
        inherited: false,
        animationType: "basicShapeOtherwiseNo",
        percentages: "no",
        groups: [
          "CSS Shapes"
        ],
        initial: "none",
        appliesto: "floats",
        computed: "asDefinedForBasicShapeWithAbsoluteURIOtherwiseAsSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/shape-outside"
      },
      "tab-size": {
        syntax: "<integer> | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "8",
        appliesto: "blockContainers",
        computed: "specifiedIntegerOrAbsoluteLength",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/tab-size"
      },
      "table-layout": {
        syntax: "auto | fixed",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Table"
        ],
        initial: "auto",
        appliesto: "tableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/table-layout"
      },
      "text-align": {
        syntax: "start | end | left | right | center | justify | match-parent",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "startOrNamelessValueIfLTRRightIfRTL",
        appliesto: "blockContainers",
        computed: "asSpecifiedExceptMatchParent",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align"
      },
      "text-align-last": {
        syntax: "auto | start | end | left | right | center | justify",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "blockContainers",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-align-last"
      },
      "text-combine-upright": {
        syntax: "none | all | [ digits <integer>? ]",
        media: "visual",
        inherited: true,
        animationType: "notAnimatable",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "none",
        appliesto: "nonReplacedInlineElements",
        computed: "keywordPlusIntegerIfDigits",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-combine-upright"
      },
      "text-decoration": {
        syntax: "<'text-decoration-line'> || <'text-decoration-style'> || <'text-decoration-color'> || <'text-decoration-thickness'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line",
          "text-decoration-thickness"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-decoration-color",
          "text-decoration-style",
          "text-decoration-line"
        ],
        appliesto: "allElements",
        computed: [
          "text-decoration-line",
          "text-decoration-style",
          "text-decoration-color",
          "text-decoration-thickness"
        ],
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration"
      },
      "text-decoration-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-color"
      },
      "text-decoration-line": {
        syntax: "none | [ underline || overline || line-through || blink ] | spelling-error | grammar-error",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-line"
      },
      "text-decoration-skip": {
        syntax: "none | [ objects || [ spaces | [ leading-spaces || trailing-spaces ] ] || edges || box-decoration ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "objects",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip"
      },
      "text-decoration-skip-ink": {
        syntax: "auto | all | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-skip-ink"
      },
      "text-decoration-style": {
        syntax: "solid | double | dotted | dashed | wavy",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "solid",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-style"
      },
      "text-decoration-thickness": {
        syntax: "auto | from-font | <length> | <percentage> ",
        media: "visual",
        inherited: false,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-decoration-thickness"
      },
      "text-emphasis": {
        syntax: "<'text-emphasis-style'> || <'text-emphasis-color'>",
        media: "visual",
        inherited: false,
        animationType: [
          "text-emphasis-color",
          "text-emphasis-style"
        ],
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        appliesto: "allElements",
        computed: [
          "text-emphasis-style",
          "text-emphasis-color"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis"
      },
      "text-emphasis-color": {
        syntax: "<color>",
        media: "visual",
        inherited: false,
        animationType: "color",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "currentcolor",
        appliesto: "allElements",
        computed: "computedColor",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-color"
      },
      "text-emphasis-position": {
        syntax: "[ over | under ] && [ right | left ]",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "over right",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-position"
      },
      "text-emphasis-style": {
        syntax: "none | [ [ filled | open ] || [ dot | circle | double-circle | triangle | sesame ] ] | <string>",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-emphasis-style"
      },
      "text-indent": {
        syntax: "<length-percentage> && hanging? && each-line?",
        media: "visual",
        inherited: true,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Text"
        ],
        initial: "0",
        appliesto: "blockContainers",
        computed: "percentageOrAbsoluteLengthPlusKeywords",
        order: "lengthOrPercentageBeforeKeywords",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-indent"
      },
      "text-justify": {
        syntax: "auto | inter-character | inter-word | none",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "auto",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-justify"
      },
      "text-orientation": {
        syntax: "mixed | upright | sideways",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "mixed",
        appliesto: "allElementsExceptTableRowGroupsRowsColumnGroupsAndColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-orientation"
      },
      "text-overflow": {
        syntax: "[ clip | ellipsis | <string> ]{1,2}",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "clip",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-overflow"
      },
      "text-rendering": {
        syntax: "auto | optimizeSpeed | optimizeLegibility | geometricPrecision",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Miscellaneous"
        ],
        initial: "auto",
        appliesto: "textElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-rendering"
      },
      "text-shadow": {
        syntax: "none | <shadow-t>#",
        media: "visual",
        inherited: true,
        animationType: "shadowList",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "colorPlusThreeAbsoluteLengths",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-shadow"
      },
      "text-size-adjust": {
        syntax: "none | auto | <percentage>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "referToSizeOfFont",
        groups: [
          "CSS Text"
        ],
        initial: "autoForSmartphoneBrowsersSupportingInflation",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "experimental",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-size-adjust"
      },
      "text-transform": {
        syntax: "none | capitalize | uppercase | lowercase | full-width | full-size-kana",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "none",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-transform"
      },
      "text-underline-offset": {
        syntax: "auto | <length> | <percentage> ",
        media: "visual",
        inherited: true,
        animationType: "byComputedValueType",
        percentages: "referToElementFontSize",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-offset"
      },
      "text-underline-position": {
        syntax: "auto | from-font | [ under || [ left | right ] ]",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text Decoration"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/text-underline-position"
      },
      top: {
        syntax: "<length> | <percentage> | auto",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToContainingBlockHeight",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "lengthAbsolutePercentageAsSpecifiedOtherwiseAuto",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/top"
      },
      "touch-action": {
        syntax: "auto | none | [ [ pan-x | pan-left | pan-right ] || [ pan-y | pan-up | pan-down ] || pinch-zoom ] | manipulation",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "Pointer Events"
        ],
        initial: "auto",
        appliesto: "allElementsExceptNonReplacedInlineElementsTableRowsColumnsRowColumnGroups",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/touch-action"
      },
      transform: {
        syntax: "none | <transform-list>",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform"
      },
      "transform-box": {
        syntax: "content-box | border-box | fill-box | stroke-box | view-box",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "view-box",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-box"
      },
      "transform-origin": {
        syntax: "[ <length-percentage> | left | center | right | top | bottom ] | [ [ <length-percentage> | left | center | right ] && [ <length-percentage> | top | center | bottom ] ] <length>?",
        media: "visual",
        inherited: false,
        animationType: "simpleListOfLpc",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "50% 50% 0",
        appliesto: "transformableElements",
        computed: "forLengthAbsoluteValueOtherwisePercentage",
        order: "oneOrTwoValuesLengthAbsoluteKeywordsPercentages",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-origin"
      },
      "transform-style": {
        syntax: "flat | preserve-3d",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transforms"
        ],
        initial: "flat",
        appliesto: "transformableElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transform-style"
      },
      transition: {
        syntax: "<single-transition>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        appliesto: "allElementsAndPseudos",
        computed: [
          "transition-delay",
          "transition-duration",
          "transition-property",
          "transition-timing-function"
        ],
        order: "orderOfAppearance",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition"
      },
      "transition-delay": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-delay"
      },
      "transition-duration": {
        syntax: "<time>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "0s",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-duration"
      },
      "transition-property": {
        syntax: "none | <single-transition-property>#",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "all",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-property"
      },
      "transition-timing-function": {
        syntax: "<easing-function>#",
        media: "interactive",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Transitions"
        ],
        initial: "ease",
        appliesto: "allElementsAndPseudos",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/transition-timing-function"
      },
      translate: {
        syntax: "none | <length-percentage> [ <length-percentage> <length>? ]?",
        media: "visual",
        inherited: false,
        animationType: "transform",
        percentages: "referToSizeOfBoundingBox",
        groups: [
          "CSS Transforms"
        ],
        initial: "none",
        appliesto: "transformableElements",
        computed: "asSpecifiedRelativeToAbsoluteLengths",
        order: "perGrammar",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/translate"
      },
      "unicode-bidi": {
        syntax: "normal | embed | isolate | bidi-override | isolate-override | plaintext",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "normal",
        appliesto: "allElementsSomeValuesNoEffectOnNonInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/unicode-bidi"
      },
      "user-select": {
        syntax: "auto | text | none | contain | all",
        media: "visual",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Basic User Interface"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/user-select"
      },
      "vertical-align": {
        syntax: "baseline | sub | super | text-top | text-bottom | middle | top | bottom | <percentage> | <length>",
        media: "visual",
        inherited: false,
        animationType: "length",
        percentages: "referToLineHeight",
        groups: [
          "CSS Table"
        ],
        initial: "baseline",
        appliesto: "inlineLevelAndTableCellElements",
        computed: "absoluteLengthOrKeyword",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/vertical-align"
      },
      visibility: {
        syntax: "visible | hidden | collapse",
        media: "visual",
        inherited: true,
        animationType: "visibility",
        percentages: "no",
        groups: [
          "CSS Box Model"
        ],
        initial: "visible",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/visibility"
      },
      "white-space": {
        syntax: "normal | pre | nowrap | pre-wrap | pre-line | break-spaces",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/white-space"
      },
      widows: {
        syntax: "<integer>",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Fragmentation"
        ],
        initial: "2",
        appliesto: "blockContainerElements",
        computed: "asSpecified",
        order: "perGrammar",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/widows"
      },
      width: {
        syntax: "auto | <length> | <percentage> | min-content | max-content | fit-content | fit-content(<length-percentage>)",
        media: "visual",
        inherited: false,
        animationType: "lpc",
        percentages: "referToWidthOfContainingBlock",
        groups: [
          "CSS Box Model"
        ],
        initial: "auto",
        appliesto: "allElementsButNonReplacedAndTableRows",
        computed: "percentageAutoOrAbsoluteLength",
        order: "lengthOrPercentageBeforeKeywordIfBothPresent",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/width"
      },
      "will-change": {
        syntax: "auto | <animateable-feature>#",
        media: "all",
        inherited: false,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Will Change"
        ],
        initial: "auto",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/will-change"
      },
      "word-break": {
        syntax: "normal | break-all | keep-all | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-break"
      },
      "word-spacing": {
        syntax: "normal | <length>",
        media: "visual",
        inherited: true,
        animationType: "length",
        percentages: "referToWidthOfAffectedGlyph",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "optimumMinAndMaxValueOfAbsoluteLengthPercentageOrNormal",
        order: "uniqueOrder",
        alsoAppliesTo: [
          "::first-letter",
          "::first-line",
          "::placeholder"
        ],
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/word-spacing"
      },
      "word-wrap": {
        syntax: "normal | break-word",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Text"
        ],
        initial: "normal",
        appliesto: "nonReplacedInlineElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/overflow-wrap"
      },
      "writing-mode": {
        syntax: "horizontal-tb | vertical-rl | vertical-lr | sideways-rl | sideways-lr",
        media: "visual",
        inherited: true,
        animationType: "discrete",
        percentages: "no",
        groups: [
          "CSS Writing Modes"
        ],
        initial: "horizontal-tb",
        appliesto: "allElementsExceptTableRowColumnGroupsTableRowsColumns",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/writing-mode"
      },
      "z-index": {
        syntax: "auto | <integer>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "CSS Positioning"
        ],
        initial: "auto",
        appliesto: "positionedElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        stacking: true,
        status: "standard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/z-index"
      },
      zoom: {
        syntax: "normal | reset | <number> | <percentage>",
        media: "visual",
        inherited: false,
        animationType: "integer",
        percentages: "no",
        groups: [
          "Microsoft Extensions"
        ],
        initial: "normal",
        appliesto: "allElements",
        computed: "asSpecified",
        order: "uniqueOrder",
        status: "nonstandard",
        mdn_url: "https://developer.mozilla.org/docs/Web/CSS/zoom"
      }
    };
  }
});

// node_modules/csso/node_modules/mdn-data/css/syntaxes.json
var require_syntaxes2 = __commonJS({
  "node_modules/csso/node_modules/mdn-data/css/syntaxes.json"(exports2, module2) {
    module2.exports = {
      "absolute-size": {
        syntax: "xx-small | x-small | small | medium | large | x-large | xx-large | xxx-large"
      },
      "alpha-value": {
        syntax: "<number> | <percentage>"
      },
      "angle-percentage": {
        syntax: "<angle> | <percentage>"
      },
      "angular-color-hint": {
        syntax: "<angle-percentage>"
      },
      "angular-color-stop": {
        syntax: "<color> && <color-stop-angle>?"
      },
      "angular-color-stop-list": {
        syntax: "[ <angular-color-stop> [, <angular-color-hint>]? ]# , <angular-color-stop>"
      },
      "animateable-feature": {
        syntax: "scroll-position | contents | <custom-ident>"
      },
      attachment: {
        syntax: "scroll | fixed | local"
      },
      "attr()": {
        syntax: "attr( <attr-name> <type-or-unit>? [, <attr-fallback> ]? )"
      },
      "attr-matcher": {
        syntax: "[ '~' | '|' | '^' | '$' | '*' ]? '='"
      },
      "attr-modifier": {
        syntax: "i | s"
      },
      "attribute-selector": {
        syntax: "'[' <wq-name> ']' | '[' <wq-name> <attr-matcher> [ <string-token> | <ident-token> ] <attr-modifier>? ']'"
      },
      "auto-repeat": {
        syntax: "repeat( [ auto-fill | auto-fit ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "auto-track-list": {
        syntax: "[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>? <auto-repeat>\n[ <line-names>? [ <fixed-size> | <fixed-repeat> ] ]* <line-names>?"
      },
      "baseline-position": {
        syntax: "[ first | last ]? baseline"
      },
      "basic-shape": {
        syntax: "<inset()> | <circle()> | <ellipse()> | <polygon()> | <path()>"
      },
      "bg-image": {
        syntax: "none | <image>"
      },
      "bg-layer": {
        syntax: "<bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "bg-position": {
        syntax: "[ [ left | center | right | top | bottom | <length-percentage> ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ] | [ center | [ left | right ] <length-percentage>? ] && [ center | [ top | bottom ] <length-percentage>? ] ]"
      },
      "bg-size": {
        syntax: "[ <length-percentage> | auto ]{1,2} | cover | contain"
      },
      "blur()": {
        syntax: "blur( <length> )"
      },
      "blend-mode": {
        syntax: "normal | multiply | screen | overlay | darken | lighten | color-dodge | color-burn | hard-light | soft-light | difference | exclusion | hue | saturation | color | luminosity"
      },
      box: {
        syntax: "border-box | padding-box | content-box"
      },
      "brightness()": {
        syntax: "brightness( <number-percentage> )"
      },
      "calc()": {
        syntax: "calc( <calc-sum> )"
      },
      "calc-sum": {
        syntax: "<calc-product> [ [ '+' | '-' ] <calc-product> ]*"
      },
      "calc-product": {
        syntax: "<calc-value> [ '*' <calc-value> | '/' <number> ]*"
      },
      "calc-value": {
        syntax: "<number> | <dimension> | <percentage> | ( <calc-sum> )"
      },
      "cf-final-image": {
        syntax: "<image> | <color>"
      },
      "cf-mixing-image": {
        syntax: "<percentage>? && <image>"
      },
      "circle()": {
        syntax: "circle( [ <shape-radius> ]? [ at <position> ]? )"
      },
      "clamp()": {
        syntax: "clamp( <calc-sum>#{3} )"
      },
      "class-selector": {
        syntax: "'.' <ident-token>"
      },
      "clip-source": {
        syntax: "<url>"
      },
      color: {
        syntax: "<rgb()> | <rgba()> | <hsl()> | <hsla()> | <hwb()> | <lab()> | <lch()> | <hex-color> | <named-color> | currentcolor | <deprecated-system-color>"
      },
      "color-stop": {
        syntax: "<color-stop-length> | <color-stop-angle>"
      },
      "color-stop-angle": {
        syntax: "<angle-percentage>{1,2}"
      },
      "color-stop-length": {
        syntax: "<length-percentage>{1,2}"
      },
      "color-stop-list": {
        syntax: "[ <linear-color-stop> [, <linear-color-hint>]? ]# , <linear-color-stop>"
      },
      combinator: {
        syntax: "'>' | '+' | '~' | [ '||' ]"
      },
      "common-lig-values": {
        syntax: "[ common-ligatures | no-common-ligatures ]"
      },
      "compat-auto": {
        syntax: "searchfield | textarea | push-button | slider-horizontal | checkbox | radio | square-button | menulist | listbox | meter | progress-bar | button"
      },
      "composite-style": {
        syntax: "clear | copy | source-over | source-in | source-out | source-atop | destination-over | destination-in | destination-out | destination-atop | xor"
      },
      "compositing-operator": {
        syntax: "add | subtract | intersect | exclude"
      },
      "compound-selector": {
        syntax: "[ <type-selector>? <subclass-selector>* [ <pseudo-element-selector> <pseudo-class-selector>* ]* ]!"
      },
      "compound-selector-list": {
        syntax: "<compound-selector>#"
      },
      "complex-selector": {
        syntax: "<compound-selector> [ <combinator>? <compound-selector> ]*"
      },
      "complex-selector-list": {
        syntax: "<complex-selector>#"
      },
      "conic-gradient()": {
        syntax: "conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "contextual-alt-values": {
        syntax: "[ contextual | no-contextual ]"
      },
      "content-distribution": {
        syntax: "space-between | space-around | space-evenly | stretch"
      },
      "content-list": {
        syntax: "[ <string> | contents | <image> | <counter> | <quote> | <target> | <leader()> ]+"
      },
      "content-position": {
        syntax: "center | start | end | flex-start | flex-end"
      },
      "content-replacement": {
        syntax: "<image>"
      },
      "contrast()": {
        syntax: "contrast( [ <number-percentage> ] )"
      },
      counter: {
        syntax: "<counter()> | <counters()>"
      },
      "counter()": {
        syntax: "counter( <counter-name>, <counter-style>? )"
      },
      "counter-name": {
        syntax: "<custom-ident>"
      },
      "counter-style": {
        syntax: "<counter-style-name> | symbols()"
      },
      "counter-style-name": {
        syntax: "<custom-ident>"
      },
      "counters()": {
        syntax: "counters( <counter-name>, <string>, <counter-style>? )"
      },
      "cross-fade()": {
        syntax: "cross-fade( <cf-mixing-image> , <cf-final-image>? )"
      },
      "cubic-bezier-timing-function": {
        syntax: "ease | ease-in | ease-out | ease-in-out | cubic-bezier(<number [0,1]>, <number>, <number [0,1]>, <number>)"
      },
      "deprecated-system-color": {
        syntax: "ActiveBorder | ActiveCaption | AppWorkspace | Background | ButtonFace | ButtonHighlight | ButtonShadow | ButtonText | CaptionText | GrayText | Highlight | HighlightText | InactiveBorder | InactiveCaption | InactiveCaptionText | InfoBackground | InfoText | Menu | MenuText | Scrollbar | ThreeDDarkShadow | ThreeDFace | ThreeDHighlight | ThreeDLightShadow | ThreeDShadow | Window | WindowFrame | WindowText"
      },
      "discretionary-lig-values": {
        syntax: "[ discretionary-ligatures | no-discretionary-ligatures ]"
      },
      "display-box": {
        syntax: "contents | none"
      },
      "display-inside": {
        syntax: "flow | flow-root | table | flex | grid | ruby"
      },
      "display-internal": {
        syntax: "table-row-group | table-header-group | table-footer-group | table-row | table-cell | table-column-group | table-column | table-caption | ruby-base | ruby-text | ruby-base-container | ruby-text-container"
      },
      "display-legacy": {
        syntax: "inline-block | inline-list-item | inline-table | inline-flex | inline-grid"
      },
      "display-listitem": {
        syntax: "<display-outside>? && [ flow | flow-root ]? && list-item"
      },
      "display-outside": {
        syntax: "block | inline | run-in"
      },
      "drop-shadow()": {
        syntax: "drop-shadow( <length>{2,3} <color>? )"
      },
      "east-asian-variant-values": {
        syntax: "[ jis78 | jis83 | jis90 | jis04 | simplified | traditional ]"
      },
      "east-asian-width-values": {
        syntax: "[ full-width | proportional-width ]"
      },
      "element()": {
        syntax: "element( <id-selector> )"
      },
      "ellipse()": {
        syntax: "ellipse( [ <shape-radius>{2} ]? [ at <position> ]? )"
      },
      "ending-shape": {
        syntax: "circle | ellipse"
      },
      "env()": {
        syntax: "env( <custom-ident> , <declaration-value>? )"
      },
      "explicit-track-list": {
        syntax: "[ <line-names>? <track-size> ]+ <line-names>?"
      },
      "family-name": {
        syntax: "<string> | <custom-ident>+"
      },
      "feature-tag-value": {
        syntax: "<string> [ <integer> | on | off ]?"
      },
      "feature-type": {
        syntax: "@stylistic | @historical-forms | @styleset | @character-variant | @swash | @ornaments | @annotation"
      },
      "feature-value-block": {
        syntax: "<feature-type> '{' <feature-value-declaration-list> '}'"
      },
      "feature-value-block-list": {
        syntax: "<feature-value-block>+"
      },
      "feature-value-declaration": {
        syntax: "<custom-ident>: <integer>+;"
      },
      "feature-value-declaration-list": {
        syntax: "<feature-value-declaration>"
      },
      "feature-value-name": {
        syntax: "<custom-ident>"
      },
      "fill-rule": {
        syntax: "nonzero | evenodd"
      },
      "filter-function": {
        syntax: "<blur()> | <brightness()> | <contrast()> | <drop-shadow()> | <grayscale()> | <hue-rotate()> | <invert()> | <opacity()> | <saturate()> | <sepia()>"
      },
      "filter-function-list": {
        syntax: "[ <filter-function> | <url> ]+"
      },
      "final-bg-layer": {
        syntax: "<'background-color'> || <bg-image> || <bg-position> [ / <bg-size> ]? || <repeat-style> || <attachment> || <box> || <box>"
      },
      "fit-content()": {
        syntax: "fit-content( [ <length> | <percentage> ] )"
      },
      "fixed-breadth": {
        syntax: "<length-percentage>"
      },
      "fixed-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <fixed-size> ]+ <line-names>? )"
      },
      "fixed-size": {
        syntax: "<fixed-breadth> | minmax( <fixed-breadth> , <track-breadth> ) | minmax( <inflexible-breadth> , <fixed-breadth> )"
      },
      "font-stretch-absolute": {
        syntax: "normal | ultra-condensed | extra-condensed | condensed | semi-condensed | semi-expanded | expanded | extra-expanded | ultra-expanded | <percentage>"
      },
      "font-variant-css21": {
        syntax: "[ normal | small-caps ]"
      },
      "font-weight-absolute": {
        syntax: "normal | bold | <number [1,1000]>"
      },
      "frequency-percentage": {
        syntax: "<frequency> | <percentage>"
      },
      "general-enclosed": {
        syntax: "[ <function-token> <any-value> ) ] | ( <ident> <any-value> )"
      },
      "generic-family": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "generic-name": {
        syntax: "serif | sans-serif | cursive | fantasy | monospace"
      },
      "geometry-box": {
        syntax: "<shape-box> | fill-box | stroke-box | view-box"
      },
      gradient: {
        syntax: "<linear-gradient()> | <repeating-linear-gradient()> | <radial-gradient()> | <repeating-radial-gradient()> | <conic-gradient()> | <repeating-conic-gradient()>"
      },
      "grayscale()": {
        syntax: "grayscale( <number-percentage> )"
      },
      "grid-line": {
        syntax: "auto | <custom-ident> | [ <integer> && <custom-ident>? ] | [ span && [ <integer> || <custom-ident> ] ]"
      },
      "historical-lig-values": {
        syntax: "[ historical-ligatures | no-historical-ligatures ]"
      },
      "hsl()": {
        syntax: "hsl( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsl( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      "hsla()": {
        syntax: "hsla( <hue> <percentage> <percentage> [ / <alpha-value> ]? ) | hsla( <hue>, <percentage>, <percentage>, <alpha-value>? )"
      },
      hue: {
        syntax: "<number> | <angle>"
      },
      "hue-rotate()": {
        syntax: "hue-rotate( <angle> )"
      },
      "hwb()": {
        syntax: "hwb( [<hue> | none] [<percentage> | none] [<percentage> | none] [ / [<alpha-value> | none] ]? )"
      },
      "id-selector": {
        syntax: "<hash-token>"
      },
      image: {
        syntax: "<url> | <image()> | <image-set()> | <element()> | <paint()> | <cross-fade()> | <gradient>"
      },
      "image()": {
        syntax: "image( <image-tags>? [ <image-src>? , <color>? ]! )"
      },
      "image-set()": {
        syntax: "image-set( <image-set-option># )"
      },
      "image-set-option": {
        syntax: "[ <image> | <string> ] [ <resolution> || type(<string>) ]"
      },
      "image-src": {
        syntax: "<url> | <string>"
      },
      "image-tags": {
        syntax: "ltr | rtl"
      },
      "inflexible-breadth": {
        syntax: "<length> | <percentage> | min-content | max-content | auto"
      },
      "inset()": {
        syntax: "inset( <length-percentage>{1,4} [ round <'border-radius'> ]? )"
      },
      "invert()": {
        syntax: "invert( <number-percentage> )"
      },
      "keyframes-name": {
        syntax: "<custom-ident> | <string>"
      },
      "keyframe-block": {
        syntax: "<keyframe-selector># {\n  <declaration-list>\n}"
      },
      "keyframe-block-list": {
        syntax: "<keyframe-block>+"
      },
      "keyframe-selector": {
        syntax: "from | to | <percentage>"
      },
      "layer()": {
        syntax: "layer( <layer-name> )"
      },
      "layer-name": {
        syntax: "<ident> [ '.' <ident> ]*"
      },
      "leader()": {
        syntax: "leader( <leader-type> )"
      },
      "leader-type": {
        syntax: "dotted | solid | space | <string>"
      },
      "length-percentage": {
        syntax: "<length> | <percentage>"
      },
      "line-names": {
        syntax: "'[' <custom-ident>* ']'"
      },
      "line-name-list": {
        syntax: "[ <line-names> | <name-repeat> ]+"
      },
      "line-style": {
        syntax: "none | hidden | dotted | dashed | solid | double | groove | ridge | inset | outset"
      },
      "line-width": {
        syntax: "<length> | thin | medium | thick"
      },
      "linear-color-hint": {
        syntax: "<length-percentage>"
      },
      "linear-color-stop": {
        syntax: "<color> <color-stop-length>?"
      },
      "linear-gradient()": {
        syntax: "linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "mask-layer": {
        syntax: "<mask-reference> || <position> [ / <bg-size> ]? || <repeat-style> || <geometry-box> || [ <geometry-box> | no-clip ] || <compositing-operator> || <masking-mode>"
      },
      "mask-position": {
        syntax: "[ <length-percentage> | left | center | right ] [ <length-percentage> | top | center | bottom ]?"
      },
      "mask-reference": {
        syntax: "none | <image> | <mask-source>"
      },
      "mask-source": {
        syntax: "<url>"
      },
      "masking-mode": {
        syntax: "alpha | luminance | match-source"
      },
      "matrix()": {
        syntax: "matrix( <number>#{6} )"
      },
      "matrix3d()": {
        syntax: "matrix3d( <number>#{16} )"
      },
      "max()": {
        syntax: "max( <calc-sum># )"
      },
      "media-and": {
        syntax: "<media-in-parens> [ and <media-in-parens> ]+"
      },
      "media-condition": {
        syntax: "<media-not> | <media-and> | <media-or> | <media-in-parens>"
      },
      "media-condition-without-or": {
        syntax: "<media-not> | <media-and> | <media-in-parens>"
      },
      "media-feature": {
        syntax: "( [ <mf-plain> | <mf-boolean> | <mf-range> ] )"
      },
      "media-in-parens": {
        syntax: "( <media-condition> ) | <media-feature> | <general-enclosed>"
      },
      "media-not": {
        syntax: "not <media-in-parens>"
      },
      "media-or": {
        syntax: "<media-in-parens> [ or <media-in-parens> ]+"
      },
      "media-query": {
        syntax: "<media-condition> | [ not | only ]? <media-type> [ and <media-condition-without-or> ]?"
      },
      "media-query-list": {
        syntax: "<media-query>#"
      },
      "media-type": {
        syntax: "<ident>"
      },
      "mf-boolean": {
        syntax: "<mf-name>"
      },
      "mf-name": {
        syntax: "<ident>"
      },
      "mf-plain": {
        syntax: "<mf-name> : <mf-value>"
      },
      "mf-range": {
        syntax: "<mf-name> [ '<' | '>' ]? '='? <mf-value>\n| <mf-value> [ '<' | '>' ]? '='? <mf-name>\n| <mf-value> '<' '='? <mf-name> '<' '='? <mf-value>\n| <mf-value> '>' '='? <mf-name> '>' '='? <mf-value>"
      },
      "mf-value": {
        syntax: "<number> | <dimension> | <ident> | <ratio>"
      },
      "min()": {
        syntax: "min( <calc-sum># )"
      },
      "minmax()": {
        syntax: "minmax( [ <length> | <percentage> | min-content | max-content | auto ] , [ <length> | <percentage> | <flex> | min-content | max-content | auto ] )"
      },
      "name-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> | auto-fill ], <line-names>+ )"
      },
      "named-color": {
        syntax: "transparent | aliceblue | antiquewhite | aqua | aquamarine | azure | beige | bisque | black | blanchedalmond | blue | blueviolet | brown | burlywood | cadetblue | chartreuse | chocolate | coral | cornflowerblue | cornsilk | crimson | cyan | darkblue | darkcyan | darkgoldenrod | darkgray | darkgreen | darkgrey | darkkhaki | darkmagenta | darkolivegreen | darkorange | darkorchid | darkred | darksalmon | darkseagreen | darkslateblue | darkslategray | darkslategrey | darkturquoise | darkviolet | deeppink | deepskyblue | dimgray | dimgrey | dodgerblue | firebrick | floralwhite | forestgreen | fuchsia | gainsboro | ghostwhite | gold | goldenrod | gray | green | greenyellow | grey | honeydew | hotpink | indianred | indigo | ivory | khaki | lavender | lavenderblush | lawngreen | lemonchiffon | lightblue | lightcoral | lightcyan | lightgoldenrodyellow | lightgray | lightgreen | lightgrey | lightpink | lightsalmon | lightseagreen | lightskyblue | lightslategray | lightslategrey | lightsteelblue | lightyellow | lime | limegreen | linen | magenta | maroon | mediumaquamarine | mediumblue | mediumorchid | mediumpurple | mediumseagreen | mediumslateblue | mediumspringgreen | mediumturquoise | mediumvioletred | midnightblue | mintcream | mistyrose | moccasin | navajowhite | navy | oldlace | olive | olivedrab | orange | orangered | orchid | palegoldenrod | palegreen | paleturquoise | palevioletred | papayawhip | peachpuff | peru | pink | plum | powderblue | purple | rebeccapurple | red | rosybrown | royalblue | saddlebrown | salmon | sandybrown | seagreen | seashell | sienna | silver | skyblue | slateblue | slategray | slategrey | snow | springgreen | steelblue | tan | teal | thistle | tomato | turquoise | violet | wheat | white | whitesmoke | yellow | yellowgreen"
      },
      "namespace-prefix": {
        syntax: "<ident>"
      },
      "ns-prefix": {
        syntax: "[ <ident-token> | '*' ]? '|'"
      },
      "number-percentage": {
        syntax: "<number> | <percentage>"
      },
      "numeric-figure-values": {
        syntax: "[ lining-nums | oldstyle-nums ]"
      },
      "numeric-fraction-values": {
        syntax: "[ diagonal-fractions | stacked-fractions ]"
      },
      "numeric-spacing-values": {
        syntax: "[ proportional-nums | tabular-nums ]"
      },
      nth: {
        syntax: "<an-plus-b> | even | odd"
      },
      "opacity()": {
        syntax: "opacity( [ <number-percentage> ] )"
      },
      "overflow-position": {
        syntax: "unsafe | safe"
      },
      "outline-radius": {
        syntax: "<length> | <percentage>"
      },
      "page-body": {
        syntax: "<declaration>? [ ; <page-body> ]? | <page-margin-box> <page-body>"
      },
      "page-margin-box": {
        syntax: "<page-margin-box-type> '{' <declaration-list> '}'"
      },
      "page-margin-box-type": {
        syntax: "@top-left-corner | @top-left | @top-center | @top-right | @top-right-corner | @bottom-left-corner | @bottom-left | @bottom-center | @bottom-right | @bottom-right-corner | @left-top | @left-middle | @left-bottom | @right-top | @right-middle | @right-bottom"
      },
      "page-selector-list": {
        syntax: "[ <page-selector># ]?"
      },
      "page-selector": {
        syntax: "<pseudo-page>+ | <ident> <pseudo-page>*"
      },
      "page-size": {
        syntax: "A5 | A4 | A3 | B5 | B4 | JIS-B5 | JIS-B4 | letter | legal | ledger"
      },
      "path()": {
        syntax: "path( [ <fill-rule>, ]? <string> )"
      },
      "paint()": {
        syntax: "paint( <ident>, <declaration-value>? )"
      },
      "perspective()": {
        syntax: "perspective( <length> )"
      },
      "polygon()": {
        syntax: "polygon( <fill-rule>? , [ <length-percentage> <length-percentage> ]# )"
      },
      position: {
        syntax: "[ [ left | center | right ] || [ top | center | bottom ] | [ left | center | right | <length-percentage> ] [ top | center | bottom | <length-percentage> ]? | [ [ left | right ] <length-percentage> ] && [ [ top | bottom ] <length-percentage> ] ]"
      },
      "pseudo-class-selector": {
        syntax: "':' <ident-token> | ':' <function-token> <any-value> ')'"
      },
      "pseudo-element-selector": {
        syntax: "':' <pseudo-class-selector>"
      },
      "pseudo-page": {
        syntax: ": [ left | right | first | blank ]"
      },
      quote: {
        syntax: "open-quote | close-quote | no-open-quote | no-close-quote"
      },
      "radial-gradient()": {
        syntax: "radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "relative-selector": {
        syntax: "<combinator>? <complex-selector>"
      },
      "relative-selector-list": {
        syntax: "<relative-selector>#"
      },
      "relative-size": {
        syntax: "larger | smaller"
      },
      "repeat-style": {
        syntax: "repeat-x | repeat-y | [ repeat | space | round | no-repeat ]{1,2}"
      },
      "repeating-conic-gradient()": {
        syntax: "repeating-conic-gradient( [ from <angle> ]? [ at <position> ]?, <angular-color-stop-list> )"
      },
      "repeating-linear-gradient()": {
        syntax: "repeating-linear-gradient( [ <angle> | to <side-or-corner> ]? , <color-stop-list> )"
      },
      "repeating-radial-gradient()": {
        syntax: "repeating-radial-gradient( [ <ending-shape> || <size> ]? [ at <position> ]? , <color-stop-list> )"
      },
      "rgb()": {
        syntax: "rgb( <percentage>{3} [ / <alpha-value> ]? ) | rgb( <number>{3} [ / <alpha-value> ]? ) | rgb( <percentage>#{3} , <alpha-value>? ) | rgb( <number>#{3} , <alpha-value>? )"
      },
      "rgba()": {
        syntax: "rgba( <percentage>{3} [ / <alpha-value> ]? ) | rgba( <number>{3} [ / <alpha-value> ]? ) | rgba( <percentage>#{3} , <alpha-value>? ) | rgba( <number>#{3} , <alpha-value>? )"
      },
      "rotate()": {
        syntax: "rotate( [ <angle> | <zero> ] )"
      },
      "rotate3d()": {
        syntax: "rotate3d( <number> , <number> , <number> , [ <angle> | <zero> ] )"
      },
      "rotateX()": {
        syntax: "rotateX( [ <angle> | <zero> ] )"
      },
      "rotateY()": {
        syntax: "rotateY( [ <angle> | <zero> ] )"
      },
      "rotateZ()": {
        syntax: "rotateZ( [ <angle> | <zero> ] )"
      },
      "saturate()": {
        syntax: "saturate( <number-percentage> )"
      },
      "scale()": {
        syntax: "scale( <number> , <number>? )"
      },
      "scale3d()": {
        syntax: "scale3d( <number> , <number> , <number> )"
      },
      "scaleX()": {
        syntax: "scaleX( <number> )"
      },
      "scaleY()": {
        syntax: "scaleY( <number> )"
      },
      "scaleZ()": {
        syntax: "scaleZ( <number> )"
      },
      "self-position": {
        syntax: "center | start | end | self-start | self-end | flex-start | flex-end"
      },
      "shape-radius": {
        syntax: "<length-percentage> | closest-side | farthest-side"
      },
      "skew()": {
        syntax: "skew( [ <angle> | <zero> ] , [ <angle> | <zero> ]? )"
      },
      "skewX()": {
        syntax: "skewX( [ <angle> | <zero> ] )"
      },
      "skewY()": {
        syntax: "skewY( [ <angle> | <zero> ] )"
      },
      "sepia()": {
        syntax: "sepia( <number-percentage> )"
      },
      shadow: {
        syntax: "inset? && <length>{2,4} && <color>?"
      },
      "shadow-t": {
        syntax: "[ <length>{2,3} && <color>? ]"
      },
      shape: {
        syntax: "rect(<top>, <right>, <bottom>, <left>)"
      },
      "shape-box": {
        syntax: "<box> | margin-box"
      },
      "side-or-corner": {
        syntax: "[ left | right ] || [ top | bottom ]"
      },
      "single-animation": {
        syntax: "<time> || <easing-function> || <time> || <single-animation-iteration-count> || <single-animation-direction> || <single-animation-fill-mode> || <single-animation-play-state> || [ none | <keyframes-name> ]"
      },
      "single-animation-direction": {
        syntax: "normal | reverse | alternate | alternate-reverse"
      },
      "single-animation-fill-mode": {
        syntax: "none | forwards | backwards | both"
      },
      "single-animation-iteration-count": {
        syntax: "infinite | <number>"
      },
      "single-animation-play-state": {
        syntax: "running | paused"
      },
      "single-animation-timeline": {
        syntax: "auto | none | <timeline-name>"
      },
      "single-transition": {
        syntax: "[ none | <single-transition-property> ] || <time> || <easing-function> || <time>"
      },
      "single-transition-property": {
        syntax: "all | <custom-ident>"
      },
      size: {
        syntax: "closest-side | farthest-side | closest-corner | farthest-corner | <length> | <length-percentage>{2}"
      },
      "step-position": {
        syntax: "jump-start | jump-end | jump-none | jump-both | start | end"
      },
      "step-timing-function": {
        syntax: "step-start | step-end | steps(<integer>[, <step-position>]?)"
      },
      "subclass-selector": {
        syntax: "<id-selector> | <class-selector> | <attribute-selector> | <pseudo-class-selector>"
      },
      "supports-condition": {
        syntax: "not <supports-in-parens> | <supports-in-parens> [ and <supports-in-parens> ]* | <supports-in-parens> [ or <supports-in-parens> ]*"
      },
      "supports-in-parens": {
        syntax: "( <supports-condition> ) | <supports-feature> | <general-enclosed>"
      },
      "supports-feature": {
        syntax: "<supports-decl> | <supports-selector-fn>"
      },
      "supports-decl": {
        syntax: "( <declaration> )"
      },
      "supports-selector-fn": {
        syntax: "selector( <complex-selector> )"
      },
      symbol: {
        syntax: "<string> | <image> | <custom-ident>"
      },
      target: {
        syntax: "<target-counter()> | <target-counters()> | <target-text()>"
      },
      "target-counter()": {
        syntax: "target-counter( [ <string> | <url> ] , <custom-ident> , <counter-style>? )"
      },
      "target-counters()": {
        syntax: "target-counters( [ <string> | <url> ] , <custom-ident> , <string> , <counter-style>? )"
      },
      "target-text()": {
        syntax: "target-text( [ <string> | <url> ] , [ content | before | after | first-letter ]? )"
      },
      "time-percentage": {
        syntax: "<time> | <percentage>"
      },
      "timeline-name": {
        syntax: "<custom-ident> | <string>"
      },
      "easing-function": {
        syntax: "linear | <cubic-bezier-timing-function> | <step-timing-function>"
      },
      "track-breadth": {
        syntax: "<length-percentage> | <flex> | min-content | max-content | auto"
      },
      "track-list": {
        syntax: "[ <line-names>? [ <track-size> | <track-repeat> ] ]+ <line-names>?"
      },
      "track-repeat": {
        syntax: "repeat( [ <integer [1,\u221E]> ] , [ <line-names>? <track-size> ]+ <line-names>? )"
      },
      "track-size": {
        syntax: "<track-breadth> | minmax( <inflexible-breadth> , <track-breadth> ) | fit-content( [ <length> | <percentage> ] )"
      },
      "transform-function": {
        syntax: "<matrix()> | <translate()> | <translateX()> | <translateY()> | <scale()> | <scaleX()> | <scaleY()> | <rotate()> | <skew()> | <skewX()> | <skewY()> | <matrix3d()> | <translate3d()> | <translateZ()> | <scale3d()> | <scaleZ()> | <rotate3d()> | <rotateX()> | <rotateY()> | <rotateZ()> | <perspective()>"
      },
      "transform-list": {
        syntax: "<transform-function>+"
      },
      "translate()": {
        syntax: "translate( <length-percentage> , <length-percentage>? )"
      },
      "translate3d()": {
        syntax: "translate3d( <length-percentage> , <length-percentage> , <length> )"
      },
      "translateX()": {
        syntax: "translateX( <length-percentage> )"
      },
      "translateY()": {
        syntax: "translateY( <length-percentage> )"
      },
      "translateZ()": {
        syntax: "translateZ( <length> )"
      },
      "type-or-unit": {
        syntax: "string | color | url | integer | number | length | angle | time | frequency | cap | ch | em | ex | ic | lh | rlh | rem | vb | vi | vw | vh | vmin | vmax | mm | Q | cm | in | pt | pc | px | deg | grad | rad | turn | ms | s | Hz | kHz | %"
      },
      "type-selector": {
        syntax: "<wq-name> | <ns-prefix>? '*'"
      },
      "var()": {
        syntax: "var( <custom-property-name> , <declaration-value>? )"
      },
      "viewport-length": {
        syntax: "auto | <length-percentage>"
      },
      "visual-box": {
        syntax: "content-box | padding-box | border-box"
      },
      "wq-name": {
        syntax: "<ns-prefix>? <ident-token>"
      }
    };
  }
});

// node_modules/csso/node_modules/css-tree/cjs/data.cjs
var require_data2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/data.cjs"(exports2, module2) {
    "use strict";
    var dataPatch = require_data_patch2();
    var mdnAtrules = require_at_rules2();
    var mdnProperties = require_properties2();
    var mdnSyntaxes = require_syntaxes2();
    var extendSyntax = /^\s*\|\s*/;
    function preprocessAtrules(dict) {
      const result = /* @__PURE__ */ Object.create(null);
      for (const atruleName in dict) {
        const atrule = dict[atruleName];
        let descriptors = null;
        if (atrule.descriptors) {
          descriptors = /* @__PURE__ */ Object.create(null);
          for (const descriptor in atrule.descriptors) {
            descriptors[descriptor] = atrule.descriptors[descriptor].syntax;
          }
        }
        result[atruleName.substr(1)] = {
          prelude: atrule.syntax.trim().replace(/\{(.|\s)+\}/, "").match(/^@\S+\s+([^;\{]*)/)[1].trim() || null,
          descriptors
        };
      }
      return result;
    }
    function patchDictionary(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        result[key] = dict[key].syntax || dict[key];
      }
      for (const key in patchDict) {
        if (key in dict) {
          if (patchDict[key].syntax) {
            result[key] = extendSyntax.test(patchDict[key].syntax) ? result[key] + " " + patchDict[key].syntax.trim() : patchDict[key].syntax;
          } else {
            delete result[key];
          }
        } else {
          if (patchDict[key].syntax) {
            result[key] = patchDict[key].syntax.replace(extendSyntax, "");
          }
        }
      }
      return result;
    }
    function patchAtrules(dict, patchDict) {
      const result = {};
      for (const key in dict) {
        const patchDescriptors = patchDict[key] && patchDict[key].descriptors || null;
        result[key] = {
          prelude: key in patchDict && "prelude" in patchDict[key] ? patchDict[key].prelude : dict[key].prelude || null,
          descriptors: patchDictionary(dict[key].descriptors || {}, patchDescriptors || {})
        };
      }
      for (const key in patchDict) {
        if (!hasOwnProperty.call(dict, key)) {
          result[key] = {
            prelude: patchDict[key].prelude || null,
            descriptors: patchDict[key].descriptors && patchDictionary({}, patchDict[key].descriptors)
          };
        }
      }
      return result;
    }
    var definitions = {
      types: patchDictionary(mdnSyntaxes, dataPatch.types),
      atrules: patchAtrules(preprocessAtrules(mdnAtrules), dataPatch.atrules),
      properties: patchDictionary(mdnProperties, dataPatch.properties)
    };
    module2.exports = definitions;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs
var require_AnPlusB2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/AnPlusB.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var charCodeDefinitions = require_char_code_definitions2();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var N = 110;
    var DISALLOW_SIGN = true;
    var ALLOW_SIGN = false;
    function checkInteger(offset, disallowSign) {
      let pos = this.tokenStart + offset;
      const code = this.charCodeAt(pos);
      if (code === PLUSSIGN || code === HYPHENMINUS) {
        if (disallowSign) {
          this.error("Number sign is not allowed");
        }
        pos++;
      }
      for (; pos < this.tokenEnd; pos++) {
        if (!charCodeDefinitions.isDigit(this.charCodeAt(pos))) {
          this.error("Integer is expected", pos);
        }
      }
    }
    function checkTokenIsInteger(disallowSign) {
      return checkInteger.call(this, 0, disallowSign);
    }
    function expectCharCode(offset, code) {
      if (!this.cmpChar(this.tokenStart + offset, code)) {
        let msg = "";
        switch (code) {
          case N:
            msg = "N is expected";
            break;
          case HYPHENMINUS:
            msg = "HyphenMinus is expected";
            break;
        }
        this.error(msg, this.tokenStart + offset);
      }
    }
    function consumeB() {
      let offset = 0;
      let sign = 0;
      let type = this.tokenType;
      while (type === types.WhiteSpace || type === types.Comment) {
        type = this.lookupType(++offset);
      }
      if (type !== types.Number) {
        if (this.isDelim(PLUSSIGN, offset) || this.isDelim(HYPHENMINUS, offset)) {
          sign = this.isDelim(PLUSSIGN, offset) ? PLUSSIGN : HYPHENMINUS;
          do {
            type = this.lookupType(++offset);
          } while (type === types.WhiteSpace || type === types.Comment);
          if (type !== types.Number) {
            this.skip(offset);
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
          }
        } else {
          return null;
        }
      }
      if (offset > 0) {
        this.skip(offset);
      }
      if (sign === 0) {
        type = this.charCodeAt(this.tokenStart);
        if (type !== PLUSSIGN && type !== HYPHENMINUS) {
          this.error("Number sign is expected");
        }
      }
      checkTokenIsInteger.call(this, sign !== 0);
      return sign === HYPHENMINUS ? "-" + this.consume(types.Number) : this.consume(types.Number);
    }
    var name = "AnPlusB";
    var structure = {
      a: [String, null],
      b: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let a = null;
      let b = null;
      if (this.tokenType === types.Number) {
        checkTokenIsInteger.call(this, ALLOW_SIGN);
        b = this.consume(types.Number);
      } else if (this.tokenType === types.Ident && this.cmpChar(this.tokenStart, HYPHENMINUS)) {
        a = "-1";
        expectCharCode.call(this, 1, N);
        switch (this.tokenEnd - this.tokenStart) {
          // -n
          // -n <signed-integer>
          // -n ['+' | '-'] <signless-integer>
          case 2:
            this.next();
            b = consumeB.call(this);
            break;
          // -n- <signless-integer>
          case 3:
            expectCharCode.call(this, 2, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // <dashndashdigit-ident>
          default:
            expectCharCode.call(this, 2, HYPHENMINUS);
            checkInteger.call(this, 3, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + 2);
        }
      } else if (this.tokenType === types.Ident || this.isDelim(PLUSSIGN) && this.lookupType(1) === types.Ident) {
        let sign = 0;
        a = "1";
        if (this.isDelim(PLUSSIGN)) {
          sign = 1;
          this.next();
        }
        expectCharCode.call(this, 0, N);
        switch (this.tokenEnd - this.tokenStart) {
          // '+'? n
          // '+'? n <signed-integer>
          // '+'? n ['+' | '-'] <signless-integer>
          case 1:
            this.next();
            b = consumeB.call(this);
            break;
          // '+'? n- <signless-integer>
          case 2:
            expectCharCode.call(this, 1, HYPHENMINUS);
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
            break;
          // '+'? <ndashdigit-ident>
          default:
            expectCharCode.call(this, 1, HYPHENMINUS);
            checkInteger.call(this, 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(start + sign + 1);
        }
      } else if (this.tokenType === types.Dimension) {
        const code = this.charCodeAt(this.tokenStart);
        const sign = code === PLUSSIGN || code === HYPHENMINUS;
        let i = this.tokenStart + sign;
        for (; i < this.tokenEnd; i++) {
          if (!charCodeDefinitions.isDigit(this.charCodeAt(i))) {
            break;
          }
        }
        if (i === this.tokenStart + sign) {
          this.error("Integer is expected", this.tokenStart + sign);
        }
        expectCharCode.call(this, i - this.tokenStart, N);
        a = this.substring(start, i);
        if (i + 1 === this.tokenEnd) {
          this.next();
          b = consumeB.call(this);
        } else {
          expectCharCode.call(this, i - this.tokenStart + 1, HYPHENMINUS);
          if (i + 2 === this.tokenEnd) {
            this.next();
            this.skipSC();
            checkTokenIsInteger.call(this, DISALLOW_SIGN);
            b = "-" + this.consume(types.Number);
          } else {
            checkInteger.call(this, i - this.tokenStart + 2, DISALLOW_SIGN);
            this.next();
            b = this.substrToCursor(i + 1);
          }
        }
      } else {
        this.error();
      }
      if (a !== null && a.charCodeAt(0) === PLUSSIGN) {
        a = a.substr(1);
      }
      if (b !== null && b.charCodeAt(0) === PLUSSIGN) {
        b = b.substr(1);
      }
      return {
        type: "AnPlusB",
        loc: this.getLocation(start, this.tokenStart),
        a,
        b
      };
    }
    function generate(node) {
      if (node.a) {
        const a = node.a === "+1" && "n" || node.a === "1" && "n" || node.a === "-1" && "-n" || node.a + "n";
        if (node.b) {
          const b = node.b[0] === "-" || node.b[0] === "+" ? node.b : "+" + node.b;
          this.tokenize(a + b);
        } else {
          this.tokenize(a);
        }
      } else {
        this.tokenize(node.b);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Atrule.cjs
var require_Atrule2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Atrule.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilLeftCurlyBracketOrSemicolon, true);
    }
    function isDeclarationBlockAtrule() {
      for (let offset = 1, type; type = this.lookupType(offset); offset++) {
        if (type === types.RightCurlyBracket) {
          return true;
        }
        if (type === types.LeftCurlyBracket || type === types.AtKeyword) {
          return false;
        }
      }
      return false;
    }
    var name = "Atrule";
    var walkContext = "atrule";
    var structure = {
      name: String,
      prelude: ["AtrulePrelude", "Raw", null],
      block: ["Block", null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let nameLowerCase;
      let prelude = null;
      let block = null;
      this.eat(types.AtKeyword);
      name2 = this.substrToCursor(start + 1);
      nameLowerCase = name2.toLowerCase();
      this.skipSC();
      if (this.eof === false && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        if (this.parseAtrulePrelude) {
          prelude = this.parseWithFallback(this.AtrulePrelude.bind(this, name2), consumeRaw);
        } else {
          prelude = consumeRaw.call(this, this.tokenIndex);
        }
        this.skipSC();
      }
      switch (this.tokenType) {
        case types.Semicolon:
          this.next();
          break;
        case types.LeftCurlyBracket:
          if (hasOwnProperty.call(this.atrule, nameLowerCase) && typeof this.atrule[nameLowerCase].block === "function") {
            block = this.atrule[nameLowerCase].block.call(this);
          } else {
            block = this.Block(isDeclarationBlockAtrule.call(this));
          }
          break;
      }
      return {
        type: "Atrule",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        prelude,
        block
      };
    }
    function generate(node) {
      this.token(types.AtKeyword, "@" + node.name);
      if (node.prelude !== null) {
        this.node(node.prelude);
      }
      if (node.block) {
        this.node(node.block);
      } else {
        this.token(types.Semicolon, ";");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs
var require_AtrulePrelude2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/AtrulePrelude.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "AtrulePrelude";
    var walkContext = "atrulePrelude";
    var structure = {
      children: [[]]
    };
    function parse(name2) {
      let children = null;
      if (name2 !== null) {
        name2 = name2.toLowerCase();
      }
      this.skipSC();
      if (hasOwnProperty.call(this.atrule, name2) && typeof this.atrule[name2].prelude === "function") {
        children = this.atrule[name2].prelude.call(this);
      } else {
        children = this.readSequence(this.scope.AtrulePrelude);
      }
      this.skipSC();
      if (this.eof !== true && this.tokenType !== types.LeftCurlyBracket && this.tokenType !== types.Semicolon) {
        this.error("Semicolon or block is expected");
      }
      return {
        type: "AtrulePrelude",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs
var require_AttributeSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/AttributeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var DOLLARSIGN = 36;
    var ASTERISK = 42;
    var EQUALSSIGN = 61;
    var CIRCUMFLEXACCENT = 94;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function getAttributeName() {
      if (this.eof) {
        this.error("Unexpected end of input");
      }
      const start = this.tokenStart;
      let expectIdent = false;
      if (this.isDelim(ASTERISK)) {
        expectIdent = true;
        this.next();
      } else if (!this.isDelim(VERTICALLINE)) {
        this.eat(types.Ident);
      }
      if (this.isDelim(VERTICALLINE)) {
        if (this.charCodeAt(this.tokenStart + 1) !== EQUALSSIGN) {
          this.next();
          this.eat(types.Ident);
        } else if (expectIdent) {
          this.error("Identifier is expected", this.tokenEnd);
        }
      } else if (expectIdent) {
        this.error("Vertical line is expected");
      }
      return {
        type: "Identifier",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function getOperator() {
      const start = this.tokenStart;
      const code = this.charCodeAt(start);
      if (code !== EQUALSSIGN && // =
      code !== TILDE && // ~=
      code !== CIRCUMFLEXACCENT && // ^=
      code !== DOLLARSIGN && // $=
      code !== ASTERISK && // *=
      code !== VERTICALLINE) {
        this.error("Attribute selector (=, ~=, ^=, $=, *=, |=) is expected");
      }
      this.next();
      if (code !== EQUALSSIGN) {
        if (!this.isDelim(EQUALSSIGN)) {
          this.error("Equal sign is expected");
        }
        this.next();
      }
      return this.substrToCursor(start);
    }
    var name = "AttributeSelector";
    var structure = {
      name: "Identifier",
      matcher: [String, null],
      value: ["String", "Identifier", null],
      flags: [String, null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let matcher = null;
      let value = null;
      let flags = null;
      this.eat(types.LeftSquareBracket);
      this.skipSC();
      name2 = getAttributeName.call(this);
      this.skipSC();
      if (this.tokenType !== types.RightSquareBracket) {
        if (this.tokenType !== types.Ident) {
          matcher = getOperator.call(this);
          this.skipSC();
          value = this.tokenType === types.String ? this.String() : this.Identifier();
          this.skipSC();
        }
        if (this.tokenType === types.Ident) {
          flags = this.consume(types.Ident);
          this.skipSC();
        }
      }
      this.eat(types.RightSquareBracket);
      return {
        type: "AttributeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        matcher,
        value,
        flags
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.node(node.name);
      if (node.matcher !== null) {
        this.tokenize(node.matcher);
        this.node(node.value);
      }
      if (node.flags !== null) {
        this.token(types.Ident, node.flags);
      }
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Block.cjs
var require_Block2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Block.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, true);
    }
    function consumeRule() {
      return this.parseWithFallback(this.Rule, consumeRaw);
    }
    function consumeRawDeclaration(startToken) {
      return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    function consumeDeclaration() {
      if (this.tokenType === types.Semicolon) {
        return consumeRawDeclaration.call(this, this.tokenIndex);
      }
      const node = this.parseWithFallback(this.Declaration, consumeRawDeclaration);
      if (this.tokenType === types.Semicolon) {
        this.next();
      }
      return node;
    }
    var name = "Block";
    var walkContext = "block";
    var structure = {
      children: [[
        "Atrule",
        "Rule",
        "Declaration"
      ]]
    };
    function parse(isDeclaration) {
      const consumer = isDeclaration ? consumeDeclaration : consumeRule;
      const start = this.tokenStart;
      let children = this.createList();
      this.eat(types.LeftCurlyBracket);
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.RightCurlyBracket:
              break scan;
            case types.WhiteSpace:
            case types.Comment:
              this.next();
              break;
            case types.AtKeyword:
              children.push(this.parseWithFallback(this.Atrule, consumeRaw));
              break;
            default:
              children.push(consumer.call(this));
          }
        }
      if (!this.eof) {
        this.eat(types.RightCurlyBracket);
      }
      return {
        type: "Block",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftCurlyBracket, "{");
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
      this.token(types.RightCurlyBracket, "}");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Brackets.cjs
var require_Brackets2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Brackets.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Brackets";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftSquareBracket);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightSquareBracket);
      }
      return {
        type: "Brackets",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.Delim, "[");
      this.children(node);
      this.token(types.Delim, "]");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/CDC.cjs
var require_CDC2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/CDC.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "CDC";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDC);
      return {
        type: "CDC",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDC, "-->");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/CDO.cjs
var require_CDO2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/CDO.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "CDO";
    var structure = [];
    function parse() {
      const start = this.tokenStart;
      this.eat(types.CDO);
      return {
        type: "CDO",
        loc: this.getLocation(start, this.tokenStart)
      };
    }
    function generate() {
      this.token(types.CDO, "<!--");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs
var require_ClassSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/ClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var FULLSTOP = 46;
    var name = "ClassSelector";
    var structure = {
      name: String
    };
    function parse() {
      this.eatDelim(FULLSTOP);
      return {
        type: "ClassSelector",
        loc: this.getLocation(this.tokenStart - 1, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Delim, ".");
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Combinator.cjs
var require_Combinator2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Combinator.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var GREATERTHANSIGN = 62;
    var TILDE = 126;
    var name = "Combinator";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      switch (this.tokenType) {
        case types.WhiteSpace:
          name2 = " ";
          break;
        case types.Delim:
          switch (this.charCodeAt(this.tokenStart)) {
            case GREATERTHANSIGN:
            case PLUSSIGN:
            case TILDE:
              this.next();
              break;
            case SOLIDUS:
              this.next();
              this.eatIdent("deep");
              this.eatDelim(SOLIDUS);
              break;
            default:
              this.error("Combinator is expected");
          }
          name2 = this.substrToCursor(start);
          break;
      }
      return {
        type: "Combinator",
        loc: this.getLocation(start, this.tokenStart),
        name: name2
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Comment.cjs
var require_Comment2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Comment.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var ASTERISK = 42;
    var SOLIDUS = 47;
    var name = "Comment";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let end = this.tokenEnd;
      this.eat(types.Comment);
      if (end - start + 2 >= 2 && this.charCodeAt(end - 2) === ASTERISK && this.charCodeAt(end - 1) === SOLIDUS) {
        end -= 2;
      }
      return {
        type: "Comment",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substring(start + 2, end)
      };
    }
    function generate(node) {
      this.token(types.Comment, "/*" + node.value + "*/");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Declaration.cjs
var require_Declaration2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Declaration.cjs"(exports2) {
    "use strict";
    var names = require_names4();
    var types = require_types3();
    var EXCLAMATIONMARK = 33;
    var NUMBERSIGN = 35;
    var DOLLARSIGN = 36;
    var AMPERSAND = 38;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    function consumeValueRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, true);
    }
    function consumeCustomPropertyRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilExclamationMarkOrSemicolon, false);
    }
    function consumeValue() {
      const startValueToken = this.tokenIndex;
      const value = this.Value();
      if (value.type !== "Raw" && this.eof === false && this.tokenType !== types.Semicolon && this.isDelim(EXCLAMATIONMARK) === false && this.isBalanceEdge(startValueToken) === false) {
        this.error();
      }
      return value;
    }
    var name = "Declaration";
    var walkContext = "declaration";
    var structure = {
      important: [Boolean, String],
      property: String,
      value: ["Value", "Raw"]
    };
    function parse() {
      const start = this.tokenStart;
      const startToken = this.tokenIndex;
      const property = readProperty.call(this);
      const customProperty = names.isCustomProperty(property);
      const parseValue = customProperty ? this.parseCustomProperty : this.parseValue;
      const consumeRaw = customProperty ? consumeCustomPropertyRaw : consumeValueRaw;
      let important = false;
      let value;
      this.skipSC();
      this.eat(types.Colon);
      const valueStart = this.tokenIndex;
      if (!customProperty) {
        this.skipSC();
      }
      if (parseValue) {
        value = this.parseWithFallback(consumeValue, consumeRaw);
      } else {
        value = consumeRaw.call(this, this.tokenIndex);
      }
      if (customProperty && value.type === "Value" && value.children.isEmpty) {
        for (let offset = valueStart - this.tokenIndex; offset <= 0; offset++) {
          if (this.lookupType(offset) === types.WhiteSpace) {
            value.children.appendData({
              type: "WhiteSpace",
              loc: null,
              value: " "
            });
            break;
          }
        }
      }
      if (this.isDelim(EXCLAMATIONMARK)) {
        important = getImportant.call(this);
        this.skipSC();
      }
      if (this.eof === false && this.tokenType !== types.Semicolon && this.isBalanceEdge(startToken) === false) {
        this.error();
      }
      return {
        type: "Declaration",
        loc: this.getLocation(start, this.tokenStart),
        important,
        property,
        value
      };
    }
    function generate(node) {
      this.token(types.Ident, node.property);
      this.token(types.Colon, ":");
      this.node(node.value);
      if (node.important) {
        this.token(types.Delim, "!");
        this.token(types.Ident, node.important === true ? "important" : node.important);
      }
    }
    function readProperty() {
      const start = this.tokenStart;
      if (this.tokenType === types.Delim) {
        switch (this.charCodeAt(this.tokenStart)) {
          case ASTERISK:
          case DOLLARSIGN:
          case PLUSSIGN:
          case NUMBERSIGN:
          case AMPERSAND:
            this.next();
            break;
          // TODO: not sure we should support this hack
          case SOLIDUS:
            this.next();
            if (this.isDelim(SOLIDUS)) {
              this.next();
            }
            break;
        }
      }
      if (this.tokenType === types.Hash) {
        this.eat(types.Hash);
      } else {
        this.eat(types.Ident);
      }
      return this.substrToCursor(start);
    }
    function getImportant() {
      this.eat(types.Delim);
      this.skipSC();
      const important = this.consume(types.Ident);
      return important === "important" ? true : important;
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs
var require_DeclarationList2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/DeclarationList.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilSemicolonIncluded, true);
    }
    var name = "DeclarationList";
    var structure = {
      children: [[
        "Declaration"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
          case types.Comment:
          case types.Semicolon:
            this.next();
            break;
          default:
            children.push(this.parseWithFallback(this.Declaration, consumeRaw));
        }
      }
      return {
        type: "DeclarationList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, (prev) => {
        if (prev.type === "Declaration") {
          this.token(types.Semicolon, ";");
        }
      });
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Dimension.cjs
var require_Dimension2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Dimension.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Dimension";
    var structure = {
      value: String,
      unit: String
    };
    function parse() {
      const start = this.tokenStart;
      const value = this.consumeNumber(types.Dimension);
      return {
        type: "Dimension",
        loc: this.getLocation(start, this.tokenStart),
        value,
        unit: this.substring(start + value.length, this.tokenStart)
      };
    }
    function generate(node) {
      this.token(types.Dimension, node.value + node.unit);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Function.cjs
var require_Function2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Function.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Function";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      const name2 = this.consumeFunctionName();
      const nameLowerCase = name2.toLowerCase();
      let children;
      children = recognizer.hasOwnProperty(nameLowerCase) ? recognizer[nameLowerCase].call(this, recognizer) : readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Function",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Function, node.name + "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Hash.cjs
var require_Hash2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Hash.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var xxx = "XXX";
    var name = "Hash";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "Hash",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Hash, "#" + node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.xxx = xxx;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Identifier.cjs
var require_Identifier2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Identifier.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Identifier";
    var structure = {
      name: String
    };
    function parse() {
      return {
        type: "Identifier",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        name: this.consume(types.Ident)
      };
    }
    function generate(node) {
      this.token(types.Ident, node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/IdSelector.cjs
var require_IdSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/IdSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "IdSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eat(types.Hash);
      return {
        type: "IdSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start + 1)
      };
    }
    function generate(node) {
      this.token(types.Delim, "#" + node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs
var require_MediaFeature2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaFeature.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "MediaFeature";
    var structure = {
      name: String,
      value: ["Identifier", "Number", "Dimension", "Ratio", null]
    };
    function parse() {
      const start = this.tokenStart;
      let name2;
      let value = null;
      this.eat(types.LeftParenthesis);
      this.skipSC();
      name2 = this.consume(types.Ident);
      this.skipSC();
      if (this.tokenType !== types.RightParenthesis) {
        this.eat(types.Colon);
        this.skipSC();
        switch (this.tokenType) {
          case types.Number:
            if (this.lookupNonWSType(1) === types.Delim) {
              value = this.Ratio();
            } else {
              value = this.Number();
            }
            break;
          case types.Dimension:
            value = this.Dimension();
            break;
          case types.Ident:
            value = this.Identifier();
            break;
          default:
            this.error("Number, dimension, ratio or identifier is expected");
        }
        this.skipSC();
      }
      this.eat(types.RightParenthesis);
      return {
        type: "MediaFeature",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        value
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.token(types.Ident, node.name);
      if (node.value !== null) {
        this.token(types.Colon, ":");
        this.node(node.value);
      }
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs
var require_MediaQuery2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaQuery.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "MediaQuery";
    var structure = {
      children: [[
        "Identifier",
        "MediaFeature",
        "WhiteSpace"
      ]]
    };
    function parse() {
      const children = this.createList();
      let child = null;
      this.skipSC();
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.MediaFeature();
              break;
            default:
              break scan;
          }
          children.push(child);
        }
      if (child === null) {
        this.error("Identifier or parenthesis is expected");
      }
      return {
        type: "MediaQuery",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs
var require_MediaQueryList2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/MediaQueryList.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "MediaQueryList";
    var structure = {
      children: [[
        "MediaQuery"
      ]]
    };
    function parse() {
      const children = this.createList();
      this.skipSC();
      while (!this.eof) {
        children.push(this.MediaQuery());
        if (this.tokenType !== types.Comma) {
          break;
        }
        this.next();
      }
      return {
        type: "MediaQueryList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Nth.cjs
var require_Nth2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Nth.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Nth";
    var structure = {
      nth: ["AnPlusB", "Identifier"],
      selector: ["SelectorList", null]
    };
    function parse() {
      this.skipSC();
      const start = this.tokenStart;
      let end = start;
      let selector = null;
      let nth;
      if (this.lookupValue(0, "odd") || this.lookupValue(0, "even")) {
        nth = this.Identifier();
      } else {
        nth = this.AnPlusB();
      }
      end = this.tokenStart;
      this.skipSC();
      if (this.lookupValue(0, "of")) {
        this.next();
        selector = this.SelectorList();
        end = this.tokenStart;
      }
      return {
        type: "Nth",
        loc: this.getLocation(start, end),
        nth,
        selector
      };
    }
    function generate(node) {
      this.node(node.nth);
      if (node.selector !== null) {
        this.token(types.Ident, "of");
        this.node(node.selector);
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Number.cjs
var require_Number2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Number.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Number";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Number",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consume(types.Number)
      };
    }
    function generate(node) {
      this.token(types.Number, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Operator.cjs
var require_Operator2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Operator.cjs"(exports2) {
    "use strict";
    var name = "Operator";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.next();
      return {
        type: "Operator",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Parentheses.cjs
var require_Parentheses2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Parentheses.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Parentheses";
    var structure = {
      children: [[]]
    };
    function parse(readSequence, recognizer) {
      const start = this.tokenStart;
      let children = null;
      this.eat(types.LeftParenthesis);
      children = readSequence.call(this, recognizer);
      if (!this.eof) {
        this.eat(types.RightParenthesis);
      }
      return {
        type: "Parentheses",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.token(types.LeftParenthesis, "(");
      this.children(node);
      this.token(types.RightParenthesis, ")");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Percentage.cjs
var require_Percentage2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Percentage.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "Percentage";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "Percentage",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: this.consumeNumber(types.Percentage)
      };
    }
    function generate(node) {
      this.token(types.Percentage, node.value + "%");
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs
var require_PseudoClassSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/PseudoClassSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "PseudoClassSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(this.tokenIndex, null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoClassSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs
var require_PseudoElementSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/PseudoElementSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "PseudoElementSelector";
    var walkContext = "function";
    var structure = {
      name: String,
      children: [["Raw"], null]
    };
    function parse() {
      const start = this.tokenStart;
      let children = null;
      let name2;
      let nameLowerCase;
      this.eat(types.Colon);
      this.eat(types.Colon);
      if (this.tokenType === types.Function) {
        name2 = this.consumeFunctionName();
        nameLowerCase = name2.toLowerCase();
        if (hasOwnProperty.call(this.pseudo, nameLowerCase)) {
          this.skipSC();
          children = this.pseudo[nameLowerCase].call(this);
          this.skipSC();
        } else {
          children = this.createList();
          children.push(
            this.Raw(this.tokenIndex, null, false)
          );
        }
        this.eat(types.RightParenthesis);
      } else {
        name2 = this.consume(types.Ident);
      }
      return {
        type: "PseudoElementSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: name2,
        children
      };
    }
    function generate(node) {
      this.token(types.Colon, ":");
      this.token(types.Colon, ":");
      if (node.children === null) {
        this.token(types.Ident, node.name);
      } else {
        this.token(types.Function, node.name + "(");
        this.children(node);
        this.token(types.RightParenthesis, ")");
      }
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Ratio.cjs
var require_Ratio2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Ratio.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var charCodeDefinitions = require_char_code_definitions2();
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    function consumeNumber() {
      this.skipSC();
      const value = this.consume(types.Number);
      for (let i = 0; i < value.length; i++) {
        const code = value.charCodeAt(i);
        if (!charCodeDefinitions.isDigit(code) && code !== FULLSTOP) {
          this.error("Unsigned number is expected", this.tokenStart - value.length + i);
        }
      }
      if (Number(value) === 0) {
        this.error("Zero number is not allowed", this.tokenStart - value.length);
      }
      return value;
    }
    var name = "Ratio";
    var structure = {
      left: String,
      right: String
    };
    function parse() {
      const start = this.tokenStart;
      const left = consumeNumber.call(this);
      let right;
      this.skipSC();
      this.eatDelim(SOLIDUS);
      right = consumeNumber.call(this);
      return {
        type: "Ratio",
        loc: this.getLocation(start, this.tokenStart),
        left,
        right
      };
    }
    function generate(node) {
      this.token(types.Number, node.left);
      this.token(types.Delim, "/");
      this.token(types.Number, node.right);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Raw.cjs
var require_Raw2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Raw.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function getOffsetExcludeWS() {
      if (this.tokenIndex > 0) {
        if (this.lookupType(-1) === types.WhiteSpace) {
          return this.tokenIndex > 1 ? this.getTokenStart(this.tokenIndex - 1) : this.firstCharOffset;
        }
      }
      return this.tokenStart;
    }
    var name = "Raw";
    var structure = {
      value: String
    };
    function parse(startToken, consumeUntil, excludeWhiteSpace) {
      const startOffset = this.getTokenStart(startToken);
      let endOffset;
      this.skipUntilBalanced(startToken, consumeUntil || this.consumeUntilBalanceEnd);
      if (excludeWhiteSpace && this.tokenStart > startOffset) {
        endOffset = getOffsetExcludeWS.call(this);
      } else {
        endOffset = this.tokenStart;
      }
      return {
        type: "Raw",
        loc: this.getLocation(startOffset, endOffset),
        value: this.substring(startOffset, endOffset)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Rule.cjs
var require_Rule2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Rule.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    function consumeRaw(startToken) {
      return this.Raw(startToken, this.consumeUntilLeftCurlyBracket, true);
    }
    function consumePrelude() {
      const prelude = this.SelectorList();
      if (prelude.type !== "Raw" && this.eof === false && this.tokenType !== types.LeftCurlyBracket) {
        this.error();
      }
      return prelude;
    }
    var name = "Rule";
    var walkContext = "rule";
    var structure = {
      prelude: ["SelectorList", "Raw"],
      block: ["Block"]
    };
    function parse() {
      const startToken = this.tokenIndex;
      const startOffset = this.tokenStart;
      let prelude;
      let block;
      if (this.parseRulePrelude) {
        prelude = this.parseWithFallback(consumePrelude, consumeRaw);
      } else {
        prelude = consumeRaw.call(this, startToken);
      }
      block = this.Block(true);
      return {
        type: "Rule",
        loc: this.getLocation(startOffset, this.tokenStart),
        prelude,
        block
      };
    }
    function generate(node) {
      this.node(node.prelude);
      this.node(node.block);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Selector.cjs
var require_Selector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Selector.cjs"(exports2) {
    "use strict";
    var name = "Selector";
    var structure = {
      children: [[
        "TypeSelector",
        "IdSelector",
        "ClassSelector",
        "AttributeSelector",
        "PseudoClassSelector",
        "PseudoElementSelector",
        "Combinator",
        "WhiteSpace"
      ]]
    };
    function parse() {
      const children = this.readSequence(this.scope.Selector);
      if (this.getFirstListNode(children) === null) {
        this.error("Selector is expected");
      }
      return {
        type: "Selector",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/SelectorList.cjs
var require_SelectorList2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/SelectorList.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var name = "SelectorList";
    var walkContext = "selector";
    var structure = {
      children: [[
        "Selector",
        "Raw"
      ]]
    };
    function parse() {
      const children = this.createList();
      while (!this.eof) {
        children.push(this.Selector());
        if (this.tokenType === types.Comma) {
          this.next();
          continue;
        }
        break;
      }
      return {
        type: "SelectorList",
        loc: this.getLocationFromList(children),
        children
      };
    }
    function generate(node) {
      this.children(node, () => this.token(types.Comma, ","));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/string.cjs
var require_string2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/string.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    var utils = require_utils2();
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    function decode(str) {
      const len = str.length;
      const firstChar = str.charCodeAt(0);
      const start = firstChar === QUOTATION_MARK || firstChar === APOSTROPHE ? 1 : 0;
      const end = start === 1 && len > 1 && str.charCodeAt(len - 1) === firstChar ? len - 2 : len - 1;
      let decoded = "";
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str, apostrophe) {
      const quote = apostrophe ? "'" : '"';
      const quoteCode = apostrophe ? APOSTROPHE : QUOTATION_MARK;
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === quoteCode || code === REVERSE_SOLIDUS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && (charCodeDefinitions.isHexDigit(code) || charCodeDefinitions.isWhiteSpace(code))) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return quote + encoded + quote;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/String.cjs
var require_String2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/String.cjs"(exports2) {
    "use strict";
    var string = require_string2();
    var types = require_types3();
    var name = "String";
    var structure = {
      value: String
    };
    function parse() {
      return {
        type: "String",
        loc: this.getLocation(this.tokenStart, this.tokenEnd),
        value: string.decode(this.consume(types.String))
      };
    }
    function generate(node) {
      this.token(types.String, string.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs
var require_StyleSheet2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/StyleSheet.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var EXCLAMATIONMARK = 33;
    function consumeRaw(startToken) {
      return this.Raw(startToken, null, false);
    }
    var name = "StyleSheet";
    var walkContext = "stylesheet";
    var structure = {
      children: [[
        "Comment",
        "CDO",
        "CDC",
        "Atrule",
        "Rule",
        "Raw"
      ]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.createList();
      let child;
      while (!this.eof) {
        switch (this.tokenType) {
          case types.WhiteSpace:
            this.next();
            continue;
          case types.Comment:
            if (this.charCodeAt(this.tokenStart + 2) !== EXCLAMATIONMARK) {
              this.next();
              continue;
            }
            child = this.Comment();
            break;
          case types.CDO:
            child = this.CDO();
            break;
          case types.CDC:
            child = this.CDC();
            break;
          // CSS Syntax Module Level 3
          // 2.2 Error handling
          // At the "top level" of a stylesheet, an <at-keyword-token> starts an at-rule.
          case types.AtKeyword:
            child = this.parseWithFallback(this.Atrule, consumeRaw);
            break;
          // Anything else starts a qualified rule ...
          default:
            child = this.parseWithFallback(this.Rule, consumeRaw);
        }
        children.push(child);
      }
      return {
        type: "StyleSheet",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
    exports2.walkContext = walkContext;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs
var require_TypeSelector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/TypeSelector.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var ASTERISK = 42;
    var VERTICALLINE = 124;
    function eatIdentifierOrAsterisk() {
      if (this.tokenType !== types.Ident && this.isDelim(ASTERISK) === false) {
        this.error("Identifier or asterisk is expected");
      }
      this.next();
    }
    var name = "TypeSelector";
    var structure = {
      name: String
    };
    function parse() {
      const start = this.tokenStart;
      if (this.isDelim(VERTICALLINE)) {
        this.next();
        eatIdentifierOrAsterisk.call(this);
      } else {
        eatIdentifierOrAsterisk.call(this);
        if (this.isDelim(VERTICALLINE)) {
          this.next();
          eatIdentifierOrAsterisk.call(this);
        }
      }
      return {
        type: "TypeSelector",
        loc: this.getLocation(start, this.tokenStart),
        name: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.name);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs
var require_UnicodeRange2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/UnicodeRange.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var charCodeDefinitions = require_char_code_definitions2();
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var QUESTIONMARK = 63;
    function eatHexSequence(offset, allowDash) {
      let len = 0;
      for (let pos = this.tokenStart + offset; pos < this.tokenEnd; pos++) {
        const code = this.charCodeAt(pos);
        if (code === HYPHENMINUS && allowDash && len !== 0) {
          eatHexSequence.call(this, offset + len + 1, false);
          return -1;
        }
        if (!charCodeDefinitions.isHexDigit(code)) {
          this.error(
            allowDash && len !== 0 ? "Hyphen minus" + (len < 6 ? " or hex digit" : "") + " is expected" : len < 6 ? "Hex digit is expected" : "Unexpected input",
            pos
          );
        }
        if (++len > 6) {
          this.error("Too many hex digits", pos);
        }
      }
      this.next();
      return len;
    }
    function eatQuestionMarkSequence(max) {
      let count = 0;
      while (this.isDelim(QUESTIONMARK)) {
        if (++count > max) {
          this.error("Too many question marks");
        }
        this.next();
      }
    }
    function startsWith(code) {
      if (this.charCodeAt(this.tokenStart) !== code) {
        this.error((code === PLUSSIGN ? "Plus sign" : "Hyphen minus") + " is expected");
      }
    }
    function scanUnicodeRange() {
      let hexLength = 0;
      switch (this.tokenType) {
        case types.Number:
          hexLength = eatHexSequence.call(this, 1, true);
          if (this.isDelim(QUESTIONMARK)) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
            break;
          }
          if (this.tokenType === types.Dimension || this.tokenType === types.Number) {
            startsWith.call(this, HYPHENMINUS);
            eatHexSequence.call(this, 1, false);
            break;
          }
          break;
        case types.Dimension:
          hexLength = eatHexSequence.call(this, 1, true);
          if (hexLength > 0) {
            eatQuestionMarkSequence.call(this, 6 - hexLength);
          }
          break;
        default:
          this.eatDelim(PLUSSIGN);
          if (this.tokenType === types.Ident) {
            hexLength = eatHexSequence.call(this, 0, true);
            if (hexLength > 0) {
              eatQuestionMarkSequence.call(this, 6 - hexLength);
            }
            break;
          }
          if (this.isDelim(QUESTIONMARK)) {
            this.next();
            eatQuestionMarkSequence.call(this, 5);
            break;
          }
          this.error("Hex digit or question mark is expected");
      }
    }
    var name = "UnicodeRange";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      this.eatIdent("u");
      scanUnicodeRange.call(this);
      return {
        type: "UnicodeRange",
        loc: this.getLocation(start, this.tokenStart),
        value: this.substrToCursor(start)
      };
    }
    function generate(node) {
      this.tokenize(node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/url.cjs
var require_url2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/url.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    var utils = require_utils2();
    var SPACE = 32;
    var REVERSE_SOLIDUS = 92;
    var QUOTATION_MARK = 34;
    var APOSTROPHE = 39;
    var LEFTPARENTHESIS = 40;
    var RIGHTPARENTHESIS = 41;
    function decode(str) {
      const len = str.length;
      let start = 4;
      let end = str.charCodeAt(len - 1) === RIGHTPARENTHESIS ? len - 2 : len - 1;
      let decoded = "";
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(start))) {
        start++;
      }
      while (start < end && charCodeDefinitions.isWhiteSpace(str.charCodeAt(end))) {
        end--;
      }
      for (let i = start; i <= end; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            if (i !== len - 1) {
              decoded = str.substr(i + 1);
            }
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      let wsBeforeHexIsNeeded = false;
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (code <= 31 || code === 127) {
          encoded += "\\" + code.toString(16);
          wsBeforeHexIsNeeded = true;
          continue;
        }
        if (code === SPACE || code === REVERSE_SOLIDUS || code === QUOTATION_MARK || code === APOSTROPHE || code === LEFTPARENTHESIS || code === RIGHTPARENTHESIS) {
          encoded += "\\" + str.charAt(i);
          wsBeforeHexIsNeeded = false;
        } else {
          if (wsBeforeHexIsNeeded && charCodeDefinitions.isHexDigit(code)) {
            encoded += " ";
          }
          encoded += str.charAt(i);
          wsBeforeHexIsNeeded = false;
        }
      }
      return "url(" + encoded + ")";
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Url.cjs
var require_Url2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Url.cjs"(exports2) {
    "use strict";
    var url = require_url2();
    var string = require_string2();
    var types = require_types3();
    var name = "Url";
    var structure = {
      value: String
    };
    function parse() {
      const start = this.tokenStart;
      let value;
      switch (this.tokenType) {
        case types.Url:
          value = url.decode(this.consume(types.Url));
          break;
        case types.Function:
          if (!this.cmpStr(this.tokenStart, this.tokenEnd, "url(")) {
            this.error("Function name must be `url`");
          }
          this.eat(types.Function);
          this.skipSC();
          value = string.decode(this.consume(types.String));
          this.skipSC();
          if (!this.eof) {
            this.eat(types.RightParenthesis);
          }
          break;
        default:
          this.error("Url or Function is expected");
      }
      return {
        type: "Url",
        loc: this.getLocation(start, this.tokenStart),
        value
      };
    }
    function generate(node) {
      this.token(types.Url, url.encode(node.value));
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/Value.cjs
var require_Value2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/Value.cjs"(exports2) {
    "use strict";
    var name = "Value";
    var structure = {
      children: [[]]
    };
    function parse() {
      const start = this.tokenStart;
      const children = this.readSequence(this.scope.Value);
      return {
        type: "Value",
        loc: this.getLocation(start, this.tokenStart),
        children
      };
    }
    function generate(node) {
      this.children(node);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs
var require_WhiteSpace2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/WhiteSpace.cjs"(exports2) {
    "use strict";
    var types = require_types3();
    var SPACE = Object.freeze({
      type: "WhiteSpace",
      loc: null,
      value: " "
    });
    var name = "WhiteSpace";
    var structure = {
      value: String
    };
    function parse() {
      this.eat(types.WhiteSpace);
      return SPACE;
    }
    function generate(node) {
      this.token(types.WhiteSpace, node.value);
    }
    exports2.generate = generate;
    exports2.name = name;
    exports2.parse = parse;
    exports2.structure = structure;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/index.cjs
var require_node3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/index.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB2();
    var Atrule = require_Atrule2();
    var AtrulePrelude = require_AtrulePrelude2();
    var AttributeSelector = require_AttributeSelector2();
    var Block = require_Block2();
    var Brackets = require_Brackets2();
    var CDC = require_CDC2();
    var CDO = require_CDO2();
    var ClassSelector = require_ClassSelector2();
    var Combinator = require_Combinator2();
    var Comment = require_Comment2();
    var Declaration = require_Declaration2();
    var DeclarationList = require_DeclarationList2();
    var Dimension = require_Dimension2();
    var Function2 = require_Function2();
    var Hash = require_Hash2();
    var Identifier = require_Identifier2();
    var IdSelector = require_IdSelector2();
    var MediaFeature = require_MediaFeature2();
    var MediaQuery = require_MediaQuery2();
    var MediaQueryList = require_MediaQueryList2();
    var Nth = require_Nth2();
    var Number$1 = require_Number2();
    var Operator = require_Operator2();
    var Parentheses = require_Parentheses2();
    var Percentage = require_Percentage2();
    var PseudoClassSelector = require_PseudoClassSelector2();
    var PseudoElementSelector = require_PseudoElementSelector2();
    var Ratio = require_Ratio2();
    var Raw = require_Raw2();
    var Rule = require_Rule2();
    var Selector = require_Selector2();
    var SelectorList = require_SelectorList2();
    var String$1 = require_String2();
    var StyleSheet = require_StyleSheet2();
    var TypeSelector = require_TypeSelector2();
    var UnicodeRange = require_UnicodeRange2();
    var Url = require_Url2();
    var Value = require_Value2();
    var WhiteSpace = require_WhiteSpace2();
    exports2.AnPlusB = AnPlusB;
    exports2.Atrule = Atrule;
    exports2.AtrulePrelude = AtrulePrelude;
    exports2.AttributeSelector = AttributeSelector;
    exports2.Block = Block;
    exports2.Brackets = Brackets;
    exports2.CDC = CDC;
    exports2.CDO = CDO;
    exports2.ClassSelector = ClassSelector;
    exports2.Combinator = Combinator;
    exports2.Comment = Comment;
    exports2.Declaration = Declaration;
    exports2.DeclarationList = DeclarationList;
    exports2.Dimension = Dimension;
    exports2.Function = Function2;
    exports2.Hash = Hash;
    exports2.Identifier = Identifier;
    exports2.IdSelector = IdSelector;
    exports2.MediaFeature = MediaFeature;
    exports2.MediaQuery = MediaQuery;
    exports2.MediaQueryList = MediaQueryList;
    exports2.Nth = Nth;
    exports2.Number = Number$1;
    exports2.Operator = Operator;
    exports2.Parentheses = Parentheses;
    exports2.Percentage = Percentage;
    exports2.PseudoClassSelector = PseudoClassSelector;
    exports2.PseudoElementSelector = PseudoElementSelector;
    exports2.Ratio = Ratio;
    exports2.Raw = Raw;
    exports2.Rule = Rule;
    exports2.Selector = Selector;
    exports2.SelectorList = SelectorList;
    exports2.String = String$1;
    exports2.StyleSheet = StyleSheet;
    exports2.TypeSelector = TypeSelector;
    exports2.UnicodeRange = UnicodeRange;
    exports2.Url = Url;
    exports2.Value = Value;
    exports2.WhiteSpace = WhiteSpace;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/config/lexer.cjs
var require_lexer2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/config/lexer.cjs"(exports2, module2) {
    "use strict";
    var data = require_data2();
    var index = require_node3();
    var lexerConfig = {
      generic: true,
      ...data,
      node: index
    };
    module2.exports = lexerConfig;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/scope/default.cjs
var require_default2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/scope/default.cjs"(exports2, module2) {
    "use strict";
    var types = require_types3();
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var HYPHENMINUS = 45;
    var SOLIDUS = 47;
    var U = 117;
    function defaultRecognizer(context) {
      switch (this.tokenType) {
        case types.Hash:
          return this.Hash();
        case types.Comma:
          return this.Operator();
        case types.LeftParenthesis:
          return this.Parentheses(this.readSequence, context.recognizer);
        case types.LeftSquareBracket:
          return this.Brackets(this.readSequence, context.recognizer);
        case types.String:
          return this.String();
        case types.Dimension:
          return this.Dimension();
        case types.Percentage:
          return this.Percentage();
        case types.Number:
          return this.Number();
        case types.Function:
          return this.cmpStr(this.tokenStart, this.tokenEnd, "url(") ? this.Url() : this.Function(this.readSequence, context.recognizer);
        case types.Url:
          return this.Url();
        case types.Ident:
          if (this.cmpChar(this.tokenStart, U) && this.cmpChar(this.tokenStart + 1, PLUSSIGN)) {
            return this.UnicodeRange();
          } else {
            return this.Identifier();
          }
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          if (code === SOLIDUS || code === ASTERISK || code === PLUSSIGN || code === HYPHENMINUS) {
            return this.Operator();
          }
          if (code === NUMBERSIGN) {
            this.error("Hex or identifier is expected", this.tokenStart + 1);
          }
          break;
        }
      }
    }
    module2.exports = defaultRecognizer;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs
var require_atrulePrelude2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/scope/atrulePrelude.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default2();
    var atrulePrelude = {
      getNode: _default
    };
    module2.exports = atrulePrelude;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/scope/selector.cjs
var require_selector2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/scope/selector.cjs"(exports2, module2) {
    "use strict";
    var types = require_types3();
    var NUMBERSIGN = 35;
    var ASTERISK = 42;
    var PLUSSIGN = 43;
    var SOLIDUS = 47;
    var FULLSTOP = 46;
    var GREATERTHANSIGN = 62;
    var VERTICALLINE = 124;
    var TILDE = 126;
    function onWhiteSpace(next, children) {
      if (children.last !== null && children.last.type !== "Combinator" && next !== null && next.type !== "Combinator") {
        children.push({
          // FIXME: this.Combinator() should be used instead
          type: "Combinator",
          loc: null,
          name: " "
        });
      }
    }
    function getNode() {
      switch (this.tokenType) {
        case types.LeftSquareBracket:
          return this.AttributeSelector();
        case types.Hash:
          return this.IdSelector();
        case types.Colon:
          if (this.lookupType(1) === types.Colon) {
            return this.PseudoElementSelector();
          } else {
            return this.PseudoClassSelector();
          }
        case types.Ident:
          return this.TypeSelector();
        case types.Number:
        case types.Percentage:
          return this.Percentage();
        case types.Dimension:
          if (this.charCodeAt(this.tokenStart) === FULLSTOP) {
            this.error("Identifier is expected", this.tokenStart + 1);
          }
          break;
        case types.Delim: {
          const code = this.charCodeAt(this.tokenStart);
          switch (code) {
            case PLUSSIGN:
            case GREATERTHANSIGN:
            case TILDE:
            case SOLIDUS:
              return this.Combinator();
            case FULLSTOP:
              return this.ClassSelector();
            case ASTERISK:
            case VERTICALLINE:
              return this.TypeSelector();
            case NUMBERSIGN:
              return this.IdSelector();
          }
          break;
        }
      }
    }
    var Selector = {
      onWhiteSpace,
      getNode
    };
    module2.exports = Selector;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/function/expression.cjs
var require_expression2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/function/expression.cjs"(exports2, module2) {
    "use strict";
    function expressionFn() {
      return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    module2.exports = expressionFn;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/function/var.cjs
var require_var2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/function/var.cjs"(exports2, module2) {
    "use strict";
    var types = require_types3();
    function varFn() {
      const children = this.createList();
      this.skipSC();
      children.push(this.Identifier());
      this.skipSC();
      if (this.tokenType === types.Comma) {
        children.push(this.Operator());
        const startIndex = this.tokenIndex;
        const value = this.parseCustomProperty ? this.Value(null) : this.Raw(this.tokenIndex, this.consumeUntilExclamationMarkOrSemicolon, false);
        if (value.type === "Value" && value.children.isEmpty) {
          for (let offset = startIndex - this.tokenIndex; offset <= 0; offset++) {
            if (this.lookupType(offset) === types.WhiteSpace) {
              value.children.appendData({
                type: "WhiteSpace",
                loc: null,
                value: " "
              });
              break;
            }
          }
        }
        children.push(value);
      }
      return children;
    }
    module2.exports = varFn;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/scope/value.cjs
var require_value2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/scope/value.cjs"(exports2, module2) {
    "use strict";
    var _default = require_default2();
    var expression = require_expression2();
    var _var = require_var2();
    function isPlusMinusOperator(node) {
      return node !== null && node.type === "Operator" && (node.value[node.value.length - 1] === "-" || node.value[node.value.length - 1] === "+");
    }
    var value = {
      getNode: _default,
      onWhiteSpace(next, children) {
        if (isPlusMinusOperator(next)) {
          next.value = " " + next.value;
        }
        if (isPlusMinusOperator(children.last)) {
          children.last.value += " ";
        }
      },
      "expression": expression,
      "var": _var
    };
    module2.exports = value;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/scope/index.cjs
var require_scope2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/scope/index.cjs"(exports2) {
    "use strict";
    var atrulePrelude = require_atrulePrelude2();
    var selector = require_selector2();
    var value = require_value2();
    exports2.AtrulePrelude = atrulePrelude;
    exports2.Selector = selector;
    exports2.Value = value;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/font-face.cjs
var require_font_face2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/font-face.cjs"(exports2, module2) {
    "use strict";
    var fontFace = {
      parse: {
        prelude: null,
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = fontFace;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/import.cjs
var require_import2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/import.cjs"(exports2, module2) {
    "use strict";
    var types = require_types3();
    var importAtrule = {
      parse: {
        prelude() {
          const children = this.createList();
          this.skipSC();
          switch (this.tokenType) {
            case types.String:
              children.push(this.String());
              break;
            case types.Url:
            case types.Function:
              children.push(this.Url());
              break;
            default:
              this.error("String or url() is expected");
          }
          if (this.lookupNonWSType(0) === types.Ident || this.lookupNonWSType(0) === types.LeftParenthesis) {
            children.push(this.MediaQueryList());
          }
          return children;
        },
        block: null
      }
    };
    module2.exports = importAtrule;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/media.cjs
var require_media2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/media.cjs"(exports2, module2) {
    "use strict";
    var media = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.MediaQueryList()
          );
        },
        block() {
          return this.Block(false);
        }
      }
    };
    module2.exports = media;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/page.cjs
var require_page2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/page.cjs"(exports2, module2) {
    "use strict";
    var page = {
      parse: {
        prelude() {
          return this.createSingleNodeList(
            this.SelectorList()
          );
        },
        block() {
          return this.Block(true);
        }
      }
    };
    module2.exports = page;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/supports.cjs
var require_supports2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/supports.cjs"(exports2, module2) {
    "use strict";
    var types = require_types3();
    function consumeRaw() {
      return this.createSingleNodeList(
        this.Raw(this.tokenIndex, null, false)
      );
    }
    function parentheses() {
      this.skipSC();
      if (this.tokenType === types.Ident && this.lookupNonWSType(1) === types.Colon) {
        return this.createSingleNodeList(
          this.Declaration()
        );
      }
      return readSequence.call(this);
    }
    function readSequence() {
      const children = this.createList();
      let child;
      this.skipSC();
      scan:
        while (!this.eof) {
          switch (this.tokenType) {
            case types.Comment:
            case types.WhiteSpace:
              this.next();
              continue;
            case types.Function:
              child = this.Function(consumeRaw, this.scope.AtrulePrelude);
              break;
            case types.Ident:
              child = this.Identifier();
              break;
            case types.LeftParenthesis:
              child = this.Parentheses(parentheses, this.scope.AtrulePrelude);
              break;
            default:
              break scan;
          }
          children.push(child);
        }
      return children;
    }
    var supports = {
      parse: {
        prelude() {
          const children = readSequence.call(this);
          if (this.getFirstListNode(children) === null) {
            this.error("Condition is expected");
          }
          return children;
        },
        block() {
          return this.Block(false);
        }
      }
    };
    module2.exports = supports;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/index.cjs
var require_atrule2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/atrule/index.cjs"(exports2, module2) {
    "use strict";
    var fontFace = require_font_face2();
    var _import = require_import2();
    var media = require_media2();
    var page = require_page2();
    var supports = require_supports2();
    var atrule = {
      "font-face": fontFace,
      "import": _import,
      media,
      page,
      supports
    };
    module2.exports = atrule;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/pseudo/index.cjs
var require_pseudo2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/pseudo/index.cjs"(exports2, module2) {
    "use strict";
    var selectorList = {
      parse() {
        return this.createSingleNodeList(
          this.SelectorList()
        );
      }
    };
    var selector = {
      parse() {
        return this.createSingleNodeList(
          this.Selector()
        );
      }
    };
    var identList = {
      parse() {
        return this.createSingleNodeList(
          this.Identifier()
        );
      }
    };
    var nth = {
      parse() {
        return this.createSingleNodeList(
          this.Nth()
        );
      }
    };
    var pseudo = {
      "dir": identList,
      "has": selectorList,
      "lang": identList,
      "matches": selectorList,
      "is": selectorList,
      "-moz-any": selectorList,
      "-webkit-any": selectorList,
      "where": selectorList,
      "not": selectorList,
      "nth-child": nth,
      "nth-last-child": nth,
      "nth-last-of-type": nth,
      "nth-of-type": nth,
      "slotted": selector
    };
    module2.exports = pseudo;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/node/index-parse.cjs
var require_index_parse2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/node/index-parse.cjs"(exports2) {
    "use strict";
    var AnPlusB = require_AnPlusB2();
    var Atrule = require_Atrule2();
    var AtrulePrelude = require_AtrulePrelude2();
    var AttributeSelector = require_AttributeSelector2();
    var Block = require_Block2();
    var Brackets = require_Brackets2();
    var CDC = require_CDC2();
    var CDO = require_CDO2();
    var ClassSelector = require_ClassSelector2();
    var Combinator = require_Combinator2();
    var Comment = require_Comment2();
    var Declaration = require_Declaration2();
    var DeclarationList = require_DeclarationList2();
    var Dimension = require_Dimension2();
    var Function2 = require_Function2();
    var Hash = require_Hash2();
    var Identifier = require_Identifier2();
    var IdSelector = require_IdSelector2();
    var MediaFeature = require_MediaFeature2();
    var MediaQuery = require_MediaQuery2();
    var MediaQueryList = require_MediaQueryList2();
    var Nth = require_Nth2();
    var Number2 = require_Number2();
    var Operator = require_Operator2();
    var Parentheses = require_Parentheses2();
    var Percentage = require_Percentage2();
    var PseudoClassSelector = require_PseudoClassSelector2();
    var PseudoElementSelector = require_PseudoElementSelector2();
    var Ratio = require_Ratio2();
    var Raw = require_Raw2();
    var Rule = require_Rule2();
    var Selector = require_Selector2();
    var SelectorList = require_SelectorList2();
    var String2 = require_String2();
    var StyleSheet = require_StyleSheet2();
    var TypeSelector = require_TypeSelector2();
    var UnicodeRange = require_UnicodeRange2();
    var Url = require_Url2();
    var Value = require_Value2();
    var WhiteSpace = require_WhiteSpace2();
    exports2.AnPlusB = AnPlusB.parse;
    exports2.Atrule = Atrule.parse;
    exports2.AtrulePrelude = AtrulePrelude.parse;
    exports2.AttributeSelector = AttributeSelector.parse;
    exports2.Block = Block.parse;
    exports2.Brackets = Brackets.parse;
    exports2.CDC = CDC.parse;
    exports2.CDO = CDO.parse;
    exports2.ClassSelector = ClassSelector.parse;
    exports2.Combinator = Combinator.parse;
    exports2.Comment = Comment.parse;
    exports2.Declaration = Declaration.parse;
    exports2.DeclarationList = DeclarationList.parse;
    exports2.Dimension = Dimension.parse;
    exports2.Function = Function2.parse;
    exports2.Hash = Hash.parse;
    exports2.Identifier = Identifier.parse;
    exports2.IdSelector = IdSelector.parse;
    exports2.MediaFeature = MediaFeature.parse;
    exports2.MediaQuery = MediaQuery.parse;
    exports2.MediaQueryList = MediaQueryList.parse;
    exports2.Nth = Nth.parse;
    exports2.Number = Number2.parse;
    exports2.Operator = Operator.parse;
    exports2.Parentheses = Parentheses.parse;
    exports2.Percentage = Percentage.parse;
    exports2.PseudoClassSelector = PseudoClassSelector.parse;
    exports2.PseudoElementSelector = PseudoElementSelector.parse;
    exports2.Ratio = Ratio.parse;
    exports2.Raw = Raw.parse;
    exports2.Rule = Rule.parse;
    exports2.Selector = Selector.parse;
    exports2.SelectorList = SelectorList.parse;
    exports2.String = String2.parse;
    exports2.StyleSheet = StyleSheet.parse;
    exports2.TypeSelector = TypeSelector.parse;
    exports2.UnicodeRange = UnicodeRange.parse;
    exports2.Url = Url.parse;
    exports2.Value = Value.parse;
    exports2.WhiteSpace = WhiteSpace.parse;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/config/parser.cjs
var require_parser3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/config/parser.cjs"(exports2, module2) {
    "use strict";
    var index = require_scope2();
    var index$1 = require_atrule2();
    var index$2 = require_pseudo2();
    var indexParse = require_index_parse2();
    var config = {
      parseContext: {
        default: "StyleSheet",
        stylesheet: "StyleSheet",
        atrule: "Atrule",
        atrulePrelude(options) {
          return this.AtrulePrelude(options.atrule ? String(options.atrule) : null);
        },
        mediaQueryList: "MediaQueryList",
        mediaQuery: "MediaQuery",
        rule: "Rule",
        selectorList: "SelectorList",
        selector: "Selector",
        block() {
          return this.Block(true);
        },
        declarationList: "DeclarationList",
        declaration: "Declaration",
        value: "Value"
      },
      scope: index,
      atrule: index$1,
      pseudo: index$2,
      node: indexParse
    };
    module2.exports = config;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/config/walker.cjs
var require_walker2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/config/walker.cjs"(exports2, module2) {
    "use strict";
    var index = require_node3();
    var config = {
      node: index
    };
    module2.exports = config;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/syntax/index.cjs
var require_syntax2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/syntax/index.cjs"(exports2, module2) {
    "use strict";
    var create = require_create10();
    var lexer = require_lexer2();
    var parser = require_parser3();
    var walker = require_walker2();
    var syntax = create({
      ...lexer,
      ...parser,
      ...walker
    });
    module2.exports = syntax;
  }
});

// node_modules/csso/node_modules/css-tree/package.json
var require_package3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/package.json"(exports2, module2) {
    module2.exports = {
      name: "css-tree",
      version: "2.2.1",
      description: "A tool set for CSS: fast detailed parser (CSS \u2192 AST), walker (AST traversal), generator (AST \u2192 CSS) and lexer (validation and matching) based on specs and browser implementations",
      author: "Roman Dvornov <rdvornov@gmail.com> (https://github.com/lahmatiy)",
      license: "MIT",
      repository: "csstree/csstree",
      keywords: [
        "css",
        "ast",
        "tokenizer",
        "parser",
        "walker",
        "lexer",
        "generator",
        "utils",
        "syntax",
        "validation"
      ],
      type: "module",
      module: "./lib/index.js",
      main: "./cjs/index.cjs",
      exports: {
        ".": {
          import: "./lib/index.js",
          require: "./cjs/index.cjs"
        },
        "./dist/*": "./dist/*.js",
        "./package.json": "./package.json",
        "./tokenizer": {
          import: "./lib/tokenizer/index.js",
          require: "./cjs/tokenizer/index.cjs"
        },
        "./parser": {
          import: "./lib/parser/index.js",
          require: "./cjs/parser/index.cjs"
        },
        "./selector-parser": {
          import: "./lib/parser/parse-selector.js",
          require: "./cjs/parser/parse-selector.cjs"
        },
        "./generator": {
          import: "./lib/generator/index.js",
          require: "./cjs/generator/index.cjs"
        },
        "./walker": {
          import: "./lib/walker/index.js",
          require: "./cjs/walker/index.cjs"
        },
        "./convertor": {
          import: "./lib/convertor/index.js",
          require: "./cjs/convertor/index.cjs"
        },
        "./lexer": {
          import: "./lib/lexer/index.js",
          require: "./cjs/lexer/index.cjs"
        },
        "./definition-syntax": {
          import: "./lib/definition-syntax/index.js",
          require: "./cjs/definition-syntax/index.cjs"
        },
        "./definition-syntax-data": {
          import: "./lib/data.js",
          require: "./cjs/data.cjs"
        },
        "./definition-syntax-data-patch": {
          import: "./lib/data-patch.js",
          require: "./cjs/data-patch.cjs"
        },
        "./utils": {
          import: "./lib/utils/index.js",
          require: "./cjs/utils/index.cjs"
        }
      },
      browser: {
        "./cjs/data.cjs": "./dist/data.cjs",
        "./cjs/version.cjs": "./dist/version.cjs",
        "./lib/data.js": "./dist/data.js",
        "./lib/version.js": "./dist/version.js"
      },
      unpkg: "dist/csstree.esm.js",
      jsdelivr: "dist/csstree.esm.js",
      scripts: {
        watch: "npm run build -- --watch",
        build: "npm run bundle && npm run esm-to-cjs --",
        "build-and-test": "npm run build && npm run test:dist && npm run test:cjs",
        bundle: "node scripts/bundle",
        "bundle-and-test": "npm run bundle && npm run test:dist",
        "esm-to-cjs": "node scripts/esm-to-cjs.cjs",
        "esm-to-cjs-and-test": "npm run esm-to-cjs && npm run test:cjs",
        lint: "eslint lib scripts && node scripts/review-syntax-patch --lint && node scripts/update-docs --lint",
        "lint-and-test": "npm run lint && npm test",
        "update:docs": "node scripts/update-docs",
        "review:syntax-patch": "node scripts/review-syntax-patch",
        test: "mocha lib/__tests --reporter ${REPORTER:-progress}",
        "test:cjs": "mocha cjs/__tests --reporter ${REPORTER:-progress}",
        "test:dist": "mocha dist/__tests --reporter ${REPORTER:-progress}",
        coverage: "c8 --exclude lib/__tests --reporter=lcovonly npm test",
        prepublishOnly: "npm run lint-and-test && npm run build-and-test",
        hydrogen: "node --trace-hydrogen --trace-phase=Z --trace-deopt --code-comments --hydrogen-track-positions --redirect-code-traces --redirect-code-traces-to=code.asm --trace_hydrogen_file=code.cfg --print-opt-code bin/parse --stat -o /dev/null"
      },
      dependencies: {
        "mdn-data": "2.0.28",
        "source-map-js": "^1.0.1"
      },
      devDependencies: {
        c8: "^7.7.1",
        clap: "^2.0.1",
        esbuild: "^0.14.53",
        eslint: "^8.4.1",
        "json-to-ast": "^2.1.0",
        mocha: "^9.1.4",
        rollup: "^2.68.0"
      },
      engines: {
        node: "^10 || ^12.20.0 || ^14.13.0 || >=15.0.0",
        npm: ">=7.0.0"
      },
      files: [
        "data",
        "dist",
        "cjs",
        "!cjs/__tests",
        "lib",
        "!lib/__tests"
      ]
    };
  }
});

// node_modules/csso/node_modules/css-tree/cjs/version.cjs
var require_version3 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/version.cjs"(exports2) {
    "use strict";
    var { version } = require_package3();
    exports2.version = version;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/definition-syntax/index.cjs
var require_definition_syntax2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/definition-syntax/index.cjs"(exports2) {
    "use strict";
    var SyntaxError2 = require_SyntaxError4();
    var generate = require_generate2();
    var parse = require_parse4();
    var walk = require_walk2();
    exports2.SyntaxError = SyntaxError2.SyntaxError;
    exports2.generate = generate.generate;
    exports2.parse = parse.parse;
    exports2.walk = walk.walk;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/clone.cjs
var require_clone2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/clone.cjs"(exports2) {
    "use strict";
    var List = require_List2();
    function clone(node) {
      const result = {};
      for (const key in node) {
        let value = node[key];
        if (value) {
          if (Array.isArray(value) || value instanceof List.List) {
            value = value.map(clone);
          } else if (value.constructor === Object) {
            value = clone(value);
          }
        }
        result[key] = value;
      }
      return result;
    }
    exports2.clone = clone;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/utils/ident.cjs
var require_ident2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/utils/ident.cjs"(exports2) {
    "use strict";
    var charCodeDefinitions = require_char_code_definitions2();
    var utils = require_utils2();
    var REVERSE_SOLIDUS = 92;
    function decode(str) {
      const end = str.length - 1;
      let decoded = "";
      for (let i = 0; i < str.length; i++) {
        let code = str.charCodeAt(i);
        if (code === REVERSE_SOLIDUS) {
          if (i === end) {
            break;
          }
          code = str.charCodeAt(++i);
          if (charCodeDefinitions.isValidEscape(REVERSE_SOLIDUS, code)) {
            const escapeStart = i - 1;
            const escapeEnd = utils.consumeEscaped(str, escapeStart);
            i = escapeEnd - 1;
            decoded += utils.decodeEscaped(str.substring(escapeStart + 1, escapeEnd));
          } else {
            if (code === 13 && str.charCodeAt(i + 1) === 10) {
              i++;
            }
          }
        } else {
          decoded += str[i];
        }
      }
      return decoded;
    }
    function encode(str) {
      let encoded = "";
      if (str.length === 1 && str.charCodeAt(0) === 45) {
        return "\\-";
      }
      for (let i = 0; i < str.length; i++) {
        const code = str.charCodeAt(i);
        if (code === 0) {
          encoded += "\uFFFD";
          continue;
        }
        if (
          // If the character is in the range [\1-\1f] (U+0001 to U+001F) or is U+007F ...
          // Note: Do not compare with 0x0001 since 0x0000 is precessed before
          code <= 31 || code === 127 || // [or] ... is in the range [0-9] (U+0030 to U+0039),
          code >= 48 && code <= 57 && // If the character is the first character ...
          (i === 0 || // If the character is the second character ... and the first character is a "-" (U+002D)
          i === 1 && str.charCodeAt(0) === 45)
        ) {
          encoded += "\\" + code.toString(16) + " ";
          continue;
        }
        if (charCodeDefinitions.isName(code)) {
          encoded += str.charAt(i);
        } else {
          encoded += "\\" + str.charAt(i);
        }
      }
      return encoded;
    }
    exports2.decode = decode;
    exports2.encode = encode;
  }
});

// node_modules/csso/node_modules/css-tree/cjs/index.cjs
var require_cjs2 = __commonJS({
  "node_modules/csso/node_modules/css-tree/cjs/index.cjs"(exports2) {
    "use strict";
    var index$1 = require_syntax2();
    var version = require_version3();
    var create = require_create10();
    var List = require_List2();
    var Lexer = require_Lexer2();
    var index = require_definition_syntax2();
    var clone = require_clone2();
    var names$1 = require_names4();
    var ident = require_ident2();
    var string = require_string2();
    var url = require_url2();
    var types = require_types3();
    var names = require_names3();
    var TokenStream = require_TokenStream2();
    var {
      tokenize,
      parse,
      generate,
      lexer,
      createLexer,
      walk,
      find,
      findLast,
      findAll,
      toPlainObject,
      fromPlainObject,
      fork
    } = index$1;
    exports2.version = version.version;
    exports2.createSyntax = create;
    exports2.List = List.List;
    exports2.Lexer = Lexer.Lexer;
    exports2.definitionSyntax = index;
    exports2.clone = clone.clone;
    exports2.isCustomProperty = names$1.isCustomProperty;
    exports2.keyword = names$1.keyword;
    exports2.property = names$1.property;
    exports2.vendorPrefix = names$1.vendorPrefix;
    exports2.ident = ident;
    exports2.string = string;
    exports2.url = url;
    exports2.tokenTypes = types;
    exports2.tokenNames = names;
    exports2.TokenStream = TokenStream.TokenStream;
    exports2.createLexer = createLexer;
    exports2.find = find;
    exports2.findAll = findAll;
    exports2.findLast = findLast;
    exports2.fork = fork;
    exports2.fromPlainObject = fromPlainObject;
    exports2.generate = generate;
    exports2.lexer = lexer;
    exports2.parse = parse;
    exports2.toPlainObject = toPlainObject;
    exports2.tokenize = tokenize;
    exports2.walk = walk;
  }
});

// node_modules/csso/cjs/usage.cjs
var require_usage = __commonJS({
  "node_modules/csso/cjs/usage.cjs"(exports2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function buildMap(list, caseInsensitive) {
      const map = /* @__PURE__ */ Object.create(null);
      if (!Array.isArray(list)) {
        return null;
      }
      for (let name of list) {
        if (caseInsensitive) {
          name = name.toLowerCase();
        }
        map[name] = true;
      }
      return map;
    }
    function buildList(data) {
      if (!data) {
        return null;
      }
      const tags = buildMap(data.tags, true);
      const ids = buildMap(data.ids);
      const classes = buildMap(data.classes);
      if (tags === null && ids === null && classes === null) {
        return null;
      }
      return {
        tags,
        ids,
        classes
      };
    }
    function buildIndex(data) {
      let scopes = false;
      if (data.scopes && Array.isArray(data.scopes)) {
        scopes = /* @__PURE__ */ Object.create(null);
        for (let i = 0; i < data.scopes.length; i++) {
          const list = data.scopes[i];
          if (!list || !Array.isArray(list)) {
            throw new Error("Wrong usage format");
          }
          for (const name of list) {
            if (hasOwnProperty2.call(scopes, name)) {
              throw new Error(`Class can't be used for several scopes: ${name}`);
            }
            scopes[name] = i + 1;
          }
        }
      }
      return {
        whitelist: buildList(data),
        blacklist: buildList(data.blacklist),
        scopes
      };
    }
    exports2.buildIndex = buildIndex;
  }
});

// node_modules/csso/cjs/clean/utils.cjs
var require_utils3 = __commonJS({
  "node_modules/csso/cjs/clean/utils.cjs"(exports2) {
    "use strict";
    function hasNoChildren(node) {
      return !node || !node.children || node.children.isEmpty;
    }
    function isNodeChildrenList(node, list) {
      return node !== null && node.children === list;
    }
    exports2.hasNoChildren = hasNoChildren;
    exports2.isNodeChildrenList = isNodeChildrenList;
  }
});

// node_modules/csso/cjs/clean/Atrule.cjs
var require_Atrule3 = __commonJS({
  "node_modules/csso/cjs/clean/Atrule.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var utils = require_utils3();
    function cleanAtrule(node, item, list) {
      if (node.block) {
        if (this.stylesheet !== null) {
          this.stylesheet.firstAtrulesAllowed = false;
        }
        if (utils.hasNoChildren(node.block)) {
          list.remove(item);
          return;
        }
      }
      switch (node.name) {
        case "charset":
          if (utils.hasNoChildren(node.prelude)) {
            list.remove(item);
            return;
          }
          if (item.prev) {
            list.remove(item);
            return;
          }
          break;
        case "import":
          if (this.stylesheet === null || !this.stylesheet.firstAtrulesAllowed) {
            list.remove(item);
            return;
          }
          list.prevUntil(item.prev, function(rule) {
            if (rule.type === "Atrule") {
              if (rule.name === "import" || rule.name === "charset") {
                return;
              }
            }
            this.root.firstAtrulesAllowed = false;
            list.remove(item);
            return true;
          }, this);
          break;
        default: {
          const name = cssTree.keyword(node.name).basename;
          if (name === "keyframes" || name === "media" || name === "supports") {
            if (utils.hasNoChildren(node.prelude) || utils.hasNoChildren(node.block)) {
              list.remove(item);
            }
          }
        }
      }
    }
    module2.exports = cleanAtrule;
  }
});

// node_modules/csso/cjs/clean/Comment.cjs
var require_Comment3 = __commonJS({
  "node_modules/csso/cjs/clean/Comment.cjs"(exports2, module2) {
    "use strict";
    function cleanComment(data, item, list) {
      list.remove(item);
    }
    module2.exports = cleanComment;
  }
});

// node_modules/csso/cjs/clean/Declaration.cjs
var require_Declaration3 = __commonJS({
  "node_modules/csso/cjs/clean/Declaration.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    function cleanDeclartion(node, item, list) {
      if (node.value.children && node.value.children.isEmpty) {
        list.remove(item);
        return;
      }
      if (cssTree.property(node.property).custom) {
        if (/\S/.test(node.value.value)) {
          node.value.value = node.value.value.trim();
        }
      }
    }
    module2.exports = cleanDeclartion;
  }
});

// node_modules/csso/cjs/clean/Raw.cjs
var require_Raw3 = __commonJS({
  "node_modules/csso/cjs/clean/Raw.cjs"(exports2, module2) {
    "use strict";
    var utils = require_utils3();
    function cleanRaw(node, item, list) {
      if (utils.isNodeChildrenList(this.stylesheet, list) || utils.isNodeChildrenList(this.block, list)) {
        list.remove(item);
      }
    }
    module2.exports = cleanRaw;
  }
});

// node_modules/csso/cjs/clean/Rule.cjs
var require_Rule3 = __commonJS({
  "node_modules/csso/cjs/clean/Rule.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var utils = require_utils3();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    var skipUsageFilteringAtrule = /* @__PURE__ */ new Set(["keyframes"]);
    function cleanUnused(selectorList, usageData) {
      selectorList.children.forEach((selector, item, list) => {
        let shouldRemove = false;
        cssTree.walk(selector, function(node) {
          if (this.selector === null || this.selector === selectorList) {
            switch (node.type) {
              case "SelectorList":
                if (this.function === null || this.function.name.toLowerCase() !== "not") {
                  if (cleanUnused(node, usageData)) {
                    shouldRemove = true;
                  }
                }
                break;
              case "ClassSelector":
                if (usageData.whitelist !== null && usageData.whitelist.classes !== null && !hasOwnProperty2.call(usageData.whitelist.classes, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.classes !== null && hasOwnProperty2.call(usageData.blacklist.classes, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "IdSelector":
                if (usageData.whitelist !== null && usageData.whitelist.ids !== null && !hasOwnProperty2.call(usageData.whitelist.ids, node.name)) {
                  shouldRemove = true;
                }
                if (usageData.blacklist !== null && usageData.blacklist.ids !== null && hasOwnProperty2.call(usageData.blacklist.ids, node.name)) {
                  shouldRemove = true;
                }
                break;
              case "TypeSelector":
                if (node.name.charAt(node.name.length - 1) !== "*") {
                  if (usageData.whitelist !== null && usageData.whitelist.tags !== null && !hasOwnProperty2.call(usageData.whitelist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                  if (usageData.blacklist !== null && usageData.blacklist.tags !== null && hasOwnProperty2.call(usageData.blacklist.tags, node.name.toLowerCase())) {
                    shouldRemove = true;
                  }
                }
                break;
            }
          }
        });
        if (shouldRemove) {
          list.remove(item);
        }
      });
      return selectorList.children.isEmpty;
    }
    function cleanRule(node, item, list, options) {
      if (utils.hasNoChildren(node.prelude) || utils.hasNoChildren(node.block)) {
        list.remove(item);
        return;
      }
      if (this.atrule && skipUsageFilteringAtrule.has(cssTree.keyword(this.atrule.name).basename)) {
        return;
      }
      const { usage } = options;
      if (usage && (usage.whitelist !== null || usage.blacklist !== null)) {
        cleanUnused(node.prelude, usage);
        if (utils.hasNoChildren(node.prelude)) {
          list.remove(item);
          return;
        }
      }
    }
    module2.exports = cleanRule;
  }
});

// node_modules/csso/cjs/clean/TypeSelector.cjs
var require_TypeSelector3 = __commonJS({
  "node_modules/csso/cjs/clean/TypeSelector.cjs"(exports2, module2) {
    "use strict";
    function cleanTypeSelector(node, item, list) {
      const name = item.data.name;
      if (name !== "*") {
        return;
      }
      const nextType = item.next && item.next.data.type;
      if (nextType === "IdSelector" || nextType === "ClassSelector" || nextType === "AttributeSelector" || nextType === "PseudoClassSelector" || nextType === "PseudoElementSelector") {
        list.remove(item);
      }
    }
    module2.exports = cleanTypeSelector;
  }
});

// node_modules/csso/cjs/clean/WhiteSpace.cjs
var require_WhiteSpace3 = __commonJS({
  "node_modules/csso/cjs/clean/WhiteSpace.cjs"(exports2, module2) {
    "use strict";
    function cleanWhitespace(node, item, list) {
      list.remove(item);
    }
    module2.exports = cleanWhitespace;
  }
});

// node_modules/csso/cjs/clean/index.cjs
var require_clean = __commonJS({
  "node_modules/csso/cjs/clean/index.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var Atrule = require_Atrule3();
    var Comment = require_Comment3();
    var Declaration = require_Declaration3();
    var Raw = require_Raw3();
    var Rule = require_Rule3();
    var TypeSelector = require_TypeSelector3();
    var WhiteSpace = require_WhiteSpace3();
    var handlers = {
      Atrule,
      Comment,
      Declaration,
      Raw,
      Rule,
      TypeSelector,
      WhiteSpace
    };
    function clean(ast, options) {
      cssTree.walk(ast, {
        leave(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list, options);
          }
        }
      });
    }
    module2.exports = clean;
  }
});

// node_modules/csso/cjs/replace/atrule/keyframes.cjs
var require_keyframes = __commonJS({
  "node_modules/csso/cjs/replace/atrule/keyframes.cjs"(exports2, module2) {
    "use strict";
    function compressKeyframes(node) {
      node.block.children.forEach((rule) => {
        rule.prelude.children.forEach((simpleselector) => {
          simpleselector.children.forEach((data, item) => {
            if (data.type === "Percentage" && data.value === "100") {
              item.data = {
                type: "TypeSelector",
                loc: data.loc,
                name: "to"
              };
            } else if (data.type === "TypeSelector" && data.name === "from") {
              item.data = {
                type: "Percentage",
                loc: data.loc,
                value: "0"
              };
            }
          });
        });
      });
    }
    module2.exports = compressKeyframes;
  }
});

// node_modules/csso/cjs/replace/Atrule.cjs
var require_Atrule4 = __commonJS({
  "node_modules/csso/cjs/replace/Atrule.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var keyframes = require_keyframes();
    function Atrule(node) {
      if (cssTree.keyword(node.name).basename === "keyframes") {
        keyframes(node);
      }
    }
    module2.exports = Atrule;
  }
});

// node_modules/csso/cjs/replace/AttributeSelector.cjs
var require_AttributeSelector3 = __commonJS({
  "node_modules/csso/cjs/replace/AttributeSelector.cjs"(exports2, module2) {
    "use strict";
    var blockUnquoteRx = /^(-?\d|--)|[\u0000-\u002c\u002e\u002f\u003A-\u0040\u005B-\u005E\u0060\u007B-\u009f]/;
    function canUnquote(value) {
      if (value === "" || value === "-") {
        return false;
      }
      return !blockUnquoteRx.test(value);
    }
    function AttributeSelector(node) {
      const attrValue = node.value;
      if (!attrValue || attrValue.type !== "String") {
        return;
      }
      if (canUnquote(attrValue.value)) {
        node.value = {
          type: "Identifier",
          loc: attrValue.loc,
          name: attrValue.value
        };
      }
    }
    module2.exports = AttributeSelector;
  }
});

// node_modules/csso/cjs/replace/property/font.cjs
var require_font = __commonJS({
  "node_modules/csso/cjs/replace/property/font.cjs"(exports2, module2) {
    "use strict";
    function compressFont(node) {
      const list = node.children;
      list.forEachRight(function(node2, item) {
        if (node2.type === "Identifier") {
          if (node2.name === "bold") {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "700"
            };
          } else if (node2.name === "normal") {
            const prev = item.prev;
            if (prev && prev.data.type === "Operator" && prev.data.value === "/") {
              this.remove(prev);
            }
            this.remove(item);
          }
        }
      });
      if (list.isEmpty) {
        list.insert(list.createItem({
          type: "Identifier",
          name: "normal"
        }));
      }
    }
    module2.exports = compressFont;
  }
});

// node_modules/csso/cjs/replace/property/font-weight.cjs
var require_font_weight = __commonJS({
  "node_modules/csso/cjs/replace/property/font-weight.cjs"(exports2, module2) {
    "use strict";
    function compressFontWeight(node) {
      const value = node.children.head.data;
      if (value.type === "Identifier") {
        switch (value.name) {
          case "normal":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "400"
            };
            break;
          case "bold":
            node.children.head.data = {
              type: "Number",
              loc: value.loc,
              value: "700"
            };
            break;
        }
      }
    }
    module2.exports = compressFontWeight;
  }
});

// node_modules/csso/cjs/replace/property/background.cjs
var require_background = __commonJS({
  "node_modules/csso/cjs/replace/property/background.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    function compressBackground(node) {
      function flush() {
        if (!buffer.length) {
          buffer.unshift(
            {
              type: "Number",
              loc: null,
              value: "0"
            },
            {
              type: "Number",
              loc: null,
              value: "0"
            }
          );
        }
        newValue.push.apply(newValue, buffer);
        buffer = [];
      }
      let newValue = [];
      let buffer = [];
      node.children.forEach((node2) => {
        if (node2.type === "Operator" && node2.value === ",") {
          flush();
          newValue.push(node2);
          return;
        }
        if (node2.type === "Identifier") {
          if (node2.name === "transparent" || node2.name === "none" || node2.name === "repeat" || node2.name === "scroll") {
            return;
          }
        }
        buffer.push(node2);
      });
      flush();
      node.children = new cssTree.List().fromArray(newValue);
    }
    module2.exports = compressBackground;
  }
});

// node_modules/csso/cjs/replace/property/border.cjs
var require_border = __commonJS({
  "node_modules/csso/cjs/replace/property/border.cjs"(exports2, module2) {
    "use strict";
    function compressBorder(node) {
      node.children.forEach((node2, item, list) => {
        if (node2.type === "Identifier" && node2.name.toLowerCase() === "none") {
          if (list.head === list.tail) {
            item.data = {
              type: "Number",
              loc: node2.loc,
              value: "0"
            };
          } else {
            list.remove(item);
          }
        }
      });
    }
    module2.exports = compressBorder;
  }
});

// node_modules/csso/cjs/replace/Value.cjs
var require_Value3 = __commonJS({
  "node_modules/csso/cjs/replace/Value.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var font = require_font();
    var fontWeight = require_font_weight();
    var background = require_background();
    var border = require_border();
    var handlers = {
      "font": font,
      "font-weight": fontWeight,
      "background": background,
      "border": border,
      "outline": border
    };
    function compressValue(node) {
      if (!this.declaration) {
        return;
      }
      const property = cssTree.property(this.declaration.property);
      if (handlers.hasOwnProperty(property.basename)) {
        handlers[property.basename](node);
      }
    }
    module2.exports = compressValue;
  }
});

// node_modules/csso/cjs/replace/Number.cjs
var require_Number3 = __commonJS({
  "node_modules/csso/cjs/replace/Number.cjs"(exports2) {
    "use strict";
    var OMIT_PLUSSIGN = /^(?:\+|(-))?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var KEEP_PLUSSIGN = /^([\+\-])?0*(\d*)(?:\.0*|(\.\d*?)0*)?$/;
    var unsafeToRemovePlusSignAfter = /* @__PURE__ */ new Set([
      "Dimension",
      "Hash",
      "Identifier",
      "Number",
      "Raw",
      "UnicodeRange"
    ]);
    function packNumber(value, item) {
      const regexp = item && item.prev !== null && unsafeToRemovePlusSignAfter.has(item.prev.data.type) ? KEEP_PLUSSIGN : OMIT_PLUSSIGN;
      value = String(value).replace(regexp, "$1$2$3");
      if (value === "" || value === "-") {
        value = "0";
      }
      return value;
    }
    function Number2(node) {
      node.value = packNumber(node.value);
    }
    exports2.Number = Number2;
    exports2.packNumber = packNumber;
  }
});

// node_modules/csso/cjs/replace/Dimension.cjs
var require_Dimension3 = __commonJS({
  "node_modules/csso/cjs/replace/Dimension.cjs"(exports2, module2) {
    "use strict";
    var _Number = require_Number3();
    var MATH_FUNCTIONS = /* @__PURE__ */ new Set([
      "calc",
      "min",
      "max",
      "clamp"
    ]);
    var LENGTH_UNIT = /* @__PURE__ */ new Set([
      // absolute length units
      "px",
      "mm",
      "cm",
      "in",
      "pt",
      "pc",
      // relative length units
      "em",
      "ex",
      "ch",
      "rem",
      // viewport-percentage lengths
      "vh",
      "vw",
      "vmin",
      "vmax",
      "vm"
    ]);
    function compressDimension(node, item) {
      const value = _Number.packNumber(node.value);
      node.value = value;
      if (value === "0" && this.declaration !== null && this.atrulePrelude === null) {
        const unit = node.unit.toLowerCase();
        if (!LENGTH_UNIT.has(unit)) {
          return;
        }
        if (this.declaration.property === "-ms-flex" || this.declaration.property === "flex") {
          return;
        }
        if (this.function && MATH_FUNCTIONS.has(this.function.name)) {
          return;
        }
        item.data = {
          type: "Number",
          loc: node.loc,
          value
        };
      }
    }
    module2.exports = compressDimension;
  }
});

// node_modules/csso/cjs/replace/Percentage.cjs
var require_Percentage3 = __commonJS({
  "node_modules/csso/cjs/replace/Percentage.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var _Number = require_Number3();
    var blacklist = /* @__PURE__ */ new Set([
      // see https://github.com/jakubpawlowicz/clean-css/issues/957
      "width",
      "min-width",
      "max-width",
      "height",
      "min-height",
      "max-height",
      // issue #410: Dont remove units in flex-basis value for (-ms-)flex shorthand
      // issue #362: shouldn't remove unit in -ms-flex since it breaks flex in IE10/11
      // issue #200: shouldn't remove unit in flex since it breaks flex in IE10/11
      "flex",
      "-ms-flex"
    ]);
    function compressPercentage(node, item) {
      node.value = _Number.packNumber(node.value);
      if (node.value === "0" && this.declaration && !blacklist.has(this.declaration.property)) {
        item.data = {
          type: "Number",
          loc: node.loc,
          value: node.value
        };
        if (!cssTree.lexer.matchDeclaration(this.declaration).isType(item.data, "length")) {
          item.data = node;
        }
      }
    }
    module2.exports = compressPercentage;
  }
});

// node_modules/csso/cjs/replace/Url.cjs
var require_Url3 = __commonJS({
  "node_modules/csso/cjs/replace/Url.cjs"(exports2, module2) {
    "use strict";
    function Url(node) {
      node.value = node.value.replace(/\\/g, "/");
    }
    module2.exports = Url;
  }
});

// node_modules/csso/cjs/replace/color.cjs
var require_color = __commonJS({
  "node_modules/csso/cjs/replace/color.cjs"(exports2) {
    "use strict";
    var cssTree = require_cjs2();
    var _Number = require_Number3();
    var NAME_TO_HEX = {
      "aliceblue": "f0f8ff",
      "antiquewhite": "faebd7",
      "aqua": "0ff",
      "aquamarine": "7fffd4",
      "azure": "f0ffff",
      "beige": "f5f5dc",
      "bisque": "ffe4c4",
      "black": "000",
      "blanchedalmond": "ffebcd",
      "blue": "00f",
      "blueviolet": "8a2be2",
      "brown": "a52a2a",
      "burlywood": "deb887",
      "cadetblue": "5f9ea0",
      "chartreuse": "7fff00",
      "chocolate": "d2691e",
      "coral": "ff7f50",
      "cornflowerblue": "6495ed",
      "cornsilk": "fff8dc",
      "crimson": "dc143c",
      "cyan": "0ff",
      "darkblue": "00008b",
      "darkcyan": "008b8b",
      "darkgoldenrod": "b8860b",
      "darkgray": "a9a9a9",
      "darkgrey": "a9a9a9",
      "darkgreen": "006400",
      "darkkhaki": "bdb76b",
      "darkmagenta": "8b008b",
      "darkolivegreen": "556b2f",
      "darkorange": "ff8c00",
      "darkorchid": "9932cc",
      "darkred": "8b0000",
      "darksalmon": "e9967a",
      "darkseagreen": "8fbc8f",
      "darkslateblue": "483d8b",
      "darkslategray": "2f4f4f",
      "darkslategrey": "2f4f4f",
      "darkturquoise": "00ced1",
      "darkviolet": "9400d3",
      "deeppink": "ff1493",
      "deepskyblue": "00bfff",
      "dimgray": "696969",
      "dimgrey": "696969",
      "dodgerblue": "1e90ff",
      "firebrick": "b22222",
      "floralwhite": "fffaf0",
      "forestgreen": "228b22",
      "fuchsia": "f0f",
      "gainsboro": "dcdcdc",
      "ghostwhite": "f8f8ff",
      "gold": "ffd700",
      "goldenrod": "daa520",
      "gray": "808080",
      "grey": "808080",
      "green": "008000",
      "greenyellow": "adff2f",
      "honeydew": "f0fff0",
      "hotpink": "ff69b4",
      "indianred": "cd5c5c",
      "indigo": "4b0082",
      "ivory": "fffff0",
      "khaki": "f0e68c",
      "lavender": "e6e6fa",
      "lavenderblush": "fff0f5",
      "lawngreen": "7cfc00",
      "lemonchiffon": "fffacd",
      "lightblue": "add8e6",
      "lightcoral": "f08080",
      "lightcyan": "e0ffff",
      "lightgoldenrodyellow": "fafad2",
      "lightgray": "d3d3d3",
      "lightgrey": "d3d3d3",
      "lightgreen": "90ee90",
      "lightpink": "ffb6c1",
      "lightsalmon": "ffa07a",
      "lightseagreen": "20b2aa",
      "lightskyblue": "87cefa",
      "lightslategray": "789",
      "lightslategrey": "789",
      "lightsteelblue": "b0c4de",
      "lightyellow": "ffffe0",
      "lime": "0f0",
      "limegreen": "32cd32",
      "linen": "faf0e6",
      "magenta": "f0f",
      "maroon": "800000",
      "mediumaquamarine": "66cdaa",
      "mediumblue": "0000cd",
      "mediumorchid": "ba55d3",
      "mediumpurple": "9370db",
      "mediumseagreen": "3cb371",
      "mediumslateblue": "7b68ee",
      "mediumspringgreen": "00fa9a",
      "mediumturquoise": "48d1cc",
      "mediumvioletred": "c71585",
      "midnightblue": "191970",
      "mintcream": "f5fffa",
      "mistyrose": "ffe4e1",
      "moccasin": "ffe4b5",
      "navajowhite": "ffdead",
      "navy": "000080",
      "oldlace": "fdf5e6",
      "olive": "808000",
      "olivedrab": "6b8e23",
      "orange": "ffa500",
      "orangered": "ff4500",
      "orchid": "da70d6",
      "palegoldenrod": "eee8aa",
      "palegreen": "98fb98",
      "paleturquoise": "afeeee",
      "palevioletred": "db7093",
      "papayawhip": "ffefd5",
      "peachpuff": "ffdab9",
      "peru": "cd853f",
      "pink": "ffc0cb",
      "plum": "dda0dd",
      "powderblue": "b0e0e6",
      "purple": "800080",
      "rebeccapurple": "639",
      "red": "f00",
      "rosybrown": "bc8f8f",
      "royalblue": "4169e1",
      "saddlebrown": "8b4513",
      "salmon": "fa8072",
      "sandybrown": "f4a460",
      "seagreen": "2e8b57",
      "seashell": "fff5ee",
      "sienna": "a0522d",
      "silver": "c0c0c0",
      "skyblue": "87ceeb",
      "slateblue": "6a5acd",
      "slategray": "708090",
      "slategrey": "708090",
      "snow": "fffafa",
      "springgreen": "00ff7f",
      "steelblue": "4682b4",
      "tan": "d2b48c",
      "teal": "008080",
      "thistle": "d8bfd8",
      "tomato": "ff6347",
      "turquoise": "40e0d0",
      "violet": "ee82ee",
      "wheat": "f5deb3",
      "white": "fff",
      "whitesmoke": "f5f5f5",
      "yellow": "ff0",
      "yellowgreen": "9acd32"
    };
    var HEX_TO_NAME = {
      "800000": "maroon",
      "800080": "purple",
      "808000": "olive",
      "808080": "gray",
      "00ffff": "cyan",
      "f0ffff": "azure",
      "f5f5dc": "beige",
      "ffe4c4": "bisque",
      "000000": "black",
      "0000ff": "blue",
      "a52a2a": "brown",
      "ff7f50": "coral",
      "ffd700": "gold",
      "008000": "green",
      "4b0082": "indigo",
      "fffff0": "ivory",
      "f0e68c": "khaki",
      "00ff00": "lime",
      "faf0e6": "linen",
      "000080": "navy",
      "ffa500": "orange",
      "da70d6": "orchid",
      "cd853f": "peru",
      "ffc0cb": "pink",
      "dda0dd": "plum",
      "f00": "red",
      "ff0000": "red",
      "fa8072": "salmon",
      "a0522d": "sienna",
      "c0c0c0": "silver",
      "fffafa": "snow",
      "d2b48c": "tan",
      "008080": "teal",
      "ff6347": "tomato",
      "ee82ee": "violet",
      "f5deb3": "wheat",
      "ffffff": "white",
      "ffff00": "yellow"
    };
    function hueToRgb(p, q, t2) {
      if (t2 < 0) {
        t2 += 1;
      }
      if (t2 > 1) {
        t2 -= 1;
      }
      if (t2 < 1 / 6) {
        return p + (q - p) * 6 * t2;
      }
      if (t2 < 1 / 2) {
        return q;
      }
      if (t2 < 2 / 3) {
        return p + (q - p) * (2 / 3 - t2) * 6;
      }
      return p;
    }
    function hslToRgb(h, s, l, a) {
      let r;
      let g;
      let b;
      if (s === 0) {
        r = g = b = l;
      } else {
        const q = l < 0.5 ? l * (1 + s) : l + s - l * s;
        const p = 2 * l - q;
        r = hueToRgb(p, q, h + 1 / 3);
        g = hueToRgb(p, q, h);
        b = hueToRgb(p, q, h - 1 / 3);
      }
      return [
        Math.round(r * 255),
        Math.round(g * 255),
        Math.round(b * 255),
        a
      ];
    }
    function toHex(value) {
      value = value.toString(16);
      return value.length === 1 ? "0" + value : value;
    }
    function parseFunctionArgs(functionArgs, count, rgb) {
      let cursor = functionArgs.head;
      let args = [];
      let wasValue = false;
      while (cursor !== null) {
        const { type, value } = cursor.data;
        switch (type) {
          case "Number":
          case "Percentage":
            if (wasValue) {
              return;
            }
            wasValue = true;
            args.push({
              type,
              value: Number(value)
            });
            break;
          case "Operator":
            if (value === ",") {
              if (!wasValue) {
                return;
              }
              wasValue = false;
            } else if (wasValue || value !== "+") {
              return;
            }
            break;
          default:
            return;
        }
        cursor = cursor.next;
      }
      if (args.length !== count) {
        return;
      }
      if (args.length === 4) {
        if (args[3].type !== "Number") {
          return;
        }
        args[3].type = "Alpha";
      }
      if (rgb) {
        if (args[0].type !== args[1].type || args[0].type !== args[2].type) {
          return;
        }
      } else {
        if (args[0].type !== "Number" || args[1].type !== "Percentage" || args[2].type !== "Percentage") {
          return;
        }
        args[0].type = "Angle";
      }
      return args.map(function(arg) {
        let value = Math.max(0, arg.value);
        switch (arg.type) {
          case "Number":
            value = Math.min(value, 255);
            break;
          case "Percentage":
            value = Math.min(value, 100) / 100;
            if (!rgb) {
              return value;
            }
            value = 255 * value;
            break;
          case "Angle":
            return (value % 360 + 360) % 360 / 360;
          case "Alpha":
            return Math.min(value, 1);
        }
        return Math.round(value);
      });
    }
    function compressFunction(node, item) {
      let functionName = node.name;
      let args;
      if (functionName === "rgba" || functionName === "hsla") {
        args = parseFunctionArgs(node.children, 4, functionName === "rgba");
        if (!args) {
          return;
        }
        if (functionName === "hsla") {
          args = hslToRgb(...args);
          node.name = "rgba";
        }
        if (args[3] === 0) {
          const scopeFunctionName = this.function && this.function.name;
          if (args[0] === 0 && args[1] === 0 && args[2] === 0 || !/^(?:to|from|color-stop)$|gradient$/i.test(scopeFunctionName)) {
            item.data = {
              type: "Identifier",
              loc: node.loc,
              name: "transparent"
            };
            return;
          }
        }
        if (args[3] !== 1) {
          node.children.forEach((node2, item2, list) => {
            if (node2.type === "Operator") {
              if (node2.value !== ",") {
                list.remove(item2);
              }
              return;
            }
            item2.data = {
              type: "Number",
              loc: node2.loc,
              value: _Number.packNumber(args.shift())
            };
          });
          return;
        }
        functionName = "rgb";
      }
      if (functionName === "hsl") {
        args = args || parseFunctionArgs(node.children, 3, false);
        if (!args) {
          return;
        }
        args = hslToRgb(...args);
        functionName = "rgb";
      }
      if (functionName === "rgb") {
        args = args || parseFunctionArgs(node.children, 3, true);
        if (!args) {
          return;
        }
        item.data = {
          type: "Hash",
          loc: node.loc,
          value: toHex(args[0]) + toHex(args[1]) + toHex(args[2])
        };
        compressHex(item.data, item);
      }
    }
    function compressIdent(node, item) {
      if (this.declaration === null) {
        return;
      }
      let color = node.name.toLowerCase();
      if (NAME_TO_HEX.hasOwnProperty(color) && cssTree.lexer.matchDeclaration(this.declaration).isType(node, "color")) {
        const hex = NAME_TO_HEX[color];
        if (hex.length + 1 <= color.length) {
          item.data = {
            type: "Hash",
            loc: node.loc,
            value: hex
          };
        } else {
          if (color === "grey") {
            color = "gray";
          }
          node.name = color;
        }
      }
    }
    function compressHex(node, item) {
      let color = node.value.toLowerCase();
      if (color.length === 6 && color[0] === color[1] && color[2] === color[3] && color[4] === color[5]) {
        color = color[0] + color[2] + color[4];
      }
      if (HEX_TO_NAME[color]) {
        item.data = {
          type: "Identifier",
          loc: node.loc,
          name: HEX_TO_NAME[color]
        };
      } else {
        node.value = color;
      }
    }
    exports2.compressFunction = compressFunction;
    exports2.compressHex = compressHex;
    exports2.compressIdent = compressIdent;
  }
});

// node_modules/csso/cjs/replace/index.cjs
var require_replace = __commonJS({
  "node_modules/csso/cjs/replace/index.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var Atrule = require_Atrule4();
    var AttributeSelector = require_AttributeSelector3();
    var Value = require_Value3();
    var Dimension = require_Dimension3();
    var Percentage = require_Percentage3();
    var _Number = require_Number3();
    var Url = require_Url3();
    var color = require_color();
    var handlers = {
      Atrule,
      AttributeSelector,
      Value,
      Dimension,
      Percentage,
      Number: _Number.Number,
      Url,
      Hash: color.compressHex,
      Identifier: color.compressIdent,
      Function: color.compressFunction
    };
    function replace(ast) {
      cssTree.walk(ast, {
        leave(node, item, list) {
          if (handlers.hasOwnProperty(node.type)) {
            handlers[node.type].call(this, node, item, list);
          }
        }
      });
    }
    module2.exports = replace;
  }
});

// node_modules/csso/cjs/restructure/prepare/createDeclarationIndexer.cjs
var require_createDeclarationIndexer = __commonJS({
  "node_modules/csso/cjs/restructure/prepare/createDeclarationIndexer.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var Index = class {
      constructor() {
        this.map = /* @__PURE__ */ new Map();
      }
      resolve(str) {
        let index = this.map.get(str);
        if (index === void 0) {
          index = this.map.size + 1;
          this.map.set(str, index);
        }
        return index;
      }
    };
    function createDeclarationIndexer() {
      const ids = new Index();
      return function markDeclaration(node) {
        const id = cssTree.generate(node);
        node.id = ids.resolve(id);
        node.length = id.length;
        node.fingerprint = null;
        return node;
      };
    }
    module2.exports = createDeclarationIndexer;
  }
});

// node_modules/csso/cjs/restructure/prepare/specificity.cjs
var require_specificity = __commonJS({
  "node_modules/csso/cjs/restructure/prepare/specificity.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    function ensureSelectorList(node) {
      if (node.type === "Raw") {
        return cssTree.parse(node.value, { context: "selectorList" });
      }
      return node;
    }
    function maxSpecificity(a, b) {
      for (let i = 0; i < 3; i++) {
        if (a[i] !== b[i]) {
          return a[i] > b[i] ? a : b;
        }
      }
      return a;
    }
    function maxSelectorListSpecificity(selectorList) {
      return ensureSelectorList(selectorList).children.reduce(
        (result, node) => maxSpecificity(specificity(node), result),
        [0, 0, 0]
      );
    }
    function specificity(simpleSelector) {
      let A = 0;
      let B = 0;
      let C = 0;
      simpleSelector.children.forEach((node) => {
        switch (node.type) {
          // count the number of ID selectors in the selector (= A)
          case "IdSelector":
            A++;
            break;
          // count the number of class selectors, attributes selectors, ...
          case "ClassSelector":
          case "AttributeSelector":
            B++;
            break;
          // ... and pseudo-classes in the selector (= B)
          case "PseudoClassSelector":
            switch (node.name.toLowerCase()) {
              // The specificity of an :is(), :not(), or :has() pseudo-class is replaced
              // by the specificity of the most specific complex selector in its selector list argument.
              case "not":
              case "has":
              case "is":
              // :matches() is used before it was renamed to :is()
              // https://github.com/w3c/csswg-drafts/issues/3258
              case "matches":
              // Older browsers support :is() functionality as prefixed pseudo-class :any()
              // https://developer.mozilla.org/en-US/docs/Web/CSS/:is
              case "-webkit-any":
              case "-moz-any": {
                const [a, b, c] = maxSelectorListSpecificity(node.children.first);
                A += a;
                B += b;
                C += c;
                break;
              }
              // Analogously, the specificity of an :nth-child() or :nth-last-child() selector
              // is the specificity of the pseudo class itself (counting as one pseudo-class selector)
              // plus the specificity of the most specific complex selector in its selector list argument (if any).
              case "nth-child":
              case "nth-last-child": {
                const arg = node.children.first;
                if (arg.type === "Nth" && arg.selector) {
                  const [a, b, c] = maxSelectorListSpecificity(arg.selector);
                  A += a;
                  B += b + 1;
                  C += c;
                } else {
                  B++;
                }
                break;
              }
              // The specificity of a :where() pseudo-class is replaced by zero.
              case "where":
                break;
              // The four Level 2 pseudo-elements (::before, ::after, ::first-line, and ::first-letter) may,
              // for legacy reasons, be represented using the <pseudo-class-selector> grammar,
              // with only a single ":" character at their start.
              // https://www.w3.org/TR/selectors-4/#single-colon-pseudos
              case "before":
              case "after":
              case "first-line":
              case "first-letter":
                C++;
                break;
              default:
                B++;
            }
            break;
          // count the number of type selectors ...
          case "TypeSelector":
            if (!node.name.endsWith("*")) {
              C++;
            }
            break;
          // ... and pseudo-elements in the selector (= C)
          case "PseudoElementSelector":
            C++;
            break;
        }
      });
      return [A, B, C];
    }
    module2.exports = specificity;
  }
});

// node_modules/csso/cjs/restructure/prepare/processSelector.cjs
var require_processSelector = __commonJS({
  "node_modules/csso/cjs/restructure/prepare/processSelector.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var specificity = require_specificity();
    var nonFreezePseudoElements = /* @__PURE__ */ new Set([
      "first-letter",
      "first-line",
      "after",
      "before"
    ]);
    var nonFreezePseudoClasses = /* @__PURE__ */ new Set([
      "link",
      "visited",
      "hover",
      "active",
      "first-letter",
      "first-line",
      "after",
      "before"
    ]);
    function processSelector(node, usageData) {
      const pseudos = /* @__PURE__ */ new Set();
      node.prelude.children.forEach(function(simpleSelector) {
        let tagName = "*";
        let scope = 0;
        simpleSelector.children.forEach(function(node2) {
          switch (node2.type) {
            case "ClassSelector":
              if (usageData && usageData.scopes) {
                const classScope = usageData.scopes[node2.name] || 0;
                if (scope !== 0 && classScope !== scope) {
                  throw new Error("Selector can't has classes from different scopes: " + cssTree.generate(simpleSelector));
                }
                scope = classScope;
              }
              break;
            case "PseudoClassSelector": {
              const name = node2.name.toLowerCase();
              if (!nonFreezePseudoClasses.has(name)) {
                pseudos.add(`:${name}`);
              }
              break;
            }
            case "PseudoElementSelector": {
              const name = node2.name.toLowerCase();
              if (!nonFreezePseudoElements.has(name)) {
                pseudos.add(`::${name}`);
              }
              break;
            }
            case "TypeSelector":
              tagName = node2.name.toLowerCase();
              break;
            case "AttributeSelector":
              if (node2.flags) {
                pseudos.add(`[${node2.flags.toLowerCase()}]`);
              }
              break;
            case "Combinator":
              tagName = "*";
              break;
          }
        });
        simpleSelector.compareMarker = specificity(simpleSelector).toString();
        simpleSelector.id = null;
        simpleSelector.id = cssTree.generate(simpleSelector);
        if (scope) {
          simpleSelector.compareMarker += ":" + scope;
        }
        if (tagName !== "*") {
          simpleSelector.compareMarker += "," + tagName;
        }
      });
      node.pseudoSignature = pseudos.size > 0 ? [...pseudos].sort().join(",") : false;
    }
    module2.exports = processSelector;
  }
});

// node_modules/csso/cjs/restructure/prepare/index.cjs
var require_prepare = __commonJS({
  "node_modules/csso/cjs/restructure/prepare/index.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var createDeclarationIndexer = require_createDeclarationIndexer();
    var processSelector = require_processSelector();
    function prepare(ast, options) {
      const markDeclaration = createDeclarationIndexer();
      cssTree.walk(ast, {
        visit: "Rule",
        enter(node) {
          node.block.children.forEach(markDeclaration);
          processSelector(node, options.usage);
        }
      });
      cssTree.walk(ast, {
        visit: "Atrule",
        enter(node) {
          if (node.prelude) {
            node.prelude.id = null;
            node.prelude.id = cssTree.generate(node.prelude);
          }
          if (cssTree.keyword(node.name).basename === "keyframes") {
            node.block.avoidRulesMerge = true;
            node.block.children.forEach(function(rule) {
              rule.prelude.children.forEach(function(simpleselector) {
                simpleselector.compareMarker = simpleselector.id;
              });
            });
          }
        }
      });
      return {
        declaration: markDeclaration
      };
    }
    module2.exports = prepare;
  }
});

// node_modules/csso/cjs/restructure/1-mergeAtrule.cjs
var require_mergeAtrule = __commonJS({
  "node_modules/csso/cjs/restructure/1-mergeAtrule.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function addRuleToMap(map, item, list, single) {
      const node = item.data;
      const name = cssTree.keyword(node.name).basename;
      const id = node.name.toLowerCase() + "/" + (node.prelude ? node.prelude.id : null);
      if (!hasOwnProperty2.call(map, name)) {
        map[name] = /* @__PURE__ */ Object.create(null);
      }
      if (single) {
        delete map[name][id];
      }
      if (!hasOwnProperty2.call(map[name], id)) {
        map[name][id] = new cssTree.List();
      }
      map[name][id].append(list.remove(item));
    }
    function relocateAtrules(ast, options) {
      const collected = /* @__PURE__ */ Object.create(null);
      let topInjectPoint = null;
      ast.children.forEach(function(node, item, list) {
        if (node.type === "Atrule") {
          const name = cssTree.keyword(node.name).basename;
          switch (name) {
            case "keyframes":
              addRuleToMap(collected, item, list, true);
              return;
            case "media":
              if (options.forceMediaMerge) {
                addRuleToMap(collected, item, list, false);
                return;
              }
              break;
          }
          if (topInjectPoint === null && name !== "charset" && name !== "import") {
            topInjectPoint = item;
          }
        } else {
          if (topInjectPoint === null) {
            topInjectPoint = item;
          }
        }
      });
      for (const atrule in collected) {
        for (const id in collected[atrule]) {
          ast.children.insertList(
            collected[atrule][id],
            atrule === "media" ? null : topInjectPoint
          );
        }
      }
    }
    function isMediaRule(node) {
      return node.type === "Atrule" && node.name === "media";
    }
    function processAtrule(node, item, list) {
      if (!isMediaRule(node)) {
        return;
      }
      const prev = item.prev && item.prev.data;
      if (!prev || !isMediaRule(prev)) {
        return;
      }
      if (node.prelude && prev.prelude && node.prelude.id === prev.prelude.id) {
        prev.block.children.appendList(node.block.children);
        list.remove(item);
      }
    }
    function rejoinAtrule(ast, options) {
      relocateAtrules(ast, options);
      cssTree.walk(ast, {
        visit: "Atrule",
        reverse: true,
        enter: processAtrule
      });
    }
    module2.exports = rejoinAtrule;
  }
});

// node_modules/csso/cjs/restructure/utils.cjs
var require_utils4 = __commonJS({
  "node_modules/csso/cjs/restructure/utils.cjs"(exports2) {
    "use strict";
    var { hasOwnProperty: hasOwnProperty2 } = Object.prototype;
    function isEqualSelectors(a, b) {
      let cursor1 = a.head;
      let cursor2 = b.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function isEqualDeclarations(a, b) {
      let cursor1 = a.head;
      let cursor2 = b.head;
      while (cursor1 !== null && cursor2 !== null && cursor1.data.id === cursor2.data.id) {
        cursor1 = cursor1.next;
        cursor2 = cursor2.next;
      }
      return cursor1 === null && cursor2 === null;
    }
    function compareDeclarations(declarations1, declarations2) {
      const result = {
        eq: [],
        ne1: [],
        ne2: [],
        ne2overrided: []
      };
      const fingerprints = /* @__PURE__ */ Object.create(null);
      const declarations2hash = /* @__PURE__ */ Object.create(null);
      for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
        declarations2hash[cursor.data.id] = true;
      }
      for (let cursor = declarations1.head; cursor; cursor = cursor.next) {
        const data = cursor.data;
        if (data.fingerprint) {
          fingerprints[data.fingerprint] = data.important;
        }
        if (declarations2hash[data.id]) {
          declarations2hash[data.id] = false;
          result.eq.push(data);
        } else {
          result.ne1.push(data);
        }
      }
      for (let cursor = declarations2.head; cursor; cursor = cursor.next) {
        const data = cursor.data;
        if (declarations2hash[data.id]) {
          if (!hasOwnProperty2.call(fingerprints, data.fingerprint) || !fingerprints[data.fingerprint] && data.important) {
            result.ne2.push(data);
          }
          result.ne2overrided.push(data);
        }
      }
      return result;
    }
    function addSelectors(dest, source) {
      source.forEach((sourceData) => {
        const newStr = sourceData.id;
        let cursor = dest.head;
        while (cursor) {
          const nextStr = cursor.data.id;
          if (nextStr === newStr) {
            return;
          }
          if (nextStr > newStr) {
            break;
          }
          cursor = cursor.next;
        }
        dest.insert(dest.createItem(sourceData), cursor);
      });
      return dest;
    }
    function hasSimilarSelectors(selectors1, selectors2) {
      let cursor1 = selectors1.head;
      while (cursor1 !== null) {
        let cursor2 = selectors2.head;
        while (cursor2 !== null) {
          if (cursor1.data.compareMarker === cursor2.data.compareMarker) {
            return true;
          }
          cursor2 = cursor2.next;
        }
        cursor1 = cursor1.next;
      }
      return false;
    }
    function unsafeToSkipNode(node) {
      switch (node.type) {
        case "Rule":
          return hasSimilarSelectors(node.prelude.children, this);
        case "Atrule":
          if (node.block) {
            return node.block.children.some(unsafeToSkipNode, this);
          }
          break;
        case "Declaration":
          return false;
      }
      return true;
    }
    exports2.addSelectors = addSelectors;
    exports2.compareDeclarations = compareDeclarations;
    exports2.hasSimilarSelectors = hasSimilarSelectors;
    exports2.isEqualDeclarations = isEqualDeclarations;
    exports2.isEqualSelectors = isEqualSelectors;
    exports2.unsafeToSkipNode = unsafeToSkipNode;
  }
});

// node_modules/csso/cjs/restructure/2-initialMergeRuleset.cjs
var require_initialMergeRuleset = __commonJS({
  "node_modules/csso/cjs/restructure/2-initialMergeRuleset.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var utils = require_utils4();
    function processRule(node, item, list) {
      const selectors = node.prelude.children;
      const declarations = node.block.children;
      list.prevUntil(item.prev, function(prev) {
        if (prev.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, prev);
        }
        const prevSelectors = prev.prelude.children;
        const prevDeclarations = prev.block.children;
        if (node.pseudoSignature === prev.pseudoSignature) {
          if (utils.isEqualSelectors(prevSelectors, selectors)) {
            prevDeclarations.appendList(declarations);
            list.remove(item);
            return true;
          }
          if (utils.isEqualDeclarations(declarations, prevDeclarations)) {
            utils.addSelectors(prevSelectors, selectors);
            list.remove(item);
            return true;
          }
        }
        return utils.hasSimilarSelectors(selectors, prevSelectors);
      });
    }
    function initialMergeRule(ast) {
      cssTree.walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    }
    module2.exports = initialMergeRule;
  }
});

// node_modules/csso/cjs/restructure/3-disjoinRuleset.cjs
var require_disjoinRuleset = __commonJS({
  "node_modules/csso/cjs/restructure/3-disjoinRuleset.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    function processRule(node, item, list) {
      const selectors = node.prelude.children;
      while (selectors.head !== selectors.tail) {
        const newSelectors = new cssTree.List();
        newSelectors.insert(selectors.remove(selectors.head));
        list.insert(list.createItem({
          type: "Rule",
          loc: node.loc,
          prelude: {
            type: "SelectorList",
            loc: node.prelude.loc,
            children: newSelectors
          },
          block: {
            type: "Block",
            loc: node.block.loc,
            children: node.block.children.copy()
          },
          pseudoSignature: node.pseudoSignature
        }), item);
      }
    }
    function disjoinRule(ast) {
      cssTree.walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    }
    module2.exports = disjoinRule;
  }
});

// node_modules/csso/cjs/restructure/4-restructShorthand.cjs
var require_restructShorthand = __commonJS({
  "node_modules/csso/cjs/restructure/4-restructShorthand.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var REPLACE = 1;
    var REMOVE = 2;
    var TOP = 0;
    var RIGHT = 1;
    var BOTTOM = 2;
    var LEFT = 3;
    var SIDES = ["top", "right", "bottom", "left"];
    var SIDE = {
      "margin-top": "top",
      "margin-right": "right",
      "margin-bottom": "bottom",
      "margin-left": "left",
      "padding-top": "top",
      "padding-right": "right",
      "padding-bottom": "bottom",
      "padding-left": "left",
      "border-top-color": "top",
      "border-right-color": "right",
      "border-bottom-color": "bottom",
      "border-left-color": "left",
      "border-top-width": "top",
      "border-right-width": "right",
      "border-bottom-width": "bottom",
      "border-left-width": "left",
      "border-top-style": "top",
      "border-right-style": "right",
      "border-bottom-style": "bottom",
      "border-left-style": "left"
    };
    var MAIN_PROPERTY = {
      "margin": "margin",
      "margin-top": "margin",
      "margin-right": "margin",
      "margin-bottom": "margin",
      "margin-left": "margin",
      "padding": "padding",
      "padding-top": "padding",
      "padding-right": "padding",
      "padding-bottom": "padding",
      "padding-left": "padding",
      "border-color": "border-color",
      "border-top-color": "border-color",
      "border-right-color": "border-color",
      "border-bottom-color": "border-color",
      "border-left-color": "border-color",
      "border-width": "border-width",
      "border-top-width": "border-width",
      "border-right-width": "border-width",
      "border-bottom-width": "border-width",
      "border-left-width": "border-width",
      "border-style": "border-style",
      "border-top-style": "border-style",
      "border-right-style": "border-style",
      "border-bottom-style": "border-style",
      "border-left-style": "border-style"
    };
    var TRBL = class {
      constructor(name) {
        this.name = name;
        this.loc = null;
        this.iehack = void 0;
        this.sides = {
          "top": null,
          "right": null,
          "bottom": null,
          "left": null
        };
      }
      getValueSequence(declaration, count) {
        const values = [];
        let iehack = "";
        const hasBadValues = declaration.value.type !== "Value" || declaration.value.children.some(function(child) {
          let special = false;
          switch (child.type) {
            case "Identifier":
              switch (child.name) {
                case "\\0":
                case "\\9":
                  iehack = child.name;
                  return;
                case "inherit":
                case "initial":
                case "unset":
                case "revert":
                  special = child.name;
                  break;
              }
              break;
            case "Dimension":
              switch (child.unit) {
                // is not supported until IE11
                case "rem":
                // v* units is too buggy across browsers and better
                // don't merge values with those units
                case "vw":
                case "vh":
                case "vmin":
                case "vmax":
                case "vm":
                  special = child.unit;
                  break;
              }
              break;
            case "Hash":
            // color
            case "Number":
            case "Percentage":
              break;
            case "Function":
              if (child.name === "var") {
                return true;
              }
              special = child.name;
              break;
            default:
              return true;
          }
          values.push({
            node: child,
            special,
            important: declaration.important
          });
        });
        if (hasBadValues || values.length > count) {
          return false;
        }
        if (typeof this.iehack === "string" && this.iehack !== iehack) {
          return false;
        }
        this.iehack = iehack;
        return values;
      }
      canOverride(side, value) {
        const currentValue = this.sides[side];
        return !currentValue || value.important && !currentValue.important;
      }
      add(name, declaration) {
        function attemptToAdd() {
          const sides = this.sides;
          const side = SIDE[name];
          if (side) {
            if (side in sides === false) {
              return false;
            }
            const values = this.getValueSequence(declaration, 1);
            if (!values || !values.length) {
              return false;
            }
            for (const key in sides) {
              if (sides[key] !== null && sides[key].special !== values[0].special) {
                return false;
              }
            }
            if (!this.canOverride(side, values[0])) {
              return true;
            }
            sides[side] = values[0];
            return true;
          } else if (name === this.name) {
            const values = this.getValueSequence(declaration, 4);
            if (!values || !values.length) {
              return false;
            }
            switch (values.length) {
              case 1:
                values[RIGHT] = values[TOP];
                values[BOTTOM] = values[TOP];
                values[LEFT] = values[TOP];
                break;
              case 2:
                values[BOTTOM] = values[TOP];
                values[LEFT] = values[RIGHT];
                break;
              case 3:
                values[LEFT] = values[RIGHT];
                break;
            }
            for (let i = 0; i < 4; i++) {
              for (const key in sides) {
                if (sides[key] !== null && sides[key].special !== values[i].special) {
                  return false;
                }
              }
            }
            for (let i = 0; i < 4; i++) {
              if (this.canOverride(SIDES[i], values[i])) {
                sides[SIDES[i]] = values[i];
              }
            }
            return true;
          }
        }
        if (!attemptToAdd.call(this)) {
          return false;
        }
        if (!this.loc) {
          this.loc = declaration.loc;
        }
        return true;
      }
      isOkToMinimize() {
        const top = this.sides.top;
        const right = this.sides.right;
        const bottom = this.sides.bottom;
        const left = this.sides.left;
        if (top && right && bottom && left) {
          const important = top.important + right.important + bottom.important + left.important;
          return important === 0 || important === 4;
        }
        return false;
      }
      getValue() {
        const result = new cssTree.List();
        const sides = this.sides;
        const values = [
          sides.top,
          sides.right,
          sides.bottom,
          sides.left
        ];
        const stringValues = [
          cssTree.generate(sides.top.node),
          cssTree.generate(sides.right.node),
          cssTree.generate(sides.bottom.node),
          cssTree.generate(sides.left.node)
        ];
        if (stringValues[LEFT] === stringValues[RIGHT]) {
          values.pop();
          if (stringValues[BOTTOM] === stringValues[TOP]) {
            values.pop();
            if (stringValues[RIGHT] === stringValues[TOP]) {
              values.pop();
            }
          }
        }
        for (let i = 0; i < values.length; i++) {
          result.appendData(values[i].node);
        }
        if (this.iehack) {
          result.appendData({
            type: "Identifier",
            loc: null,
            name: this.iehack
          });
        }
        return {
          type: "Value",
          loc: null,
          children: result
        };
      }
      getDeclaration() {
        return {
          type: "Declaration",
          loc: this.loc,
          important: this.sides.top.important,
          property: this.name,
          value: this.getValue()
        };
      }
    };
    function processRule(rule, shorts, shortDeclarations, lastShortSelector) {
      const declarations = rule.block.children;
      const selector = rule.prelude.children.first.id;
      rule.block.children.forEachRight(function(declaration, item) {
        const property = declaration.property;
        if (!MAIN_PROPERTY.hasOwnProperty(property)) {
          return;
        }
        const key = MAIN_PROPERTY[property];
        let shorthand;
        let operation;
        if (!lastShortSelector || selector === lastShortSelector) {
          if (key in shorts) {
            operation = REMOVE;
            shorthand = shorts[key];
          }
        }
        if (!shorthand || !shorthand.add(property, declaration)) {
          operation = REPLACE;
          shorthand = new TRBL(key);
          if (!shorthand.add(property, declaration)) {
            lastShortSelector = null;
            return;
          }
        }
        shorts[key] = shorthand;
        shortDeclarations.push({
          operation,
          block: declarations,
          item,
          shorthand
        });
        lastShortSelector = selector;
      });
      return lastShortSelector;
    }
    function processShorthands(shortDeclarations, markDeclaration) {
      shortDeclarations.forEach(function(item) {
        const shorthand = item.shorthand;
        if (!shorthand.isOkToMinimize()) {
          return;
        }
        if (item.operation === REPLACE) {
          item.item.data = markDeclaration(shorthand.getDeclaration());
        } else {
          item.block.remove(item.item);
        }
      });
    }
    function restructBlock(ast, indexer) {
      const stylesheetMap = {};
      const shortDeclarations = [];
      cssTree.walk(ast, {
        visit: "Rule",
        reverse: true,
        enter(node) {
          const stylesheet = this.block || this.stylesheet;
          const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
          let ruleMap;
          let shorts;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {
              lastShortSelector: null
            };
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            shorts = ruleMap[ruleId];
          } else {
            shorts = {};
            ruleMap[ruleId] = shorts;
          }
          ruleMap.lastShortSelector = processRule.call(this, node, shorts, shortDeclarations, ruleMap.lastShortSelector);
        }
      });
      processShorthands(shortDeclarations, indexer.declaration);
    }
    module2.exports = restructBlock;
  }
});

// node_modules/csso/cjs/restructure/6-restructBlock.cjs
var require_restructBlock = __commonJS({
  "node_modules/csso/cjs/restructure/6-restructBlock.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var fingerprintId = 1;
    var dontRestructure = /* @__PURE__ */ new Set([
      "src"
      // https://github.com/afelix/csso/issues/50
    ]);
    var DONT_MIX_VALUE = {
      // https://developer.mozilla.org/en-US/docs/Web/CSS/display#Browser_compatibility
      "display": /table|ruby|flex|-(flex)?box$|grid|contents|run-in/i,
      // https://developer.mozilla.org/en/docs/Web/CSS/text-align
      "text-align": /^(start|end|match-parent|justify-all)$/i
    };
    var SAFE_VALUES = {
      cursor: [
        "auto",
        "crosshair",
        "default",
        "move",
        "text",
        "wait",
        "help",
        "n-resize",
        "e-resize",
        "s-resize",
        "w-resize",
        "ne-resize",
        "nw-resize",
        "se-resize",
        "sw-resize",
        "pointer",
        "progress",
        "not-allowed",
        "no-drop",
        "vertical-text",
        "all-scroll",
        "col-resize",
        "row-resize"
      ],
      overflow: [
        "hidden",
        "visible",
        "scroll",
        "auto"
      ],
      position: [
        "static",
        "relative",
        "absolute",
        "fixed"
      ]
    };
    var NEEDLESS_TABLE = {
      "border-width": ["border"],
      "border-style": ["border"],
      "border-color": ["border"],
      "border-top": ["border"],
      "border-right": ["border"],
      "border-bottom": ["border"],
      "border-left": ["border"],
      "border-top-width": ["border-top", "border-width", "border"],
      "border-right-width": ["border-right", "border-width", "border"],
      "border-bottom-width": ["border-bottom", "border-width", "border"],
      "border-left-width": ["border-left", "border-width", "border"],
      "border-top-style": ["border-top", "border-style", "border"],
      "border-right-style": ["border-right", "border-style", "border"],
      "border-bottom-style": ["border-bottom", "border-style", "border"],
      "border-left-style": ["border-left", "border-style", "border"],
      "border-top-color": ["border-top", "border-color", "border"],
      "border-right-color": ["border-right", "border-color", "border"],
      "border-bottom-color": ["border-bottom", "border-color", "border"],
      "border-left-color": ["border-left", "border-color", "border"],
      "margin-top": ["margin"],
      "margin-right": ["margin"],
      "margin-bottom": ["margin"],
      "margin-left": ["margin"],
      "padding-top": ["padding"],
      "padding-right": ["padding"],
      "padding-bottom": ["padding"],
      "padding-left": ["padding"],
      "font-style": ["font"],
      "font-variant": ["font"],
      "font-weight": ["font"],
      "font-size": ["font"],
      "font-family": ["font"],
      "list-style-type": ["list-style"],
      "list-style-position": ["list-style"],
      "list-style-image": ["list-style"]
    };
    function getPropertyFingerprint(propertyName, declaration, fingerprints) {
      const realName = cssTree.property(propertyName).basename;
      if (realName === "background") {
        return propertyName + ":" + cssTree.generate(declaration.value);
      }
      const declarationId = declaration.id;
      let fingerprint = fingerprints[declarationId];
      if (!fingerprint) {
        switch (declaration.value.type) {
          case "Value":
            const special = {};
            let vendorId = "";
            let iehack = "";
            let raw = false;
            declaration.value.children.forEach(function walk(node) {
              switch (node.type) {
                case "Value":
                case "Brackets":
                case "Parentheses":
                  node.children.forEach(walk);
                  break;
                case "Raw":
                  raw = true;
                  break;
                case "Identifier": {
                  const { name } = node;
                  if (!vendorId) {
                    vendorId = cssTree.keyword(name).vendor;
                  }
                  if (/\\[09]/.test(name)) {
                    iehack = RegExp.lastMatch;
                  }
                  if (SAFE_VALUES.hasOwnProperty(realName)) {
                    if (SAFE_VALUES[realName].indexOf(name) === -1) {
                      special[name] = true;
                    }
                  } else if (DONT_MIX_VALUE.hasOwnProperty(realName)) {
                    if (DONT_MIX_VALUE[realName].test(name)) {
                      special[name] = true;
                    }
                  }
                  break;
                }
                case "Function": {
                  let { name } = node;
                  if (!vendorId) {
                    vendorId = cssTree.keyword(name).vendor;
                  }
                  if (name === "rect") {
                    const hasComma = node.children.some(
                      (node2) => node2.type === "Operator" && node2.value === ","
                    );
                    if (!hasComma) {
                      name = "rect-backward";
                    }
                  }
                  special[name + "()"] = true;
                  node.children.forEach(walk);
                  break;
                }
                case "Dimension": {
                  const { unit } = node;
                  if (/\\[09]/.test(unit)) {
                    iehack = RegExp.lastMatch;
                  }
                  switch (unit) {
                    // is not supported until IE11
                    case "rem":
                    // v* units is too buggy across browsers and better
                    // don't merge values with those units
                    case "vw":
                    case "vh":
                    case "vmin":
                    case "vmax":
                    case "vm":
                      special[unit] = true;
                      break;
                  }
                  break;
                }
              }
            });
            fingerprint = raw ? "!" + fingerprintId++ : "!" + Object.keys(special).sort() + "|" + iehack + vendorId;
            break;
          case "Raw":
            fingerprint = "!" + declaration.value.value;
            break;
          default:
            fingerprint = cssTree.generate(declaration.value);
        }
        fingerprints[declarationId] = fingerprint;
      }
      return propertyName + fingerprint;
    }
    function needless(props, declaration, fingerprints) {
      const property = cssTree.property(declaration.property);
      if (NEEDLESS_TABLE.hasOwnProperty(property.basename)) {
        const table = NEEDLESS_TABLE[property.basename];
        for (const entry of table) {
          const ppre = getPropertyFingerprint(property.prefix + entry, declaration, fingerprints);
          const prev = props.hasOwnProperty(ppre) ? props[ppre] : null;
          if (prev && (!declaration.important || prev.item.data.important)) {
            return prev;
          }
        }
      }
    }
    function processRule(rule, item, list, props, fingerprints) {
      const declarations = rule.block.children;
      declarations.forEachRight(function(declaration, declarationItem) {
        const { property } = declaration;
        const fingerprint = getPropertyFingerprint(property, declaration, fingerprints);
        const prev = props[fingerprint];
        if (prev && !dontRestructure.has(property)) {
          if (declaration.important && !prev.item.data.important) {
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
            prev.block.remove(prev.item);
          } else {
            declarations.remove(declarationItem);
          }
        } else {
          const prev2 = needless(props, declaration, fingerprints);
          if (prev2) {
            declarations.remove(declarationItem);
          } else {
            declaration.fingerprint = fingerprint;
            props[fingerprint] = {
              block: declarations,
              item: declarationItem
            };
          }
        }
      });
      if (declarations.isEmpty) {
        list.remove(item);
      }
    }
    function restructBlock(ast) {
      const stylesheetMap = {};
      const fingerprints = /* @__PURE__ */ Object.create(null);
      cssTree.walk(ast, {
        visit: "Rule",
        reverse: true,
        enter(node, item, list) {
          const stylesheet = this.block || this.stylesheet;
          const ruleId = (node.pseudoSignature || "") + "|" + node.prelude.children.first.id;
          let ruleMap;
          let props;
          if (!stylesheetMap.hasOwnProperty(stylesheet.id)) {
            ruleMap = {};
            stylesheetMap[stylesheet.id] = ruleMap;
          } else {
            ruleMap = stylesheetMap[stylesheet.id];
          }
          if (ruleMap.hasOwnProperty(ruleId)) {
            props = ruleMap[ruleId];
          } else {
            props = {};
            ruleMap[ruleId] = props;
          }
          processRule.call(this, node, item, list, props, fingerprints);
        }
      });
    }
    module2.exports = restructBlock;
  }
});

// node_modules/csso/cjs/restructure/7-mergeRuleset.cjs
var require_mergeRuleset = __commonJS({
  "node_modules/csso/cjs/restructure/7-mergeRuleset.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var utils = require_utils4();
    function processRule(node, item, list) {
      const selectors = node.prelude.children;
      const declarations = node.block.children;
      const nodeCompareMarker = selectors.first.compareMarker;
      const skippedCompareMarkers = {};
      list.nextUntil(item.next, function(next, nextItem) {
        if (next.type !== "Rule") {
          return utils.unsafeToSkipNode.call(selectors, next);
        }
        if (node.pseudoSignature !== next.pseudoSignature) {
          return true;
        }
        const nextFirstSelector = next.prelude.children.head;
        const nextDeclarations = next.block.children;
        const nextCompareMarker = nextFirstSelector.data.compareMarker;
        if (nextCompareMarker in skippedCompareMarkers) {
          return true;
        }
        if (selectors.head === selectors.tail) {
          if (selectors.first.id === nextFirstSelector.data.id) {
            declarations.appendList(nextDeclarations);
            list.remove(nextItem);
            return;
          }
        }
        if (utils.isEqualDeclarations(declarations, nextDeclarations)) {
          const nextStr = nextFirstSelector.data.id;
          selectors.some((data, item2) => {
            const curStr = data.id;
            if (nextStr < curStr) {
              selectors.insert(nextFirstSelector, item2);
              return true;
            }
            if (!item2.next) {
              selectors.insert(nextFirstSelector);
              return true;
            }
          });
          list.remove(nextItem);
          return;
        }
        if (nextCompareMarker === nodeCompareMarker) {
          return true;
        }
        skippedCompareMarkers[nextCompareMarker] = true;
      });
    }
    function mergeRule(ast) {
      cssTree.walk(ast, {
        visit: "Rule",
        enter: processRule
      });
    }
    module2.exports = mergeRule;
  }
});

// node_modules/csso/cjs/restructure/8-restructRuleset.cjs
var require_restructRuleset = __commonJS({
  "node_modules/csso/cjs/restructure/8-restructRuleset.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var utils = require_utils4();
    function calcSelectorLength(list) {
      return list.reduce((res, data) => res + data.id.length + 1, 0) - 1;
    }
    function calcDeclarationsLength(tokens) {
      let length = 0;
      for (const token of tokens) {
        length += token.length;
      }
      return length + // declarations
      tokens.length - 1;
    }
    function processRule(node, item, list) {
      const avoidRulesMerge = this.block !== null ? this.block.avoidRulesMerge : false;
      const selectors = node.prelude.children;
      const block = node.block;
      const disallowDownMarkers = /* @__PURE__ */ Object.create(null);
      let allowMergeUp = true;
      let allowMergeDown = true;
      list.prevUntil(item.prev, function(prev, prevItem) {
        const prevBlock = prev.block;
        const prevType = prev.type;
        if (prevType !== "Rule") {
          const unsafe = utils.unsafeToSkipNode.call(selectors, prev);
          if (!unsafe && prevType === "Atrule" && prevBlock) {
            cssTree.walk(prevBlock, {
              visit: "Rule",
              enter(node2) {
                node2.prelude.children.forEach((data) => {
                  disallowDownMarkers[data.compareMarker] = true;
                });
              }
            });
          }
          return unsafe;
        }
        if (node.pseudoSignature !== prev.pseudoSignature) {
          return true;
        }
        const prevSelectors = prev.prelude.children;
        allowMergeDown = !prevSelectors.some(
          (selector) => selector.compareMarker in disallowDownMarkers
        );
        if (!allowMergeDown && !allowMergeUp) {
          return true;
        }
        if (allowMergeUp && utils.isEqualSelectors(prevSelectors, selectors)) {
          prevBlock.children.appendList(block.children);
          list.remove(item);
          return true;
        }
        const diff = utils.compareDeclarations(block.children, prevBlock.children);
        if (diff.eq.length) {
          if (!diff.ne1.length && !diff.ne2.length) {
            if (allowMergeDown) {
              utils.addSelectors(selectors, prevSelectors);
              list.remove(prevItem);
            }
            return true;
          } else if (!avoidRulesMerge) {
            if (diff.ne1.length && !diff.ne2.length) {
              const selectorLength = calcSelectorLength(selectors);
              const blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeUp && selectorLength < blockLength) {
                utils.addSelectors(prevSelectors, selectors);
                block.children.fromArray(diff.ne1);
              }
            } else if (!diff.ne1.length && diff.ne2.length) {
              const selectorLength = calcSelectorLength(prevSelectors);
              const blockLength = calcDeclarationsLength(diff.eq);
              if (allowMergeDown && selectorLength < blockLength) {
                utils.addSelectors(selectors, prevSelectors);
                prevBlock.children.fromArray(diff.ne2);
              }
            } else {
              const newSelector = {
                type: "SelectorList",
                loc: null,
                children: utils.addSelectors(prevSelectors.copy(), selectors)
              };
              const newBlockLength = calcSelectorLength(newSelector.children) + 2;
              const blockLength = calcDeclarationsLength(diff.eq);
              if (blockLength >= newBlockLength) {
                const newItem = list.createItem({
                  type: "Rule",
                  loc: null,
                  prelude: newSelector,
                  block: {
                    type: "Block",
                    loc: null,
                    children: new cssTree.List().fromArray(diff.eq)
                  },
                  pseudoSignature: node.pseudoSignature
                });
                block.children.fromArray(diff.ne1);
                prevBlock.children.fromArray(diff.ne2overrided);
                if (allowMergeUp) {
                  list.insert(newItem, prevItem);
                } else {
                  list.insert(newItem, item);
                }
                return true;
              }
            }
          }
        }
        if (allowMergeUp) {
          allowMergeUp = !prevSelectors.some(
            (prevSelector) => selectors.some(
              (selector) => selector.compareMarker === prevSelector.compareMarker
            )
          );
        }
        prevSelectors.forEach((data) => {
          disallowDownMarkers[data.compareMarker] = true;
        });
      });
    }
    function restructRule(ast) {
      cssTree.walk(ast, {
        visit: "Rule",
        reverse: true,
        enter: processRule
      });
    }
    module2.exports = restructRule;
  }
});

// node_modules/csso/cjs/restructure/index.cjs
var require_restructure = __commonJS({
  "node_modules/csso/cjs/restructure/index.cjs"(exports2, module2) {
    "use strict";
    var index = require_prepare();
    var _1MergeAtrule = require_mergeAtrule();
    var _2InitialMergeRuleset = require_initialMergeRuleset();
    var _3DisjoinRuleset = require_disjoinRuleset();
    var _4RestructShorthand = require_restructShorthand();
    var _6RestructBlock = require_restructBlock();
    var _7MergeRuleset = require_mergeRuleset();
    var _8RestructRuleset = require_restructRuleset();
    function restructure(ast, options) {
      const indexer = index(ast, options);
      options.logger("prepare", ast);
      _1MergeAtrule(ast, options);
      options.logger("mergeAtrule", ast);
      _2InitialMergeRuleset(ast);
      options.logger("initialMergeRuleset", ast);
      _3DisjoinRuleset(ast);
      options.logger("disjoinRuleset", ast);
      _4RestructShorthand(ast, indexer);
      options.logger("restructShorthand", ast);
      _6RestructBlock(ast);
      options.logger("restructBlock", ast);
      _7MergeRuleset(ast);
      options.logger("mergeRuleset", ast);
      _8RestructRuleset(ast);
      options.logger("restructRuleset", ast);
    }
    module2.exports = restructure;
  }
});

// node_modules/csso/cjs/compress.cjs
var require_compress = __commonJS({
  "node_modules/csso/cjs/compress.cjs"(exports2, module2) {
    "use strict";
    var cssTree = require_cjs2();
    var usage = require_usage();
    var index = require_clean();
    var index$1 = require_replace();
    var index$2 = require_restructure();
    function readChunk(input, specialComments) {
      const children = new cssTree.List();
      let nonSpaceTokenInBuffer = false;
      let protectedComment;
      input.nextUntil(input.head, (node, item, list) => {
        if (node.type === "Comment") {
          if (!specialComments || node.value.charAt(0) !== "!") {
            list.remove(item);
            return;
          }
          if (nonSpaceTokenInBuffer || protectedComment) {
            return true;
          }
          list.remove(item);
          protectedComment = node;
          return;
        }
        if (node.type !== "WhiteSpace") {
          nonSpaceTokenInBuffer = true;
        }
        children.insert(list.remove(item));
      });
      return {
        comment: protectedComment,
        stylesheet: {
          type: "StyleSheet",
          loc: null,
          children
        }
      };
    }
    function compressChunk(ast, firstAtrulesAllowed, num, options) {
      options.logger(`Compress block #${num}`, null, true);
      let seed = 1;
      if (ast.type === "StyleSheet") {
        ast.firstAtrulesAllowed = firstAtrulesAllowed;
        ast.id = seed++;
      }
      cssTree.walk(ast, {
        visit: "Atrule",
        enter(node) {
          if (node.block !== null) {
            node.block.id = seed++;
          }
        }
      });
      options.logger("init", ast);
      index(ast, options);
      options.logger("clean", ast);
      index$1(ast);
      options.logger("replace", ast);
      if (options.restructuring) {
        index$2(ast, options);
      }
      return ast;
    }
    function getCommentsOption(options) {
      let comments = "comments" in options ? options.comments : "exclamation";
      if (typeof comments === "boolean") {
        comments = comments ? "exclamation" : false;
      } else if (comments !== "exclamation" && comments !== "first-exclamation") {
        comments = false;
      }
      return comments;
    }
    function getRestructureOption(options) {
      if ("restructure" in options) {
        return options.restructure;
      }
      return "restructuring" in options ? options.restructuring : true;
    }
    function wrapBlock(block) {
      return new cssTree.List().appendData({
        type: "Rule",
        loc: null,
        prelude: {
          type: "SelectorList",
          loc: null,
          children: new cssTree.List().appendData({
            type: "Selector",
            loc: null,
            children: new cssTree.List().appendData({
              type: "TypeSelector",
              loc: null,
              name: "x"
            })
          })
        },
        block
      });
    }
    function compress(ast, options) {
      ast = ast || { type: "StyleSheet", loc: null, children: new cssTree.List() };
      options = options || {};
      const compressOptions = {
        logger: typeof options.logger === "function" ? options.logger : function() {
        },
        restructuring: getRestructureOption(options),
        forceMediaMerge: Boolean(options.forceMediaMerge),
        usage: options.usage ? usage.buildIndex(options.usage) : false
      };
      const output = new cssTree.List();
      let specialComments = getCommentsOption(options);
      let firstAtrulesAllowed = true;
      let input;
      let chunk;
      let chunkNum = 1;
      let chunkChildren;
      if (options.clone) {
        ast = cssTree.clone(ast);
      }
      if (ast.type === "StyleSheet") {
        input = ast.children;
        ast.children = output;
      } else {
        input = wrapBlock(ast);
      }
      do {
        chunk = readChunk(input, Boolean(specialComments));
        compressChunk(chunk.stylesheet, firstAtrulesAllowed, chunkNum++, compressOptions);
        chunkChildren = chunk.stylesheet.children;
        if (chunk.comment) {
          if (!output.isEmpty) {
            output.insert(cssTree.List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
          output.insert(cssTree.List.createItem(chunk.comment));
          if (!chunkChildren.isEmpty) {
            output.insert(cssTree.List.createItem({
              type: "Raw",
              value: "\n"
            }));
          }
        }
        if (firstAtrulesAllowed && !chunkChildren.isEmpty) {
          const lastRule = chunkChildren.last;
          if (lastRule.type !== "Atrule" || lastRule.name !== "import" && lastRule.name !== "charset") {
            firstAtrulesAllowed = false;
          }
        }
        if (specialComments !== "exclamation") {
          specialComments = false;
        }
        output.appendList(chunkChildren);
      } while (!input.isEmpty);
      return {
        ast
      };
    }
    module2.exports = compress;
  }
});

// node_modules/csso/cjs/syntax.cjs
var require_syntax3 = __commonJS({
  "node_modules/csso/cjs/syntax.cjs"(exports2) {
    "use strict";
    var cssTree = require_cjs2();
    var compress = require_compress();
    var specificity = require_specificity();
    function encodeString(value) {
      const stringApostrophe = cssTree.string.encode(value, true);
      const stringQuote = cssTree.string.encode(value);
      return stringApostrophe.length < stringQuote.length ? stringApostrophe : stringQuote;
    }
    var {
      lexer,
      tokenize,
      parse,
      generate,
      walk,
      find,
      findLast,
      findAll,
      fromPlainObject,
      toPlainObject
    } = cssTree.fork({
      node: {
        String: {
          generate(node) {
            this.token(cssTree.tokenTypes.String, encodeString(node.value));
          }
        },
        Url: {
          generate(node) {
            const encodedUrl = cssTree.url.encode(node.value);
            const string = encodeString(node.value);
            this.token(
              cssTree.tokenTypes.Url,
              encodedUrl.length <= string.length + 5 ? encodedUrl : "url(" + string + ")"
            );
          }
        }
      }
    });
    exports2.compress = compress;
    exports2.specificity = specificity;
    exports2.find = find;
    exports2.findAll = findAll;
    exports2.findLast = findLast;
    exports2.fromPlainObject = fromPlainObject;
    exports2.generate = generate;
    exports2.lexer = lexer;
    exports2.parse = parse;
    exports2.toPlainObject = toPlainObject;
    exports2.tokenize = tokenize;
    exports2.walk = walk;
  }
});

// node_modules/csso/cjs/utils.cjs
var require_utils5 = __commonJS({
  "node_modules/csso/cjs/utils.cjs"(exports2) {
    "use strict";
    var processSelector = require_processSelector();
    var utils$1 = require_utils4();
    exports2.processSelector = processSelector;
    exports2.addSelectors = utils$1.addSelectors;
    exports2.compareDeclarations = utils$1.compareDeclarations;
    exports2.hasSimilarSelectors = utils$1.hasSimilarSelectors;
    exports2.isEqualDeclarations = utils$1.isEqualDeclarations;
    exports2.isEqualSelectors = utils$1.isEqualSelectors;
    exports2.unsafeToSkipNode = utils$1.unsafeToSkipNode;
  }
});

// node_modules/csso/cjs/index.cjs
var require_cjs3 = __commonJS({
  "node_modules/csso/cjs/index.cjs"(exports2) {
    "use strict";
    var version = require_version2();
    var syntax = require_syntax3();
    var utils = require_utils5();
    var { parse, generate, compress } = syntax;
    function debugOutput(name, options, startTime, data) {
      if (options.debug) {
        console.error(`## ${name} done in %d ms
`, Date.now() - startTime);
      }
      return data;
    }
    function createDefaultLogger(level) {
      let lastDebug;
      return function logger(title, ast) {
        let line = title;
        if (ast) {
          line = `[${((Date.now() - lastDebug) / 1e3).toFixed(3)}s] ${line}`;
        }
        if (level > 1 && ast) {
          let css = generate(ast);
          if (level === 2 && css.length > 256) {
            css = css.substr(0, 256) + "...";
          }
          line += `
  ${css}
`;
        }
        console.error(line);
        lastDebug = Date.now();
      };
    }
    function buildCompressOptions(options) {
      options = { ...options };
      if (typeof options.logger !== "function" && options.debug) {
        options.logger = createDefaultLogger(options.debug);
      }
      return options;
    }
    function runHandler(ast, options, handlers) {
      if (!Array.isArray(handlers)) {
        handlers = [handlers];
      }
      handlers.forEach((fn) => fn(ast, options));
    }
    function minify(context, source, options) {
      options = options || {};
      const filename = options.filename || "<unknown>";
      let result;
      const ast = debugOutput(
        "parsing",
        options,
        Date.now(),
        parse(source, {
          context,
          filename,
          positions: Boolean(options.sourceMap)
        })
      );
      if (options.beforeCompress) {
        debugOutput(
          "beforeCompress",
          options,
          Date.now(),
          runHandler(ast, options, options.beforeCompress)
        );
      }
      const compressResult = debugOutput(
        "compress",
        options,
        Date.now(),
        compress(ast, buildCompressOptions(options))
      );
      if (options.afterCompress) {
        debugOutput(
          "afterCompress",
          options,
          Date.now(),
          runHandler(compressResult, options, options.afterCompress)
        );
      }
      if (options.sourceMap) {
        result = debugOutput("generate(sourceMap: true)", options, Date.now(), (() => {
          const tmp = generate(compressResult.ast, { sourceMap: true });
          tmp.map._file = filename;
          tmp.map.setSourceContent(filename, source);
          return tmp;
        })());
      } else {
        result = debugOutput("generate", options, Date.now(), {
          css: generate(compressResult.ast),
          map: null
        });
      }
      return result;
    }
    function minifyStylesheet(source, options) {
      return minify("stylesheet", source, options);
    }
    function minifyBlock(source, options) {
      return minify("declarationList", source, options);
    }
    exports2.version = version.version;
    exports2.syntax = syntax;
    exports2.utils = utils;
    exports2.minify = minifyStylesheet;
    exports2.minifyBlock = minifyBlock;
  }
});

// node_modules/svgo/lib/style.js
var require_style = __commonJS({
  "node_modules/svgo/lib/style.js"(exports2) {
    "use strict";
    var csstree = require_cjs();
    var csswhat = require_commonjs();
    var {
      syntax: { specificity }
    } = require_cjs3();
    var { visit, matches } = require_xast();
    var {
      attrsGroups,
      inheritableAttrs,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    var csstreeWalkSkip = csstree.walk.skip;
    var parseRule = (ruleNode, dynamic) => {
      const declarations = [];
      ruleNode.block.children.forEach((cssNode) => {
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
        }
      });
      const rules = [];
      csstree.walk(ruleNode.prelude, (node) => {
        if (node.type === "Selector") {
          const newNode = csstree.clone(node);
          let hasPseudoClasses = false;
          csstree.walk(newNode, (pseudoClassNode, item, list) => {
            if (pseudoClassNode.type === "PseudoClassSelector") {
              hasPseudoClasses = true;
              list.remove(item);
            }
          });
          rules.push({
            specificity: specificity(node),
            dynamic: hasPseudoClasses || dynamic,
            // compute specificity from original node to consider pseudo classes
            selector: csstree.generate(newNode),
            declarations
          });
        }
      });
      return rules;
    };
    var parseStylesheet = (css, dynamic) => {
      const rules = [];
      const ast = csstree.parse(css, {
        parseValue: false,
        parseAtrulePrelude: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Rule") {
          rules.push(...parseRule(cssNode, dynamic || false));
          return csstreeWalkSkip;
        }
        if (cssNode.type === "Atrule") {
          if (cssNode.name === "keyframes" || cssNode.name === "-webkit-keyframes") {
            return csstreeWalkSkip;
          }
          csstree.walk(cssNode, (ruleNode) => {
            if (ruleNode.type === "Rule") {
              rules.push(...parseRule(ruleNode, dynamic || true));
              return csstreeWalkSkip;
            }
          });
          return csstreeWalkSkip;
        }
      });
      return rules;
    };
    var parseStyleDeclarations = (css) => {
      const declarations = [];
      const ast = csstree.parse(css, {
        context: "declarationList",
        parseValue: false
      });
      csstree.walk(ast, (cssNode) => {
        if (cssNode.type === "Declaration") {
          declarations.push({
            name: cssNode.property,
            value: csstree.generate(cssNode.value),
            important: cssNode.important === true
          });
        }
      });
      return declarations;
    };
    var computeOwnStyle = (stylesheet, node) => {
      const computedStyle = {};
      const importantStyles = /* @__PURE__ */ new Map();
      for (const [name, value] of Object.entries(node.attributes)) {
        if (attrsGroups.presentation.has(name)) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, false);
        }
      }
      for (const { selector, declarations, dynamic } of stylesheet.rules) {
        if (matches(node, selector)) {
          for (const { name, value, important } of declarations) {
            const computed = computedStyle[name];
            if (computed && computed.type === "dynamic") {
              continue;
            }
            if (dynamic) {
              computedStyle[name] = { type: "dynamic", inherited: false };
              continue;
            }
            if (computed == null || important === true || importantStyles.get(name) === false) {
              computedStyle[name] = { type: "static", inherited: false, value };
              importantStyles.set(name, important);
            }
          }
        }
      }
      const styleDeclarations = node.attributes.style == null ? [] : parseStyleDeclarations(node.attributes.style);
      for (const { name, value, important } of styleDeclarations) {
        const computed = computedStyle[name];
        if (computed && computed.type === "dynamic") {
          continue;
        }
        if (computed == null || important === true || importantStyles.get(name) === false) {
          computedStyle[name] = { type: "static", inherited: false, value };
          importantStyles.set(name, important);
        }
      }
      return computedStyle;
    };
    var compareSpecificity = (a, b) => {
      for (let i = 0; i < 4; i += 1) {
        if (a[i] < b[i]) {
          return -1;
        } else if (a[i] > b[i]) {
          return 1;
        }
      }
      return 0;
    };
    exports2.compareSpecificity = compareSpecificity;
    var collectStylesheet = (root) => {
      const rules = [];
      const parents = /* @__PURE__ */ new Map();
      visit(root, {
        element: {
          enter: (node, parentNode) => {
            parents.set(node, parentNode);
            if (node.name !== "style") {
              return;
            }
            if (node.attributes.type == null || node.attributes.type === "" || node.attributes.type === "text/css") {
              const dynamic = node.attributes.media != null && node.attributes.media !== "all";
              for (const child of node.children) {
                if (child.type === "text" || child.type === "cdata") {
                  rules.push(...parseStylesheet(child.value, dynamic));
                }
              }
            }
          }
        }
      });
      rules.sort((a, b) => compareSpecificity(a.specificity, b.specificity));
      return { rules, parents };
    };
    exports2.collectStylesheet = collectStylesheet;
    var computeStyle = (stylesheet, node) => {
      const { parents } = stylesheet;
      const computedStyles = computeOwnStyle(stylesheet, node);
      let parent = parents.get(node);
      while (parent != null && parent.type !== "root") {
        const inheritedStyles = computeOwnStyle(stylesheet, parent);
        for (const [name, computed] of Object.entries(inheritedStyles)) {
          if (computedStyles[name] == null && inheritableAttrs.has(name) && !presentationNonInheritableGroupAttrs.has(name)) {
            computedStyles[name] = { ...computed, inherited: true };
          }
        }
        parent = parents.get(parent);
      }
      return computedStyles;
    };
    exports2.computeStyle = computeStyle;
    var includesAttrSelector = (selector, name, value = null, traversed = false) => {
      const selectors = typeof selector === "string" ? csswhat.parse(selector) : csswhat.parse(csstree.generate(selector.data));
      for (const subselector of selectors) {
        const hasAttrSelector = subselector.some((segment, index) => {
          if (traversed) {
            if (index === subselector.length - 1) {
              return false;
            }
            const isNextTraversal = csswhat.isTraversal(subselector[index + 1]);
            if (!isNextTraversal) {
              return false;
            }
          }
          if (segment.type !== "attribute" || segment.name !== name) {
            return false;
          }
          return value == null ? true : segment.value === value;
        });
        if (hasAttrSelector) {
          return true;
        }
      }
      return false;
    };
    exports2.includesAttrSelector = includesAttrSelector;
  }
});

// node_modules/svgo/plugins/inlineStyles.js
var require_inlineStyles = __commonJS({
  "node_modules/svgo/plugins/inlineStyles.js"(exports2) {
    "use strict";
    var csstree = require_cjs();
    var {
      syntax: { specificity }
    } = require_cjs3();
    var {
      visitSkip,
      querySelectorAll,
      detachNodeFromParent
    } = require_xast();
    var { compareSpecificity, includesAttrSelector } = require_style();
    var { attrsGroups, pseudoClasses } = require_collections();
    exports2.name = "inlineStyles";
    exports2.description = "inline styles (additional options)";
    var preservedPseudos = [
      ...pseudoClasses.functional,
      ...pseudoClasses.treeStructural
    ];
    exports2.fn = (root, params) => {
      const {
        onlyMatchedOnce = true,
        removeMatchedSelectors = true,
        useMqs = ["", "screen"],
        usePseudos = [""]
      } = params;
      const styles = [];
      let selectors = [];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (node.name !== "style" || node.children.length === 0) {
              return;
            }
            if (node.attributes.type != null && node.attributes.type !== "" && node.attributes.type !== "text/css") {
              return;
            }
            const cssText = node.children.filter((child) => child.type === "text" || child.type === "cdata").map((child) => child.value).join("");
            let cssAst = null;
            try {
              cssAst = csstree.parse(cssText, {
                parseValue: false,
                parseCustomProperty: false
              });
            } catch {
              return;
            }
            if (cssAst.type === "StyleSheet") {
              styles.push({ node, parentNode, cssAst });
            }
            csstree.walk(cssAst, {
              visit: "Rule",
              enter(node2) {
                const atrule = this.atrule;
                let mediaQuery = "";
                if (atrule != null) {
                  mediaQuery = atrule.name;
                  if (atrule.prelude != null) {
                    mediaQuery += ` ${csstree.generate(atrule.prelude)}`;
                  }
                }
                if (!useMqs.includes(mediaQuery)) {
                  return;
                }
                if (node2.prelude.type === "SelectorList") {
                  node2.prelude.children.forEach((childNode, item) => {
                    if (childNode.type === "Selector") {
                      const pseudos = [];
                      childNode.children.forEach(
                        (grandchildNode, grandchildItem, grandchildList) => {
                          const isPseudo = grandchildNode.type === "PseudoClassSelector" || grandchildNode.type === "PseudoElementSelector";
                          if (isPseudo && !preservedPseudos.includes(grandchildNode.name)) {
                            pseudos.push({
                              item: grandchildItem,
                              list: grandchildList
                            });
                          }
                        }
                      );
                      const pseudoSelectors = csstree.generate({
                        type: "Selector",
                        children: new csstree.List().fromArray(
                          pseudos.map((pseudo) => pseudo.item.data)
                        )
                      });
                      if (usePseudos.includes(pseudoSelectors)) {
                        for (const pseudo of pseudos) {
                          pseudo.list.remove(pseudo.item);
                        }
                      }
                      selectors.push({ node: childNode, rule: node2, item });
                    }
                  });
                }
              }
            });
          }
        },
        root: {
          exit: () => {
            if (styles.length === 0) {
              return;
            }
            const sortedSelectors = selectors.slice().sort((a, b) => {
              const aSpecificity = specificity(a.item.data);
              const bSpecificity = specificity(b.item.data);
              return compareSpecificity(aSpecificity, bSpecificity);
            }).reverse();
            for (const selector of sortedSelectors) {
              const selectorText = csstree.generate(selector.item.data);
              const matchedElements = [];
              try {
                for (const node of querySelectorAll(root, selectorText)) {
                  if (node.type === "element") {
                    matchedElements.push(node);
                  }
                }
              } catch (selectError) {
                continue;
              }
              if (matchedElements.length === 0) {
                continue;
              }
              if (onlyMatchedOnce && matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of matchedElements) {
                const styleDeclarationList = csstree.parse(
                  selectedEl.attributes.style ?? "",
                  {
                    context: "declarationList",
                    parseValue: false
                  }
                );
                if (styleDeclarationList.type !== "DeclarationList") {
                  continue;
                }
                const styleDeclarationItems = /* @__PURE__ */ new Map();
                let firstListItem;
                csstree.walk(styleDeclarationList, {
                  visit: "Declaration",
                  enter(node, item) {
                    if (firstListItem == null) {
                      firstListItem = item;
                    }
                    styleDeclarationItems.set(node.property.toLowerCase(), item);
                  }
                });
                csstree.walk(selector.rule, {
                  visit: "Declaration",
                  enter(ruleDeclaration) {
                    const property = ruleDeclaration.property;
                    if (attrsGroups.presentation.has(property) && !selectors.some(
                      (selector2) => includesAttrSelector(selector2.item, property)
                    )) {
                      delete selectedEl.attributes[property];
                    }
                    const matchedItem = styleDeclarationItems.get(property);
                    const ruleDeclarationItem = styleDeclarationList.children.createItem(ruleDeclaration);
                    if (matchedItem == null) {
                      styleDeclarationList.children.insert(
                        ruleDeclarationItem,
                        firstListItem
                      );
                    } else if (matchedItem.data.important !== true && ruleDeclaration.important === true) {
                      styleDeclarationList.children.replace(
                        matchedItem,
                        ruleDeclarationItem
                      );
                      styleDeclarationItems.set(property, ruleDeclarationItem);
                    }
                  }
                });
                const newStyles = csstree.generate(styleDeclarationList);
                if (newStyles.length !== 0) {
                  selectedEl.attributes.style = newStyles;
                }
              }
              if (removeMatchedSelectors && matchedElements.length !== 0 && selector.rule.prelude.type === "SelectorList") {
                selector.rule.prelude.children.remove(selector.item);
              }
              selector.matchedElements = matchedElements;
            }
            if (!removeMatchedSelectors) {
              return;
            }
            for (const selector of sortedSelectors) {
              if (selector.matchedElements == null) {
                continue;
              }
              if (onlyMatchedOnce && selector.matchedElements.length > 1) {
                continue;
              }
              for (const selectedEl of selector.matchedElements) {
                const classList = new Set(
                  selectedEl.attributes.class == null ? null : selectedEl.attributes.class.split(" ")
                );
                for (const child of selector.node.children) {
                  if (child.type === "ClassSelector" && !selectors.some(
                    (selector2) => includesAttrSelector(
                      selector2.item,
                      "class",
                      child.name,
                      true
                    )
                  )) {
                    classList.delete(child.name);
                  }
                }
                if (classList.size === 0) {
                  delete selectedEl.attributes.class;
                } else {
                  selectedEl.attributes.class = Array.from(classList).join(" ");
                }
                const firstSubSelector = selector.node.children.first;
                if (firstSubSelector?.type === "IdSelector" && selectedEl.attributes.id === firstSubSelector.name && !selectors.some(
                  (selector2) => includesAttrSelector(
                    selector2.item,
                    "id",
                    firstSubSelector.name,
                    true
                  )
                )) {
                  delete selectedEl.attributes.id;
                }
              }
            }
            for (const style of styles) {
              csstree.walk(style.cssAst, {
                visit: "Rule",
                enter: function(node, item, list) {
                  if (node.type === "Rule" && node.prelude.type === "SelectorList" && node.prelude.children.isEmpty) {
                    list.remove(item);
                  }
                }
              });
              if (style.cssAst.children.isEmpty) {
                detachNodeFromParent(style.node, style.parentNode);
              } else {
                const firstChild = style.node.children[0];
                if (firstChild.type === "text" || firstChild.type === "cdata") {
                  firstChild.value = csstree.generate(style.cssAst);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/svgo/tools.js
var require_tools = __commonJS({
  "node_modules/svgo/lib/svgo/tools.js"(exports2) {
    "use strict";
    var { attrsGroups, referencesProps } = require_collections();
    var regReferencesUrl = /\burl\((["'])?#(.+?)\1\)/g;
    var regReferencesHref = /^#(.+?)$/;
    var regReferencesBegin = /(\w+)\.[a-zA-Z]/;
    exports2.encodeSVGDatauri = (str, type) => {
      var prefix = "data:image/svg+xml";
      if (!type || type === "base64") {
        prefix += ";base64,";
        str = prefix + Buffer.from(str).toString("base64");
      } else if (type === "enc") {
        str = prefix + "," + encodeURIComponent(str);
      } else if (type === "unenc") {
        str = prefix + "," + str;
      }
      return str;
    };
    exports2.decodeSVGDatauri = (str) => {
      var regexp = /data:image\/svg\+xml(;charset=[^;,]*)?(;base64)?,(.*)/;
      var match = regexp.exec(str);
      if (!match) return str;
      var data = match[3];
      if (match[2]) {
        str = Buffer.from(data, "base64").toString("utf8");
      } else if (data.charAt(0) === "%") {
        str = decodeURIComponent(data);
      } else if (data.charAt(0) === "<") {
        str = data;
      }
      return str;
    };
    exports2.cleanupOutData = (data, params, command) => {
      let str = "";
      let delimiter;
      let prev;
      data.forEach((item, i) => {
        delimiter = " ";
        if (i == 0) delimiter = "";
        if (params.noSpaceAfterFlags && (command == "A" || command == "a")) {
          var pos = i % 7;
          if (pos == 4 || pos == 5) delimiter = "";
        }
        const itemStr = params.leadingZero ? removeLeadingZero(item) : item.toString();
        if (params.negativeExtraSpace && delimiter != "" && (item < 0 || itemStr.charAt(0) === "." && prev % 1 !== 0)) {
          delimiter = "";
        }
        prev = item;
        str += delimiter + itemStr;
      });
      return str;
    };
    var removeLeadingZero = (value) => {
      const strValue = value.toString();
      if (0 < value && value < 1 && strValue.startsWith("0")) {
        return strValue.slice(1);
      }
      if (-1 < value && value < 0 && strValue[1] === "0") {
        return strValue[0] + strValue.slice(2);
      }
      return strValue;
    };
    exports2.removeLeadingZero = removeLeadingZero;
    var hasScripts = (node) => {
      if (node.name === "script" && node.children.length !== 0) {
        return true;
      }
      if (node.name === "a") {
        const hasJsLinks = Object.entries(node.attributes).some(
          ([attrKey, attrValue]) => (attrKey === "href" || attrKey.endsWith(":href")) && attrValue != null && attrValue.trimStart().startsWith("javascript:")
        );
        if (hasJsLinks) {
          return true;
        }
      }
      const eventAttrs = [
        ...attrsGroups.animationEvent,
        ...attrsGroups.documentEvent,
        ...attrsGroups.documentElementEvent,
        ...attrsGroups.globalEvent,
        ...attrsGroups.graphicalEvent
      ];
      return eventAttrs.some((attr) => node.attributes[attr] != null);
    };
    exports2.hasScripts = hasScripts;
    var includesUrlReference = (body) => {
      return new RegExp(regReferencesUrl).test(body);
    };
    exports2.includesUrlReference = includesUrlReference;
    var findReferences = (attribute, value) => {
      const results = [];
      if (referencesProps.has(attribute)) {
        const matches = value.matchAll(regReferencesUrl);
        for (const match of matches) {
          results.push(match[2]);
        }
      }
      if (attribute === "href" || attribute.endsWith(":href")) {
        const match = regReferencesHref.exec(value);
        if (match != null) {
          results.push(match[1]);
        }
      }
      if (attribute === "begin") {
        const match = regReferencesBegin.exec(value);
        if (match != null) {
          results.push(match[1]);
        }
      }
      return results.map((body) => decodeURI(body));
    };
    exports2.findReferences = findReferences;
    var toFixed = (num, precision) => {
      const pow = 10 ** precision;
      return Math.round(num * pow) / pow;
    };
    exports2.toFixed = toFixed;
  }
});

// node_modules/svgo/plugins/minifyStyles.js
var require_minifyStyles = __commonJS({
  "node_modules/svgo/plugins/minifyStyles.js"(exports2) {
    "use strict";
    var csso = require_cjs3();
    var { detachNodeFromParent } = require_xast();
    var { hasScripts } = require_tools();
    exports2.name = "minifyStyles";
    exports2.description = "minifies styles and removes unused styles";
    exports2.fn = (_root, { usage, ...params }) => {
      const styleElements = /* @__PURE__ */ new Map();
      const elementsWithStyleAttributes = [];
      const tagsUsage = /* @__PURE__ */ new Set();
      const idsUsage = /* @__PURE__ */ new Set();
      const classesUsage = /* @__PURE__ */ new Set();
      let enableTagsUsage = true;
      let enableIdsUsage = true;
      let enableClassesUsage = true;
      let forceUsageDeoptimized = false;
      if (typeof usage === "boolean") {
        enableTagsUsage = usage;
        enableIdsUsage = usage;
        enableClassesUsage = usage;
      } else if (usage) {
        enableTagsUsage = usage.tags == null ? true : usage.tags;
        enableIdsUsage = usage.ids == null ? true : usage.ids;
        enableClassesUsage = usage.classes == null ? true : usage.classes;
        forceUsageDeoptimized = usage.force == null ? false : usage.force;
      }
      let deoptimized = false;
      return {
        element: {
          enter: (node, parentNode) => {
            if (hasScripts(node)) {
              deoptimized = true;
            }
            tagsUsage.add(node.name);
            if (node.attributes.id != null) {
              idsUsage.add(node.attributes.id);
            }
            if (node.attributes.class != null) {
              for (const className of node.attributes.class.split(/\s+/)) {
                classesUsage.add(className);
              }
            }
            if (node.name === "style" && node.children.length !== 0) {
              styleElements.set(node, parentNode);
            } else if (node.attributes.style != null) {
              elementsWithStyleAttributes.push(node);
            }
          }
        },
        root: {
          exit: () => {
            const cssoUsage = {};
            if (!deoptimized || forceUsageDeoptimized) {
              if (enableTagsUsage) {
                cssoUsage.tags = Array.from(tagsUsage);
              }
              if (enableIdsUsage) {
                cssoUsage.ids = Array.from(idsUsage);
              }
              if (enableClassesUsage) {
                cssoUsage.classes = Array.from(classesUsage);
              }
            }
            for (const [styleNode, styleNodeParent] of styleElements.entries()) {
              if (styleNode.children[0].type === "text" || styleNode.children[0].type === "cdata") {
                const cssText = styleNode.children[0].value;
                const minified = csso.minify(cssText, {
                  ...params,
                  usage: cssoUsage
                }).css;
                if (minified.length === 0) {
                  detachNodeFromParent(styleNode, styleNodeParent);
                  continue;
                }
                if (cssText.indexOf(">") >= 0 || cssText.indexOf("<") >= 0) {
                  styleNode.children[0].type = "cdata";
                  styleNode.children[0].value = minified;
                } else {
                  styleNode.children[0].type = "text";
                  styleNode.children[0].value = minified;
                }
              }
            }
            for (const node of elementsWithStyleAttributes) {
              const elemStyle = node.attributes.style;
              node.attributes.style = csso.minifyBlock(elemStyle, {
                ...params
              }).css;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupIds.js
var require_cleanupIds = __commonJS({
  "node_modules/svgo/plugins/cleanupIds.js"(exports2) {
    "use strict";
    var { visitSkip } = require_xast();
    var { hasScripts, findReferences } = require_tools();
    exports2.name = "cleanupIds";
    exports2.description = "removes unused IDs and minifies used";
    var generateIdChars = [
      "a",
      "b",
      "c",
      "d",
      "e",
      "f",
      "g",
      "h",
      "i",
      "j",
      "k",
      "l",
      "m",
      "n",
      "o",
      "p",
      "q",
      "r",
      "s",
      "t",
      "u",
      "v",
      "w",
      "x",
      "y",
      "z",
      "A",
      "B",
      "C",
      "D",
      "E",
      "F",
      "G",
      "H",
      "I",
      "J",
      "K",
      "L",
      "M",
      "N",
      "O",
      "P",
      "Q",
      "R",
      "S",
      "T",
      "U",
      "V",
      "W",
      "X",
      "Y",
      "Z"
    ];
    var maxIdIndex = generateIdChars.length - 1;
    var hasStringPrefix = (string, prefixes) => {
      for (const prefix of prefixes) {
        if (string.startsWith(prefix)) {
          return true;
        }
      }
      return false;
    };
    var generateId = (currentId) => {
      if (currentId == null) {
        return [0];
      }
      currentId[currentId.length - 1] += 1;
      for (let i = currentId.length - 1; i > 0; i--) {
        if (currentId[i] > maxIdIndex) {
          currentId[i] = 0;
          if (currentId[i - 1] !== void 0) {
            currentId[i - 1]++;
          }
        }
      }
      if (currentId[0] > maxIdIndex) {
        currentId[0] = 0;
        currentId.unshift(0);
      }
      return currentId;
    };
    var getIdString = (arr) => {
      return arr.map((i) => generateIdChars[i]).join("");
    };
    exports2.fn = (_root, params) => {
      const {
        remove = true,
        minify = true,
        preserve = [],
        preservePrefixes = [],
        force = false
      } = params;
      const preserveIds = new Set(
        Array.isArray(preserve) ? preserve : preserve ? [preserve] : []
      );
      const preserveIdPrefixes = Array.isArray(preservePrefixes) ? preservePrefixes : preservePrefixes ? [preservePrefixes] : [];
      const nodeById = /* @__PURE__ */ new Map();
      const referencesById = /* @__PURE__ */ new Map();
      let deoptimized = false;
      return {
        element: {
          enter: (node) => {
            if (!force) {
              if (node.name === "style" && node.children.length !== 0 || hasScripts(node)) {
                deoptimized = true;
                return;
              }
              if (node.name === "svg") {
                let hasDefsOnly = true;
                for (const child of node.children) {
                  if (child.type !== "element" || child.name !== "defs") {
                    hasDefsOnly = false;
                    break;
                  }
                }
                if (hasDefsOnly) {
                  return visitSkip;
                }
              }
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "id") {
                const id = value;
                if (nodeById.has(id)) {
                  delete node.attributes.id;
                } else {
                  nodeById.set(id, node);
                }
              } else {
                const ids = findReferences(name, value);
                for (const id of ids) {
                  let refs = referencesById.get(id);
                  if (refs == null) {
                    refs = [];
                    referencesById.set(id, refs);
                  }
                  refs.push({ element: node, name });
                }
              }
            }
          }
        },
        root: {
          exit: () => {
            if (deoptimized) {
              return;
            }
            const isIdPreserved = (id) => preserveIds.has(id) || hasStringPrefix(id, preserveIdPrefixes);
            let currentId = null;
            for (const [id, refs] of referencesById) {
              const node = nodeById.get(id);
              if (node != null) {
                if (minify && isIdPreserved(id) === false) {
                  let currentIdString = null;
                  do {
                    currentId = generateId(currentId);
                    currentIdString = getIdString(currentId);
                  } while (isIdPreserved(currentIdString) || referencesById.has(currentIdString) && nodeById.get(currentIdString) == null);
                  node.attributes.id = currentIdString;
                  for (const { element, name } of refs) {
                    const value = element.attributes[name];
                    if (value.includes("#")) {
                      element.attributes[name] = value.replace(
                        `#${encodeURI(id)}`,
                        `#${currentIdString}`
                      );
                    } else {
                      element.attributes[name] = value.replace(
                        `${id}.`,
                        `${currentIdString}.`
                      );
                    }
                  }
                }
                nodeById.delete(id);
              }
            }
            if (remove) {
              for (const [id, node] of nodeById) {
                if (isIdPreserved(id) === false) {
                  delete node.attributes.id;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUselessDefs.js
var require_removeUselessDefs = __commonJS({
  "node_modules/svgo/plugins/removeUselessDefs.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports2.name = "removeUselessDefs";
    exports2.description = "removes elements in <defs> without id";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "defs") {
              const usefulNodes = [];
              collectUsefulNodes(node, usefulNodes);
              if (usefulNodes.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
              for (const usefulNode of usefulNodes) {
                Object.defineProperty(usefulNode, "parentNode", {
                  writable: true,
                  value: node
                });
              }
              node.children = usefulNodes;
            } else if (elemsGroups.nonRendering.has(node.name) && node.attributes.id == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
    var collectUsefulNodes = (node, usefulNodes) => {
      for (const child of node.children) {
        if (child.type === "element") {
          if (child.attributes.id != null || child.name === "style") {
            usefulNodes.push(child);
          } else {
            collectUsefulNodes(child, usefulNodes);
          }
        }
      }
    };
  }
});

// node_modules/svgo/plugins/cleanupNumericValues.js
var require_cleanupNumericValues = __commonJS({
  "node_modules/svgo/plugins/cleanupNumericValues.js"(exports2) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports2.name = "cleanupNumericValues";
    exports2.description = "rounds numeric values to the fixed precision, removes default \u2018px\u2019 units";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var absoluteLengths = {
      // relative to px
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports2.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      return {
        element: {
          enter: (node) => {
            if (node.attributes.viewBox != null) {
              const nums = node.attributes.viewBox.split(/\s,?\s*|,\s*/g);
              node.attributes.viewBox = nums.map((value) => {
                const num = Number(value);
                return Number.isNaN(num) ? value : Number(num.toFixed(floatPrecision));
              }).join(" ");
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              if (name === "version") {
                continue;
              }
              const match = value.match(regNumericValues);
              if (match) {
                let num = Number(Number(match[1]).toFixed(floatPrecision));
                let matchedUnit = match[3] || "";
                let units = matchedUnit;
                if (convertToPx && units !== "" && units in absoluteLengths) {
                  const pxNum = Number(
                    (absoluteLengths[units] * Number(match[1])).toFixed(
                      floatPrecision
                    )
                  );
                  if (pxNum.toString().length < match[0].length) {
                    num = pxNum;
                    units = "px";
                  }
                }
                let str;
                if (leadingZero) {
                  str = removeLeadingZero(num);
                } else {
                  str = num.toString();
                }
                if (defaultPx && units === "px") {
                  units = "";
                }
                node.attributes[name] = str + units;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertColors.js
var require_convertColors = __commonJS({
  "node_modules/svgo/plugins/convertColors.js"(exports2) {
    "use strict";
    var collections = require_collections();
    exports2.name = "convertColors";
    exports2.description = "converts colors: rgb() to #rrggbb and #rrggbb to #rgb";
    var rNumber = "([+-]?(?:\\d*\\.\\d+|\\d+\\.?)%?)";
    var rComma = "\\s*,\\s*";
    var regRGB = new RegExp(
      "^rgb\\(\\s*" + rNumber + rComma + rNumber + rComma + rNumber + "\\s*\\)$"
    );
    var regHEX = /^#(([a-fA-F0-9])\2){3}$/;
    var convertRgbToHex = ([r, g, b]) => {
      const hexNumber = (
        // operator precedence is (+) > (<<) > (|)
        (256 + // [1][0]
        r << // [1][r]
        8 | // [1][r][0]
        g) << // [1][r][g]
        8 | // [1][r][g][0]
        b
      );
      return "#" + hexNumber.toString(16).slice(1).toUpperCase();
    };
    exports2.fn = (_root, params) => {
      const {
        currentColor = false,
        names2hex = true,
        rgb2hex = true,
        shorthex = true,
        shortname = true
      } = params;
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (collections.colorsProps.has(name)) {
                let val = value;
                if (currentColor) {
                  let matched;
                  if (typeof currentColor === "string") {
                    matched = val === currentColor;
                  } else if (currentColor instanceof RegExp) {
                    matched = currentColor.exec(val) != null;
                  } else {
                    matched = val !== "none";
                  }
                  if (matched) {
                    val = "currentColor";
                  }
                }
                if (names2hex) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsNames[colorName] != null) {
                    val = collections.colorsNames[colorName];
                  }
                }
                if (rgb2hex) {
                  let match = val.match(regRGB);
                  if (match != null) {
                    let nums = match.slice(1, 4).map((m) => {
                      let n;
                      if (m.indexOf("%") > -1) {
                        n = Math.round(parseFloat(m) * 2.55);
                      } else {
                        n = Number(m);
                      }
                      return Math.max(0, Math.min(n, 255));
                    });
                    val = convertRgbToHex(nums);
                  }
                }
                if (shorthex) {
                  let match = val.match(regHEX);
                  if (match != null) {
                    val = "#" + match[0][1] + match[0][3] + match[0][5];
                  }
                }
                if (shortname) {
                  const colorName = val.toLowerCase();
                  if (collections.colorsShortNames[colorName] != null) {
                    val = collections.colorsShortNames[colorName];
                  }
                }
                node.attributes[name] = val;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUnknownsAndDefaults.js
var require_removeUnknownsAndDefaults = __commonJS({
  "node_modules/svgo/plugins/removeUnknownsAndDefaults.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var {
      elems,
      attrsGroups,
      elemsGroups,
      attrsGroupsDefaults,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports2.name = "removeUnknownsAndDefaults";
    exports2.description = "removes unknown elements content and attributes, removes attrs with default values";
    var allowedChildrenPerElement = /* @__PURE__ */ new Map();
    var allowedAttributesPerElement = /* @__PURE__ */ new Map();
    var attributesDefaultsPerElement = /* @__PURE__ */ new Map();
    for (const [name, config] of Object.entries(elems)) {
      const allowedChildren = /* @__PURE__ */ new Set();
      if (config.content) {
        for (const elementName of config.content) {
          allowedChildren.add(elementName);
        }
      }
      if (config.contentGroups) {
        for (const contentGroupName of config.contentGroups) {
          const elemsGroup = elemsGroups[contentGroupName];
          if (elemsGroup) {
            for (const elementName of elemsGroup) {
              allowedChildren.add(elementName);
            }
          }
        }
      }
      const allowedAttributes = /* @__PURE__ */ new Set();
      if (config.attrs) {
        for (const attrName of config.attrs) {
          allowedAttributes.add(attrName);
        }
      }
      const attributesDefaults = /* @__PURE__ */ new Map();
      if (config.defaults) {
        for (const [attrName, defaultValue] of Object.entries(config.defaults)) {
          attributesDefaults.set(attrName, defaultValue);
        }
      }
      for (const attrsGroupName of config.attrsGroups) {
        const attrsGroup = attrsGroups[attrsGroupName];
        if (attrsGroup) {
          for (const attrName of attrsGroup) {
            allowedAttributes.add(attrName);
          }
        }
        const groupDefaults = attrsGroupsDefaults[attrsGroupName];
        if (groupDefaults) {
          for (const [attrName, defaultValue] of Object.entries(groupDefaults)) {
            attributesDefaults.set(attrName, defaultValue);
          }
        }
      }
      allowedChildrenPerElement.set(name, allowedChildren);
      allowedAttributesPerElement.set(name, allowedAttributes);
      attributesDefaultsPerElement.set(name, attributesDefaults);
    }
    exports2.fn = (root, params) => {
      const {
        unknownContent = true,
        unknownAttrs = true,
        defaultAttrs = true,
        defaultMarkupDeclarations = true,
        uselessOverrides = true,
        keepDataAttrs = true,
        keepAriaAttrs = true,
        keepRoleAttr = false
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        instruction: {
          enter: (node) => {
            if (defaultMarkupDeclarations) {
              node.value = node.value.replace(/\s*standalone\s*=\s*(["'])no\1/, "");
            }
          }
        },
        element: {
          enter: (node, parentNode) => {
            if (node.name.includes(":")) {
              return;
            }
            if (node.name === "foreignObject") {
              return visitSkip;
            }
            if (unknownContent && parentNode.type === "element") {
              const allowedChildren = allowedChildrenPerElement.get(
                parentNode.name
              );
              if (allowedChildren == null || allowedChildren.size === 0) {
                if (allowedChildrenPerElement.get(node.name) == null) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              } else {
                if (allowedChildren.has(node.name) === false) {
                  detachNodeFromParent(node, parentNode);
                  return;
                }
              }
            }
            const allowedAttributes = allowedAttributesPerElement.get(node.name);
            const attributesDefaults = attributesDefaultsPerElement.get(node.name);
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            for (const [name, value] of Object.entries(node.attributes)) {
              if (keepDataAttrs && name.startsWith("data-")) {
                continue;
              }
              if (keepAriaAttrs && name.startsWith("aria-")) {
                continue;
              }
              if (keepRoleAttr && name === "role") {
                continue;
              }
              if (name === "xmlns") {
                continue;
              }
              if (name.includes(":")) {
                const [prefix] = name.split(":");
                if (prefix !== "xml" && prefix !== "xlink") {
                  continue;
                }
              }
              if (unknownAttrs && allowedAttributes && allowedAttributes.has(name) === false) {
                delete node.attributes[name];
              }
              if (defaultAttrs && node.attributes.id == null && attributesDefaults && attributesDefaults.get(name) === value) {
                if (computedParentStyle?.[name] == null) {
                  delete node.attributes[name];
                }
              }
              if (uselessOverrides && node.attributes.id == null) {
                const style = computedParentStyle?.[name];
                if (presentationNonInheritableGroupAttrs.has(name) === false && style != null && style.type === "static" && style.value === value) {
                  delete node.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js
var require_removeNonInheritableGroupAttrs = __commonJS({
  "node_modules/svgo/plugins/removeNonInheritableGroupAttrs.js"(exports2) {
    "use strict";
    var {
      inheritableAttrs,
      attrsGroups,
      presentationNonInheritableGroupAttrs
    } = require_collections();
    exports2.name = "removeNonInheritableGroupAttrs";
    exports2.description = "removes non-inheritable group\u2019s presentational attributes";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "g") {
              for (const name of Object.keys(node.attributes)) {
                if (attrsGroups.presentation.has(name) && !inheritableAttrs.has(name) && !presentationNonInheritableGroupAttrs.has(name)) {
                  delete node.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUselessStrokeAndFill.js
var require_removeUselessStrokeAndFill = __commonJS({
  "node_modules/svgo/plugins/removeUselessStrokeAndFill.js"(exports2) {
    "use strict";
    var { visit, visitSkip, detachNodeFromParent } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { hasScripts } = require_tools();
    var { elemsGroups } = require_collections();
    exports2.name = "removeUselessStrokeAndFill";
    exports2.description = "removes useless stroke and fill attributes";
    exports2.fn = (root, params) => {
      const {
        stroke: removeStroke = true,
        fill: removeFill = true,
        removeNone = false
      } = params;
      let hasStyleOrScript = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "style" || hasScripts(node)) {
              hasStyleOrScript = true;
            }
          }
        }
      });
      if (hasStyleOrScript) {
        return null;
      }
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null) {
              return visitSkip;
            }
            if (!elemsGroups.shape.has(node.name)) {
              return;
            }
            const computedStyle = computeStyle(stylesheet, node);
            const stroke = computedStyle.stroke;
            const strokeOpacity = computedStyle["stroke-opacity"];
            const strokeWidth = computedStyle["stroke-width"];
            const markerEnd = computedStyle["marker-end"];
            const fill = computedStyle.fill;
            const fillOpacity = computedStyle["fill-opacity"];
            const computedParentStyle = parentNode.type === "element" ? computeStyle(stylesheet, parentNode) : null;
            const parentStroke = computedParentStyle == null ? null : computedParentStyle.stroke;
            if (removeStroke) {
              if (stroke == null || stroke.type === "static" && stroke.value == "none" || strokeOpacity != null && strokeOpacity.type === "static" && strokeOpacity.value === "0" || strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0") {
                if (strokeWidth != null && strokeWidth.type === "static" && strokeWidth.value === "0" || markerEnd == null) {
                  for (const name of Object.keys(node.attributes)) {
                    if (name.startsWith("stroke")) {
                      delete node.attributes[name];
                    }
                  }
                  if (parentStroke != null && parentStroke.type === "static" && parentStroke.value !== "none") {
                    node.attributes.stroke = "none";
                  }
                }
              }
            }
            if (removeFill) {
              if (fill != null && fill.type === "static" && fill.value === "none" || fillOpacity != null && fillOpacity.type === "static" && fillOpacity.value === "0") {
                for (const name of Object.keys(node.attributes)) {
                  if (name.startsWith("fill-")) {
                    delete node.attributes[name];
                  }
                }
                if (fill == null || fill.type === "static" && fill.value !== "none") {
                  node.attributes.fill = "none";
                }
              }
            }
            if (removeNone) {
              if ((stroke == null || node.attributes.stroke === "none") && (fill != null && fill.type === "static" && fill.value === "none" || node.attributes.fill === "none")) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeViewBox.js
var require_removeViewBox = __commonJS({
  "node_modules/svgo/plugins/removeViewBox.js"(exports2) {
    "use strict";
    exports2.name = "removeViewBox";
    exports2.description = "removes viewBox attribute when possible";
    var viewBoxElems = /* @__PURE__ */ new Set(["pattern", "svg", "symbol"]);
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (viewBoxElems.has(node.name) && node.attributes.viewBox != null && node.attributes.width != null && node.attributes.height != null) {
              if (node.name === "svg" && parentNode.type !== "root") {
                return;
              }
              const nums = node.attributes.viewBox.split(/[ ,]+/g);
              if (nums[0] === "0" && nums[1] === "0" && node.attributes.width.replace(/px$/, "") === nums[2] && // could use parseFloat too
              node.attributes.height.replace(/px$/, "") === nums[3]) {
                delete node.attributes.viewBox;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupEnableBackground.js
var require_cleanupEnableBackground = __commonJS({
  "node_modules/svgo/plugins/cleanupEnableBackground.js"(exports2) {
    "use strict";
    var csstree = require_cjs();
    var { visit } = require_xast();
    exports2.name = "cleanupEnableBackground";
    exports2.description = "remove or cleanup enable-background attribute when possible";
    var regEnableBackground = /^new\s0\s0\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)\s([-+]?\d*\.?\d+([eE][-+]?\d+)?)$/;
    exports2.fn = (root) => {
      let hasFilter = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "filter") {
              hasFilter = true;
            }
          }
        }
      });
      return {
        element: {
          enter: (node) => {
            let newStyle = null;
            let enableBackgroundDeclaration = null;
            if (node.attributes.style != null) {
              newStyle = csstree.parse(node.attributes.style, {
                context: "declarationList"
              });
              if (newStyle.type === "DeclarationList") {
                const enableBackgroundDeclarations = [];
                csstree.walk(newStyle, (node2, nodeItem) => {
                  if (node2.type === "Declaration" && node2.property === "enable-background") {
                    enableBackgroundDeclarations.push(nodeItem);
                    enableBackgroundDeclaration = nodeItem;
                  }
                });
                for (let i = 0; i < enableBackgroundDeclarations.length - 1; i++) {
                  newStyle.children.remove(enableBackgroundDeclarations[i]);
                }
              }
            }
            if (!hasFilter) {
              delete node.attributes["enable-background"];
              if (newStyle?.type === "DeclarationList") {
                if (enableBackgroundDeclaration) {
                  newStyle.children.remove(enableBackgroundDeclaration);
                }
                if (newStyle.children.isEmpty) {
                  delete node.attributes.style;
                } else {
                  node.attributes.style = csstree.generate(newStyle);
                }
              }
              return;
            }
            const hasDimensions = node.attributes.width != null && node.attributes.height != null;
            if ((node.name === "svg" || node.name === "mask" || node.name === "pattern") && hasDimensions) {
              const attrValue = node.attributes["enable-background"];
              const attrCleaned = cleanupValue(
                attrValue,
                node.name,
                node.attributes.width,
                node.attributes.height
              );
              if (attrCleaned) {
                node.attributes["enable-background"] = attrCleaned;
              } else {
                delete node.attributes["enable-background"];
              }
              if (newStyle?.type === "DeclarationList" && enableBackgroundDeclaration) {
                const styleValue = csstree.generate(
                  // @ts-ignore
                  enableBackgroundDeclaration.data.value
                );
                const styleCleaned = cleanupValue(
                  styleValue,
                  node.name,
                  node.attributes.width,
                  node.attributes.height
                );
                if (styleCleaned) {
                  enableBackgroundDeclaration.data.value = {
                    type: "Raw",
                    value: styleCleaned
                  };
                } else {
                  newStyle.children.remove(enableBackgroundDeclaration);
                }
              }
            }
            if (newStyle?.type === "DeclarationList") {
              if (newStyle.children.isEmpty) {
                delete node.attributes.style;
              } else {
                node.attributes.style = csstree.generate(newStyle);
              }
            }
          }
        }
      };
    };
    var cleanupValue = (value, nodeName, width, height) => {
      const match = regEnableBackground.exec(value);
      if (match != null && width === match[1] && height === match[3]) {
        return nodeName === "svg" ? void 0 : "new";
      }
      return value;
    };
  }
});

// node_modules/svgo/lib/path.js
var require_path = __commonJS({
  "node_modules/svgo/lib/path.js"(exports2) {
    "use strict";
    var { removeLeadingZero, toFixed } = require_tools();
    var argsCountPerCommand = {
      M: 2,
      m: 2,
      Z: 0,
      z: 0,
      L: 2,
      l: 2,
      H: 1,
      h: 1,
      V: 1,
      v: 1,
      C: 6,
      c: 6,
      S: 4,
      s: 4,
      Q: 4,
      q: 4,
      T: 2,
      t: 2,
      A: 7,
      a: 7
    };
    var isCommand = (c) => {
      return c in argsCountPerCommand;
    };
    var isWsp = (c) => {
      const codePoint = c.codePointAt(0);
      return codePoint === 32 || codePoint === 9 || codePoint === 13 || codePoint === 10;
    };
    var isDigit = (c) => {
      const codePoint = c.codePointAt(0);
      if (codePoint == null) {
        return false;
      }
      return 48 <= codePoint && codePoint <= 57;
    };
    var readNumber = (string, cursor) => {
      let i = cursor;
      let value = "";
      let state = (
        /** @type {ReadNumberState} */
        "none"
      );
      for (; i < string.length; i += 1) {
        const c = string[i];
        if (c === "+" || c === "-") {
          if (state === "none") {
            state = "sign";
            value += c;
            continue;
          }
          if (state === "e") {
            state = "exponent_sign";
            value += c;
            continue;
          }
        }
        if (isDigit(c)) {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "whole";
            value += c;
            continue;
          }
          if (state === "decimal_point" || state === "decimal") {
            state = "decimal";
            value += c;
            continue;
          }
          if (state === "e" || state === "exponent_sign" || state === "exponent") {
            state = "exponent";
            value += c;
            continue;
          }
        }
        if (c === ".") {
          if (state === "none" || state === "sign" || state === "whole") {
            state = "decimal_point";
            value += c;
            continue;
          }
        }
        if (c === "E" || c == "e") {
          if (state === "whole" || state === "decimal_point" || state === "decimal") {
            state = "e";
            value += c;
            continue;
          }
        }
        break;
      }
      const number = Number.parseFloat(value);
      if (Number.isNaN(number)) {
        return [cursor, null];
      } else {
        return [i - 1, number];
      }
    };
    var parsePathData = (string) => {
      const pathData = [];
      let command = null;
      let args = (
        /** @type {number[]} */
        []
      );
      let argsCount = 0;
      let canHaveComma = false;
      let hadComma = false;
      for (let i = 0; i < string.length; i += 1) {
        const c = string.charAt(i);
        if (isWsp(c)) {
          continue;
        }
        if (canHaveComma && c === ",") {
          if (hadComma) {
            break;
          }
          hadComma = true;
          continue;
        }
        if (isCommand(c)) {
          if (hadComma) {
            return pathData;
          }
          if (command == null) {
            if (c !== "M" && c !== "m") {
              return pathData;
            }
          } else {
            if (args.length !== 0) {
              return pathData;
            }
          }
          command = c;
          args = [];
          argsCount = argsCountPerCommand[command];
          canHaveComma = false;
          if (argsCount === 0) {
            pathData.push({ command, args });
          }
          continue;
        }
        if (command == null) {
          return pathData;
        }
        let newCursor = i;
        let number = null;
        if (command === "A" || command === "a") {
          const position = args.length;
          if (position === 0 || position === 1) {
            if (c !== "+" && c !== "-") {
              [newCursor, number] = readNumber(string, i);
            }
          }
          if (position === 2 || position === 5 || position === 6) {
            [newCursor, number] = readNumber(string, i);
          }
          if (position === 3 || position === 4) {
            if (c === "0") {
              number = 0;
            }
            if (c === "1") {
              number = 1;
            }
          }
        } else {
          [newCursor, number] = readNumber(string, i);
        }
        if (number == null) {
          return pathData;
        }
        args.push(number);
        canHaveComma = true;
        hadComma = false;
        i = newCursor;
        if (args.length === argsCount) {
          pathData.push({ command, args });
          if (command === "M") {
            command = "L";
          }
          if (command === "m") {
            command = "l";
          }
          args = [];
        }
      }
      return pathData;
    };
    exports2.parsePathData = parsePathData;
    var roundAndStringify = (number, precision) => {
      if (precision != null) {
        number = toFixed(number, precision);
      }
      return {
        roundedStr: removeLeadingZero(number),
        rounded: number
      };
    };
    var stringifyArgs = (command, args, precision, disableSpaceAfterFlags) => {
      let result = "";
      let previous;
      for (let i = 0; i < args.length; i++) {
        const { roundedStr, rounded } = roundAndStringify(args[i], precision);
        if (disableSpaceAfterFlags && (command === "A" || command === "a") && // consider combined arcs
        (i % 7 === 4 || i % 7 === 5)) {
          result += roundedStr;
        } else if (i === 0 || rounded < 0) {
          result += roundedStr;
        } else if (!Number.isInteger(previous) && rounded != 0 && rounded < 1 && rounded > -1) {
          result += roundedStr;
        } else {
          result += ` ${roundedStr}`;
        }
        previous = rounded;
      }
      return result;
    };
    var stringifyPathData = ({ pathData, precision, disableSpaceAfterFlags }) => {
      if (pathData.length === 1) {
        const { command, args } = pathData[0];
        return command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
      }
      let result = "";
      let prev = { ...pathData[0] };
      if (pathData[1].command === "L") {
        prev.command = "M";
      } else if (pathData[1].command === "l") {
        prev.command = "m";
      }
      for (let i = 1; i < pathData.length; i++) {
        const { command, args } = pathData[i];
        if (prev.command === command && prev.command !== "M" && prev.command !== "m" || // combine matching moveto and lineto sequences
        prev.command === "M" && command === "L" || prev.command === "m" && command === "l") {
          prev.args = [...prev.args, ...args];
          if (i === pathData.length - 1) {
            result += prev.command + stringifyArgs(
              prev.command,
              prev.args,
              precision,
              disableSpaceAfterFlags
            );
          }
        } else {
          result += prev.command + stringifyArgs(
            prev.command,
            prev.args,
            precision,
            disableSpaceAfterFlags
          );
          if (i === pathData.length - 1) {
            result += command + stringifyArgs(command, args, precision, disableSpaceAfterFlags);
          } else {
            prev = { command, args };
          }
        }
      }
      return result;
    };
    exports2.stringifyPathData = stringifyPathData;
  }
});

// node_modules/svgo/plugins/removeHiddenElems.js
var require_removeHiddenElems = __commonJS({
  "node_modules/svgo/plugins/removeHiddenElems.js"(exports2) {
    "use strict";
    var { elemsGroups } = require_collections();
    var {
      visit,
      visitSkip,
      querySelector,
      detachNodeFromParent
    } = require_xast();
    var { collectStylesheet, computeStyle } = require_style();
    var { parsePathData } = require_path();
    var { hasScripts, findReferences } = require_tools();
    var nonRendering = elemsGroups.nonRendering;
    exports2.name = "removeHiddenElems";
    exports2.description = "removes hidden elements (zero sized, with absent attributes)";
    exports2.fn = (root, params) => {
      const {
        isHidden = true,
        displayNone = true,
        opacity0 = true,
        circleR0 = true,
        ellipseRX0 = true,
        ellipseRY0 = true,
        rectWidth0 = true,
        rectHeight0 = true,
        patternWidth0 = true,
        patternHeight0 = true,
        imageWidth0 = true,
        imageHeight0 = true,
        pathEmptyD = true,
        polylineEmptyPoints = true,
        polygonEmptyPoints = true
      } = params;
      const stylesheet = collectStylesheet(root);
      const nonRenderedNodes = /* @__PURE__ */ new Map();
      const removedDefIds = /* @__PURE__ */ new Set();
      const allDefs = /* @__PURE__ */ new Map();
      const allReferences = /* @__PURE__ */ new Set();
      const referencesById = /* @__PURE__ */ new Map();
      let deoptimized = false;
      function removeElement(node, parentNode) {
        if (node.type === "element" && node.attributes.id != null && parentNode.type === "element" && parentNode.name === "defs") {
          removedDefIds.add(node.attributes.id);
        }
        detachNodeFromParent(node, parentNode);
      }
      visit(root, {
        element: {
          enter: (node, parentNode) => {
            if (nonRendering.has(node.name)) {
              if (node.attributes.id == null) {
                detachNodeFromParent(node, parentNode);
                return visitSkip;
              }
              nonRenderedNodes.set(node, parentNode);
              return visitSkip;
            }
            const computedStyle = computeStyle(stylesheet, node);
            if (opacity0 && computedStyle.opacity && computedStyle.opacity.type === "static" && computedStyle.opacity.value === "0") {
              removeElement(node, parentNode);
            }
          }
        }
      });
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style" && node.children.length !== 0 || hasScripts(node)) {
              deoptimized = true;
              return;
            }
            if (node.name === "defs") {
              allDefs.set(node, parentNode);
            }
            if (node.name === "use") {
              for (const attr of Object.keys(node.attributes)) {
                if (attr !== "href" && !attr.endsWith(":href")) continue;
                const value = node.attributes[attr];
                const id = value.slice(1);
                let refs = referencesById.get(id);
                if (!refs) {
                  refs = [];
                  referencesById.set(id, refs);
                }
                refs.push({ node, parentNode });
              }
            }
            const computedStyle = computeStyle(stylesheet, node);
            if (isHidden && computedStyle.visibility && computedStyle.visibility.type === "static" && computedStyle.visibility.value === "hidden" && // keep if any descendant enables visibility
            querySelector(node, "[visibility=visible]") == null) {
              removeElement(node, parentNode);
              return;
            }
            if (displayNone && computedStyle.display && computedStyle.display.type === "static" && computedStyle.display.value === "none" && // markers with display: none still rendered
            node.name !== "marker") {
              removeElement(node, parentNode);
              return;
            }
            if (circleR0 && node.name === "circle" && node.children.length === 0 && node.attributes.r === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (ellipseRX0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.rx === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (ellipseRY0 && node.name === "ellipse" && node.children.length === 0 && node.attributes.ry === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.width === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (rectHeight0 && rectWidth0 && node.name === "rect" && node.children.length === 0 && node.attributes.height === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (patternWidth0 && node.name === "pattern" && node.attributes.width === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (patternHeight0 && node.name === "pattern" && node.attributes.height === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (imageWidth0 && node.name === "image" && node.attributes.width === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (imageHeight0 && node.name === "image" && node.attributes.height === "0") {
              removeElement(node, parentNode);
              return;
            }
            if (pathEmptyD && node.name === "path") {
              if (node.attributes.d == null) {
                removeElement(node, parentNode);
                return;
              }
              const pathData = parsePathData(node.attributes.d);
              if (pathData.length === 0) {
                removeElement(node, parentNode);
                return;
              }
              if (pathData.length === 1 && computedStyle["marker-start"] == null && computedStyle["marker-end"] == null) {
                removeElement(node, parentNode);
                return;
              }
            }
            if (polylineEmptyPoints && node.name === "polyline" && node.attributes.points == null) {
              removeElement(node, parentNode);
              return;
            }
            if (polygonEmptyPoints && node.name === "polygon" && node.attributes.points == null) {
              removeElement(node, parentNode);
              return;
            }
            for (const [name, value] of Object.entries(node.attributes)) {
              const ids = findReferences(name, value);
              for (const id of ids) {
                allReferences.add(id);
              }
            }
          }
        },
        root: {
          exit: () => {
            for (const id of removedDefIds) {
              const refs = referencesById.get(id);
              if (refs) {
                for (const { node, parentNode } of refs) {
                  detachNodeFromParent(node, parentNode);
                }
              }
            }
            if (!deoptimized) {
              for (const [
                nonRenderedNode,
                nonRenderedParent
              ] of nonRenderedNodes.entries()) {
                const id = nonRenderedNode.attributes.id;
                if (!allReferences.has(id)) {
                  detachNodeFromParent(nonRenderedNode, nonRenderedParent);
                }
              }
            }
            for (const [node, parentNode] of allDefs.entries()) {
              if (node.children.length === 0) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyText.js
var require_removeEmptyText = __commonJS({
  "node_modules/svgo/plugins/removeEmptyText.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeEmptyText";
    exports2.description = "removes empty <text> elements";
    exports2.fn = (root, params) => {
      const { text = true, tspan = true, tref = true } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (text && node.name === "text" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tspan && node.name === "tspan" && node.children.length === 0) {
              detachNodeFromParent(node, parentNode);
            }
            if (tref && node.name === "tref" && node.attributes["xlink:href"] == null) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertShapeToPath.js
var require_convertShapeToPath = __commonJS({
  "node_modules/svgo/plugins/convertShapeToPath.js"(exports2) {
    "use strict";
    var { stringifyPathData } = require_path();
    var { detachNodeFromParent } = require_xast();
    exports2.name = "convertShapeToPath";
    exports2.description = "converts basic shapes to more compact path form";
    var regNumber = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports2.fn = (root, params) => {
      const { convertArcs = false, floatPrecision: precision } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "rect" && node.attributes.width != null && node.attributes.height != null && node.attributes.rx == null && node.attributes.ry == null) {
              const x = Number(node.attributes.x || "0");
              const y = Number(node.attributes.y || "0");
              const width = Number(node.attributes.width);
              const height = Number(node.attributes.height);
              if (Number.isNaN(x - y + width - height)) return;
              const pathData = [
                { command: "M", args: [x, y] },
                { command: "H", args: [x + width] },
                { command: "V", args: [y + height] },
                { command: "H", args: [x] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x;
              delete node.attributes.y;
              delete node.attributes.width;
              delete node.attributes.height;
            }
            if (node.name === "line") {
              const x1 = Number(node.attributes.x1 || "0");
              const y1 = Number(node.attributes.y1 || "0");
              const x2 = Number(node.attributes.x2 || "0");
              const y2 = Number(node.attributes.y2 || "0");
              if (Number.isNaN(x1 - y1 + x2 - y2)) return;
              const pathData = [
                { command: "M", args: [x1, y1] },
                { command: "L", args: [x2, y2] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.x1;
              delete node.attributes.y1;
              delete node.attributes.x2;
              delete node.attributes.y2;
            }
            if ((node.name === "polyline" || node.name === "polygon") && node.attributes.points != null) {
              const coords = (node.attributes.points.match(regNumber) || []).map(
                Number
              );
              if (coords.length < 4) {
                detachNodeFromParent(node, parentNode);
                return;
              }
              const pathData = [];
              for (let i = 0; i < coords.length; i += 2) {
                pathData.push({
                  command: i === 0 ? "M" : "L",
                  args: coords.slice(i, i + 2)
                });
              }
              if (node.name === "polygon") {
                pathData.push({ command: "z", args: [] });
              }
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.points;
            }
            if (node.name === "circle" && convertArcs) {
              const cx = Number(node.attributes.cx || "0");
              const cy = Number(node.attributes.cy || "0");
              const r = Number(node.attributes.r || "0");
              if (Number.isNaN(cx - cy + r)) {
                return;
              }
              const pathData = [
                { command: "M", args: [cx, cy - r] },
                { command: "A", args: [r, r, 0, 1, 0, cx, cy + r] },
                { command: "A", args: [r, r, 0, 1, 0, cx, cy - r] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.r;
            }
            if (node.name === "ellipse" && convertArcs) {
              const ecx = Number(node.attributes.cx || "0");
              const ecy = Number(node.attributes.cy || "0");
              const rx = Number(node.attributes.rx || "0");
              const ry = Number(node.attributes.ry || "0");
              if (Number.isNaN(ecx - ecy + rx - ry)) {
                return;
              }
              const pathData = [
                { command: "M", args: [ecx, ecy - ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy + ry] },
                { command: "A", args: [rx, ry, 0, 1, 0, ecx, ecy - ry] },
                { command: "z", args: [] }
              ];
              node.name = "path";
              node.attributes.d = stringifyPathData({ pathData, precision });
              delete node.attributes.cx;
              delete node.attributes.cy;
              delete node.attributes.rx;
              delete node.attributes.ry;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertEllipseToCircle.js
var require_convertEllipseToCircle = __commonJS({
  "node_modules/svgo/plugins/convertEllipseToCircle.js"(exports2) {
    "use strict";
    exports2.name = "convertEllipseToCircle";
    exports2.description = "converts non-eccentric <ellipse>s to <circle>s";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "ellipse") {
              const rx = node.attributes.rx || "0";
              const ry = node.attributes.ry || "0";
              if (rx === ry || rx === "auto" || ry === "auto") {
                node.name = "circle";
                const radius = rx === "auto" ? ry : rx;
                delete node.attributes.rx;
                delete node.attributes.ry;
                node.attributes.r = radius;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveElemsAttrsToGroup.js
var require_moveElemsAttrsToGroup = __commonJS({
  "node_modules/svgo/plugins/moveElemsAttrsToGroup.js"(exports2) {
    "use strict";
    var { visit } = require_xast();
    var { inheritableAttrs, pathElems } = require_collections();
    exports2.name = "moveElemsAttrsToGroup";
    exports2.description = "Move common attributes of group children to the group";
    exports2.fn = (root) => {
      let deoptimizedWithStyles = false;
      visit(root, {
        element: {
          enter: (node) => {
            if (node.name === "style") {
              deoptimizedWithStyles = true;
            }
          }
        }
      });
      return {
        element: {
          exit: (node) => {
            if (node.name !== "g" || node.children.length <= 1) {
              return;
            }
            if (deoptimizedWithStyles) {
              return;
            }
            const commonAttributes = /* @__PURE__ */ new Map();
            let initial = true;
            let everyChildIsPath = true;
            for (const child of node.children) {
              if (child.type === "element") {
                if (!pathElems.has(child.name)) {
                  everyChildIsPath = false;
                }
                if (initial) {
                  initial = false;
                  for (const [name, value] of Object.entries(child.attributes)) {
                    if (inheritableAttrs.has(name)) {
                      commonAttributes.set(name, value);
                    }
                  }
                } else {
                  for (const [name, value] of commonAttributes) {
                    if (child.attributes[name] !== value) {
                      commonAttributes.delete(name);
                    }
                  }
                }
              }
            }
            if (node.attributes["clip-path"] != null || node.attributes.mask != null) {
              commonAttributes.delete("transform");
            }
            if (everyChildIsPath) {
              commonAttributes.delete("transform");
            }
            for (const [name, value] of commonAttributes) {
              if (name === "transform") {
                if (node.attributes.transform != null) {
                  node.attributes.transform = `${node.attributes.transform} ${value}`;
                } else {
                  node.attributes.transform = value;
                }
              } else {
                node.attributes[name] = value;
              }
            }
            for (const child of node.children) {
              if (child.type === "element") {
                for (const [name] of commonAttributes) {
                  delete child.attributes[name];
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/moveGroupAttrsToElems.js
var require_moveGroupAttrsToElems = __commonJS({
  "node_modules/svgo/plugins/moveGroupAttrsToElems.js"(exports2) {
    "use strict";
    var { pathElems, referencesProps } = require_collections();
    var { includesUrlReference } = require_tools();
    exports2.name = "moveGroupAttrsToElems";
    exports2.description = "moves some group attributes to the content elements";
    var pathElemsWithGroupsAndText = [...pathElems, "g", "text"];
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "g" && node.children.length !== 0 && node.attributes.transform != null && Object.entries(node.attributes).some(
              ([name, value]) => referencesProps.has(name) && includesUrlReference(value)
            ) === false && node.children.every(
              (child) => child.type === "element" && pathElemsWithGroupsAndText.includes(child.name) && child.attributes.id == null
            )) {
              for (const child of node.children) {
                const value = node.attributes.transform;
                if (child.type === "element") {
                  if (child.attributes.transform != null) {
                    child.attributes.transform = `${value} ${child.attributes.transform}`;
                  } else {
                    child.attributes.transform = value;
                  }
                }
              }
              delete node.attributes.transform;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/collapseGroups.js
var require_collapseGroups = __commonJS({
  "node_modules/svgo/plugins/collapseGroups.js"(exports2) {
    "use strict";
    var { inheritableAttrs, elemsGroups } = require_collections();
    exports2.name = "collapseGroups";
    exports2.description = "collapses useless groups";
    var hasAnimatedAttr = (node, name) => {
      if (node.type === "element") {
        if (elemsGroups.animation.has(node.name) && node.attributes.attributeName === name) {
          return true;
        }
        for (const child of node.children) {
          if (hasAnimatedAttr(child, name)) {
            return true;
          }
        }
      }
      return false;
    };
    exports2.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (parentNode.type === "root" || parentNode.name === "switch") {
              return;
            }
            if (node.name !== "g" || node.children.length === 0) {
              return;
            }
            if (Object.keys(node.attributes).length !== 0 && node.children.length === 1) {
              const firstChild = node.children[0];
              if (firstChild.type === "element" && firstChild.attributes.id == null && node.attributes.filter == null && (node.attributes.class == null || firstChild.attributes.class == null) && (node.attributes["clip-path"] == null && node.attributes.mask == null || firstChild.name === "g" && node.attributes.transform == null && firstChild.attributes.transform == null)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  if (hasAnimatedAttr(firstChild, name)) {
                    return;
                  }
                  if (firstChild.attributes[name] == null) {
                    firstChild.attributes[name] = value;
                  } else if (name === "transform") {
                    firstChild.attributes[name] = value + " " + firstChild.attributes[name];
                  } else if (firstChild.attributes[name] === "inherit") {
                    firstChild.attributes[name] = value;
                  } else if (inheritableAttrs.has(name) === false && firstChild.attributes[name] !== value) {
                    return;
                  }
                  delete node.attributes[name];
                }
              }
            }
            if (Object.keys(node.attributes).length === 0) {
              for (const child of node.children) {
                if (child.type === "element" && elemsGroups.animation.has(child.name)) {
                  return;
                }
              }
              const index = parentNode.children.indexOf(node);
              parentNode.children.splice(index, 1, ...node.children);
              for (const child of node.children) {
                Object.defineProperty(child, "parentNode", {
                  writable: true,
                  value: parentNode
                });
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/_path.js
var require_path2 = __commonJS({
  "node_modules/svgo/plugins/_path.js"(exports2) {
    "use strict";
    var { parsePathData, stringifyPathData } = require_path();
    var prevCtrlPoint;
    var path2js = (path44) => {
      if (path44.pathJS) return path44.pathJS;
      const pathData = [];
      const newPathData = parsePathData(path44.attributes.d);
      for (const { command, args } of newPathData) {
        pathData.push({ command, args });
      }
      if (pathData.length && pathData[0].command == "m") {
        pathData[0].command = "M";
      }
      path44.pathJS = pathData;
      return pathData;
    };
    exports2.path2js = path2js;
    var convertRelativeToAbsolute = (data) => {
      const newData = [];
      let start = [0, 0];
      let cursor = [0, 0];
      for (let { command, args } of data) {
        args = args.slice();
        if (command === "m") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "M";
        }
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "h") {
          args[0] += cursor[0];
          command = "H";
        }
        if (command === "H") {
          cursor[0] = args[0];
        }
        if (command === "v") {
          args[0] += cursor[1];
          command = "V";
        }
        if (command === "V") {
          cursor[1] = args[0];
        }
        if (command === "l") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "L";
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "c") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          args[4] += cursor[0];
          args[5] += cursor[1];
          command = "C";
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
        }
        if (command === "s") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "S";
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "q") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          args[2] += cursor[0];
          args[3] += cursor[1];
          command = "Q";
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
        }
        if (command === "t") {
          args[0] += cursor[0];
          args[1] += cursor[1];
          command = "T";
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
        }
        if (command === "a") {
          args[5] += cursor[0];
          args[6] += cursor[1];
          command = "A";
        }
        if (command === "A") {
          cursor[0] = args[5];
          cursor[1] = args[6];
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
          command = "z";
        }
        newData.push({ command, args });
      }
      return newData;
    };
    exports2.js2path = function(path44, data, params) {
      path44.pathJS = data;
      const pathData = [];
      for (const item of data) {
        if (pathData.length !== 0 && (item.command === "M" || item.command === "m")) {
          const last = pathData[pathData.length - 1];
          if (last.command === "M" || last.command === "m") {
            pathData.pop();
          }
        }
        pathData.push({
          command: item.command,
          args: item.args
        });
      }
      path44.attributes.d = stringifyPathData({
        pathData,
        precision: params.floatPrecision,
        disableSpaceAfterFlags: params.noSpaceAfterFlags
      });
    };
    function set(dest, source) {
      dest[0] = source[source.length - 2];
      dest[1] = source[source.length - 1];
      return dest;
    }
    exports2.intersects = function(path1, path210) {
      const points1 = gatherPoints(convertRelativeToAbsolute(path1));
      const points2 = gatherPoints(convertRelativeToAbsolute(path210));
      if (points1.maxX <= points2.minX || points2.maxX <= points1.minX || points1.maxY <= points2.minY || points2.maxY <= points1.minY || points1.list.every((set1) => {
        return points2.list.every((set2) => {
          return set1.list[set1.maxX][0] <= set2.list[set2.minX][0] || set2.list[set2.maxX][0] <= set1.list[set1.minX][0] || set1.list[set1.maxY][1] <= set2.list[set2.minY][1] || set2.list[set2.maxY][1] <= set1.list[set1.minY][1];
        });
      }))
        return false;
      const hullNest1 = points1.list.map(convexHull);
      const hullNest2 = points2.list.map(convexHull);
      return hullNest1.some(function(hull1) {
        if (hull1.list.length < 3) return false;
        return hullNest2.some(function(hull2) {
          if (hull2.list.length < 3) return false;
          var simplex = [getSupport(hull1, hull2, [1, 0])], direction = minus(simplex[0]);
          var iterations = 1e4;
          while (true) {
            if (iterations-- == 0) {
              console.error(
                "Error: infinite loop while processing mergePaths plugin."
              );
              return true;
            }
            simplex.push(getSupport(hull1, hull2, direction));
            if (dot(direction, simplex[simplex.length - 1]) <= 0) return false;
            if (processSimplex(simplex, direction)) return true;
          }
        });
      });
      function getSupport(a, b, direction) {
        return sub(supportPoint(a, direction), supportPoint(b, minus(direction)));
      }
      function supportPoint(polygon, direction) {
        var index = direction[1] >= 0 ? direction[0] < 0 ? polygon.maxY : polygon.maxX : direction[0] < 0 ? polygon.minX : polygon.minY, max = -Infinity, value;
        while ((value = dot(polygon.list[index], direction)) > max) {
          max = value;
          index = ++index % polygon.list.length;
        }
        return polygon.list[(index || polygon.list.length) - 1];
      }
    };
    function processSimplex(simplex, direction) {
      if (simplex.length == 2) {
        let a = simplex[1], b = simplex[0], AO = minus(simplex[1]), AB = sub(b, a);
        if (dot(AO, AB) > 0) {
          set(direction, orth(AB, a));
        } else {
          set(direction, AO);
          simplex.shift();
        }
      } else {
        let a = simplex[2], b = simplex[1], c = simplex[0], AB = sub(b, a), AC = sub(c, a), AO = minus(a), ACB = orth(AB, AC), ABC = orth(AC, AB);
        if (dot(ACB, AO) > 0) {
          if (dot(AB, AO) > 0) {
            set(direction, ACB);
            simplex.shift();
          } else {
            set(direction, AO);
            simplex.splice(0, 2);
          }
        } else if (dot(ABC, AO) > 0) {
          if (dot(AC, AO) > 0) {
            set(direction, ABC);
            simplex.splice(1, 1);
          } else {
            set(direction, AO);
            simplex.splice(0, 2);
          }
        } else return true;
      }
      return false;
    }
    function minus(v) {
      return [-v[0], -v[1]];
    }
    function sub(v1, v2) {
      return [v1[0] - v2[0], v1[1] - v2[1]];
    }
    function dot(v1, v2) {
      return v1[0] * v2[0] + v1[1] * v2[1];
    }
    function orth(v, from) {
      var o = [-v[1], v[0]];
      return dot(o, minus(from)) < 0 ? minus(o) : o;
    }
    function gatherPoints(pathData) {
      const points = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
      const addPoint = (path44, point) => {
        if (!path44.list.length || point[1] > path44.list[path44.maxY][1]) {
          path44.maxY = path44.list.length;
          points.maxY = points.list.length ? Math.max(point[1], points.maxY) : point[1];
        }
        if (!path44.list.length || point[0] > path44.list[path44.maxX][0]) {
          path44.maxX = path44.list.length;
          points.maxX = points.list.length ? Math.max(point[0], points.maxX) : point[0];
        }
        if (!path44.list.length || point[1] < path44.list[path44.minY][1]) {
          path44.minY = path44.list.length;
          points.minY = points.list.length ? Math.min(point[1], points.minY) : point[1];
        }
        if (!path44.list.length || point[0] < path44.list[path44.minX][0]) {
          path44.minX = path44.list.length;
          points.minX = points.list.length ? Math.min(point[0], points.minX) : point[0];
        }
        path44.list.push(point);
      };
      for (let i = 0; i < pathData.length; i += 1) {
        const pathDataItem = pathData[i];
        let subPath = points.list.length === 0 ? { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 } : points.list[points.list.length - 1];
        let prev = i === 0 ? null : pathData[i - 1];
        let basePoint = subPath.list.length === 0 ? null : subPath.list[subPath.list.length - 1];
        let data = pathDataItem.args;
        let ctrlPoint = basePoint;
        const toAbsolute = (n, i2) => n + (basePoint == null ? 0 : basePoint[i2 % 2]);
        switch (pathDataItem.command) {
          case "M":
            subPath = { list: [], minX: 0, minY: 0, maxX: 0, maxY: 0 };
            points.list.push(subPath);
            break;
          case "H":
            if (basePoint != null) {
              addPoint(subPath, [data[0], basePoint[1]]);
            }
            break;
          case "V":
            if (basePoint != null) {
              addPoint(subPath, [basePoint[0], data[0]]);
            }
            break;
          case "Q":
            addPoint(subPath, data.slice(0, 2));
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "T":
            if (basePoint != null && prev != null && (prev.command == "Q" || prev.command == "T")) {
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
              addPoint(subPath, ctrlPoint);
              prevCtrlPoint = [data[0] - ctrlPoint[0], data[1] - ctrlPoint[1]];
            }
            break;
          case "C":
            if (basePoint != null) {
              addPoint(subPath, [
                0.5 * (basePoint[0] + data[0]),
                0.5 * (basePoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            addPoint(subPath, [
              0.5 * (data[2] + data[4]),
              0.5 * (data[3] + data[5])
            ]);
            prevCtrlPoint = [data[4] - data[2], data[5] - data[3]];
            break;
          case "S":
            if (basePoint != null && prev != null && (prev.command == "C" || prev.command == "S")) {
              addPoint(subPath, [
                basePoint[0] + 0.5 * prevCtrlPoint[0],
                basePoint[1] + 0.5 * prevCtrlPoint[1]
              ]);
              ctrlPoint = [
                basePoint[0] + prevCtrlPoint[0],
                basePoint[1] + prevCtrlPoint[1]
              ];
            }
            if (ctrlPoint != null) {
              addPoint(subPath, [
                0.5 * (ctrlPoint[0] + data[0]),
                0.5 * (ctrlPoint[1] + data[1])
              ]);
            }
            addPoint(subPath, [
              0.5 * (data[0] + data[2]),
              0.5 * (data[1] + data[3])
            ]);
            prevCtrlPoint = [data[2] - data[0], data[3] - data[1]];
            break;
          case "A":
            if (basePoint != null) {
              var curves = a2c.apply(0, basePoint.concat(data));
              for (var cData; (cData = curves.splice(0, 6).map(toAbsolute)).length; ) {
                if (basePoint != null) {
                  addPoint(subPath, [
                    0.5 * (basePoint[0] + cData[0]),
                    0.5 * (basePoint[1] + cData[1])
                  ]);
                }
                addPoint(subPath, [
                  0.5 * (cData[0] + cData[2]),
                  0.5 * (cData[1] + cData[3])
                ]);
                addPoint(subPath, [
                  0.5 * (cData[2] + cData[4]),
                  0.5 * (cData[3] + cData[5])
                ]);
                if (curves.length) addPoint(subPath, basePoint = cData.slice(-2));
              }
            }
            break;
        }
        if (data.length >= 2) addPoint(subPath, data.slice(-2));
      }
      return points;
    }
    function convexHull(points) {
      points.list.sort(function(a, b) {
        return a[0] == b[0] ? a[1] - b[1] : a[0] - b[0];
      });
      var lower = [], minY = 0, bottom = 0;
      for (let i = 0; i < points.list.length; i++) {
        while (lower.length >= 2 && cross(lower[lower.length - 2], lower[lower.length - 1], points.list[i]) <= 0) {
          lower.pop();
        }
        if (points.list[i][1] < points.list[minY][1]) {
          minY = i;
          bottom = lower.length;
        }
        lower.push(points.list[i]);
      }
      var upper = [], maxY = points.list.length - 1, top = 0;
      for (let i = points.list.length; i--; ) {
        while (upper.length >= 2 && cross(upper[upper.length - 2], upper[upper.length - 1], points.list[i]) <= 0) {
          upper.pop();
        }
        if (points.list[i][1] > points.list[maxY][1]) {
          maxY = i;
          top = upper.length;
        }
        upper.push(points.list[i]);
      }
      upper.pop();
      lower.pop();
      const hullList = lower.concat(upper);
      const hull = {
        list: hullList,
        minX: 0,
        // by sorting
        maxX: lower.length,
        minY: bottom,
        maxY: (lower.length + top) % hullList.length
      };
      return hull;
    }
    function cross(o, a, b) {
      return (a[0] - o[0]) * (b[1] - o[1]) - (a[1] - o[1]) * (b[0] - o[0]);
    }
    var a2c = (x1, y1, rx, ry, angle, large_arc_flag, sweep_flag, x2, y2, recursive) => {
      const _120 = Math.PI * 120 / 180;
      const rad = Math.PI / 180 * (+angle || 0);
      let res = [];
      const rotateX = (x3, y3, rad2) => {
        return x3 * Math.cos(rad2) - y3 * Math.sin(rad2);
      };
      const rotateY = (x3, y3, rad2) => {
        return x3 * Math.sin(rad2) + y3 * Math.cos(rad2);
      };
      if (!recursive) {
        x1 = rotateX(x1, y1, -rad);
        y1 = rotateY(x1, y1, -rad);
        x2 = rotateX(x2, y2, -rad);
        y2 = rotateY(x2, y2, -rad);
        var x = (x1 - x2) / 2, y = (y1 - y2) / 2;
        var h = x * x / (rx * rx) + y * y / (ry * ry);
        if (h > 1) {
          h = Math.sqrt(h);
          rx = h * rx;
          ry = h * ry;
        }
        var rx2 = rx * rx;
        var ry2 = ry * ry;
        var k = (large_arc_flag == sweep_flag ? -1 : 1) * Math.sqrt(
          Math.abs(
            (rx2 * ry2 - rx2 * y * y - ry2 * x * x) / (rx2 * y * y + ry2 * x * x)
          )
        );
        var cx = k * rx * y / ry + (x1 + x2) / 2;
        var cy = k * -ry * x / rx + (y1 + y2) / 2;
        var f1 = Math.asin(Number(((y1 - cy) / ry).toFixed(9)));
        var f2 = Math.asin(Number(((y2 - cy) / ry).toFixed(9)));
        f1 = x1 < cx ? Math.PI - f1 : f1;
        f2 = x2 < cx ? Math.PI - f2 : f2;
        f1 < 0 && (f1 = Math.PI * 2 + f1);
        f2 < 0 && (f2 = Math.PI * 2 + f2);
        if (sweep_flag && f1 > f2) {
          f1 = f1 - Math.PI * 2;
        }
        if (!sweep_flag && f2 > f1) {
          f2 = f2 - Math.PI * 2;
        }
      } else {
        f1 = recursive[0];
        f2 = recursive[1];
        cx = recursive[2];
        cy = recursive[3];
      }
      var df = f2 - f1;
      if (Math.abs(df) > _120) {
        var f2old = f2, x2old = x2, y2old = y2;
        f2 = f1 + _120 * (sweep_flag && f2 > f1 ? 1 : -1);
        x2 = cx + rx * Math.cos(f2);
        y2 = cy + ry * Math.sin(f2);
        res = a2c(x2, y2, rx, ry, angle, 0, sweep_flag, x2old, y2old, [
          f2,
          f2old,
          cx,
          cy
        ]);
      }
      df = f2 - f1;
      var c1 = Math.cos(f1), s1 = Math.sin(f1), c2 = Math.cos(f2), s2 = Math.sin(f2), t2 = Math.tan(df / 4), hx = 4 / 3 * rx * t2, hy = 4 / 3 * ry * t2, m = [
        -hx * s1,
        hy * c1,
        x2 + hx * s2 - x1,
        y2 - hy * c2 - y1,
        x2 - x1,
        y2 - y1
      ];
      if (recursive) {
        return m.concat(res);
      } else {
        res = m.concat(res);
        var newres = [];
        for (var i = 0, n = res.length; i < n; i++) {
          newres[i] = i % 2 ? rotateY(res[i - 1], res[i], rad) : rotateX(res[i], res[i + 1], rad);
        }
        return newres;
      }
    };
  }
});

// node_modules/svgo/plugins/_transforms.js
var require_transforms = __commonJS({
  "node_modules/svgo/plugins/_transforms.js"(exports2) {
    "use strict";
    var { toFixed } = require_tools();
    var transformTypes = /* @__PURE__ */ new Set([
      "matrix",
      "rotate",
      "scale",
      "skewX",
      "skewY",
      "translate"
    ]);
    var regTransformSplit = /\s*(matrix|translate|scale|rotate|skewX|skewY)\s*\(\s*(.+?)\s*\)[\s,]*/;
    var regNumericValues = /[-+]?(?:\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    exports2.transform2js = (transformString) => {
      const transforms = [];
      let currentTransform = null;
      for (const item of transformString.split(regTransformSplit)) {
        if (!item) {
          continue;
        }
        if (transformTypes.has(item)) {
          currentTransform = { name: item, data: [] };
          transforms.push(currentTransform);
        } else {
          let num;
          while (num = regNumericValues.exec(item)) {
            num = Number(num);
            if (currentTransform != null) {
              currentTransform.data.push(num);
            }
          }
        }
      }
      return currentTransform == null || currentTransform.data.length == 0 ? [] : transforms;
    };
    exports2.transformsMultiply = (transforms) => {
      const matrixData = transforms.map((transform) => {
        if (transform.name === "matrix") {
          return transform.data;
        }
        return transformToMatrix(transform);
      });
      const matrixTransform = {
        name: "matrix",
        data: matrixData.length > 0 ? matrixData.reduce(multiplyTransformMatrices) : []
      };
      return matrixTransform;
    };
    var mth = {
      /**
       * @param {number} deg
       * @returns {number}
       */
      rad: (deg) => {
        return deg * Math.PI / 180;
      },
      /**
       * @param {number} rad
       * @returns {number}
       */
      deg: (rad) => {
        return rad * 180 / Math.PI;
      },
      /**
       * @param {number} deg
       * @returns {number}
       */
      cos: (deg) => {
        return Math.cos(mth.rad(deg));
      },
      /**
       * @param {number} val
       * @param {number} floatPrecision
       * @returns {number}
       */
      acos: (val, floatPrecision) => {
        return toFixed(mth.deg(Math.acos(val)), floatPrecision);
      },
      /**
       * @param {number} deg
       * @returns {number}
       */
      sin: (deg) => {
        return Math.sin(mth.rad(deg));
      },
      /**
       * @param {number} val
       * @param {number} floatPrecision
       * @returns {number}
       */
      asin: (val, floatPrecision) => {
        return toFixed(mth.deg(Math.asin(val)), floatPrecision);
      },
      /**
       * @param {number} deg
       * @returns {number}
       */
      tan: (deg) => {
        return Math.tan(mth.rad(deg));
      },
      /**
       * @param {number} val
       * @param {number} floatPrecision
       * @returns {number}
       */
      atan: (val, floatPrecision) => {
        return toFixed(mth.deg(Math.atan(val)), floatPrecision);
      }
    };
    exports2.matrixToTransform = (transform, params) => {
      const floatPrecision = params.floatPrecision;
      const data = transform.data;
      const transforms = [];
      if (data[4] || data[5]) {
        transforms.push({
          name: "translate",
          data: data.slice(4, data[5] ? 6 : 5)
        });
      }
      let sx = toFixed(Math.hypot(data[0], data[1]), params.transformPrecision);
      let sy = toFixed(
        (data[0] * data[3] - data[1] * data[2]) / sx,
        params.transformPrecision
      );
      const colsSum = data[0] * data[2] + data[1] * data[3];
      const rowsSum = data[0] * data[1] + data[2] * data[3];
      const scaleBefore = rowsSum !== 0 || sx === sy;
      if (!data[1] && data[2]) {
        transforms.push({
          name: "skewX",
          data: [mth.atan(data[2] / sy, floatPrecision)]
        });
      } else if (data[1] && !data[2]) {
        transforms.push({
          name: "skewY",
          data: [mth.atan(data[1] / data[0], floatPrecision)]
        });
        sx = data[0];
        sy = data[3];
      } else if (!colsSum || sx === 1 && sy === 1 || !scaleBefore) {
        if (!scaleBefore) {
          sx = Math.hypot(data[0], data[2]);
          sy = Math.hypot(data[1], data[3]);
          if (toFixed(data[0], params.transformPrecision) < 0) {
            sx = -sx;
          }
          if (data[3] < 0 || Math.sign(data[1]) === Math.sign(data[2]) && toFixed(data[3], params.transformPrecision) === 0) {
            sy = -sy;
          }
          transforms.push({ name: "scale", data: [sx, sy] });
        }
        const angle = Math.min(Math.max(-1, data[0] / sx), 1);
        const rotate = [
          mth.acos(angle, floatPrecision) * ((scaleBefore ? 1 : sy) * data[1] < 0 ? -1 : 1)
        ];
        if (rotate[0]) {
          transforms.push({ name: "rotate", data: rotate });
        }
        if (rowsSum && colsSum)
          transforms.push({
            name: "skewX",
            data: [mth.atan(colsSum / (sx * sx), floatPrecision)]
          });
        if (rotate[0] && (data[4] || data[5])) {
          transforms.shift();
          const oneOverCos = 1 - data[0] / sx;
          const sin = data[1] / (scaleBefore ? sx : sy);
          const x = data[4] * (scaleBefore ? 1 : sy);
          const y = data[5] * (scaleBefore ? 1 : sx);
          const denom = (oneOverCos ** 2 + sin ** 2) * (scaleBefore ? 1 : sx * sy);
          rotate.push(
            (oneOverCos * x - sin * y) / denom,
            (oneOverCos * y + sin * x) / denom
          );
        }
      } else if (data[1] || data[2]) {
        return [transform];
      }
      if (scaleBefore && (sx != 1 || sy != 1) || !transforms.length) {
        transforms.push({
          name: "scale",
          data: sx == sy ? [sx] : [sx, sy]
        });
      }
      return transforms;
    };
    var transformToMatrix = (transform) => {
      if (transform.name === "matrix") {
        return transform.data;
      }
      switch (transform.name) {
        case "translate":
          return [1, 0, 0, 1, transform.data[0], transform.data[1] || 0];
        case "scale":
          return [
            transform.data[0],
            0,
            0,
            transform.data[1] || transform.data[0],
            0,
            0
          ];
        case "rotate":
          var cos = mth.cos(transform.data[0]), sin = mth.sin(transform.data[0]), cx = transform.data[1] || 0, cy = transform.data[2] || 0;
          return [
            cos,
            sin,
            -sin,
            cos,
            (1 - cos) * cx + sin * cy,
            (1 - cos) * cy - sin * cx
          ];
        case "skewX":
          return [1, 0, mth.tan(transform.data[0]), 1, 0, 0];
        case "skewY":
          return [1, mth.tan(transform.data[0]), 0, 1, 0, 0];
        default:
          throw Error(`Unknown transform ${transform.name}`);
      }
    };
    exports2.transformArc = (cursor, arc, transform) => {
      const x = arc[5] - cursor[0];
      const y = arc[6] - cursor[1];
      let a = arc[0];
      let b = arc[1];
      const rot = arc[2] * Math.PI / 180;
      const cos = Math.cos(rot);
      const sin = Math.sin(rot);
      if (a > 0 && b > 0) {
        let h = Math.pow(x * cos + y * sin, 2) / (4 * a * a) + Math.pow(y * cos - x * sin, 2) / (4 * b * b);
        if (h > 1) {
          h = Math.sqrt(h);
          a *= h;
          b *= h;
        }
      }
      const ellipse = [a * cos, a * sin, -b * sin, b * cos, 0, 0];
      const m = multiplyTransformMatrices(transform, ellipse);
      const lastCol = m[2] * m[2] + m[3] * m[3];
      const squareSum = m[0] * m[0] + m[1] * m[1] + lastCol;
      const root = Math.hypot(m[0] - m[3], m[1] + m[2]) * Math.hypot(m[0] + m[3], m[1] - m[2]);
      if (!root) {
        arc[0] = arc[1] = Math.sqrt(squareSum / 2);
        arc[2] = 0;
      } else {
        const majorAxisSqr = (squareSum + root) / 2;
        const minorAxisSqr = (squareSum - root) / 2;
        const major = Math.abs(majorAxisSqr - lastCol) > 1e-6;
        const sub = (major ? majorAxisSqr : minorAxisSqr) - lastCol;
        const rowsSum = m[0] * m[2] + m[1] * m[3];
        const term1 = m[0] * sub + m[2] * rowsSum;
        const term2 = m[1] * sub + m[3] * rowsSum;
        arc[0] = Math.sqrt(majorAxisSqr);
        arc[1] = Math.sqrt(minorAxisSqr);
        arc[2] = ((major ? term2 < 0 : term1 > 0) ? -1 : 1) * Math.acos((major ? term1 : term2) / Math.hypot(term1, term2)) * 180 / Math.PI;
      }
      if (transform[0] < 0 !== transform[3] < 0) {
        arc[4] = 1 - arc[4];
      }
      return arc;
    };
    var multiplyTransformMatrices = (a, b) => {
      return [
        a[0] * b[0] + a[2] * b[1],
        a[1] * b[0] + a[3] * b[1],
        a[0] * b[2] + a[2] * b[3],
        a[1] * b[2] + a[3] * b[3],
        a[0] * b[4] + a[2] * b[5] + a[4],
        a[1] * b[4] + a[3] * b[5] + a[5]
      ];
    };
  }
});

// node_modules/svgo/plugins/applyTransforms.js
var require_applyTransforms = __commonJS({
  "node_modules/svgo/plugins/applyTransforms.js"(exports2) {
    "use strict";
    var { collectStylesheet, computeStyle } = require_style();
    var {
      transformsMultiply,
      transform2js,
      transformArc
    } = require_transforms();
    var { path2js } = require_path2();
    var {
      removeLeadingZero,
      includesUrlReference
    } = require_tools();
    var { referencesProps, attrsGroupsDefaults } = require_collections();
    var regNumericValues = /[-+]?(\d*\.\d+|\d+\.?)(?:[eE][-+]?\d+)?/g;
    var applyTransforms = (root, params) => {
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            if (node.attributes.d == null) {
              return;
            }
            if (node.attributes.id != null) {
              return;
            }
            if (node.attributes.transform == null || node.attributes.transform === "" || // styles are not considered when applying transform
            // can be fixed properly with new style engine
            node.attributes.style != null || Object.entries(node.attributes).some(
              ([name, value]) => referencesProps.has(name) && includesUrlReference(value)
            )) {
              return;
            }
            const computedStyle = computeStyle(stylesheet, node);
            const transformStyle = computedStyle.transform;
            if (transformStyle.type === "static" && transformStyle.value !== node.attributes.transform) {
              return;
            }
            const matrix = transformsMultiply(
              transform2js(node.attributes.transform)
            );
            const stroke = computedStyle.stroke?.type === "static" ? computedStyle.stroke.value : null;
            const strokeWidth = computedStyle["stroke-width"]?.type === "static" ? computedStyle["stroke-width"].value : null;
            const transformPrecision = params.transformPrecision;
            if (computedStyle.stroke?.type === "dynamic" || computedStyle["stroke-width"]?.type === "dynamic") {
              return;
            }
            const scale = Number(
              Math.sqrt(
                matrix.data[0] * matrix.data[0] + matrix.data[1] * matrix.data[1]
              ).toFixed(transformPrecision)
            );
            if (stroke && stroke != "none") {
              if (!params.applyTransformsStroked) {
                return;
              }
              if ((matrix.data[0] !== matrix.data[3] || matrix.data[1] !== -matrix.data[2]) && (matrix.data[0] !== -matrix.data[3] || matrix.data[1] !== matrix.data[2])) {
                return;
              }
              if (scale !== 1) {
                if (node.attributes["vector-effect"] !== "non-scaling-stroke") {
                  node.attributes["stroke-width"] = (strokeWidth || attrsGroupsDefaults.presentation["stroke-width"]).trim().replace(
                    regNumericValues,
                    (num) => removeLeadingZero(Number(num) * scale)
                  );
                  if (node.attributes["stroke-dashoffset"] != null) {
                    node.attributes["stroke-dashoffset"] = node.attributes["stroke-dashoffset"].trim().replace(
                      regNumericValues,
                      (num) => removeLeadingZero(Number(num) * scale)
                    );
                  }
                  if (node.attributes["stroke-dasharray"] != null) {
                    node.attributes["stroke-dasharray"] = node.attributes["stroke-dasharray"].trim().replace(
                      regNumericValues,
                      (num) => removeLeadingZero(Number(num) * scale)
                    );
                  }
                }
              }
            }
            const pathData = path2js(node);
            applyMatrixToPathData(pathData, matrix.data);
            delete node.attributes.transform;
          }
        }
      };
    };
    exports2.applyTransforms = applyTransforms;
    var transformAbsolutePoint = (matrix, x, y) => {
      const newX = matrix[0] * x + matrix[2] * y + matrix[4];
      const newY = matrix[1] * x + matrix[3] * y + matrix[5];
      return [newX, newY];
    };
    var transformRelativePoint = (matrix, x, y) => {
      const newX = matrix[0] * x + matrix[2] * y;
      const newY = matrix[1] * x + matrix[3] * y;
      return [newX, newY];
    };
    var applyMatrixToPathData = (pathData, matrix) => {
      const start = [0, 0];
      const cursor = [0, 0];
      for (const pathItem of pathData) {
        let { command, args } = pathItem;
        if (command === "M") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "H") {
          command = "L";
          args = [args[0], cursor[1]];
        }
        if (command === "h") {
          command = "l";
          args = [args[0], 0];
        }
        if (command === "V") {
          command = "L";
          args = [cursor[0], args[0]];
        }
        if (command === "v") {
          command = "l";
          args = [0, args[0]];
        }
        if (command === "L") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "C") {
          cursor[0] = args[4];
          cursor[1] = args[5];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformAbsolutePoint(matrix, args[2], args[3]);
          const [x, y] = transformAbsolutePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x;
          args[5] = y;
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x2, y2] = transformRelativePoint(matrix, args[2], args[3]);
          const [x, y] = transformRelativePoint(matrix, args[4], args[5]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x2;
          args[3] = y2;
          args[4] = x;
          args[5] = y;
        }
        if (command === "S") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x2, y2] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x;
          args[3] = y;
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x2, y2] = transformRelativePoint(matrix, args[0], args[1]);
          const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x2;
          args[1] = y2;
          args[2] = x;
          args[3] = y;
        }
        if (command === "Q") {
          cursor[0] = args[2];
          cursor[1] = args[3];
          const [x1, y1] = transformAbsolutePoint(matrix, args[0], args[1]);
          const [x, y] = transformAbsolutePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x;
          args[3] = y;
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
          const [x1, y1] = transformRelativePoint(matrix, args[0], args[1]);
          const [x, y] = transformRelativePoint(matrix, args[2], args[3]);
          args[0] = x1;
          args[1] = y1;
          args[2] = x;
          args[3] = y;
        }
        if (command === "T") {
          cursor[0] = args[0];
          cursor[1] = args[1];
          const [x, y] = transformAbsolutePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          const [x, y] = transformRelativePoint(matrix, args[0], args[1]);
          args[0] = x;
          args[1] = y;
        }
        if (command === "A") {
          transformArc(cursor, args, matrix);
          cursor[0] = args[5];
          cursor[1] = args[6];
          if (Math.abs(args[2]) > 80) {
            const a = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x, y] = transformAbsolutePoint(matrix, args[5], args[6]);
          args[5] = x;
          args[6] = y;
        }
        if (command === "a") {
          transformArc([0, 0], args, matrix);
          cursor[0] += args[5];
          cursor[1] += args[6];
          if (Math.abs(args[2]) > 80) {
            const a = args[0];
            const rotation = args[2];
            args[0] = args[1];
            args[1] = a;
            args[2] = rotation + (rotation > 0 ? -90 : 90);
          }
          const [x, y] = transformRelativePoint(matrix, args[5], args[6]);
          args[5] = x;
          args[6] = y;
        }
        if (command === "z" || command === "Z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
      }
    };
  }
});

// node_modules/svgo/plugins/convertPathData.js
var require_convertPathData = __commonJS({
  "node_modules/svgo/plugins/convertPathData.js"(exports2) {
    "use strict";
    var { collectStylesheet, computeStyle } = require_style();
    var { visit } = require_xast();
    var { pathElems } = require_collections();
    var { path2js, js2path } = require_path2();
    var { applyTransforms } = require_applyTransforms();
    var { cleanupOutData, toFixed } = require_tools();
    exports2.name = "convertPathData";
    exports2.description = "optimizes path data: writes in shorter form, applies transformations";
    var roundData;
    var precision;
    var error;
    var arcThreshold;
    var arcTolerance;
    exports2.fn = (root, params) => {
      const {
        // TODO convert to separate plugin in v3
        applyTransforms: _applyTransforms = true,
        applyTransformsStroked = true,
        makeArcs = {
          threshold: 2.5,
          // coefficient of rounding error
          tolerance: 0.5
          // percentage of radius
        },
        straightCurves = true,
        convertToQ = true,
        lineShorthands = true,
        convertToZ = true,
        curveSmoothShorthands = true,
        floatPrecision = 3,
        transformPrecision = 5,
        smartArcRounding = true,
        removeUseless = true,
        collapseRepeated = true,
        utilizeAbsolute = true,
        leadingZero = true,
        negativeExtraSpace = true,
        noSpaceAfterFlags = false,
        // a20 60 45 0 1 30 20  a20 60 45 0130 20
        forceAbsolutePath = false
      } = params;
      const newParams = {
        applyTransforms: _applyTransforms,
        applyTransformsStroked,
        makeArcs,
        straightCurves,
        convertToQ,
        lineShorthands,
        convertToZ,
        curveSmoothShorthands,
        floatPrecision,
        transformPrecision,
        smartArcRounding,
        removeUseless,
        collapseRepeated,
        utilizeAbsolute,
        leadingZero,
        negativeExtraSpace,
        noSpaceAfterFlags,
        forceAbsolutePath
      };
      if (_applyTransforms) {
        visit(
          root,
          // @ts-ignore
          applyTransforms(root, {
            transformPrecision,
            applyTransformsStroked
          })
        );
      }
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            if (pathElems.has(node.name) && node.attributes.d != null) {
              const computedStyle = computeStyle(stylesheet, node);
              precision = floatPrecision;
              error = precision !== false ? +Math.pow(0.1, precision).toFixed(precision) : 0.01;
              roundData = precision && precision > 0 && precision < 20 ? strongRound : round;
              if (makeArcs) {
                arcThreshold = makeArcs.threshold;
                arcTolerance = makeArcs.tolerance;
              }
              const hasMarkerMid = computedStyle["marker-mid"] != null;
              const maybeHasStroke = computedStyle.stroke && (computedStyle.stroke.type === "dynamic" || computedStyle.stroke.value !== "none");
              const maybeHasLinecap = computedStyle["stroke-linecap"] && (computedStyle["stroke-linecap"].type === "dynamic" || computedStyle["stroke-linecap"].value !== "butt");
              const maybeHasStrokeAndLinecap = maybeHasStroke && maybeHasLinecap;
              const isSafeToUseZ = maybeHasStroke ? computedStyle["stroke-linecap"]?.type === "static" && computedStyle["stroke-linecap"].value === "round" && computedStyle["stroke-linejoin"]?.type === "static" && computedStyle["stroke-linejoin"].value === "round" : true;
              var data = path2js(node);
              if (data.length) {
                convertToRelative(data);
                data = filters(data, newParams, {
                  isSafeToUseZ,
                  maybeHasStrokeAndLinecap,
                  hasMarkerMid
                });
                if (utilizeAbsolute) {
                  data = convertToMixed(data, newParams);
                }
                js2path(node, data, newParams);
              }
            }
          }
        }
      };
    };
    var convertToRelative = (pathData) => {
      let start = [0, 0];
      let cursor = [0, 0];
      let prevCoords = [0, 0];
      for (let i = 0; i < pathData.length; i += 1) {
        const pathItem = pathData[i];
        let { command, args } = pathItem;
        if (command === "m") {
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "M") {
          if (i !== 0) {
            command = "m";
          }
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
          start[0] = cursor[0];
          start[1] = cursor[1];
        }
        if (command === "l") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "L") {
          command = "l";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "h") {
          cursor[0] += args[0];
        }
        if (command === "H") {
          command = "h";
          args[0] -= cursor[0];
          cursor[0] += args[0];
        }
        if (command === "v") {
          cursor[1] += args[0];
        }
        if (command === "V") {
          command = "v";
          args[0] -= cursor[1];
          cursor[1] += args[0];
        }
        if (command === "c") {
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "C") {
          command = "c";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          args[4] -= cursor[0];
          args[5] -= cursor[1];
          cursor[0] += args[4];
          cursor[1] += args[5];
        }
        if (command === "s") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "S") {
          command = "s";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "q") {
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "Q") {
          command = "q";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          args[2] -= cursor[0];
          args[3] -= cursor[1];
          cursor[0] += args[2];
          cursor[1] += args[3];
        }
        if (command === "t") {
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "T") {
          command = "t";
          args[0] -= cursor[0];
          args[1] -= cursor[1];
          cursor[0] += args[0];
          cursor[1] += args[1];
        }
        if (command === "a") {
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "A") {
          command = "a";
          args[5] -= cursor[0];
          args[6] -= cursor[1];
          cursor[0] += args[5];
          cursor[1] += args[6];
        }
        if (command === "Z" || command === "z") {
          cursor[0] = start[0];
          cursor[1] = start[1];
        }
        pathItem.command = command;
        pathItem.args = args;
        pathItem.base = prevCoords;
        pathItem.coords = [cursor[0], cursor[1]];
        prevCoords = pathItem.coords;
      }
      return pathData;
    };
    function filters(path44, params, { isSafeToUseZ, maybeHasStrokeAndLinecap, hasMarkerMid }) {
      const stringify = data2Path.bind(null, params);
      const relSubpoint = [0, 0];
      const pathBase = [0, 0];
      let prev = {};
      let prevQControlPoint;
      path44 = path44.filter(function(item, index, path45) {
        const qControlPoint = prevQControlPoint;
        prevQControlPoint = void 0;
        let command = item.command;
        let data = item.args;
        let next = path45[index + 1];
        if (command !== "Z" && command !== "z") {
          var sdata = data, circle;
          if (command === "s") {
            sdata = [0, 0].concat(data);
            const pdata = prev.args;
            const n = pdata.length;
            sdata[0] = pdata[n - 2] - pdata[n - 4];
            sdata[1] = pdata[n - 1] - pdata[n - 3];
          }
          if (params.makeArcs && (command == "c" || command == "s") && isConvex(sdata) && (circle = findCircle(sdata))) {
            var r = roundData([circle.radius])[0], angle = findArcAngle(sdata, circle), sweep = sdata[5] * sdata[0] - sdata[4] * sdata[1] > 0 ? 1 : 0, arc = {
              command: "a",
              args: [r, r, 0, 0, sweep, sdata[4], sdata[5]],
              // @ts-ignore
              coords: item.coords.slice(),
              // @ts-ignore
              base: item.base
            }, output = [arc], relCenter = [
              circle.center[0] - sdata[4],
              circle.center[1] - sdata[5]
            ], relCircle = { center: relCenter, radius: circle.radius }, arcCurves = [item], hasPrev = 0, suffix = "", nextLonghand;
            if (prev.command == "c" && isConvex(prev.args) && isArcPrev(prev.args, circle) || prev.command == "a" && prev.sdata && isArcPrev(prev.sdata, circle)) {
              arcCurves.unshift(prev);
              arc.base = prev.base;
              arc.args[5] = arc.coords[0] - arc.base[0];
              arc.args[6] = arc.coords[1] - arc.base[1];
              var prevData = prev.command == "a" ? prev.sdata : prev.args;
              var prevAngle = findArcAngle(prevData, {
                center: [
                  prevData[4] + circle.center[0],
                  prevData[5] + circle.center[1]
                ],
                radius: circle.radius
              });
              angle += prevAngle;
              if (angle > Math.PI) arc.args[3] = 1;
              hasPrev = 1;
            }
            for (var j = index; (next = path45[++j]) && (next.command === "c" || next.command === "s"); ) {
              var nextData = next.args;
              if (next.command == "s") {
                nextLonghand = makeLonghand(
                  { command: "s", args: next.args.slice() },
                  path45[j - 1].args
                );
                nextData = nextLonghand.args;
                nextLonghand.args = nextData.slice(0, 2);
                suffix = stringify([nextLonghand]);
              }
              if (isConvex(nextData) && isArc(nextData, relCircle)) {
                angle += findArcAngle(nextData, relCircle);
                if (angle - 2 * Math.PI > 1e-3) break;
                if (angle > Math.PI) arc.args[3] = 1;
                arcCurves.push(next);
                if (2 * Math.PI - angle > 1e-3) {
                  arc.coords = next.coords;
                  arc.args[5] = arc.coords[0] - arc.base[0];
                  arc.args[6] = arc.coords[1] - arc.base[1];
                } else {
                  arc.args[5] = 2 * (relCircle.center[0] - nextData[4]);
                  arc.args[6] = 2 * (relCircle.center[1] - nextData[5]);
                  arc.coords = [
                    // @ts-ignore
                    arc.base[0] + arc.args[5],
                    // @ts-ignore
                    arc.base[1] + arc.args[6]
                  ];
                  arc = {
                    command: "a",
                    args: [
                      r,
                      r,
                      0,
                      0,
                      sweep,
                      // @ts-ignore
                      next.coords[0] - arc.coords[0],
                      // @ts-ignore
                      next.coords[1] - arc.coords[1]
                    ],
                    // @ts-ignore
                    coords: next.coords,
                    // @ts-ignore
                    base: arc.coords
                  };
                  output.push(arc);
                  j++;
                  break;
                }
                relCenter[0] -= nextData[4];
                relCenter[1] -= nextData[5];
              } else break;
            }
            if ((stringify(output) + suffix).length < stringify(arcCurves).length) {
              if (path45[j] && path45[j].command == "s") {
                makeLonghand(path45[j], path45[j - 1].args);
              }
              if (hasPrev) {
                var prevArc = output.shift();
                roundData(prevArc.args);
                relSubpoint[0] += prevArc.args[5] - prev.args[prev.args.length - 2];
                relSubpoint[1] += prevArc.args[6] - prev.args[prev.args.length - 1];
                prev.command = "a";
                prev.args = prevArc.args;
                item.base = prev.coords = prevArc.coords;
              }
              arc = output.shift();
              if (arcCurves.length == 1) {
                item.sdata = sdata.slice();
              } else if (arcCurves.length - 1 - hasPrev > 0) {
                path45.splice(index + 1, arcCurves.length - 1 - hasPrev, ...output);
              }
              if (!arc) return false;
              command = "a";
              data = arc.args;
              item.coords = arc.coords;
            }
          }
          if (precision !== false) {
            if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
              for (var i = data.length; i--; ) {
                data[i] += item.base[i % 2] - relSubpoint[i % 2];
              }
            } else if (command == "h") {
              data[0] += item.base[0] - relSubpoint[0];
            } else if (command == "v") {
              data[0] += item.base[1] - relSubpoint[1];
            } else if (command == "a") {
              data[5] += item.base[0] - relSubpoint[0];
              data[6] += item.base[1] - relSubpoint[1];
            }
            roundData(data);
            if (command == "h") relSubpoint[0] += data[0];
            else if (command == "v") relSubpoint[1] += data[0];
            else {
              relSubpoint[0] += data[data.length - 2];
              relSubpoint[1] += data[data.length - 1];
            }
            roundData(relSubpoint);
            if (command === "M" || command === "m") {
              pathBase[0] = relSubpoint[0];
              pathBase[1] = relSubpoint[1];
            }
          }
          const sagitta = command === "a" ? calculateSagitta(data) : void 0;
          if (params.smartArcRounding && sagitta !== void 0 && precision) {
            for (let precisionNew = precision; precisionNew >= 0; precisionNew--) {
              const radius = toFixed(data[0], precisionNew);
              const sagittaNew = (
                /** @type {number} */
                calculateSagitta([radius, radius, ...data.slice(2)])
              );
              if (Math.abs(sagitta - sagittaNew) < error) {
                data[0] = radius;
                data[1] = radius;
              } else {
                break;
              }
            }
          }
          if (params.straightCurves) {
            if (command === "c" && isCurveStraightLine(data) || command === "s" && isCurveStraightLine(sdata)) {
              if (next && next.command == "s") makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "q" && isCurveStraightLine(data)) {
              if (next && next.command == "t") makeLonghand(next, data);
              command = "l";
              data = data.slice(-2);
            } else if (command === "t" && prev.command !== "q" && prev.command !== "t") {
              command = "l";
              data = data.slice(-2);
            } else if (command === "a" && (data[0] === 0 || data[1] === 0 || sagitta !== void 0 && sagitta < error)) {
              command = "l";
              data = data.slice(-2);
            }
          }
          if (params.convertToQ && command == "c") {
            const x1 = (
              // @ts-ignore
              0.75 * (item.base[0] + data[0]) - 0.25 * item.base[0]
            );
            const x2 = (
              // @ts-ignore
              0.75 * (item.base[0] + data[2]) - 0.25 * (item.base[0] + data[4])
            );
            if (Math.abs(x1 - x2) < error * 2) {
              const y1 = (
                // @ts-ignore
                0.75 * (item.base[1] + data[1]) - 0.25 * item.base[1]
              );
              const y2 = (
                // @ts-ignore
                0.75 * (item.base[1] + data[3]) - 0.25 * (item.base[1] + data[5])
              );
              if (Math.abs(y1 - y2) < error * 2) {
                const newData = data.slice();
                newData.splice(
                  0,
                  4,
                  // @ts-ignore
                  x1 + x2 - item.base[0],
                  // @ts-ignore
                  y1 + y2 - item.base[1]
                );
                roundData(newData);
                const originalLength = cleanupOutData(data, params).length, newLength = cleanupOutData(newData, params).length;
                if (newLength < originalLength) {
                  command = "q";
                  data = newData;
                  if (next && next.command == "s") makeLonghand(next, data);
                }
              }
            }
          }
          if (params.lineShorthands && command === "l") {
            if (data[1] === 0) {
              command = "h";
              data.pop();
            } else if (data[0] === 0) {
              command = "v";
              data.shift();
            }
          }
          if (params.collapseRepeated && hasMarkerMid === false && (command === "m" || command === "h" || command === "v") && prev.command && command == prev.command.toLowerCase() && (command != "h" && command != "v" || prev.args[0] >= 0 == data[0] >= 0)) {
            prev.args[0] += data[0];
            if (command != "h" && command != "v") {
              prev.args[1] += data[1];
            }
            prev.coords = item.coords;
            path45[index] = prev;
            return false;
          }
          if (params.curveSmoothShorthands && prev.command) {
            if (command === "c") {
              if (prev.command === "c" && Math.abs(data[0] - -(prev.args[2] - prev.args[4])) < error && Math.abs(data[1] - -(prev.args[3] - prev.args[5])) < error) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command === "s" && Math.abs(data[0] - -(prev.args[0] - prev.args[2])) < error && Math.abs(data[1] - -(prev.args[1] - prev.args[3])) < error) {
                command = "s";
                data = data.slice(2);
              } else if (prev.command !== "c" && prev.command !== "s" && Math.abs(data[0]) < error && Math.abs(data[1]) < error) {
                command = "s";
                data = data.slice(2);
              }
            } else if (command === "q") {
              if (prev.command === "q" && Math.abs(data[0] - (prev.args[2] - prev.args[0])) < error && Math.abs(data[1] - (prev.args[3] - prev.args[1])) < error) {
                command = "t";
                data = data.slice(2);
              } else if (prev.command === "t") {
                const predictedControlPoint = reflectPoint(
                  // @ts-ignore
                  qControlPoint,
                  // @ts-ignore
                  item.base
                );
                const realControlPoint = [
                  // @ts-ignore
                  data[0] + item.base[0],
                  // @ts-ignore
                  data[1] + item.base[1]
                ];
                if (Math.abs(predictedControlPoint[0] - realControlPoint[0]) < error && Math.abs(predictedControlPoint[1] - realControlPoint[1]) < error) {
                  command = "t";
                  data = data.slice(2);
                }
              }
            }
          }
          if (params.removeUseless && !maybeHasStrokeAndLinecap) {
            if ((command === "l" || command === "h" || command === "v" || command === "q" || command === "t" || command === "c" || command === "s") && data.every(function(i2) {
              return i2 === 0;
            })) {
              path45[index] = prev;
              return false;
            }
            if (command === "a" && data[5] === 0 && data[6] === 0) {
              path45[index] = prev;
              return false;
            }
          }
          if (params.convertToZ && (isSafeToUseZ || next?.command === "Z" || next?.command === "z") && (command === "l" || command === "h" || command === "v")) {
            if (
              // @ts-ignore
              Math.abs(pathBase[0] - item.coords[0]) < error && // @ts-ignore
              Math.abs(pathBase[1] - item.coords[1]) < error
            ) {
              command = "z";
              data = [];
            }
          }
          item.command = command;
          item.args = data;
        } else {
          relSubpoint[0] = pathBase[0];
          relSubpoint[1] = pathBase[1];
          if (prev.command === "Z" || prev.command === "z") return false;
        }
        if ((command === "Z" || command === "z") && params.removeUseless && isSafeToUseZ && // @ts-ignore
        Math.abs(item.base[0] - item.coords[0]) < error / 10 && // @ts-ignore
        Math.abs(item.base[1] - item.coords[1]) < error / 10)
          return false;
        if (command === "q") {
          prevQControlPoint = [data[0] + item.base[0], data[1] + item.base[1]];
        } else if (command === "t") {
          if (qControlPoint) {
            prevQControlPoint = reflectPoint(qControlPoint, item.base);
          } else {
            prevQControlPoint = item.coords;
          }
        }
        prev = item;
        return true;
      });
      return path44;
    }
    function convertToMixed(path44, params) {
      var prev = path44[0];
      path44 = path44.filter(function(item, index) {
        if (index == 0) return true;
        if (item.command === "Z" || item.command === "z") {
          prev = item;
          return true;
        }
        var command = item.command, data = item.args, adata = data.slice(), rdata = data.slice();
        if (command === "m" || command === "l" || command === "t" || command === "q" || command === "s" || command === "c") {
          for (var i = adata.length; i--; ) {
            adata[i] += item.base[i % 2];
          }
        } else if (command == "h") {
          adata[0] += item.base[0];
        } else if (command == "v") {
          adata[0] += item.base[1];
        } else if (command == "a") {
          adata[5] += item.base[0];
          adata[6] += item.base[1];
        }
        roundData(adata);
        roundData(rdata);
        var absoluteDataStr = cleanupOutData(adata, params), relativeDataStr = cleanupOutData(rdata, params);
        if (params.forceAbsolutePath || absoluteDataStr.length < relativeDataStr.length && !(params.negativeExtraSpace && command == prev.command && prev.command.charCodeAt(0) > 96 && absoluteDataStr.length == relativeDataStr.length - 1 && (data[0] < 0 || Math.floor(data[0]) === 0 && !Number.isInteger(data[0]) && prev.args[prev.args.length - 1] % 1))) {
          item.command = command.toUpperCase();
          item.args = adata;
        }
        prev = item;
        return true;
      });
      return path44;
    }
    function isConvex(data) {
      var center = getIntersection([
        0,
        0,
        data[2],
        data[3],
        data[0],
        data[1],
        data[4],
        data[5]
      ]);
      return center != null && data[2] < center[0] == center[0] < 0 && data[3] < center[1] == center[1] < 0 && data[4] < center[0] == center[0] < data[0] && data[5] < center[1] == center[1] < data[1];
    }
    function getIntersection(coords) {
      var a1 = coords[1] - coords[3], b1 = coords[2] - coords[0], c1 = coords[0] * coords[3] - coords[2] * coords[1], a2 = coords[5] - coords[7], b2 = coords[6] - coords[4], c2 = coords[4] * coords[7] - coords[5] * coords[6], denom = a1 * b2 - a2 * b1;
      if (!denom) return;
      var cross = [(b1 * c2 - b2 * c1) / denom, (a1 * c2 - a2 * c1) / -denom];
      if (!isNaN(cross[0]) && !isNaN(cross[1]) && isFinite(cross[0]) && isFinite(cross[1])) {
        return cross;
      }
    }
    function strongRound(data) {
      const precisionNum = precision || 0;
      for (let i = data.length; i-- > 0; ) {
        const fixed = toFixed(data[i], precisionNum);
        if (fixed !== data[i]) {
          const rounded = toFixed(data[i], precisionNum - 1);
          data[i] = toFixed(Math.abs(rounded - data[i]), precisionNum + 1) >= error ? fixed : rounded;
        }
      }
      return data;
    }
    function round(data) {
      for (var i = data.length; i-- > 0; ) {
        data[i] = Math.round(data[i]);
      }
      return data;
    }
    function isCurveStraightLine(data) {
      var i = data.length - 2, a = -data[i + 1], b = data[i], d = 1 / (a * a + b * b);
      if (i <= 1 || !isFinite(d)) return false;
      while ((i -= 2) >= 0) {
        if (Math.sqrt(Math.pow(a * data[i] + b * data[i + 1], 2) * d) > error)
          return false;
      }
      return true;
    }
    function calculateSagitta(data) {
      if (data[3] === 1) return void 0;
      const [rx, ry] = data;
      if (Math.abs(rx - ry) > error) return void 0;
      const chord = Math.sqrt(data[5] ** 2 + data[6] ** 2);
      if (chord > rx * 2) return void 0;
      return rx - Math.sqrt(rx ** 2 - 0.25 * chord ** 2);
    }
    function makeLonghand(item, data) {
      switch (item.command) {
        case "s":
          item.command = "c";
          break;
        case "t":
          item.command = "q";
          break;
      }
      item.args.unshift(
        data[data.length - 2] - data[data.length - 4],
        data[data.length - 1] - data[data.length - 3]
      );
      return item;
    }
    function getDistance(point1, point2) {
      return Math.sqrt((point1[0] - point2[0]) ** 2 + (point1[1] - point2[1]) ** 2);
    }
    function reflectPoint(controlPoint, base) {
      return [2 * base[0] - controlPoint[0], 2 * base[1] - controlPoint[1]];
    }
    function getCubicBezierPoint(curve, t2) {
      var sqrT = t2 * t2, cubT = sqrT * t2, mt = 1 - t2, sqrMt = mt * mt;
      return [
        3 * sqrMt * t2 * curve[0] + 3 * mt * sqrT * curve[2] + cubT * curve[4],
        3 * sqrMt * t2 * curve[1] + 3 * mt * sqrT * curve[3] + cubT * curve[5]
      ];
    }
    function findCircle(curve) {
      var midPoint = getCubicBezierPoint(curve, 1 / 2), m1 = [midPoint[0] / 2, midPoint[1] / 2], m2 = [(midPoint[0] + curve[4]) / 2, (midPoint[1] + curve[5]) / 2], center = getIntersection([
        m1[0],
        m1[1],
        m1[0] + m1[1],
        m1[1] - m1[0],
        m2[0],
        m2[1],
        m2[0] + (m2[1] - midPoint[1]),
        m2[1] - (m2[0] - midPoint[0])
      ]), radius = center && getDistance([0, 0], center), tolerance = Math.min(arcThreshold * error, arcTolerance * radius / 100);
      if (center && // @ts-ignore
      radius < 1e15 && [1 / 4, 3 / 4].every(function(point) {
        return Math.abs(
          // @ts-ignore
          getDistance(getCubicBezierPoint(curve, point), center) - radius
        ) <= tolerance;
      }))
        return { center, radius };
    }
    function isArc(curve, circle) {
      var tolerance = Math.min(
        arcThreshold * error,
        arcTolerance * circle.radius / 100
      );
      return [0, 1 / 4, 1 / 2, 3 / 4, 1].every(function(point) {
        return Math.abs(
          getDistance(getCubicBezierPoint(curve, point), circle.center) - circle.radius
        ) <= tolerance;
      });
    }
    function isArcPrev(curve, circle) {
      return isArc(curve, {
        center: [circle.center[0] + curve[4], circle.center[1] + curve[5]],
        radius: circle.radius
      });
    }
    function findArcAngle(curve, relCircle) {
      var x1 = -relCircle.center[0], y1 = -relCircle.center[1], x2 = curve[4] - relCircle.center[0], y2 = curve[5] - relCircle.center[1];
      return Math.acos(
        (x1 * x2 + y1 * y2) / Math.sqrt((x1 * x1 + y1 * y1) * (x2 * x2 + y2 * y2))
      );
    }
    function data2Path(params, pathData) {
      return pathData.reduce(function(pathString, item) {
        var strData = "";
        if (item.args) {
          strData = cleanupOutData(roundData(item.args.slice()), params);
        }
        return pathString + item.command + strData;
      }, "");
    }
  }
});

// node_modules/svgo/plugins/convertTransform.js
var require_convertTransform = __commonJS({
  "node_modules/svgo/plugins/convertTransform.js"(exports2) {
    "use strict";
    var { cleanupOutData, toFixed } = require_tools();
    var {
      transform2js,
      transformsMultiply,
      matrixToTransform
    } = require_transforms();
    exports2.name = "convertTransform";
    exports2.description = "collapses multiple transformations and optimizes it";
    exports2.fn = (_root, params) => {
      const {
        convertToShorts: convertToShorts2 = true,
        // degPrecision = 3, // transformPrecision (or matrix precision) - 2 by default
        degPrecision,
        floatPrecision = 3,
        transformPrecision = 5,
        matrixToTransform: matrixToTransform2 = true,
        shortTranslate = true,
        shortScale = true,
        shortRotate = true,
        removeUseless: removeUseless2 = true,
        collapseIntoOne = true,
        leadingZero = true,
        negativeExtraSpace = false
      } = params;
      const newParams = {
        convertToShorts: convertToShorts2,
        degPrecision,
        floatPrecision,
        transformPrecision,
        matrixToTransform: matrixToTransform2,
        shortTranslate,
        shortScale,
        shortRotate,
        removeUseless: removeUseless2,
        collapseIntoOne,
        leadingZero,
        negativeExtraSpace
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.transform != null) {
              convertTransform(node, "transform", newParams);
            }
            if (node.attributes.gradientTransform != null) {
              convertTransform(node, "gradientTransform", newParams);
            }
            if (node.attributes.patternTransform != null) {
              convertTransform(node, "patternTransform", newParams);
            }
          }
        }
      };
    };
    var convertTransform = (item, attrName, params) => {
      let data = transform2js(item.attributes[attrName]);
      params = definePrecision(data, params);
      if (params.collapseIntoOne && data.length > 1) {
        data = [transformsMultiply(data)];
      }
      if (params.convertToShorts) {
        data = convertToShorts(data, params);
      } else {
        data.forEach((item2) => roundTransform(item2, params));
      }
      if (params.removeUseless) {
        data = removeUseless(data);
      }
      if (data.length) {
        item.attributes[attrName] = js2transform(data, params);
      } else {
        delete item.attributes[attrName];
      }
    };
    var definePrecision = (data, { ...newParams }) => {
      const matrixData = [];
      for (const item of data) {
        if (item.name == "matrix") {
          matrixData.push(...item.data.slice(0, 4));
        }
      }
      let numberOfDigits = newParams.transformPrecision;
      if (matrixData.length) {
        newParams.transformPrecision = Math.min(
          newParams.transformPrecision,
          Math.max.apply(Math, matrixData.map(floatDigits)) || newParams.transformPrecision
        );
        numberOfDigits = Math.max.apply(
          Math,
          matrixData.map(
            (n) => n.toString().replace(/\D+/g, "").length
            // Number of digits in a number. 123.45  5
          )
        );
      }
      if (newParams.degPrecision == null) {
        newParams.degPrecision = Math.max(
          0,
          Math.min(newParams.floatPrecision, numberOfDigits - 2)
        );
      }
      return newParams;
    };
    var degRound = (data, params) => {
      if (params.degPrecision != null && params.degPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.degPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatRound = (data, params) => {
      if (params.floatPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.floatPrecision, data);
      } else {
        return round(data);
      }
    };
    var transformRound = (data, params) => {
      if (params.transformPrecision >= 1 && params.floatPrecision < 20) {
        return smartRound(params.transformPrecision, data);
      } else {
        return round(data);
      }
    };
    var floatDigits = (n) => {
      const str = n.toString();
      return str.slice(str.indexOf(".")).length - 1;
    };
    var convertToShorts = (transforms, params) => {
      for (var i = 0; i < transforms.length; i++) {
        let transform = transforms[i];
        if (params.matrixToTransform && transform.name === "matrix") {
          var decomposed = matrixToTransform(transform, params);
          if (js2transform(decomposed, params).length <= js2transform([transform], params).length) {
            transforms.splice(i, 1, ...decomposed);
          }
          transform = transforms[i];
        }
        roundTransform(transform, params);
        if (params.shortTranslate && transform.name === "translate" && transform.data.length === 2 && !transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortScale && transform.name === "scale" && transform.data.length === 2 && transform.data[0] === transform.data[1]) {
          transform.data.pop();
        }
        if (params.shortRotate && transforms[i - 2]?.name === "translate" && transforms[i - 1].name === "rotate" && transforms[i].name === "translate" && transforms[i - 2].data[0] === -transforms[i].data[0] && transforms[i - 2].data[1] === -transforms[i].data[1]) {
          transforms.splice(i - 2, 3, {
            name: "rotate",
            data: [
              transforms[i - 1].data[0],
              transforms[i - 2].data[0],
              transforms[i - 2].data[1]
            ]
          });
          i -= 2;
        }
      }
      return transforms;
    };
    var removeUseless = (transforms) => {
      return transforms.filter((transform) => {
        if (["translate", "rotate", "skewX", "skewY"].indexOf(transform.name) > -1 && (transform.data.length == 1 || transform.name == "rotate") && !transform.data[0] || // translate(0, 0)
        transform.name == "translate" && !transform.data[0] && !transform.data[1] || // scale(1)
        transform.name == "scale" && transform.data[0] == 1 && (transform.data.length < 2 || transform.data[1] == 1) || // matrix(1 0 0 1 0 0)
        transform.name == "matrix" && transform.data[0] == 1 && transform.data[3] == 1 && !(transform.data[1] || transform.data[2] || transform.data[4] || transform.data[5])) {
          return false;
        }
        return true;
      });
    };
    var js2transform = (transformJS, params) => {
      const transformString = transformJS.map((transform) => {
        roundTransform(transform, params);
        return `${transform.name}(${cleanupOutData(transform.data, params)})`;
      }).join("");
      return transformString;
    };
    var roundTransform = (transform, params) => {
      switch (transform.name) {
        case "translate":
          transform.data = floatRound(transform.data, params);
          break;
        case "rotate":
          transform.data = [
            ...degRound(transform.data.slice(0, 1), params),
            ...floatRound(transform.data.slice(1), params)
          ];
          break;
        case "skewX":
        case "skewY":
          transform.data = degRound(transform.data, params);
          break;
        case "scale":
          transform.data = transformRound(transform.data, params);
          break;
        case "matrix":
          transform.data = [
            ...transformRound(transform.data.slice(0, 4), params),
            ...floatRound(transform.data.slice(4), params)
          ];
          break;
      }
      return transform;
    };
    var round = (data) => {
      return data.map(Math.round);
    };
    var smartRound = (precision, data) => {
      for (var i = data.length, tolerance = +Math.pow(0.1, precision).toFixed(precision); i--; ) {
        if (toFixed(data[i], precision) !== data[i]) {
          var rounded = +data[i].toFixed(precision - 1);
          data[i] = +Math.abs(rounded - data[i]).toFixed(precision + 1) >= tolerance ? +data[i].toFixed(precision) : rounded;
        }
      }
      return data;
    };
  }
});

// node_modules/svgo/plugins/removeEmptyAttrs.js
var require_removeEmptyAttrs = __commonJS({
  "node_modules/svgo/plugins/removeEmptyAttrs.js"(exports2) {
    "use strict";
    var { attrsGroups } = require_collections();
    exports2.name = "removeEmptyAttrs";
    exports2.description = "removes empty attributes";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            for (const [name, value] of Object.entries(node.attributes)) {
              if (value === "" && // empty conditional processing attributes prevents elements from rendering
              !attrsGroups.conditionalProcessing.has(name)) {
                delete node.attributes[name];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeEmptyContainers.js
var require_removeEmptyContainers = __commonJS({
  "node_modules/svgo/plugins/removeEmptyContainers.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { elemsGroups } = require_collections();
    exports2.name = "removeEmptyContainers";
    exports2.description = "removes empty container elements";
    exports2.fn = () => {
      return {
        element: {
          exit: (node, parentNode) => {
            if (node.name === "svg" || !elemsGroups.container.has(node.name) || node.children.length !== 0) {
              return;
            }
            if (node.name === "pattern" && Object.keys(node.attributes).length !== 0) {
              return;
            }
            if (node.name === "g" && node.attributes.filter != null) {
              return;
            }
            if (node.name === "mask" && node.attributes.id != null) {
              return;
            }
            if (parentNode.type === "element" && parentNode.name === "switch") {
              return;
            }
            detachNodeFromParent(node, parentNode);
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/mergePaths.js
var require_mergePaths = __commonJS({
  "node_modules/svgo/plugins/mergePaths.js"(exports2) {
    "use strict";
    var { collectStylesheet, computeStyle } = require_style();
    var { path2js, js2path, intersects } = require_path2();
    exports2.name = "mergePaths";
    exports2.description = "merges multiple paths in one if possible";
    exports2.fn = (root, params) => {
      const {
        force = false,
        floatPrecision,
        noSpaceAfterFlags = false
        // a20 60 45 0 1 30 20  a20 60 45 0130 20
      } = params;
      const stylesheet = collectStylesheet(root);
      return {
        element: {
          enter: (node) => {
            if (node.children.length <= 1) {
              return;
            }
            const elementsToRemove = [];
            let prevChild = node.children[0];
            let prevPathData = null;
            const updatePreviousPath = (child, pathData) => {
              js2path(child, pathData, {
                floatPrecision,
                noSpaceAfterFlags
              });
              prevPathData = null;
            };
            for (let i = 1; i < node.children.length; i++) {
              const child = node.children[i];
              if (prevChild.type !== "element" || prevChild.name !== "path" || prevChild.children.length !== 0 || prevChild.attributes.d == null) {
                if (prevPathData && prevChild.type === "element") {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                continue;
              }
              if (child.type !== "element" || child.name !== "path" || child.children.length !== 0 || child.attributes.d == null) {
                if (prevPathData) {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                continue;
              }
              const computedStyle = computeStyle(stylesheet, child);
              if (computedStyle["marker-start"] || computedStyle["marker-mid"] || computedStyle["marker-end"]) {
                if (prevPathData) {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                continue;
              }
              const childAttrs = Object.keys(child.attributes);
              if (childAttrs.length !== Object.keys(prevChild.attributes).length) {
                if (prevPathData) {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                continue;
              }
              const areAttrsEqual = childAttrs.some((attr) => {
                return attr !== "d" && prevChild.type === "element" && prevChild.attributes[attr] !== child.attributes[attr];
              });
              if (areAttrsEqual) {
                if (prevPathData) {
                  updatePreviousPath(prevChild, prevPathData);
                }
                prevChild = child;
                continue;
              }
              const hasPrevPath = prevPathData != null;
              const currentPathData = path2js(child);
              prevPathData = prevPathData ?? path2js(prevChild);
              if (force || !intersects(prevPathData, currentPathData)) {
                prevPathData.push(...currentPathData);
                elementsToRemove.push(child);
                continue;
              }
              if (hasPrevPath) {
                updatePreviousPath(prevChild, prevPathData);
              }
              prevChild = child;
              prevPathData = null;
            }
            if (prevPathData && prevChild.type === "element") {
              updatePreviousPath(prevChild, prevPathData);
            }
            node.children = node.children.filter(
              (child) => !elementsToRemove.includes(child)
            );
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeUnusedNS.js
var require_removeUnusedNS = __commonJS({
  "node_modules/svgo/plugins/removeUnusedNS.js"(exports2) {
    "use strict";
    exports2.name = "removeUnusedNS";
    exports2.description = "removes unused namespaces declaration";
    exports2.fn = () => {
      const unusedNamespaces = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of Object.keys(node.attributes)) {
                if (name.startsWith("xmlns:")) {
                  const local = name.slice("xmlns:".length);
                  unusedNamespaces.add(local);
                }
              }
            }
            if (unusedNamespaces.size !== 0) {
              if (node.name.includes(":")) {
                const [ns] = node.name.split(":");
                if (unusedNamespaces.has(ns)) {
                  unusedNamespaces.delete(ns);
                }
              }
              for (const name of Object.keys(node.attributes)) {
                if (name.includes(":")) {
                  const [ns] = name.split(":");
                  unusedNamespaces.delete(ns);
                }
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const name of unusedNamespaces) {
                delete node.attributes[`xmlns:${name}`];
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortAttrs.js
var require_sortAttrs = __commonJS({
  "node_modules/svgo/plugins/sortAttrs.js"(exports2) {
    "use strict";
    exports2.name = "sortAttrs";
    exports2.description = "Sort element attributes for better compression";
    exports2.fn = (_root, params) => {
      const {
        order = [
          "id",
          "width",
          "height",
          "x",
          "x1",
          "x2",
          "y",
          "y1",
          "y2",
          "cx",
          "cy",
          "r",
          "fill",
          "stroke",
          "marker",
          "d",
          "points"
        ],
        xmlnsOrder = "front"
      } = params;
      const getNsPriority = (name) => {
        if (xmlnsOrder === "front") {
          if (name === "xmlns") {
            return 3;
          }
          if (name.startsWith("xmlns:")) {
            return 2;
          }
        }
        if (name.includes(":")) {
          return 1;
        }
        return 0;
      };
      const compareAttrs = ([aName], [bName]) => {
        const aPriority = getNsPriority(aName);
        const bPriority = getNsPriority(bName);
        const priorityNs = bPriority - aPriority;
        if (priorityNs !== 0) {
          return priorityNs;
        }
        const [aPart] = aName.split("-");
        const [bPart] = bName.split("-");
        if (aPart !== bPart) {
          const aInOrderFlag = order.includes(aPart) ? 1 : 0;
          const bInOrderFlag = order.includes(bPart) ? 1 : 0;
          if (aInOrderFlag === 1 && bInOrderFlag === 1) {
            return order.indexOf(aPart) - order.indexOf(bPart);
          }
          const priorityOrder = bInOrderFlag - aInOrderFlag;
          if (priorityOrder !== 0) {
            return priorityOrder;
          }
        }
        return aName < bName ? -1 : 1;
      };
      return {
        element: {
          enter: (node) => {
            const attrs = Object.entries(node.attributes);
            attrs.sort(compareAttrs);
            const sortedAttributes = {};
            for (const [name, value] of attrs) {
              sortedAttributes[name] = value;
            }
            node.attributes = sortedAttributes;
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/sortDefsChildren.js
var require_sortDefsChildren = __commonJS({
  "node_modules/svgo/plugins/sortDefsChildren.js"(exports2) {
    "use strict";
    exports2.name = "sortDefsChildren";
    exports2.description = "Sorts children of <defs> to improve compression";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "defs") {
              const frequencies = /* @__PURE__ */ new Map();
              for (const child of node.children) {
                if (child.type === "element") {
                  const frequency = frequencies.get(child.name);
                  if (frequency == null) {
                    frequencies.set(child.name, 1);
                  } else {
                    frequencies.set(child.name, frequency + 1);
                  }
                }
              }
              node.children.sort((a, b) => {
                if (a.type !== "element" || b.type !== "element") {
                  return 0;
                }
                const aFrequency = frequencies.get(a.name);
                const bFrequency = frequencies.get(b.name);
                if (aFrequency != null && bFrequency != null) {
                  const frequencyComparison = bFrequency - aFrequency;
                  if (frequencyComparison !== 0) {
                    return frequencyComparison;
                  }
                }
                const lengthComparison = b.name.length - a.name.length;
                if (lengthComparison !== 0) {
                  return lengthComparison;
                }
                if (a.name !== b.name) {
                  return a.name > b.name ? -1 : 1;
                }
                return 0;
              });
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeTitle.js
var require_removeTitle = __commonJS({
  "node_modules/svgo/plugins/removeTitle.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeTitle";
    exports2.description = "removes <title>";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "title") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDesc.js
var require_removeDesc = __commonJS({
  "node_modules/svgo/plugins/removeDesc.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeDesc";
    exports2.description = "removes <desc>";
    var standardDescs = /^(Created with|Created using)/;
    exports2.fn = (root, params) => {
      const { removeAny = false } = params;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "desc") {
              if (removeAny || node.children.length === 0 || node.children[0].type === "text" && standardDescs.test(node.children[0].value)) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/preset-default.js
var require_preset_default = __commonJS({
  "node_modules/svgo/plugins/preset-default.js"(exports2, module2) {
    "use strict";
    var { createPreset } = require_plugins();
    var removeDoctype = require_removeDoctype();
    var removeXMLProcInst = require_removeXMLProcInst();
    var removeComments = require_removeComments();
    var removeMetadata = require_removeMetadata();
    var removeEditorsNSData = require_removeEditorsNSData();
    var cleanupAttrs = require_cleanupAttrs();
    var mergeStyles = require_mergeStyles();
    var inlineStyles = require_inlineStyles();
    var minifyStyles = require_minifyStyles();
    var cleanupIds = require_cleanupIds();
    var removeUselessDefs = require_removeUselessDefs();
    var cleanupNumericValues = require_cleanupNumericValues();
    var convertColors = require_convertColors();
    var removeUnknownsAndDefaults = require_removeUnknownsAndDefaults();
    var removeNonInheritableGroupAttrs = require_removeNonInheritableGroupAttrs();
    var removeUselessStrokeAndFill = require_removeUselessStrokeAndFill();
    var removeViewBox = require_removeViewBox();
    var cleanupEnableBackground = require_cleanupEnableBackground();
    var removeHiddenElems = require_removeHiddenElems();
    var removeEmptyText = require_removeEmptyText();
    var convertShapeToPath = require_convertShapeToPath();
    var convertEllipseToCircle = require_convertEllipseToCircle();
    var moveElemsAttrsToGroup = require_moveElemsAttrsToGroup();
    var moveGroupAttrsToElems = require_moveGroupAttrsToElems();
    var collapseGroups = require_collapseGroups();
    var convertPathData = require_convertPathData();
    var convertTransform = require_convertTransform();
    var removeEmptyAttrs = require_removeEmptyAttrs();
    var removeEmptyContainers = require_removeEmptyContainers();
    var mergePaths = require_mergePaths();
    var removeUnusedNS = require_removeUnusedNS();
    var sortAttrs = require_sortAttrs();
    var sortDefsChildren = require_sortDefsChildren();
    var removeTitle = require_removeTitle();
    var removeDesc = require_removeDesc();
    var presetDefault = createPreset({
      name: "preset-default",
      plugins: [
        removeDoctype,
        removeXMLProcInst,
        removeComments,
        removeMetadata,
        removeEditorsNSData,
        cleanupAttrs,
        mergeStyles,
        inlineStyles,
        minifyStyles,
        cleanupIds,
        removeUselessDefs,
        cleanupNumericValues,
        convertColors,
        removeUnknownsAndDefaults,
        removeNonInheritableGroupAttrs,
        removeUselessStrokeAndFill,
        removeViewBox,
        cleanupEnableBackground,
        removeHiddenElems,
        removeEmptyText,
        convertShapeToPath,
        convertEllipseToCircle,
        moveElemsAttrsToGroup,
        moveGroupAttrsToElems,
        collapseGroups,
        convertPathData,
        convertTransform,
        removeEmptyAttrs,
        removeEmptyContainers,
        mergePaths,
        removeUnusedNS,
        sortAttrs,
        sortDefsChildren,
        removeTitle,
        removeDesc
      ]
    });
    module2.exports = presetDefault;
  }
});

// node_modules/svgo/plugins/addAttributesToSVGElement.js
var require_addAttributesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addAttributesToSVGElement.js"(exports2) {
    "use strict";
    exports2.name = "addAttributesToSVGElement";
    exports2.description = "adds attributes to an outer <svg> element";
    var ENOCLS = `Error in plugin "addAttributesToSVGElement": absent parameters.
It should have a list of "attributes" or one "attribute".
Config example:

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attribute: "mySvg"
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: ["mySvg", "size-big"]
    }
  }
]

plugins: [
  {
    name: 'addAttributesToSVGElement',
    params: {
      attributes: [
        {
          focusable: false
        },
        {
          'data-image': icon
        }
      ]
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (!Array.isArray(params.attributes) && !params.attribute) {
        console.error(ENOCLS);
        return null;
      }
      const attributes = params.attributes || [params.attribute];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              for (const attribute of attributes) {
                if (typeof attribute === "string") {
                  if (node.attributes[attribute] == null) {
                    node.attributes[attribute] = void 0;
                  }
                }
                if (typeof attribute === "object") {
                  for (const key of Object.keys(attribute)) {
                    if (node.attributes[key] == null) {
                      node.attributes[key] = attribute[key];
                    }
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/addClassesToSVGElement.js
var require_addClassesToSVGElement = __commonJS({
  "node_modules/svgo/plugins/addClassesToSVGElement.js"(exports2) {
    "use strict";
    exports2.name = "addClassesToSVGElement";
    exports2.description = "adds classnames to an outer <svg> element";
    var ENOCLS = `Error in plugin "addClassesToSVGElement": absent parameters.
It should have a list of classes in "classNames" or one "className".
Config example:

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      className: "mySvg"
    }
  }
]

plugins: [
  {
    name: "addClassesToSVGElement",
    params: {
      classNames: ["mySvg", "size-big"]
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (!(Array.isArray(params.classNames) && params.classNames.some(String)) && !params.className) {
        console.error(ENOCLS);
        return null;
      }
      const classNames = params.classNames || [params.className];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              const classList = new Set(
                node.attributes.class == null ? null : node.attributes.class.split(" ")
              );
              for (const className of classNames) {
                if (className != null) {
                  classList.add(className);
                }
              }
              node.attributes.class = Array.from(classList).join(" ");
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/cleanupListOfValues.js
var require_cleanupListOfValues = __commonJS({
  "node_modules/svgo/plugins/cleanupListOfValues.js"(exports2) {
    "use strict";
    var { removeLeadingZero } = require_tools();
    exports2.name = "cleanupListOfValues";
    exports2.description = "rounds list of values to the fixed precision";
    var regNumericValues = /^([-+]?\d*\.?\d+([eE][-+]?\d+)?)(px|pt|pc|mm|cm|m|in|ft|em|ex|%)?$/;
    var regSeparator = /\s+,?\s*|,\s*/;
    var absoluteLengths = {
      // relative to px
      cm: 96 / 2.54,
      mm: 96 / 25.4,
      in: 96,
      pt: 4 / 3,
      pc: 16,
      px: 1
    };
    exports2.fn = (_root, params) => {
      const {
        floatPrecision = 3,
        leadingZero = true,
        defaultPx = true,
        convertToPx = true
      } = params;
      const roundValues = (lists) => {
        const roundedList = [];
        for (const elem of lists.split(regSeparator)) {
          const match = elem.match(regNumericValues);
          const matchNew = elem.match(/new/);
          if (match) {
            let num = Number(Number(match[1]).toFixed(floatPrecision));
            let matchedUnit = match[3] || "";
            let units = matchedUnit;
            if (convertToPx && units && units in absoluteLengths) {
              const pxNum = Number(
                (absoluteLengths[units] * Number(match[1])).toFixed(floatPrecision)
              );
              if (pxNum.toString().length < match[0].length) {
                num = pxNum;
                units = "px";
              }
            }
            let str;
            if (leadingZero) {
              str = removeLeadingZero(num);
            } else {
              str = num.toString();
            }
            if (defaultPx && units === "px") {
              units = "";
            }
            roundedList.push(str + units);
          } else if (matchNew) {
            roundedList.push("new");
          } else if (elem) {
            roundedList.push(elem);
          }
        }
        return roundedList.join(" ");
      };
      return {
        element: {
          enter: (node) => {
            if (node.attributes.points != null) {
              node.attributes.points = roundValues(node.attributes.points);
            }
            if (node.attributes["enable-background"] != null) {
              node.attributes["enable-background"] = roundValues(
                node.attributes["enable-background"]
              );
            }
            if (node.attributes.viewBox != null) {
              node.attributes.viewBox = roundValues(node.attributes.viewBox);
            }
            if (node.attributes["stroke-dasharray"] != null) {
              node.attributes["stroke-dasharray"] = roundValues(
                node.attributes["stroke-dasharray"]
              );
            }
            if (node.attributes.dx != null) {
              node.attributes.dx = roundValues(node.attributes.dx);
            }
            if (node.attributes.dy != null) {
              node.attributes.dy = roundValues(node.attributes.dy);
            }
            if (node.attributes.x != null) {
              node.attributes.x = roundValues(node.attributes.x);
            }
            if (node.attributes.y != null) {
              node.attributes.y = roundValues(node.attributes.y);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertOneStopGradients.js
var require_convertOneStopGradients = __commonJS({
  "node_modules/svgo/plugins/convertOneStopGradients.js"(exports2) {
    "use strict";
    var { attrsGroupsDefaults, colorsProps } = require_collections();
    var {
      detachNodeFromParent,
      querySelectorAll,
      querySelector
    } = require_xast();
    var { computeStyle, collectStylesheet } = require_style();
    exports2.name = "convertOneStopGradients";
    exports2.description = "converts one-stop (single color) gradients to a plain color";
    exports2.fn = (root) => {
      const stylesheet = collectStylesheet(root);
      const effectedDefs = /* @__PURE__ */ new Set();
      const allDefs = /* @__PURE__ */ new Map();
      const gradientsToDetach = /* @__PURE__ */ new Map();
      let xlinkHrefCount = 0;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes["xlink:href"] != null) {
              xlinkHrefCount++;
            }
            if (node.name === "defs") {
              allDefs.set(node, parentNode);
              return;
            }
            if (node.name !== "linearGradient" && node.name !== "radialGradient") {
              return;
            }
            const stops = node.children.filter((child) => {
              return child.type === "element" && child.name === "stop";
            });
            const href = node.attributes["xlink:href"] || node.attributes["href"];
            let effectiveNode = stops.length === 0 && href != null && href.startsWith("#") ? querySelector(root, href) : node;
            if (effectiveNode == null || effectiveNode.type !== "element") {
              gradientsToDetach.set(node, parentNode);
              return;
            }
            const effectiveStops = effectiveNode.children.filter((child) => {
              return child.type === "element" && child.name === "stop";
            });
            if (effectiveStops.length !== 1 || effectiveStops[0].type !== "element") {
              return;
            }
            if (parentNode.type === "element" && parentNode.name === "defs") {
              effectedDefs.add(parentNode);
            }
            gradientsToDetach.set(node, parentNode);
            let color;
            const style = computeStyle(stylesheet, effectiveStops[0])["stop-color"];
            if (style != null && style.type === "static") {
              color = style.value;
            }
            const selectorVal = `url(#${node.attributes.id})`;
            const selector = [...colorsProps].map((attr) => `[${attr}="${selectorVal}"]`).join(",");
            const elements = querySelectorAll(root, selector);
            for (const element of elements) {
              if (element.type !== "element") {
                continue;
              }
              for (const attr of colorsProps) {
                if (element.attributes[attr] !== selectorVal) {
                  continue;
                }
                if (color != null) {
                  element.attributes[attr] = color;
                } else {
                  delete element.attributes[attr];
                }
              }
            }
            const styledElements = querySelectorAll(
              root,
              `[style*=${selectorVal}]`
            );
            for (const element of styledElements) {
              if (element.type !== "element") {
                continue;
              }
              element.attributes.style = element.attributes.style.replace(
                selectorVal,
                color || attrsGroupsDefaults.presentation["stop-color"]
              );
            }
          },
          exit: (node) => {
            if (node.name === "svg") {
              for (const [gradient, parent] of gradientsToDetach.entries()) {
                if (gradient.attributes["xlink:href"] != null) {
                  xlinkHrefCount--;
                }
                detachNodeFromParent(gradient, parent);
              }
              if (xlinkHrefCount === 0) {
                delete node.attributes["xmlns:xlink"];
              }
              for (const [defs, parent] of allDefs.entries()) {
                if (effectedDefs.has(defs) && defs.children.length === 0) {
                  detachNodeFromParent(defs, parent);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/convertStyleToAttrs.js
var require_convertStyleToAttrs = __commonJS({
  "node_modules/svgo/plugins/convertStyleToAttrs.js"(exports2) {
    "use strict";
    var { attrsGroups } = require_collections();
    exports2.name = "convertStyleToAttrs";
    exports2.description = "converts style to attributes";
    var g = (...args) => {
      return "(?:" + args.join("|") + ")";
    };
    var stylingProps = attrsGroups.presentation;
    var rEscape = "\\\\(?:[0-9a-f]{1,6}\\s?|\\r\\n|.)";
    var rAttr = "\\s*(" + g("[^:;\\\\]", rEscape) + "*?)\\s*";
    var rSingleQuotes = "'(?:[^'\\n\\r\\\\]|" + rEscape + ")*?(?:'|$)";
    var rQuotes = '"(?:[^"\\n\\r\\\\]|' + rEscape + ')*?(?:"|$)';
    var rQuotedString = new RegExp("^" + g(rSingleQuotes, rQuotes) + "$");
    var rParenthesis = "\\(" + g(`[^'"()\\\\]+`, rEscape, rSingleQuotes, rQuotes) + "*?\\)";
    var rValue = "\\s*(" + g(
      `[^!'"();\\\\]+?`,
      rEscape,
      rSingleQuotes,
      rQuotes,
      rParenthesis,
      "[^;]*?"
    ) + "*?)";
    var rDeclEnd = "\\s*(?:;\\s*|$)";
    var rImportant = "(\\s*!important(?![-(\\w]))?";
    var regDeclarationBlock = new RegExp(
      rAttr + ":" + rValue + rImportant + rDeclEnd,
      "ig"
    );
    var regStripComments = new RegExp(
      g(rEscape, rSingleQuotes, rQuotes, "/\\*[^]*?\\*/"),
      "ig"
    );
    exports2.fn = (_root, params) => {
      const { keepImportant = false } = params;
      return {
        element: {
          enter: (node) => {
            if (node.attributes.style != null) {
              let styles = [];
              const newAttributes = {};
              const styleValue = node.attributes.style.replace(
                regStripComments,
                (match) => {
                  return match[0] == "/" ? "" : match[0] == "\\" && /[-g-z]/i.test(match[1]) ? match[1] : match;
                }
              );
              regDeclarationBlock.lastIndex = 0;
              for (var rule; rule = regDeclarationBlock.exec(styleValue); ) {
                if (!keepImportant || !rule[3]) {
                  styles.push([rule[1], rule[2]]);
                }
              }
              if (styles.length) {
                styles = styles.filter(function(style) {
                  if (style[0]) {
                    var prop = style[0].toLowerCase(), val = style[1];
                    if (rQuotedString.test(val)) {
                      val = val.slice(1, -1);
                    }
                    if (stylingProps.has(prop)) {
                      newAttributes[prop] = val;
                      return false;
                    }
                  }
                  return true;
                });
                Object.assign(node.attributes, newAttributes);
                if (styles.length) {
                  node.attributes.style = styles.map((declaration) => declaration.join(":")).join(";");
                } else {
                  delete node.attributes.style;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/prefixIds.js
var require_prefixIds = __commonJS({
  "node_modules/svgo/plugins/prefixIds.js"(exports2) {
    "use strict";
    var csstree = require_cjs();
    var { referencesProps } = require_collections();
    exports2.name = "prefixIds";
    exports2.description = "prefix IDs";
    var getBasename = (path44) => {
      const matched = /[/\\]?([^/\\]+)$/.exec(path44);
      if (matched) {
        return matched[1];
      }
      return "";
    };
    var escapeIdentifierName = (str) => {
      return str.replace(/[. ]/g, "_");
    };
    var unquote = (string) => {
      if (string.startsWith('"') && string.endsWith('"') || string.startsWith("'") && string.endsWith("'")) {
        return string.slice(1, -1);
      }
      return string;
    };
    var prefixId = (prefixGenerator, body) => {
      const prefix = prefixGenerator(body);
      if (body.startsWith(prefix)) {
        return body;
      }
      return prefix + body;
    };
    var prefixReference = (prefixGenerator, reference) => {
      if (reference.startsWith("#")) {
        return "#" + prefixId(prefixGenerator, reference.slice(1));
      }
      return null;
    };
    var generatePrefix = (body, node, info, prefixGenerator, delim, history) => {
      if (typeof prefixGenerator === "function") {
        let prefix = history.get(body);
        if (prefix != null) {
          return prefix;
        }
        prefix = prefixGenerator(node, info) + delim;
        history.set(body, prefix);
        return prefix;
      }
      if (typeof prefixGenerator === "string") {
        return prefixGenerator + delim;
      }
      if (prefixGenerator === false) {
        return "";
      }
      if (info.path != null && info.path.length > 0) {
        return escapeIdentifierName(getBasename(info.path)) + delim;
      }
      return "prefix" + delim;
    };
    exports2.fn = (_root, params, info) => {
      const {
        delim = "__",
        prefix,
        prefixIds = true,
        prefixClassNames = true
      } = params;
      const prefixMap = /* @__PURE__ */ new Map();
      return {
        element: {
          enter: (node) => {
            const prefixGenerator = (id) => generatePrefix(id, node, info, prefix, delim, prefixMap);
            if (node.name === "style") {
              if (node.children.length === 0) {
                return;
              }
              for (const child of node.children) {
                if (child.type !== "text" && child.type !== "cdata") {
                  continue;
                }
                const cssText = child.value;
                let cssAst = null;
                try {
                  cssAst = csstree.parse(cssText, {
                    parseValue: true,
                    parseCustomProperty: false
                  });
                } catch {
                  return;
                }
                csstree.walk(cssAst, (node2) => {
                  if (prefixIds && node2.type === "IdSelector" || prefixClassNames && node2.type === "ClassSelector") {
                    node2.name = prefixId(prefixGenerator, node2.name);
                    return;
                  }
                  if (node2.type === "Url" && node2.value.length > 0) {
                    const prefixed = prefixReference(
                      prefixGenerator,
                      unquote(node2.value)
                    );
                    if (prefixed != null) {
                      node2.value = prefixed;
                    }
                  }
                });
                child.value = csstree.generate(cssAst);
                return;
              }
            }
            if (prefixIds && node.attributes.id != null && node.attributes.id.length !== 0) {
              node.attributes.id = prefixId(prefixGenerator, node.attributes.id);
            }
            if (prefixClassNames && node.attributes.class != null && node.attributes.class.length !== 0) {
              node.attributes.class = node.attributes.class.split(/\s+/).map((name) => prefixId(prefixGenerator, name)).join(" ");
            }
            for (const name of ["href", "xlink:href"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const prefixed = prefixReference(
                  prefixGenerator,
                  node.attributes[name]
                );
                if (prefixed != null) {
                  node.attributes[name] = prefixed;
                }
              }
            }
            for (const name of referencesProps) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                node.attributes[name] = node.attributes[name].replace(
                  /\burl\((["'])?(#.+?)\1\)/gi,
                  (match, _, url) => {
                    const prefixed = prefixReference(prefixGenerator, url);
                    if (prefixed == null) {
                      return match;
                    }
                    return `url(${prefixed})`;
                  }
                );
              }
            }
            for (const name of ["begin", "end"]) {
              if (node.attributes[name] != null && node.attributes[name].length !== 0) {
                const parts = node.attributes[name].split(/\s*;\s+/).map((val) => {
                  if (val.endsWith(".end") || val.endsWith(".start")) {
                    const [id, postfix] = val.split(".");
                    return `${prefixId(prefixGenerator, id)}.${postfix}`;
                  }
                  return val;
                });
                node.attributes[name] = parts.join("; ");
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeAttributesBySelector.js
var require_removeAttributesBySelector = __commonJS({
  "node_modules/svgo/plugins/removeAttributesBySelector.js"(exports2) {
    "use strict";
    var { querySelectorAll } = require_xast();
    exports2.name = "removeAttributesBySelector";
    exports2.description = "removes attributes of elements that match a css selector";
    exports2.fn = (root, params) => {
      const selectors = Array.isArray(params.selectors) ? params.selectors : [params];
      for (const { selector, attributes } of selectors) {
        const nodes = querySelectorAll(root, selector);
        for (const node of nodes) {
          if (node.type === "element") {
            if (Array.isArray(attributes)) {
              for (const name of attributes) {
                delete node.attributes[name];
              }
            } else {
              delete node.attributes[attributes];
            }
          }
        }
      }
      return {};
    };
  }
});

// node_modules/svgo/plugins/removeAttrs.js
var require_removeAttrs = __commonJS({
  "node_modules/svgo/plugins/removeAttrs.js"(exports2) {
    "use strict";
    exports2.name = "removeAttrs";
    exports2.description = "removes specified attributes";
    var DEFAULT_SEPARATOR = ":";
    var ENOATTRS = `Warning: The plugin "removeAttrs" requires the "attrs" parameter.
It should have a pattern to remove, otherwise the plugin is a noop.
Config example:

plugins: [
  {
    name: "removeAttrs",
    params: {
      attrs: "(fill|stroke)"
    }
  }
]
`;
    exports2.fn = (root, params) => {
      if (typeof params.attrs == "undefined") {
        console.warn(ENOATTRS);
        return null;
      }
      const elemSeparator = typeof params.elemSeparator == "string" ? params.elemSeparator : DEFAULT_SEPARATOR;
      const preserveCurrentColor = typeof params.preserveCurrentColor == "boolean" ? params.preserveCurrentColor : false;
      const attrs = Array.isArray(params.attrs) ? params.attrs : [params.attrs];
      return {
        element: {
          enter: (node) => {
            for (let pattern of attrs) {
              if (!pattern.includes(elemSeparator)) {
                pattern = [".*", pattern, ".*"].join(elemSeparator);
              } else if (pattern.split(elemSeparator).length < 3) {
                pattern = [pattern, ".*"].join(elemSeparator);
              }
              const list = pattern.split(elemSeparator).map((value) => {
                if (value === "*") {
                  value = ".*";
                }
                return new RegExp(["^", value, "$"].join(""), "i");
              });
              if (list[0].test(node.name)) {
                for (const [name, value] of Object.entries(node.attributes)) {
                  const isFillCurrentColor = preserveCurrentColor && name == "fill" && value == "currentColor";
                  const isStrokeCurrentColor = preserveCurrentColor && name == "stroke" && value == "currentColor";
                  if (!isFillCurrentColor && !isStrokeCurrentColor && // matches attribute name
                  list[1].test(name) && // matches attribute value
                  list[2].test(value)) {
                    delete node.attributes[name];
                  }
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeDimensions.js
var require_removeDimensions = __commonJS({
  "node_modules/svgo/plugins/removeDimensions.js"(exports2) {
    "use strict";
    exports2.name = "removeDimensions";
    exports2.description = "removes width and height in presence of viewBox (opposite to removeViewBox, disable it first)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "svg") {
              if (node.attributes.viewBox != null) {
                delete node.attributes.width;
                delete node.attributes.height;
              } else if (node.attributes.width != null && node.attributes.height != null && Number.isNaN(Number(node.attributes.width)) === false && Number.isNaN(Number(node.attributes.height)) === false) {
                const width = Number(node.attributes.width);
                const height = Number(node.attributes.height);
                node.attributes.viewBox = `0 0 ${width} ${height}`;
                delete node.attributes.width;
                delete node.attributes.height;
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeElementsByAttr.js
var require_removeElementsByAttr = __commonJS({
  "node_modules/svgo/plugins/removeElementsByAttr.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeElementsByAttr";
    exports2.description = "removes arbitrary elements by ID or className (disabled by default)";
    exports2.fn = (root, params) => {
      const ids = params.id == null ? [] : Array.isArray(params.id) ? params.id : [params.id];
      const classes = params.class == null ? [] : Array.isArray(params.class) ? params.class : [params.class];
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.attributes.id != null && ids.length !== 0) {
              if (ids.includes(node.attributes.id)) {
                detachNodeFromParent(node, parentNode);
              }
            }
            if (node.attributes.class && classes.length !== 0) {
              const classList = node.attributes.class.split(" ");
              for (const item of classes) {
                if (classList.includes(item)) {
                  detachNodeFromParent(node, parentNode);
                  break;
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeOffCanvasPaths.js
var require_removeOffCanvasPaths = __commonJS({
  "node_modules/svgo/plugins/removeOffCanvasPaths.js"(exports2) {
    "use strict";
    var { visitSkip, detachNodeFromParent } = require_xast();
    var { parsePathData } = require_path();
    var { intersects } = require_path2();
    exports2.name = "removeOffCanvasPaths";
    exports2.description = "removes elements that are drawn outside of the viewbox (disabled by default)";
    exports2.fn = () => {
      let viewBoxData = null;
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              let viewBox = "";
              if (node.attributes.viewBox != null) {
                viewBox = node.attributes.viewBox;
              } else if (node.attributes.height != null && node.attributes.width != null) {
                viewBox = `0 0 ${node.attributes.width} ${node.attributes.height}`;
              }
              viewBox = viewBox.replace(/[,+]|px/g, " ").replace(/\s+/g, " ").replace(/^\s*|\s*$/g, "");
              const m = /^(-?\d*\.?\d+) (-?\d*\.?\d+) (\d*\.?\d+) (\d*\.?\d+)$/.exec(
                viewBox
              );
              if (m == null) {
                return;
              }
              const left = Number.parseFloat(m[1]);
              const top = Number.parseFloat(m[2]);
              const width = Number.parseFloat(m[3]);
              const height = Number.parseFloat(m[4]);
              viewBoxData = {
                left,
                top,
                right: left + width,
                bottom: top + height,
                width,
                height
              };
            }
            if (node.attributes.transform != null) {
              return visitSkip;
            }
            if (node.name === "path" && node.attributes.d != null && viewBoxData != null) {
              const pathData = parsePathData(node.attributes.d);
              let visible = false;
              for (const pathDataItem of pathData) {
                if (pathDataItem.command === "M") {
                  const [x, y] = pathDataItem.args;
                  if (x >= viewBoxData.left && x <= viewBoxData.right && y >= viewBoxData.top && y <= viewBoxData.bottom) {
                    visible = true;
                  }
                }
              }
              if (visible) {
                return;
              }
              if (pathData.length === 2) {
                pathData.push({ command: "z", args: [] });
              }
              const { left, top, width, height } = viewBoxData;
              const viewBoxPathData = [
                { command: "M", args: [left, top] },
                { command: "h", args: [width] },
                { command: "v", args: [height] },
                { command: "H", args: [left] },
                { command: "z", args: [] }
              ];
              if (intersects(viewBoxPathData, pathData) === false) {
                detachNodeFromParent(node, parentNode);
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeRasterImages.js
var require_removeRasterImages = __commonJS({
  "node_modules/svgo/plugins/removeRasterImages.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeRasterImages";
    exports2.description = "removes raster images (disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "image" && node.attributes["xlink:href"] != null && /(\.|image\/)(jpe?g|png|gif)/.test(node.attributes["xlink:href"])) {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeScriptElement.js
var require_removeScriptElement = __commonJS({
  "node_modules/svgo/plugins/removeScriptElement.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    var { attrsGroups } = require_collections();
    exports2.name = "removeScriptElement";
    exports2.description = "removes scripts (disabled by default)";
    var eventAttrs = [
      ...attrsGroups.animationEvent,
      ...attrsGroups.documentEvent,
      ...attrsGroups.documentElementEvent,
      ...attrsGroups.globalEvent,
      ...attrsGroups.graphicalEvent
    ];
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "script") {
              detachNodeFromParent(node, parentNode);
              return;
            }
            for (const attr of eventAttrs) {
              if (node.attributes[attr] != null) {
                delete node.attributes[attr];
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name !== "a") {
              return;
            }
            for (const attr of Object.keys(node.attributes)) {
              if (attr === "href" || attr.endsWith(":href")) {
                if (node.attributes[attr] == null || !node.attributes[attr].trimStart().startsWith("javascript:")) {
                  continue;
                }
                const index = parentNode.children.indexOf(node);
                parentNode.children.splice(index, 1, ...node.children);
                for (const child of node.children) {
                  Object.defineProperty(child, "parentNode", {
                    writable: true,
                    value: parentNode
                  });
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeStyleElement.js
var require_removeStyleElement = __commonJS({
  "node_modules/svgo/plugins/removeStyleElement.js"(exports2) {
    "use strict";
    var { detachNodeFromParent } = require_xast();
    exports2.name = "removeStyleElement";
    exports2.description = "removes <style> element (disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "style") {
              detachNodeFromParent(node, parentNode);
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXlink.js
var require_removeXlink = __commonJS({
  "node_modules/svgo/plugins/removeXlink.js"(exports2) {
    "use strict";
    var { elems } = require_collections();
    exports2.name = "removeXlink";
    exports2.description = "remove xlink namespace and replaces attributes with the SVG 2 equivalent where applicable";
    var XLINK_NAMESPACE = "http://www.w3.org/1999/xlink";
    var SHOW_TO_TARGET = {
      new: "_blank",
      replace: "_self"
    };
    var LEGACY_ELEMENTS = /* @__PURE__ */ new Set([
      "cursor",
      "filter",
      "font-face-uri",
      "glyphRef",
      "tref"
    ]);
    var findPrefixedAttrs = (node, prefixes, attr) => {
      return prefixes.map((prefix) => `${prefix}:${attr}`).filter((attr2) => node.attributes[attr2] != null);
    };
    exports2.fn = (_, params) => {
      const { includeLegacy } = params;
      const xlinkPrefixes = [];
      const overriddenPrefixes = [];
      const usedInLegacyElement = [];
      return {
        element: {
          enter: (node) => {
            for (const [key, value] of Object.entries(node.attributes)) {
              if (key.startsWith("xmlns:")) {
                const prefix = key.split(":", 2)[1];
                if (value === XLINK_NAMESPACE) {
                  xlinkPrefixes.push(prefix);
                  continue;
                }
                if (xlinkPrefixes.includes(prefix)) {
                  overriddenPrefixes.push(prefix);
                }
              }
            }
            if (overriddenPrefixes.some((prefix) => xlinkPrefixes.includes(prefix))) {
              return;
            }
            const showAttrs = findPrefixedAttrs(node, xlinkPrefixes, "show");
            let showHandled = node.attributes.target != null;
            for (let i = showAttrs.length - 1; i >= 0; i--) {
              const attr = showAttrs[i];
              const value = node.attributes[attr];
              const mapping = SHOW_TO_TARGET[value];
              if (showHandled || mapping == null) {
                delete node.attributes[attr];
                continue;
              }
              if (mapping !== elems[node.name]?.defaults?.target) {
                node.attributes.target = mapping;
              }
              delete node.attributes[attr];
              showHandled = true;
            }
            const titleAttrs = findPrefixedAttrs(node, xlinkPrefixes, "title");
            for (let i = titleAttrs.length - 1; i >= 0; i--) {
              const attr = titleAttrs[i];
              const value = node.attributes[attr];
              const hasTitle = node.children.filter(
                (child) => child.type === "element" && child.name === "title"
              );
              if (hasTitle.length > 0) {
                delete node.attributes[attr];
                continue;
              }
              const titleTag = {
                type: "element",
                name: "title",
                attributes: {},
                children: [
                  {
                    type: "text",
                    value
                  }
                ]
              };
              Object.defineProperty(titleTag, "parentNode", {
                writable: true,
                value: node
              });
              node.children.unshift(titleTag);
              delete node.attributes[attr];
            }
            const hrefAttrs = findPrefixedAttrs(node, xlinkPrefixes, "href");
            if (hrefAttrs.length > 0 && LEGACY_ELEMENTS.has(node.name) && !includeLegacy) {
              hrefAttrs.map((attr) => attr.split(":", 1)[0]).forEach((prefix) => usedInLegacyElement.push(prefix));
              return;
            }
            for (let i = hrefAttrs.length - 1; i >= 0; i--) {
              const attr = hrefAttrs[i];
              const value = node.attributes[attr];
              if (node.attributes.href != null) {
                delete node.attributes[attr];
                continue;
              }
              node.attributes.href = value;
              delete node.attributes[attr];
            }
          },
          exit: (node) => {
            for (const [key, value] of Object.entries(node.attributes)) {
              const [prefix, attr] = key.split(":", 2);
              if (xlinkPrefixes.includes(prefix) && !overriddenPrefixes.includes(prefix) && !usedInLegacyElement.includes(prefix) && !includeLegacy) {
                delete node.attributes[key];
                continue;
              }
              if (key.startsWith("xmlns:") && !usedInLegacyElement.includes(attr)) {
                if (value === XLINK_NAMESPACE) {
                  const index = xlinkPrefixes.indexOf(attr);
                  xlinkPrefixes.splice(index, 1);
                  delete node.attributes[key];
                  continue;
                }
                if (overriddenPrefixes.includes(prefix)) {
                  const index = overriddenPrefixes.indexOf(attr);
                  overriddenPrefixes.splice(index, 1);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/removeXMLNS.js
var require_removeXMLNS = __commonJS({
  "node_modules/svgo/plugins/removeXMLNS.js"(exports2) {
    "use strict";
    exports2.name = "removeXMLNS";
    exports2.description = "removes xmlns attribute (for inline svg, disabled by default)";
    exports2.fn = () => {
      return {
        element: {
          enter: (node) => {
            if (node.name === "svg") {
              delete node.attributes.xmlns;
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/plugins/reusePaths.js
var require_reusePaths = __commonJS({
  "node_modules/svgo/plugins/reusePaths.js"(exports2) {
    "use strict";
    var { collectStylesheet } = require_style();
    var { detachNodeFromParent, querySelectorAll } = require_xast();
    exports2.name = "reusePaths";
    exports2.description = "Finds <path> elements with the same d, fill, and stroke, and converts them to <use> elements referencing a single <path> def.";
    exports2.fn = (root) => {
      const stylesheet = collectStylesheet(root);
      const paths = /* @__PURE__ */ new Map();
      let svgDefs;
      const hrefs = /* @__PURE__ */ new Set();
      return {
        element: {
          enter: (node, parentNode) => {
            if (node.name === "path" && node.attributes.d != null) {
              const d = node.attributes.d;
              const fill = node.attributes.fill || "";
              const stroke = node.attributes.stroke || "";
              const key = d + ";s:" + stroke + ";f:" + fill;
              let list = paths.get(key);
              if (list == null) {
                list = [];
                paths.set(key, list);
              }
              list.push(node);
            }
            if (svgDefs == null && node.name === "defs" && parentNode.type === "element" && parentNode.name === "svg") {
              svgDefs = node;
            }
            if (node.name === "use") {
              for (const name of ["href", "xlink:href"]) {
                const href = node.attributes[name];
                if (href != null && href.startsWith("#") && href.length > 1) {
                  hrefs.add(href.slice(1));
                }
              }
            }
          },
          exit: (node, parentNode) => {
            if (node.name === "svg" && parentNode.type === "root") {
              let defsTag = svgDefs;
              if (defsTag == null) {
                defsTag = {
                  type: "element",
                  name: "defs",
                  attributes: {},
                  children: []
                };
                Object.defineProperty(defsTag, "parentNode", {
                  writable: true,
                  value: node
                });
              }
              let index = 0;
              for (const list of paths.values()) {
                if (list.length > 1) {
                  const reusablePath = {
                    type: "element",
                    name: "path",
                    attributes: {},
                    children: []
                  };
                  for (const attr of ["fill", "stroke", "d"]) {
                    if (list[0].attributes[attr] != null) {
                      reusablePath.attributes[attr] = list[0].attributes[attr];
                    }
                  }
                  const originalId = list[0].attributes.id;
                  if (originalId == null || hrefs.has(originalId) || stylesheet.rules.some(
                    (rule) => rule.selector === `#${originalId}`
                  )) {
                    reusablePath.attributes.id = "reuse-" + index++;
                  } else {
                    reusablePath.attributes.id = originalId;
                    delete list[0].attributes.id;
                  }
                  Object.defineProperty(reusablePath, "parentNode", {
                    writable: true,
                    value: defsTag
                  });
                  defsTag.children.push(reusablePath);
                  for (const pathNode of list) {
                    delete pathNode.attributes.d;
                    delete pathNode.attributes.stroke;
                    delete pathNode.attributes.fill;
                    if (defsTag.children.includes(pathNode) && pathNode.children.length === 0) {
                      if (Object.keys(pathNode.attributes).length === 0) {
                        detachNodeFromParent(pathNode, defsTag);
                        continue;
                      }
                      if (Object.keys(pathNode.attributes).length === 1 && pathNode.attributes.id != null) {
                        detachNodeFromParent(pathNode, defsTag);
                        const selector = `[xlink\\:href=#${pathNode.attributes.id}], [href=#${pathNode.attributes.id}]`;
                        for (const child of querySelectorAll(node, selector)) {
                          if (child.type !== "element") {
                            continue;
                          }
                          for (const name of ["href", "xlink:href"]) {
                            if (child.attributes[name] != null) {
                              child.attributes[name] = "#" + reusablePath.attributes.id;
                            }
                          }
                        }
                        continue;
                      }
                    }
                    pathNode.name = "use";
                    pathNode.attributes["xlink:href"] = "#" + reusablePath.attributes.id;
                  }
                }
              }
              if (defsTag.children.length !== 0) {
                if (node.attributes["xmlns:xlink"] == null) {
                  node.attributes["xmlns:xlink"] = "http://www.w3.org/1999/xlink";
                }
                if (svgDefs == null) {
                  node.children.unshift(defsTag);
                }
              }
            }
          }
        }
      };
    };
  }
});

// node_modules/svgo/lib/builtin.js
var require_builtin = __commonJS({
  "node_modules/svgo/lib/builtin.js"(exports2) {
    "use strict";
    exports2.builtin = [
      require_preset_default(),
      require_addAttributesToSVGElement(),
      require_addClassesToSVGElement(),
      require_cleanupAttrs(),
      require_cleanupEnableBackground(),
      require_cleanupIds(),
      require_cleanupListOfValues(),
      require_cleanupNumericValues(),
      require_collapseGroups(),
      require_convertColors(),
      require_convertEllipseToCircle(),
      require_convertOneStopGradients(),
      require_convertPathData(),
      require_convertShapeToPath(),
      require_convertStyleToAttrs(),
      require_convertTransform(),
      require_mergeStyles(),
      require_inlineStyles(),
      require_mergePaths(),
      require_minifyStyles(),
      require_moveElemsAttrsToGroup(),
      require_moveGroupAttrsToElems(),
      require_prefixIds(),
      require_removeAttributesBySelector(),
      require_removeAttrs(),
      require_removeComments(),
      require_removeDesc(),
      require_removeDimensions(),
      require_removeDoctype(),
      require_removeEditorsNSData(),
      require_removeElementsByAttr(),
      require_removeEmptyAttrs(),
      require_removeEmptyContainers(),
      require_removeEmptyText(),
      require_removeHiddenElems(),
      require_removeMetadata(),
      require_removeNonInheritableGroupAttrs(),
      require_removeOffCanvasPaths(),
      require_removeRasterImages(),
      require_removeScriptElement(),
      require_removeStyleElement(),
      require_removeTitle(),
      require_removeUnknownsAndDefaults(),
      require_removeUnusedNS(),
      require_removeUselessDefs(),
      require_removeUselessStrokeAndFill(),
      require_removeViewBox(),
      require_removeXlink(),
      require_removeXMLNS(),
      require_removeXMLProcInst(),
      require_reusePaths(),
      require_sortAttrs(),
      require_sortDefsChildren()
    ];
  }
});

// node_modules/svgo/lib/svgo.js
var require_svgo = __commonJS({
  "node_modules/svgo/lib/svgo.js"(exports2) {
    "use strict";
    var { parseSvg } = require_parser();
    var { stringifySvg } = require_stringifier();
    var { builtin } = require_builtin();
    var { invokePlugins } = require_plugins();
    var { encodeSVGDatauri } = require_tools();
    var pluginsMap = {};
    for (const plugin of builtin) {
      pluginsMap[plugin.name] = plugin;
    }
    var resolvePluginConfig = (plugin) => {
      if (typeof plugin === "string") {
        const builtinPlugin = pluginsMap[plugin];
        if (builtinPlugin == null) {
          throw Error(`Unknown builtin plugin "${plugin}" specified.`);
        }
        return {
          name: plugin,
          params: {},
          fn: builtinPlugin.fn
        };
      }
      if (typeof plugin === "object" && plugin != null) {
        if (plugin.name == null) {
          throw Error(`Plugin name should be specified`);
        }
        let fn = plugin.fn;
        if (fn == null) {
          const builtinPlugin = pluginsMap[plugin.name];
          if (builtinPlugin == null) {
            throw Error(`Unknown builtin plugin "${plugin.name}" specified.`);
          }
          fn = builtinPlugin.fn;
        }
        return {
          name: plugin.name,
          params: plugin.params,
          fn
        };
      }
      return null;
    };
    var optimize2 = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      const maxPassCount = config.multipass ? 10 : 1;
      let prevResultSize = Number.POSITIVE_INFINITY;
      let output = "";
      const info = {};
      if (config.path != null) {
        info.path = config.path;
      }
      for (let i = 0; i < maxPassCount; i += 1) {
        info.multipassCount = i;
        const ast = parseSvg(input, config.path);
        const plugins = config.plugins || ["preset-default"];
        if (!Array.isArray(plugins)) {
          throw Error(
            "malformed config, `plugins` property must be an array.\nSee more info here: https://github.com/svg/svgo#configuration"
          );
        }
        const resolvedPlugins = plugins.filter((plugin) => plugin != null).map(resolvePluginConfig);
        if (resolvedPlugins.length < plugins.length) {
          console.warn(
            "Warning: plugins list includes null or undefined elements, these will be ignored."
          );
        }
        const globalOverrides = {};
        if (config.floatPrecision != null) {
          globalOverrides.floatPrecision = config.floatPrecision;
        }
        invokePlugins(ast, info, resolvedPlugins, null, globalOverrides);
        output = stringifySvg(ast, config.js2svg);
        if (output.length < prevResultSize) {
          input = output;
          prevResultSize = output.length;
        } else {
          break;
        }
      }
      if (config.datauri) {
        output = encodeSVGDatauri(output, config.datauri);
      }
      return {
        data: output
      };
    };
    exports2.optimize = optimize2;
  }
});

// node_modules/svgo/lib/svgo-node.js
var require_svgo_node = __commonJS({
  "node_modules/svgo/lib/svgo-node.js"(exports2) {
    "use strict";
    var os2 = require("os");
    var fs38 = require("fs");
    var { pathToFileURL } = require("url");
    var path44 = require("path");
    var { optimize: optimizeAgnostic } = require_svgo();
    var importConfig = async (configFile) => {
      let config;
      if (configFile.endsWith(".cjs")) {
        config = require(configFile);
      } else {
        const { default: imported } = await import(pathToFileURL(configFile));
        config = imported;
      }
      if (config == null || typeof config !== "object" || Array.isArray(config)) {
        throw Error(`Invalid config file "${configFile}"`);
      }
      return config;
    };
    var isFile = async (file) => {
      try {
        const stats = await fs38.promises.stat(file);
        return stats.isFile();
      } catch {
        return false;
      }
    };
    var loadConfig = async (configFile, cwd = process.cwd()) => {
      if (configFile != null) {
        if (path44.isAbsolute(configFile)) {
          return await importConfig(configFile);
        } else {
          return await importConfig(path44.join(cwd, configFile));
        }
      }
      let dir = cwd;
      while (true) {
        const js = path44.join(dir, "svgo.config.js");
        if (await isFile(js)) {
          return await importConfig(js);
        }
        const mjs = path44.join(dir, "svgo.config.mjs");
        if (await isFile(mjs)) {
          return await importConfig(mjs);
        }
        const cjs = path44.join(dir, "svgo.config.cjs");
        if (await isFile(cjs)) {
          return await importConfig(cjs);
        }
        const parent = path44.dirname(dir);
        if (dir === parent) {
          return null;
        }
        dir = parent;
      }
    };
    exports2.loadConfig = loadConfig;
    var optimize2 = (input, config) => {
      if (config == null) {
        config = {};
      }
      if (typeof config !== "object") {
        throw Error("Config should be an object");
      }
      return optimizeAgnostic(input, {
        ...config,
        js2svg: {
          // platform specific default for end of line
          eol: os2.EOL === "\r\n" ? "crlf" : "lf",
          ...config.js2svg
        }
      });
    };
    exports2.optimize = optimize2;
  }
});

// src/services/ColorService.ts
function getColorService() {
  if (!colorServiceInstance) {
    colorServiceInstance = new ColorService();
  }
  return colorServiceInstance;
}
var ColorService, colorServiceInstance;
var init_ColorService = __esm({
  "src/services/ColorService.ts"() {
    "use strict";
    ColorService = class {
      /**
       * Extract colors from SVG, filtering out SMIL secondary colors for UI display
       */
      extractColorsFromSvg(svg) {
        const { colors, hasCurrentColor, hasSmil } = this.extractAllColorsFromSvg(svg);
        let filteredColors = colors;
        if (hasSmil && colors.length > 1) {
          const primaryColors = colors.filter((c) => {
            if (c === "currentColor") return true;
            const hex = this.toHexColor(c).toLowerCase();
            return hex !== "#000000" && hex !== "#000" && !hex.match(/^#0[0-2][0-2][0-2][0-2][0-2]$/);
          });
          if (primaryColors.length > 0) {
            filteredColors = primaryColors;
          }
        }
        return { colors: filteredColors, hasCurrentColor, hasSmil };
      }
      /**
       * Extract ALL colors from SVG without filtering (for saving variants)
       */
      extractAllColorsFromSvg(svg) {
        const colorRegex = /(fill|stroke|stop-color)=["']([^"']+)["']/gi;
        const styleColorRegex = /(fill|stroke|stop-color)\s*:\s*([^;"'\s]+)/gi;
        const colorsSet = /* @__PURE__ */ new Set();
        let hasCurrentColor = false;
        const hasSmil = /<animate[^>]*>/i.test(svg) || /<animateTransform[^>]*>/i.test(svg) || /<animateMotion[^>]*>/i.test(svg);
        let colorMatch;
        while ((colorMatch = colorRegex.exec(svg)) !== null) {
          const color = colorMatch[2].toLowerCase();
          if (color === "currentcolor") {
            hasCurrentColor = true;
            colorsSet.add("currentColor");
          } else if (color !== "none" && color !== "transparent" && !color.startsWith("url(")) {
            colorsSet.add(color);
          }
        }
        while ((colorMatch = styleColorRegex.exec(svg)) !== null) {
          const color = colorMatch[2].toLowerCase();
          if (color === "currentcolor") {
            hasCurrentColor = true;
            if (!colorsSet.has("currentColor")) {
              colorsSet.add("currentColor");
            }
          } else if (color !== "none" && color !== "transparent" && !color.startsWith("url(")) {
            colorsSet.add(color);
          }
        }
        return { colors: Array.from(colorsSet), hasCurrentColor, hasSmil };
      }
      /**
       * Replace a color in an SVG with a new color
       */
      replaceColorInSvg(svg, oldColor, newColor) {
        const normalizeColor = (color) => {
          color = color.toLowerCase().trim();
          if (/^#[0-9a-f]{3}$/i.test(color)) {
            return "#" + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          return color;
        };
        const oldNorm = normalizeColor(oldColor);
        const newNorm = normalizeColor(newColor);
        let result = svg;
        result = result.replace(
          new RegExp(`(fill|stroke|stop-color|flood-color|lighting-color)=["']${oldNorm}["']`, "gi"),
          `$1="${newNorm}"`
        );
        result = result.replace(
          new RegExp(`(fill|stroke|stop-color|flood-color|lighting-color)=["']${oldColor}["']`, "gi"),
          `$1="${newNorm}"`
        );
        result = result.replace(
          new RegExp(`(fill|stroke|stop-color)\\s*:\\s*${oldNorm}`, "gi"),
          `$1: ${newNorm}`
        );
        return result;
      }
      /**
       * Convert a color to hex format
       */
      toHexColor(color) {
        if (color.startsWith("#")) {
          if (color.length === 4) {
            return "#" + color[1] + color[1] + color[2] + color[2] + color[3] + color[3];
          }
          return color;
        }
        const namedColors = {
          black: "#000000",
          white: "#ffffff",
          red: "#ff0000",
          green: "#00ff00",
          blue: "#0000ff",
          yellow: "#ffff00",
          cyan: "#00ffff",
          magenta: "#ff00ff",
          gray: "#808080",
          grey: "#808080",
          orange: "#ffa500",
          purple: "#800080",
          pink: "#ffc0cb",
          brown: "#a52a2a",
          navy: "#000080",
          teal: "#008080",
          olive: "#808000",
          maroon: "#800000",
          aqua: "#00ffff",
          lime: "#00ff00",
          silver: "#c0c0c0",
          fuchsia: "#ff00ff",
          currentcolor: "currentColor"
        };
        const lowerColor = color.toLowerCase();
        if (namedColors[lowerColor]) {
          return namedColors[lowerColor];
        }
        const rgbMatch = color.match(/rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/i);
        if (rgbMatch) {
          const r = parseInt(rgbMatch[1], 10).toString(16).padStart(2, "0");
          const g = parseInt(rgbMatch[2], 10).toString(16).padStart(2, "0");
          const b = parseInt(rgbMatch[3], 10).toString(16).padStart(2, "0");
          return `#${r}${g}${b}`;
        }
        return color;
      }
      // ==================== Color Transformations ====================
      hexToRgb(hex) {
        const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
        return result ? {
          r: parseInt(result[1], 16),
          g: parseInt(result[2], 16),
          b: parseInt(result[3], 16)
        } : null;
      }
      rgbToHex(r, g, b) {
        const clamp = (v) => Math.max(0, Math.min(255, Math.round(v)));
        return "#" + [r, g, b].map((v) => clamp(v).toString(16).padStart(2, "0")).join("");
      }
      invertColor(hex) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        return this.rgbToHex(255 - rgb.r, 255 - rgb.g, 255 - rgb.b);
      }
      darkenColor(hex, amount = 0.3) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        return this.rgbToHex(rgb.r * (1 - amount), rgb.g * (1 - amount), rgb.b * (1 - amount));
      }
      lightenColor(hex, amount = 0.3) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        return this.rgbToHex(
          rgb.r + (255 - rgb.r) * amount,
          rgb.g + (255 - rgb.g) * amount,
          rgb.b + (255 - rgb.b) * amount
        );
      }
      desaturateColor(hex, amount = 0.5) {
        const rgb = this.hexToRgb(hex);
        if (!rgb) return hex;
        const gray = rgb.r * 0.299 + rgb.g * 0.587 + rgb.b * 0.114;
        return this.rgbToHex(
          rgb.r + (gray - rgb.r) * amount,
          rgb.g + (gray - rgb.g) * amount,
          rgb.b + (gray - rgb.b) * amount
        );
      }
      /**
       * Generate auto variant colors based on transformation type
       */
      generateAutoVariantColors(colors, type) {
        let newColors;
        let variantName;
        switch (type) {
          case "invert":
            newColors = colors.map((c) => this.invertColor(this.toHexColor(c)));
            variantName = "Inverted";
            break;
          case "darken":
            newColors = colors.map((c) => this.darkenColor(this.toHexColor(c), 0.3));
            variantName = "Dark";
            break;
          case "lighten":
            newColors = colors.map((c) => this.lightenColor(this.toHexColor(c), 0.3));
            variantName = "Light";
            break;
          case "muted":
            newColors = colors.map((c) => this.desaturateColor(this.toHexColor(c), 0.5));
            variantName = "Muted";
            break;
          case "grayscale":
            newColors = colors.map((c) => this.desaturateColor(this.toHexColor(c), 1));
            variantName = "Grayscale";
            break;
          default:
            return { colors, variantName: "" };
        }
        return { colors: newColors, variantName };
      }
    };
    colorServiceInstance = null;
  }
});

// src/services/VariantsService.ts
function getVariantsService() {
  if (!variantsServiceInstance) {
    variantsServiceInstance = new VariantsService();
  }
  return variantsServiceInstance;
}
var vscode23, fs19, path23, VariantsService, variantsServiceInstance;
var init_VariantsService = __esm({
  "src/services/VariantsService.ts"() {
    "use strict";
    vscode23 = __toESM(require("vscode"));
    fs19 = __toESM(require("node:fs"));
    path23 = __toESM(require("node:path"));
    init_config();
    VariantsService = class {
      // Cache for variants - changes are stored here until explicitly saved
      _variantsCache = null;
      _defaultsCache = null;
      _colorMappingsCache = null;
      _hasUnsavedChanges = false;
      /**
       * Check if there are unsaved changes
       */
      get hasUnsavedChanges() {
        return this._hasUnsavedChanges;
      }
      /**
       * Reset the cache (e.g., when switching icons)
       */
      resetCache() {
        this._variantsCache = null;
        this._defaultsCache = null;
        this._colorMappingsCache = null;
        this._hasUnsavedChanges = false;
      }
      /**
       * Get the path to the variants.js file
       */
      _getVariantsFilePath() {
        const outputDir = getSvgConfig("outputDirectory", "bezier-icons");
        const workspaceFolders = vscode23.workspace.workspaceFolders;
        if (!workspaceFolders || !outputDir) return void 0;
        return path23.join(workspaceFolders[0].uri.fsPath, outputDir, "variants.js");
      }
      /**
       * Read all variants from file (or cache)
       */
      _readVariantsFromFile() {
        if (this._variantsCache !== null) {
          return { ...this._variantsCache };
        }
        try {
          const filePath = this._getVariantsFilePath();
          if (!filePath) {
            this._variantsCache = {};
            return {};
          }
          if (!fs19.existsSync(filePath)) {
            this._variantsCache = {};
            return {};
          }
          const content = fs19.readFileSync(filePath, "utf-8");
          const match = content.match(/export\s+const\s+Variants\s*=\s*(\{[\s\S]*\});/);
          if (match) {
            this._variantsCache = new Function(`return ${match[1]}`)();
            return { ...this._variantsCache };
          }
          this._variantsCache = {};
          return {};
        } catch {
          this._variantsCache = {};
          return {};
        }
      }
      /**
       * Update cache without writing to file
       */
      _updateVariantsCache(allVariants) {
        this._variantsCache = allVariants;
        this._hasUnsavedChanges = true;
      }
      /**
       * Read default variants from file (or cache)
       */
      _readDefaultVariants() {
        if (this._defaultsCache !== null) {
          return { ...this._defaultsCache };
        }
        try {
          const filePath = this._getVariantsFilePath();
          if (!filePath) {
            this._defaultsCache = {};
            return {};
          }
          if (!fs19.existsSync(filePath)) {
            this._defaultsCache = {};
            return {};
          }
          const content = fs19.readFileSync(filePath, "utf-8");
          const match = content.match(/export\s+const\s+defaultVariants\s*=\s*(\{[\s\S]*?\});/);
          if (match) {
            this._defaultsCache = new Function(`return ${match[1]}`)();
            return { ...this._defaultsCache };
          }
          this._defaultsCache = {};
          return {};
        } catch {
          this._defaultsCache = {};
          return {};
        }
      }
      /**
       * Read color mappings from file (or cache)
       */
      _readColorMappings() {
        if (this._colorMappingsCache !== null) {
          return { ...this._colorMappingsCache };
        }
        try {
          const filePath = this._getVariantsFilePath();
          if (!filePath || !fs19.existsSync(filePath)) {
            this._colorMappingsCache = {};
            return {};
          }
          const content = fs19.readFileSync(filePath, "utf-8");
          const match = content.match(/export\s+const\s+colorMappings\s*=\s*(\{[\s\S]*?\});/);
          if (match) {
            this._colorMappingsCache = new Function(`return ${match[1]}`)();
            return { ...this._colorMappingsCache };
          }
          this._colorMappingsCache = {};
          return {};
        } catch {
          this._colorMappingsCache = {};
          return {};
        }
      }
      /**
       * Get color mappings for an icon
       */
      getColorMappings(iconName) {
        const allMappings = this._readColorMappings();
        return allMappings[iconName] || {};
      }
      /**
       * Set a color mapping for an icon
       */
      setColorMapping(iconName, originalColor, newColor) {
        const allMappings = this._readColorMappings();
        if (!allMappings[iconName]) {
          allMappings[iconName] = {};
        }
        const normOrig = originalColor.toLowerCase();
        const normNew = newColor.toLowerCase();
        if (normOrig === normNew) {
          delete allMappings[iconName][normOrig];
          if (Object.keys(allMappings[iconName]).length === 0) {
            delete allMappings[iconName];
          }
        } else {
          allMappings[iconName][normOrig] = normNew;
        }
        this._colorMappingsCache = allMappings;
        this._hasUnsavedChanges = true;
      }
      /**
       * Clear all color mappings for an icon
       */
      clearColorMappings(iconName) {
        const allMappings = this._readColorMappings();
        delete allMappings[iconName];
        this._colorMappingsCache = allMappings;
        this._hasUnsavedChanges = true;
      }
      /**
       * Remove all data for an icon (variants, colorMappings, defaults)
       * Used when removing an icon from the built icons library
       */
      removeIconData(iconName) {
        const allVariants = this._readVariantsFromFile();
        delete allVariants[iconName];
        this._variantsCache = allVariants;
        const allMappings = this._readColorMappings();
        delete allMappings[iconName];
        this._colorMappingsCache = allMappings;
        const defaults = this._readDefaultVariants();
        delete defaults[iconName];
        this._defaultsCache = defaults;
        this._hasUnsavedChanges = true;
      }
      /**
       * Persist cached variants to disk
       */
      persistToFile() {
        try {
          const filePath = this._getVariantsFilePath();
          if (!filePath) return;
          const dir = path23.dirname(filePath);
          if (!fs19.existsSync(dir)) {
            fs19.mkdirSync(dir, { recursive: true });
          }
          const defaults = this._defaultsCache || this._readDefaultVariants();
          const allVariants = this._variantsCache || this._readVariantsFromFile();
          const colorMappings = this._colorMappingsCache || this._readColorMappings();
          let content = "// Auto-generated by Icon Studio\n";
          content += "// Variants for icons - edit freely or use the Icon Editor\n\n";
          content += "// Default Variant for each icon (used when no variant attribute is specified)\n";
          content += "export const defaultVariants = {\n";
          const defaultEntries = Object.entries(defaults);
          defaultEntries.forEach(([iconName, variantName], idx) => {
            content += `  '${iconName}': '${variantName}'`;
            content += idx < defaultEntries.length - 1 ? ",\n" : "\n";
          });
          content += "};\n\n";
          content += "// Color mappings per icon: { originalColor: newColor }\n";
          content += "export const colorMappings = {\n";
          const mappingEntries = Object.entries(colorMappings);
          mappingEntries.forEach(([iconName, mappings], iconIdx) => {
            content += `  '${iconName}': {
`;
            const colorEntries = Object.entries(mappings);
            colorEntries.forEach(([origColor, newColor], colorIdx) => {
              content += `    '${origColor}': '${newColor}'`;
              content += colorIdx < colorEntries.length - 1 ? ",\n" : "\n";
            });
            content += `  }`;
            content += iconIdx < mappingEntries.length - 1 ? ",\n" : "\n";
          });
          content += "};\n\n";
          content += "export const Variants = {\n";
          const iconEntries = Object.entries(allVariants);
          iconEntries.forEach(([iconName, iconVariants], iconIdx) => {
            content += `  '${iconName}': {
`;
            const variantEntries = Object.entries(iconVariants);
            variantEntries.forEach(([variantName, colors], variantIdx) => {
              const colorsStr = colors.map((c) => `'${c}'`).join(", ");
              content += `    '${variantName}': [${colorsStr}]`;
              content += variantIdx < variantEntries.length - 1 ? ",\n" : "\n";
            });
            content += `  }`;
            content += iconIdx < iconEntries.length - 1 ? ",\n" : "\n";
          });
          content += "};\n";
          fs19.writeFileSync(filePath, content);
          this._hasUnsavedChanges = false;
        } catch (error) {
          console.error("Error writing Variants:", error);
        }
      }
      /**
       * Get all variants including internal ones (for _original lookup)
       */
      getAllVariants(iconName) {
        const allVariants = this._readVariantsFromFile();
        const iconVariants = allVariants[iconName] || {};
        return Object.entries(iconVariants).map(([name, colors]) => ({ name, colors }));
      }
      /**
       * Get visible variants (excluding internal ones starting with _)
       */
      getSavedVariants(iconName) {
        const allVariants = this._readVariantsFromFile();
        const iconVariants = allVariants[iconName] || {};
        return Object.entries(iconVariants).filter(([name]) => !name.startsWith("_")).map(([name, colors]) => ({ name, colors }));
      }
      /**
       * Get the default variant for an icon
       */
      getDefaultVariant(iconName) {
        const defaults = this._readDefaultVariants();
        return defaults[iconName] || null;
      }
      /**
       * Set the default variant for an icon
       */
      setDefaultVariant(iconName, variantName) {
        const defaults = this._readDefaultVariants();
        if (variantName) {
          defaults[iconName] = variantName;
        } else {
          delete defaults[iconName];
        }
        this._defaultsCache = defaults;
        this._hasUnsavedChanges = true;
      }
      /**
       * Save a new variant or update existing one
       */
      saveVariant(iconName, variantName, colors) {
        const allVariants = this._readVariantsFromFile();
        if (!allVariants[iconName]) {
          allVariants[iconName] = {};
        }
        allVariants[iconName][variantName] = colors;
        this._updateVariantsCache(allVariants);
      }
      /**
       * Delete a variant by index
       */
      deleteVariant(iconName, index) {
        const allVariants = this._readVariantsFromFile();
        const iconVariants = allVariants[iconName];
        if (iconVariants) {
          const visibleNames = Object.keys(iconVariants).filter((n) => !n.startsWith("_"));
          if (visibleNames[index]) {
            delete allVariants[iconName][visibleNames[index]];
            const remainingVisible = Object.keys(allVariants[iconName]).filter((n) => !n.startsWith("_"));
            if (remainingVisible.length === 0) {
              const internalVariants = Object.entries(allVariants[iconName]).filter(
                ([n]) => n.startsWith("_")
              );
              if (internalVariants.length === 0) {
                delete allVariants[iconName];
              }
            }
            this._updateVariantsCache(allVariants);
          }
        }
      }
      /**
       * Update a variant's name and colors by index
       */
      updateVariant(iconName, index, newName, colors) {
        const allVariants = this._readVariantsFromFile();
        const iconVariants = allVariants[iconName];
        if (iconVariants) {
          const visibleNames = Object.keys(iconVariants).filter((n) => !n.startsWith("_"));
          const oldName = visibleNames[index];
          if (oldName) {
            delete allVariants[iconName][oldName];
            allVariants[iconName][newName] = colors;
            this._updateVariantsCache(allVariants);
          }
        }
      }
      /**
       * Update only the colors of a variant by index
       */
      updateVariantColors(iconName, index, colors) {
        const allVariants = this._readVariantsFromFile();
        const iconVariants = allVariants[iconName];
        if (iconVariants) {
          const visibleNames = Object.keys(iconVariants).filter((n) => !n.startsWith("_"));
          const variantName = visibleNames[index];
          if (variantName) {
            allVariants[iconName][variantName] = colors;
            this._updateVariantsCache(allVariants);
          }
        }
      }
      /**
       * Ensure an icon has stored original colors and a "custom" variant
       * @returns The original colors (from saved _original variant or provided)
       */
      ensureCustomVariant(iconName, currentColors) {
        const allVariants = this.getAllVariants(iconName);
        const hasCustom = allVariants.some((v) => v.name === "custom");
        const savedOriginal = allVariants.find((v) => v.name === "_original");
        let originalColors = currentColors;
        if (savedOriginal) {
          originalColors = [...savedOriginal.colors];
        } else if (currentColors.length > 0) {
          this.saveVariant(iconName, "_original", [...currentColors]);
        }
        if (!hasCustom && originalColors.length > 0) {
          this.saveVariant(iconName, "custom", [...originalColors]);
        }
        return originalColors;
      }
    };
    variantsServiceInstance = null;
  }
});

// src/services/UsageFinderService.ts
function getUsageFinderService() {
  if (!usageFinderInstance) {
    usageFinderInstance = new UsageFinderService();
  }
  return usageFinderInstance;
}
var vscode24, UsageFinderService, usageFinderInstance;
var init_UsageFinderService = __esm({
  "src/services/UsageFinderService.ts"() {
    "use strict";
    vscode24 = __toESM(require("vscode"));
    UsageFinderService = class {
      /**
       * Find all usages of an icon in the workspace
       */
      async findIconUsages(iconName) {
        const usages = [];
        const patterns = this.buildSearchPatterns(iconName);
        const filePatterns = [
          "**/*.ts",
          "**/*.tsx",
          "**/*.js",
          "**/*.jsx",
          "**/*.vue",
          "**/*.svelte",
          "**/*.html",
          "**/*.css",
          "**/*.scss",
          "**/*.less",
          "**/*.json"
        ];
        for (const filePattern of filePatterns) {
          const files = await vscode24.workspace.findFiles(filePattern, "**/node_modules/**");
          for (const file of files) {
            try {
              const document = await vscode24.workspace.openTextDocument(file);
              const text = document.getText();
              for (const pattern of patterns) {
                const matches = this.findMatches(text, pattern);
                for (const match of matches) {
                  const position = document.positionAt(match.index);
                  const lineText = document.lineAt(position.line).text;
                  const existingUsage = usages.find(
                    (u) => u.file === file.fsPath && u.line === position.line + 1
                  );
                  if (!existingUsage) {
                    usages.push({
                      file: file.fsPath,
                      relativePath: vscode24.workspace.asRelativePath(file),
                      line: position.line + 1,
                      column: position.character + 1,
                      text: lineText.trim(),
                      context: this.getContext(document, position.line)
                    });
                  }
                }
              }
            } catch (_error) {
              continue;
            }
          }
        }
        return usages.sort((a, b) => {
          const pathCompare = a.relativePath.localeCompare(b.relativePath);
          return pathCompare !== 0 ? pathCompare : a.line - b.line;
        });
      }
      /**
       * Build search patterns for different naming conventions
       */
      buildSearchPatterns(iconName) {
        const patterns = [];
        patterns.push(iconName);
        patterns.push(`"${iconName}"`);
        patterns.push(`'${iconName}'`);
        patterns.push(`icon-${iconName}`);
        patterns.push(`icon:${iconName}`);
        const pascalCase = this.toPascalCase(iconName);
        if (pascalCase !== iconName) {
          patterns.push(pascalCase);
        }
        return patterns;
      }
      /**
       * Find all matches of a pattern in text
       */
      findMatches(text, pattern) {
        const matches = [];
        let index = 0;
        while ((index = text.indexOf(pattern, index)) !== -1) {
          matches.push({ index });
          index += pattern.length;
        }
        return matches;
      }
      /**
       * Get context around a line (1 line before and after)
       */
      getContext(document, line) {
        const lines = [];
        const start = Math.max(0, line - 1);
        const end = Math.min(document.lineCount - 1, line + 1);
        for (let i = start; i <= end; i++) {
          lines.push(document.lineAt(i).text);
        }
        return lines.join("\n");
      }
      /**
       * Convert string to PascalCase
       */
      toPascalCase(str) {
        return str.replace(/[-_](.)/g, (_, char) => char.toUpperCase()).replace(/^(.)/, (_, char) => char.toUpperCase());
      }
    };
  }
});

// src/services/SvgOptimizer.ts
var import_svgo, defaultOptions, SvgOptimizer;
var init_SvgOptimizer = __esm({
  "src/services/SvgOptimizer.ts"() {
    "use strict";
    import_svgo = __toESM(require_svgo_node());
    defaultOptions = {
      removeComments: true,
      removeMetadata: true,
      removeTitle: false,
      removeDesc: true,
      removeUselessDefs: true,
      removeEditorsNSData: true,
      removeEmptyAttrs: true,
      removeHiddenElems: true,
      removeEmptyText: true,
      removeEmptyContainers: true,
      minifyStyles: true,
      convertColors: true,
      convertPathData: true,
      convertTransform: true,
      removeUnusedNS: true,
      sortAttrs: true,
      mergePaths: false,
      removeOffCanvasPaths: false,
      precision: 3
    };
    SvgOptimizer = class {
      /**
       * Optimize SVG using SVGO
       */
      optimize(svg, options = {}) {
        const opts = { ...defaultOptions, ...options };
        const originalSize = new Blob([svg]).size;
        const svgoConfig = {
          multipass: true,
          plugins: this.buildPluginList(opts)
        };
        try {
          const result = (0, import_svgo.optimize)(svg, svgoConfig);
          const optimizedSize = new Blob([result.data]).size;
          const savings = originalSize - optimizedSize;
          const savingsPercent = originalSize > 0 ? savings / originalSize * 100 : 0;
          return {
            svg: result.data,
            originalSize,
            optimizedSize,
            savings,
            savingsPercent
          };
        } catch (_error) {
          return {
            svg,
            originalSize,
            optimizedSize: originalSize,
            savings: 0,
            savingsPercent: 0
          };
        }
      }
      /**
       * Build SVGO plugin list from options
       */
      buildPluginList(opts) {
        const plugins = ["removeDoctype", "removeXMLProcInst", "removeXMLNS"];
        if (opts.removeComments) plugins.push("removeComments");
        if (opts.removeMetadata) plugins.push("removeMetadata");
        if (opts.removeTitle) plugins.push("removeTitle");
        if (opts.removeDesc) plugins.push("removeDesc");
        if (opts.removeUselessDefs) plugins.push("removeUselessDefs");
        if (opts.removeEditorsNSData) plugins.push("removeEditorsNSData");
        if (opts.removeEmptyAttrs) plugins.push("removeEmptyAttrs");
        if (opts.removeHiddenElems) plugins.push("removeHiddenElems");
        if (opts.removeEmptyText) plugins.push("removeEmptyText");
        if (opts.removeEmptyContainers) plugins.push("removeEmptyContainers");
        if (opts.removeUnusedNS) plugins.push("removeUnusedNS");
        if (opts.sortAttrs) plugins.push("sortAttrs");
        if (opts.minifyStyles) {
          plugins.push({
            name: "minifyStyles",
            params: { usage: true }
          });
        }
        if (opts.convertColors) {
          plugins.push({
            name: "convertColors",
            params: {
              currentColor: false,
              names2hex: true,
              rgb2hex: true,
              shorthex: true,
              shortname: true
            }
          });
        }
        if (opts.convertPathData) {
          plugins.push({
            name: "convertPathData",
            params: {
              floatPrecision: opts.precision || 3,
              transformPrecision: opts.precision || 3
            }
          });
        }
        if (opts.convertTransform) {
          plugins.push({
            name: "convertTransform",
            params: { floatPrecision: opts.precision || 3 }
          });
        }
        if (opts.mergePaths) {
          plugins.push("mergePaths");
        }
        if (opts.removeOffCanvasPaths) {
          plugins.push("removeOffCanvasPaths");
        }
        plugins.push("cleanupIds");
        plugins.push("removeUselessStrokeAndFill");
        plugins.push("cleanupNumericValues");
        plugins.push("collapseGroups");
        return plugins;
      }
      /**
       * Format file size for display
       */
      formatSize(bytes) {
        if (bytes < 1024) return `${bytes} B`;
        if (bytes < 1024 * 1024) return `${(bytes / 1024).toFixed(1)} KB`;
        return `${(bytes / (1024 * 1024)).toFixed(1)} MB`;
      }
      /**
       * Get optimization presets
       */
      getPresets() {
        return {
          safe: {
            removeComments: true,
            removeMetadata: true,
            removeDesc: true,
            removeEditorsNSData: true,
            removeEmptyAttrs: true,
            removeEmptyContainers: true,
            removeUnusedNS: true,
            sortAttrs: true,
            precision: 3
          },
          aggressive: {
            ...defaultOptions,
            removeTitle: true,
            mergePaths: true,
            precision: 2
          },
          minimal: {
            removeComments: true,
            removeMetadata: true,
            removeEditorsNSData: true
          }
        };
      }
    };
  }
});

// src/panels/handlers/iconDetailHandlers.ts
async function handleGoToLocation(ctx) {
  if (ctx.iconDetails?.location) {
    const uri = vscode25.Uri.file(ctx.iconDetails.location.file);
    const position = new vscode25.Position(ctx.iconDetails.location.line - 1, 0);
    await vscode25.window.showTextDocument(uri, {
      selection: new vscode25.Range(position, position),
      preview: false
    });
  }
}
async function handleGoToUsage(message) {
  if (message.file && message.line) {
    const uri = vscode25.Uri.file(message.file);
    const position = new vscode25.Position(message.line - 1, 0);
    await vscode25.window.showTextDocument(uri, {
      selection: new vscode25.Range(position, position),
      preview: true
    });
  }
}
async function handleCopyName(ctx) {
  if (ctx.iconDetails?.name) {
    await vscode25.env.clipboard.writeText(ctx.iconDetails.name);
    vscode25.window.showInformationMessage(
      t("messages.copiedNameToClipboard", { name: ctx.iconDetails.name })
    );
  }
}
async function handleCopySvg(ctx, message) {
  const svgToCopy = message.svg || ctx.iconDetails?.svg;
  if (svgToCopy) {
    await vscode25.env.clipboard.writeText(svgToCopy);
    vscode25.window.showInformationMessage(t("messages.svgCopiedToClipboard"));
  }
}
async function handleOpenEditor(ctx) {
  if (ctx.iconDetails) {
    await vscode25.commands.executeCommand("sageboxIconStudio.colorEditor", {
      icon: {
        name: ctx.iconDetails.name,
        svg: ctx.iconDetails.svg,
        path: ctx.iconDetails.location?.file,
        line: ctx.iconDetails.location?.line,
        isBuilt: ctx.iconDetails.isBuilt
      }
    });
  }
}
async function handleOptimizeSvg(ctx, message) {
  if (ctx.iconDetails?.svg) {
    const preset = message.preset || "safe";
    const presets = svgOptimizer.getPresets();
    const result = svgOptimizer.optimize(ctx.iconDetails.svg, presets[preset] || presets.safe);
    await ctx.panel.webview.postMessage({
      command: "optimizeResult",
      ...result,
      originalSizeStr: svgOptimizer.formatSize(result.originalSize),
      optimizedSizeStr: svgOptimizer.formatSize(result.optimizedSize)
    });
    if (result.savingsPercent > 0) {
      vscode25.window.showInformationMessage(
        `SVG optimized! Saved ${svgOptimizer.formatSize(result.savings)} (${result.savingsPercent.toFixed(1)}%)`
      );
    } else {
      vscode25.window.showInformationMessage(t("messages.svgAlreadyOptimized"));
    }
  }
}
function handleApplyOptimizedSvg(ctx, message) {
  if (ctx.iconDetails && message.svg) {
    ctx.setIconDetails({ ...ctx.iconDetails, svg: message.svg });
    vscode25.window.showInformationMessage(t("messages.optimizedSvgApplied"));
  }
}
async function handleChangeColor(ctx, message) {
  if (ctx.iconDetails?.svg && message.oldColor && message.newColor) {
    const updatedSvg = colorService.replaceColorInSvg(
      ctx.iconDetails.svg,
      message.oldColor,
      message.newColor
    );
    ctx.setIconDetails({ ...ctx.iconDetails, svg: updatedSvg });
    await ctx.panel.webview.postMessage({
      command: "colorChanged",
      svg: updatedSvg
    });
  }
}
function handleAddColorToSvg(ctx, message) {
  if (ctx.iconDetails?.svg && message.color) {
    let updatedSvg = ctx.iconDetails.svg;
    if (updatedSvg.includes("fill=")) {
      updatedSvg = updatedSvg.replace(
        /<svg([^>]*)fill=["'][^"']*["']/,
        `<svg$1fill="${message.color}"`
      );
    } else {
      updatedSvg = updatedSvg.replace(/<svg/, `<svg fill="${message.color}"`);
    }
    ctx.setIconDetails({ ...ctx.iconDetails, svg: updatedSvg });
    ctx.update();
    vscode25.window.showInformationMessage(t("messages.addedFillColor", { color: message.color }));
  }
}
function handleApplyVariant(ctx, message) {
  if (ctx.iconDetails && message.index !== void 0) {
    const variantsService = getVariantsService();
    const variants = variantsService.getSavedVariants(ctx.iconDetails.name);
    const variant = variants[message.index];
    if (variant) {
      const { colors: currentColors } = colorService.extractAllColorsFromSvg(ctx.iconDetails.svg);
      let newSvg = ctx.iconDetails.svg;
      for (let i = 0; i < Math.min(currentColors.length, variant.colors.length); i++) {
        newSvg = colorService.replaceColorInSvg(newSvg, currentColors[i], variant.colors[i]);
      }
      ctx.setIconDetails({ ...ctx.iconDetails, svg: newSvg });
      ctx.setSelectedVariantIndex(message.index);
      ctx.update();
    }
  }
}
function handleApplyDefaultVariant(ctx) {
  if (ctx.iconDetails && ctx.originalColors.length > 0) {
    const { colors: currentColors } = colorService.extractAllColorsFromSvg(ctx.iconDetails.svg);
    let newSvg = ctx.iconDetails.svg;
    for (let i = 0; i < Math.min(currentColors.length, ctx.originalColors.length); i++) {
      newSvg = colorService.replaceColorInSvg(newSvg, currentColors[i], ctx.originalColors[i]);
    }
    ctx.setIconDetails({ ...ctx.iconDetails, svg: newSvg });
    ctx.setSelectedVariantIndex(-1);
    ctx.update();
  }
}
async function handleSaveVariant(ctx) {
  if (ctx.iconDetails) {
    const variantName = await vscode25.window.showInputBox({
      prompt: t("editor.enterVariantName"),
      placeHolder: t("editor.variantPlaceholder")
    });
    if (variantName) {
      const { colors } = colorService.extractAllColorsFromSvg(ctx.iconDetails.svg);
      const variantsService = getVariantsService();
      variantsService.saveVariant(ctx.iconDetails.name, variantName, colors);
      variantsService.persistToFile();
      ctx.update();
      vscode25.window.showInformationMessage(t("messages.variantSaved", { name: variantName }));
    }
  }
}
function handleDeleteVariant(ctx, message) {
  if (ctx.iconDetails && message.index !== void 0) {
    const variantsService = getVariantsService();
    variantsService.deleteVariant(ctx.iconDetails.name, message.index);
    const variants = variantsService.getSavedVariants(ctx.iconDetails.name);
    const variantNames = variants.map((s) => s.name);
    const currentDefault = variantsService.getDefaultVariant(ctx.iconDetails.name);
    if (currentDefault && !variantNames.includes(currentDefault)) {
      variantsService.setDefaultVariant(ctx.iconDetails.name, null);
    }
    variantsService.persistToFile();
    if (ctx.selectedVariantIndex === message.index) {
      ctx.setSelectedVariantIndex(-1);
    } else if (ctx.selectedVariantIndex > message.index) {
      ctx.setSelectedVariantIndex(ctx.selectedVariantIndex - 1);
    }
    ctx.update();
  }
}
function handleSetDefaultVariant(ctx, message) {
  if (ctx.iconDetails) {
    const variantsService = getVariantsService();
    variantsService.setDefaultVariant(ctx.iconDetails.name, message.variantName);
    variantsService.persistToFile();
    ctx.update();
    if (message.variantName) {
      vscode25.window.showInformationMessage(
        t("messages.variantSetAsDefault", {
          name: message.variantName,
          iconName: ctx.iconDetails.name
        })
      );
    } else {
      vscode25.window.showInformationMessage(
        t("messages.defaultVariantCleared", { iconName: ctx.iconDetails.name })
      );
    }
  }
}
async function handleMessage(ctx, message) {
  switch (message.command) {
    case "goToLocation":
      await handleGoToLocation(ctx);
      break;
    case "copyName":
      await handleCopyName(ctx);
      break;
    case "copySvg":
      await handleCopySvg(ctx, message);
      break;
    case "openEditor":
      await handleOpenEditor(ctx);
      break;
    case "optimizeSvg":
      await handleOptimizeSvg(ctx, message);
      break;
    case "applyOptimizedSvg":
      handleApplyOptimizedSvg(ctx, message);
      break;
    case "changeColor":
      await handleChangeColor(ctx, message);
      break;
    case "addColorToSvg":
      handleAddColorToSvg(ctx, message);
      break;
    case "goToUsage":
      await handleGoToUsage(message);
      break;
    case "applyVariant":
      handleApplyVariant(ctx, message);
      break;
    case "applyDefaultVariant":
      handleApplyDefaultVariant(ctx);
      break;
    case "saveVariant":
      await handleSaveVariant(ctx);
      break;
    case "deleteVariant":
      handleDeleteVariant(ctx, message);
      break;
    case "setDefaultVariant":
      handleSetDefaultVariant(ctx, message);
      break;
    case "openExternal":
      if (message.url) {
        vscode25.env.openExternal(vscode25.Uri.parse(message.url));
      }
      break;
  }
}
var vscode25, svgOptimizer, colorService;
var init_iconDetailHandlers = __esm({
  "src/panels/handlers/iconDetailHandlers.ts"() {
    "use strict";
    vscode25 = __toESM(require("vscode"));
    init_SvgOptimizer();
    init_ColorService();
    init_VariantsService();
    init_i18n();
    svgOptimizer = new SvgOptimizer();
    colorService = new ColorService();
  }
});

// src/panels/IconDetailsPanel.ts
var IconDetailsPanel_exports = {};
__export(IconDetailsPanel_exports, {
  IconDetailsPanel: () => IconDetailsPanel
});
var vscode26, fs20, path24, colorService2, IconDetailsPanel;
var init_IconDetailsPanel = __esm({
  "src/panels/IconDetailsPanel.ts"() {
    "use strict";
    vscode26 = __toESM(require("vscode"));
    fs20 = __toESM(require("fs"));
    path24 = __toESM(require("path"));
    init_ColorService();
    init_VariantsService();
    init_UsageFinderService();
    init_iconDetailHandlers();
    init_i18n();
    init_LicenseService();
    init_AnimationKeyframes();
    colorService2 = new ColorService();
    IconDetailsPanel = class _IconDetailsPanel {
      static currentPanel;
      _panel;
      _extensionUri;
      _disposables = [];
      _iconDetails;
      _originalColors = [];
      _selectedVariantIndex = -1;
      static createOrShow(extensionUri, details) {
        const column = vscode26.window.activeTextEditor ? vscode26.window.activeTextEditor.viewColumn : void 0;
        if (_IconDetailsPanel.currentPanel) {
          _IconDetailsPanel.currentPanel._panel.reveal(column);
          if (details) {
            _IconDetailsPanel.currentPanel._iconDetails = details;
            _IconDetailsPanel.currentPanel._originalColors = colorService2.extractAllColorsFromSvg(
              details.svg
            ).colors;
            _IconDetailsPanel.currentPanel._selectedVariantIndex = -1;
            _IconDetailsPanel.currentPanel._update(details);
          }
          return;
        }
        const panel = vscode26.window.createWebviewPanel(
          "iconDetails",
          t("details.title"),
          column || vscode26.ViewColumn.One,
          {
            enableScripts: true,
            localResourceRoots: [extensionUri],
            retainContextWhenHidden: true
          }
        );
        _IconDetailsPanel.currentPanel = new _IconDetailsPanel(panel, extensionUri, details);
      }
      constructor(panel, extensionUri, details) {
        this._panel = panel;
        this._extensionUri = extensionUri;
        this._iconDetails = details;
        if (details) {
          this._originalColors = colorService2.extractAllColorsFromSvg(details.svg).colors;
        }
        this._update(details);
        this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
        this._panel.onDidChangeViewState(
          (e) => {
            if (e.webviewPanel.visible && this._iconDetails) {
              vscode26.commands.executeCommand(
                "sageboxIconStudio.revealInTree",
                this._iconDetails.name,
                this._iconDetails.location?.file,
                this._iconDetails.location?.line
              );
            }
          },
          null,
          this._disposables
        );
        this._panel.webview.onDidReceiveMessage(
          async (message) => {
            if (message.command === "findUsages") {
              if (this._iconDetails?.name) {
                this._findIconUsages(this._iconDetails.name);
              }
              return;
            }
            const ctx = {
              iconDetails: this._iconDetails,
              originalColors: this._originalColors,
              selectedVariantIndex: this._selectedVariantIndex,
              panel: this._panel,
              update: () => this._update(),
              setIconDetails: (details2) => {
                this._iconDetails = details2;
              },
              setSelectedVariantIndex: (index) => {
                this._selectedVariantIndex = index;
              }
            };
            await handleMessage(ctx, message);
          },
          null,
          this._disposables
        );
      }
      async _findIconUsages(iconName) {
        const usageFinderService = getUsageFinderService();
        try {
          const usages = await usageFinderService.findIconUsages(iconName);
          const formattedUsages = usages.map((u) => ({
            file: u.file,
            line: u.line,
            preview: u.text.substring(0, 100) + (u.text.length > 100 ? "..." : "")
          }));
          this._panel.webview.postMessage({
            command: "usagesResult",
            usages: formattedUsages,
            total: formattedUsages.length
          });
        } catch {
          this._panel.webview.postMessage({ command: "usagesResult", usages: [], total: 0 });
        }
      }
      dispose() {
        _IconDetailsPanel.currentPanel = void 0;
        this._panel.dispose();
        while (this._disposables.length) {
          const x = this._disposables.pop();
          if (x) {
            x.dispose();
          }
        }
      }
      _update(details) {
        if (details) {
          this._iconDetails = details;
          this._panel.title = `Details: ${details.name}`;
        }
        this._panel.webview.html = this._getHtmlForWebview();
      }
      _getHtmlForWebview() {
        if (!this._iconDetails) {
          return `<!DOCTYPE html>
<html><body><p>No icon selected</p></body></html>`;
        }
        const { name, svg, location, isBuilt, animation } = this._iconDetails;
        const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/);
        const viewBox = viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24";
        const widthMatch = svg.match(/width=["']([^"']+)["']/);
        const heightMatch = svg.match(/height=["']([^"']+)["']/);
        const dimensions = widthMatch && heightMatch ? `${widthMatch[1]} \xD7 ${heightMatch[1]}` : null;
        const fileSize = new Blob([svg]).size;
        const fileSizeStr = fileSize < 1024 ? `${fileSize} B` : `${(fileSize / 1024).toFixed(1)} KB`;
        const pathCount = (svg.match(/<path/g) || []).length;
        const circleCount = (svg.match(/<circle/g) || []).length;
        const rectCount = (svg.match(/<rect/g) || []).length;
        const lineCount = (svg.match(/<line/g) || []).length;
        const polygonCount = (svg.match(/<polygon/g) || []).length;
        const ellipseCount = (svg.match(/<ellipse/g) || []).length;
        const totalElements = pathCount + circleCount + rectCount + lineCount + polygonCount + ellipseCount;
        const elementParts = [];
        if (pathCount) elementParts.push(`${pathCount} path`);
        if (circleCount) elementParts.push(`${circleCount} circle`);
        if (rectCount) elementParts.push(`${rectCount} rect`);
        if (lineCount) elementParts.push(`${lineCount} line`);
        if (polygonCount) elementParts.push(`${polygonCount} polygon`);
        if (ellipseCount) elementParts.push(`${ellipseCount} ellipse`);
        const elementsStr = elementParts.join(", ") || "none";
        const hasGradient = /<(linearGradient|radialGradient)/i.test(svg);
        const hasFilter = /<filter/i.test(svg);
        const hasClipPath = /<clipPath/i.test(svg);
        const hasMask = /<mask/i.test(svg);
        const features = [
          hasGradient ? "gradient" : "",
          hasFilter ? "filter" : "",
          hasClipPath ? "clipPath" : "",
          hasMask ? "mask" : ""
        ].filter(Boolean);
        const fileName = location ? location.file.split(/[/\\]/).pop() : "";
        let displaySvg = svg;
        if (!svg.includes("width=") && !svg.includes("style=")) {
          displaySvg = svg.replace("<svg", '<svg width="100%" height="100%"');
        }
        let animationKeyframes = "";
        let animationCssRule = "";
        if (animation && animation.type && animation.type !== "none") {
          const duration = animation.duration || 1;
          const timing = animation.timing || "ease";
          const iteration = animation.iteration || "infinite";
          const delay = animation.delay || 0;
          const direction = animation.direction || "normal";
          const animationShorthand = `${animation.type} ${duration}s ${timing} ${delay}s ${iteration} ${direction}`;
          const inlineProps = `animation: ${animationShorthand}; transform-origin: center; transform-box: fill-box; will-change: transform, filter; animation-fill-mode: both;`;
          animationCssRule = `#previewBox svg { ${inlineProps} }`;
          const svgTagMatch = displaySvg.match(/<svg\b([^>]*)>/i);
          if (svgTagMatch) {
            const svgAttrs = svgTagMatch[1];
            if (/style\s*=/.test(svgAttrs)) {
              displaySvg = displaySvg.replace(/(<svg\b[^>]*?)style=(['"])([\s\S]*?)\2/, (_m, pre, q, content) => `${pre}style=${q}${content} ${inlineProps}${q}`);
            } else {
              displaySvg = displaySvg.replace("<svg", `<svg style="${inlineProps}"`);
            }
          } else {
            if (displaySvg.includes("<svg")) displaySvg = displaySvg.replace("<svg", `<svg style="${inlineProps}"`);
          }
          animationKeyframes = getKeyframesForAnimation(animation.type);
        }
        const { colors: allColors, hasCurrentColor } = colorService2.extractAllColorsFromSvg(svg);
        const totalColorCount = allColors.length;
        const MAX_COLORS_TO_SHOW = 50;
        const svgColors = allColors.slice(0, MAX_COLORS_TO_SHOW);
        const hasMoreColors = totalColorCount > MAX_COLORS_TO_SHOW;
        const templatesDir = path24.join(this._extensionUri.fsPath, "dist", "templates", "icon-details");
        const cssContent = fs20.readFileSync(path24.join(templatesDir, "iconDetails.css"), "utf-8");
        const jsTemplate = fs20.readFileSync(path24.join(templatesDir, "iconDetails.js"), "utf-8");
        const i18nObject = {
          noUsagesFound: t("webview.js.noUsagesFound"),
          original: t("webview.js.original"),
          optimized: t("webview.js.optimized"),
          saved: t("webview.js.saved"),
          alreadyOptimal: t("webview.js.alreadyOptimal")
        };
        const jsContent = jsTemplate.replace(/__I18N__/g, JSON.stringify(i18nObject));
        const badgeHtml = isBuilt !== void 0 ? `<span class="badge ${isBuilt ? "built" : "draft"}">${isBuilt ? t("webview.details.built") : t("webview.details.draft")}</span>` : "";
        const locationButtonHtml = location ? `<button class="action-btn" onclick="goToLocation()" title="${t("webview.details.goToSource")}"><span class="codicon codicon-go-to-file"></span></button>` : "";
        const colorsHtml = hasMoreColors ? `<div class="colors-warning"><span class="codicon codicon-warning"></span><span>${t("webview.details.colorsWarning").replace("{count}", String(totalColorCount))}</span></div>` : `<div class="color-swatches" id="colorSwatches">
          ${hasCurrentColor ? `<div class="current-color-info"><span class="codicon codicon-paintcan"></span><span>${t("webview.details.usesCurrentColor")}</span><span class="color-hint">(${t("webview.details.inheritsFromCss")})</span></div>` : ""}
          ${svgColors.length > 0 ? svgColors.map((color) => `<div class="color-swatch-view" style="background-color: ${color}" title="Click to copy: ${color}" onclick="copyColor('${color}')"><span class="color-tooltip">${color}</span></div>`).join("") : !hasCurrentColor ? `<span class="no-colors">${t("webview.details.noColorsDetected")}</span>` : ""}
        </div>`;
        const _dimensionsHtml = dimensions ? `<div class="detail-card"><div class="detail-label"><span class="codicon codicon-screen-full"></span> ${t("webview.details.dimensions")}</div><div class="detail-value">${dimensions}</div></div>` : "";
        const featuresHtml = features.length > 0 ? `<div class="detail-card"><div class="detail-label"><span class="codicon codicon-extensions"></span> ${t("webview.details.features")}</div><div class="features">${features.map((f) => `<span class="feature-tag" data-feature="${f}">${f}</span>`).join("")}</div></div>` : "";
        const locationCardHtml = location ? `<div class="detail-card clickable location-card" onclick="goToLocation()"><div class="detail-label"><span class="codicon codicon-go-to-file"></span> ${t("webview.details.sourceLocation")}</div><div class="detail-value">${fileName}:${location.line}</div><div class="detail-sub">${location.file}</div></div>` : "";
        let licenseCardHtml = "";
        const iconifyParsed = parseIconifyName(name);
        if (iconifyParsed) {
          const licenseInfo = getIconLicenseInfoSync(iconifyParsed.prefix);
          const iconifyPageUrl = `https://icon-sets.iconify.design/${iconifyParsed.prefix}/${iconifyParsed.name}/`;
          const iconifyDownloadUrl = `https://api.iconify.design/${iconifyParsed.prefix}/${iconifyParsed.name}.svg`;
          if (licenseInfo) {
            const authorLink = licenseInfo.author?.url ? `<a href="${licenseInfo.author.url}" class="license-link" onclick="openExternal('${licenseInfo.author.url}')">${licenseInfo.author.name}</a>` : licenseInfo.author?.name || t("webview.details.unknownAuthor");
            const licenseLink = licenseInfo.license?.url ? `<a href="${licenseInfo.license.url}" class="license-link" onclick="openExternal('${licenseInfo.license.url}')">${licenseInfo.license.spdx || licenseInfo.license.title}</a>` : licenseInfo.license?.spdx || licenseInfo.license?.title || t("webview.details.unknownLicense");
            licenseCardHtml = `
          <div class="detail-card license-card">
            <div class="detail-label"><span class="codicon codicon-law"></span> ${t("webview.details.license")}</div>
            <div class="license-info">
              <div class="license-row"><span class="license-label">${t("webview.details.collection")}:</span> <span class="license-value">${licenseInfo.name || iconifyParsed.prefix}</span></div>
              <div class="license-row"><span class="license-label">${t("webview.details.author")}:</span> <span class="license-value">${authorLink}</span></div>
              <div class="license-row"><span class="license-label">${t("webview.details.licenseType")}:</span> <span class="license-value">${licenseLink} \u2705</span></div>
              <div class="license-row"><span class="license-label">${t("webview.details.download")}:</span> <span class="license-value"><a href="${iconifyPageUrl}" class="license-link" onclick="openExternal('${iconifyPageUrl}')"><span class="codicon codicon-link-external"></span> Iconify</a> \xB7 <a href="${iconifyDownloadUrl}" class="license-link" onclick="openExternal('${iconifyDownloadUrl}')"><span class="codicon codicon-cloud-download"></span> SVG</a></span></div>
            </div>
          </div>`;
          } else {
            licenseCardHtml = `
          <div class="detail-card license-card warning">
            <div class="detail-label"><span class="codicon codicon-law"></span> ${t("webview.details.license")}</div>
            <div class="license-info">
              <div class="license-row"><span class="license-label">${t("webview.details.collection")}:</span> <span class="license-value">${iconifyParsed.prefix}</span></div>
              <div class="license-row"><span class="license-value warning-text">\u26A0\uFE0F ${t("webview.details.licenseUnknown")}</span></div>
              <div class="license-row"><span class="license-label">${t("webview.details.download")}:</span> <span class="license-value"><a href="${iconifyPageUrl}" class="license-link" onclick="openExternal('${iconifyPageUrl}')"><span class="codicon codicon-link-external"></span> Iconify</a> \xB7 <a href="${iconifyDownloadUrl}" class="license-link" onclick="openExternal('${iconifyDownloadUrl}')"><span class="codicon codicon-cloud-download"></span> SVG</a></span></div>
            </div>
          </div>`;
          }
        }
        const variantsContentHtml = hasMoreColors ? `<div class="Variants-disabled-message"><span class="codicon codicon-info"></span> ${t("webview.details.variantsDisabled")}</div>` : `<div class="Variants-container" id="VariantsContainer">${this._generateVariantsHtml(name)}</div>`;
        const variantsAddButtonHtml = !hasMoreColors ? `<button class="variant-add-btn" onclick="saveVariant()" title="${t("webview.details.saveVariant")}"><span class="codicon codicon-add"></span></button>` : "";
        let animationHtml = "";
        if (animation && animation.type && animation.type !== "none") {
          const animDetails = [];
          if (animation.duration) animDetails.push(`${animation.duration}s`);
          if (animation.timing) animDetails.push(animation.timing);
          if (animation.iteration) animDetails.push(animation.iteration);
          if (animation.delay) animDetails.push(`delay: ${animation.delay}s`);
          if (animation.direction) animDetails.push(animation.direction);
          const detailsStr = animDetails.length > 0 ? ` \xB7 ${animDetails.join(" \xB7 ")}` : "";
          animationHtml = `<div class="animation-section">
          <h2><span class="codicon codicon-play"></span> ${t("webview.details.animation")}</h2>
          <div class="animation-info">
            <span class="animation-type">\u26A1 ${animation.type}</span>
            <span class="animation-details">${detailsStr}</span>
          </div>
        </div>`;
        }
        return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@vscode/codicons/dist/codicon.css" />
  <style>${cssContent}
  ${animationKeyframes}
  ${animationCssRule}</style>
</head>
<body>
  <div class="container">
    <header class="header">
      <span class="icon-name">${name}</span>
      ${badgeHtml}
    </header>
    
    <div class="content">
      <div class="preview-section">
        <div class="preview-container">
          <div class="preview-box zoom-3" id="previewBox">${displaySvg}</div>
        </div>
        
        <div class="zoom-controls">
          <button class="zoom-btn" onclick="zoomOut()" title="${t("webview.details.zoomOut")}"><span class="codicon codicon-zoom-out"></span></button>
          <span class="zoom-level" id="zoomLevel">100%</span>
          <button class="zoom-btn" onclick="zoomIn()" title="${t("webview.details.zoomIn")}"><span class="codicon codicon-zoom-in"></span></button>
          <button class="zoom-btn" onclick="resetZoom()" title="${t("webview.details.resetZoom")}"><span class="codicon codicon-screen-normal"></span></button>
        </div>
        
        <div class="quick-actions">
          <button class="action-btn" onclick="copyName()" title="${t("webview.details.copyIconName")}"><span class="codicon codicon-copy"></span></button>
          <button class="action-btn" onclick="copySvg()" title="${t("webview.details.copySvgCode")}"><span class="codicon codicon-code"></span></button>
          <button class="action-btn primary" onclick="openEditor()" title="${t("webview.details.openInEditor")}"><span class="codicon codicon-edit"></span></button>
          ${locationButtonHtml}
        </div>
        
        <div class="color-picker-section">
          <div class="color-picker-title"><span class="codicon codicon-symbol-color"></span> ${t("webview.details.colors")}</div>
          ${colorsHtml}
        </div>
      </div>
      
      <div class="details-section">
        <h2>${t("webview.details.properties")}</h2>
        
        <!-- Compact Stats Row -->
        <div class="stats-row">
          <div class="stat-item">
            <span class="stat-value">${viewBox}</span>
            <span class="stat-label">viewBox</span>
          </div>
          <div class="stat-divider"></div>
          <div class="stat-item">
            <span class="stat-value" id="fileSize">${fileSizeStr}</span>
            <span class="stat-label">Size</span>
          </div>
          <div class="stat-divider"></div>
          <div class="stat-item">
            <span class="stat-value">${totalElements}</span>
            <span class="stat-label">Elements</span>
          </div>
        </div>
        
        <div class="details-grid">
          <div class="detail-card">
            <div class="detail-label"><span class="codicon codicon-symbol-class"></span> ${t("webview.details.elementsBreakdown") || "Elements Breakdown"}</div>
            <div class="detail-sub">${elementsStr}</div>
          </div>
          ${featuresHtml}
          ${locationCardHtml}
          ${licenseCardHtml}
        </div>
        
        ${animationHtml}
        
        <div class="Variants-section${hasMoreColors ? " disabled-section" : ""}">
          <div class="Variants-header">
            <h2><span class="codicon codicon-color-mode"></span> ${t("webview.details.variants")}</h2>
            ${variantsAddButtonHtml}
          </div>
          ${variantsContentHtml}
        </div>
        
        <div class="usages-section">
          <div class="usages-header">
            <h2><span class="codicon codicon-references"></span> ${t("webview.details.usages")}</h2>
            <span class="usages-count" id="usagesCount"></span>
          </div>
          <div class="usages-list" id="usagesList">
            <div class="loading"><span class="codicon codicon-sync"></span> ${t("webview.details.searchingUsages")}</div>
          </div>
        </div>
      </div>
    </div>
  </div>
  <script>${jsContent}</script>
</body>
</html>`;
      }
      _generateVariantsHtml(iconName) {
        const variantsService = getVariantsService();
        const savedVariants = variantsService.getSavedVariants(iconName);
        const defaultVariant = variantsService.getDefaultVariant(iconName);
        const originalVariant = `
      <div class="variant-item default${this._selectedVariantIndex === -1 ? " selected" : ""}${!defaultVariant ? " is-default" : ""}" onclick="applyDefaultVariant()" title="Original colors${!defaultVariant ? " (active default)" : ""}">
        <div class="variant-colors">
          ${this._originalColors.slice(0, 4).map((c) => `<div class="variant-color-dot" style="background:${c}"></div>`).join("")}
        </div>
        <span class="variant-name">original</span>
        <div class="variant-actions">
          <button class="variant-set-default${!defaultVariant ? " active" : ""}" onclick="event.stopPropagation(); setDefaultVariant(null)" title="${!defaultVariant ? "Currently default" : "Set as default"}">
            <span class="codicon codicon-star${!defaultVariant ? "-full" : "-empty"}"></span>
          </button>
        </div>
      </div>
    `;
        const savedVariantsHtml = savedVariants.map(
          (variant, index) => `
      <div class="variant-item${this._selectedVariantIndex === index ? " selected" : ""}${defaultVariant === variant.name ? " is-default" : ""}" onclick="applyVariant(${index})" title="${variant.name} - Click to apply${defaultVariant === variant.name ? " (active default)" : ""}">
        <div class="variant-colors">
          ${variant.colors.slice(0, 4).map((c) => `<div class="variant-color-dot" style="background:${c}"></div>`).join("")}
        </div>
        <span class="variant-name">${variant.name}</span>
        <div class="variant-actions">
          <button class="variant-set-default${defaultVariant === variant.name ? " active" : ""}" onclick="event.stopPropagation(); setDefaultVariant('${variant.name}')" title="${defaultVariant === variant.name ? "Currently default" : "Set as default"}">
            <span class="codicon codicon-star${defaultVariant === variant.name ? "-full" : "-empty"}"></span>
          </button>
          <button class="variant-delete" onclick="event.stopPropagation(); deleteVariant(${index})" title="Delete">
            <span class="codicon codicon-trash"></span>
          </button>
        </div>
      </div>
    `
        ).join("");
        return originalVariant + savedVariantsHtml;
      }
    };
  }
});

// node_modules/@xmldom/xmldom/lib/conventions.js
var require_conventions = __commonJS({
  "node_modules/@xmldom/xmldom/lib/conventions.js"(exports2) {
    "use strict";
    function find(list, predicate, ac) {
      if (ac === void 0) {
        ac = Array.prototype;
      }
      if (list && typeof ac.find === "function") {
        return ac.find.call(list, predicate);
      }
      for (var i = 0; i < list.length; i++) {
        if (Object.prototype.hasOwnProperty.call(list, i)) {
          var item = list[i];
          if (predicate.call(void 0, item, i, list)) {
            return item;
          }
        }
      }
    }
    function freeze(object, oc) {
      if (oc === void 0) {
        oc = Object;
      }
      return oc && typeof oc.freeze === "function" ? oc.freeze(object) : object;
    }
    function assign(target, source) {
      if (target === null || typeof target !== "object") {
        throw new TypeError("target is not an object");
      }
      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
      return target;
    }
    var MIME_TYPE = freeze({
      /**
       * `text/html`, the only mime type that triggers treating an XML document as HTML.
       *
       * @see DOMParser.SupportedType.isHTML
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring WHATWG HTML Spec
       */
      HTML: "text/html",
      /**
       * Helper method to check a mime type if it indicates an HTML document
       *
       * @param {string} [value]
       * @returns {boolean}
       *
       * @see https://www.iana.org/assignments/media-types/text/html IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/HTML Wikipedia
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMParser/parseFromString MDN
       * @see https://html.spec.whatwg.org/multipage/dynamic-markup-insertion.html#dom-domparser-parsefromstring 	 */
      isHTML: function(value) {
        return value === MIME_TYPE.HTML;
      },
      /**
       * `application/xml`, the standard mime type for XML documents.
       *
       * @see https://www.iana.org/assignments/media-types/application/xml IANA MimeType registration
       * @see https://tools.ietf.org/html/rfc7303#section-9.1 RFC 7303
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_APPLICATION: "application/xml",
      /**
       * `text/html`, an alias for `application/xml`.
       *
       * @see https://tools.ietf.org/html/rfc7303#section-9.2 RFC 7303
       * @see https://www.iana.org/assignments/media-types/text/xml IANA MimeType registration
       * @see https://en.wikipedia.org/wiki/XML_and_MIME Wikipedia
       */
      XML_TEXT: "text/xml",
      /**
       * `application/xhtml+xml`, indicates an XML document that has the default HTML namespace,
       * but is parsed as an XML document.
       *
       * @see https://www.iana.org/assignments/media-types/application/xhtml+xml IANA MimeType registration
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument WHATWG DOM Spec
       * @see https://en.wikipedia.org/wiki/XHTML Wikipedia
       */
      XML_XHTML_APPLICATION: "application/xhtml+xml",
      /**
       * `image/svg+xml`,
       *
       * @see https://www.iana.org/assignments/media-types/image/svg+xml IANA MimeType registration
       * @see https://www.w3.org/TR/SVG11/ W3C SVG 1.1
       * @see https://en.wikipedia.org/wiki/Scalable_Vector_Graphics Wikipedia
       */
      XML_SVG_IMAGE: "image/svg+xml"
    });
    var NAMESPACE = freeze({
      /**
       * The XHTML namespace.
       *
       * @see http://www.w3.org/1999/xhtml
       */
      HTML: "http://www.w3.org/1999/xhtml",
      /**
       * Checks if `uri` equals `NAMESPACE.HTML`.
       *
       * @param {string} [uri]
       *
       * @see NAMESPACE.HTML
       */
      isHTML: function(uri) {
        return uri === NAMESPACE.HTML;
      },
      /**
       * The SVG namespace.
       *
       * @see http://www.w3.org/2000/svg
       */
      SVG: "http://www.w3.org/2000/svg",
      /**
       * The `xml:` namespace.
       *
       * @see http://www.w3.org/XML/1998/namespace
       */
      XML: "http://www.w3.org/XML/1998/namespace",
      /**
       * The `xmlns:` namespace
       *
       * @see https://www.w3.org/2000/xmlns/
       */
      XMLNS: "http://www.w3.org/2000/xmlns/"
    });
    exports2.assign = assign;
    exports2.find = find;
    exports2.freeze = freeze;
    exports2.MIME_TYPE = MIME_TYPE;
    exports2.NAMESPACE = NAMESPACE;
  }
});

// node_modules/@xmldom/xmldom/lib/dom.js
var require_dom = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom.js"(exports2) {
    var conventions = require_conventions();
    var find = conventions.find;
    var NAMESPACE = conventions.NAMESPACE;
    function notEmptyString(input) {
      return input !== "";
    }
    function splitOnASCIIWhitespace(input) {
      return input ? input.split(/[\t\n\f\r ]+/).filter(notEmptyString) : [];
    }
    function orderedSetReducer(current, element) {
      if (!current.hasOwnProperty(element)) {
        current[element] = true;
      }
      return current;
    }
    function toOrderedSet(input) {
      if (!input) return [];
      var list = splitOnASCIIWhitespace(input);
      return Object.keys(list.reduce(orderedSetReducer, {}));
    }
    function arrayIncludes(list) {
      return function(element) {
        return list && list.indexOf(element) !== -1;
      };
    }
    function copy(src, dest) {
      for (var p in src) {
        if (Object.prototype.hasOwnProperty.call(src, p)) {
          dest[p] = src[p];
        }
      }
    }
    function _extends(Class, Super) {
      var pt = Class.prototype;
      if (!(pt instanceof Super)) {
        let t3 = function() {
        };
        var t2 = t3;
        ;
        t3.prototype = Super.prototype;
        t3 = new t3();
        copy(pt, t3);
        Class.prototype = pt = t3;
      }
      if (pt.constructor != Class) {
        if (typeof Class != "function") {
          console.error("unknown Class:" + Class);
        }
        pt.constructor = Class;
      }
    }
    var NodeType = {};
    var ELEMENT_NODE = NodeType.ELEMENT_NODE = 1;
    var ATTRIBUTE_NODE = NodeType.ATTRIBUTE_NODE = 2;
    var TEXT_NODE = NodeType.TEXT_NODE = 3;
    var CDATA_SECTION_NODE = NodeType.CDATA_SECTION_NODE = 4;
    var ENTITY_REFERENCE_NODE = NodeType.ENTITY_REFERENCE_NODE = 5;
    var ENTITY_NODE = NodeType.ENTITY_NODE = 6;
    var PROCESSING_INSTRUCTION_NODE = NodeType.PROCESSING_INSTRUCTION_NODE = 7;
    var COMMENT_NODE = NodeType.COMMENT_NODE = 8;
    var DOCUMENT_NODE = NodeType.DOCUMENT_NODE = 9;
    var DOCUMENT_TYPE_NODE = NodeType.DOCUMENT_TYPE_NODE = 10;
    var DOCUMENT_FRAGMENT_NODE = NodeType.DOCUMENT_FRAGMENT_NODE = 11;
    var NOTATION_NODE = NodeType.NOTATION_NODE = 12;
    var ExceptionCode = {};
    var ExceptionMessage = {};
    var INDEX_SIZE_ERR = ExceptionCode.INDEX_SIZE_ERR = (ExceptionMessage[1] = "Index size error", 1);
    var DOMSTRING_SIZE_ERR = ExceptionCode.DOMSTRING_SIZE_ERR = (ExceptionMessage[2] = "DOMString size error", 2);
    var HIERARCHY_REQUEST_ERR = ExceptionCode.HIERARCHY_REQUEST_ERR = (ExceptionMessage[3] = "Hierarchy request error", 3);
    var WRONG_DOCUMENT_ERR = ExceptionCode.WRONG_DOCUMENT_ERR = (ExceptionMessage[4] = "Wrong document", 4);
    var INVALID_CHARACTER_ERR = ExceptionCode.INVALID_CHARACTER_ERR = (ExceptionMessage[5] = "Invalid character", 5);
    var NO_DATA_ALLOWED_ERR = ExceptionCode.NO_DATA_ALLOWED_ERR = (ExceptionMessage[6] = "No data allowed", 6);
    var NO_MODIFICATION_ALLOWED_ERR = ExceptionCode.NO_MODIFICATION_ALLOWED_ERR = (ExceptionMessage[7] = "No modification allowed", 7);
    var NOT_FOUND_ERR = ExceptionCode.NOT_FOUND_ERR = (ExceptionMessage[8] = "Not found", 8);
    var NOT_SUPPORTED_ERR = ExceptionCode.NOT_SUPPORTED_ERR = (ExceptionMessage[9] = "Not supported", 9);
    var INUSE_ATTRIBUTE_ERR = ExceptionCode.INUSE_ATTRIBUTE_ERR = (ExceptionMessage[10] = "Attribute in use", 10);
    var INVALID_STATE_ERR = ExceptionCode.INVALID_STATE_ERR = (ExceptionMessage[11] = "Invalid state", 11);
    var SYNTAX_ERR = ExceptionCode.SYNTAX_ERR = (ExceptionMessage[12] = "Syntax error", 12);
    var INVALID_MODIFICATION_ERR = ExceptionCode.INVALID_MODIFICATION_ERR = (ExceptionMessage[13] = "Invalid modification", 13);
    var NAMESPACE_ERR = ExceptionCode.NAMESPACE_ERR = (ExceptionMessage[14] = "Invalid namespace", 14);
    var INVALID_ACCESS_ERR = ExceptionCode.INVALID_ACCESS_ERR = (ExceptionMessage[15] = "Invalid access", 15);
    function DOMException(code, message) {
      if (message instanceof Error) {
        var error = message;
      } else {
        error = this;
        Error.call(this, ExceptionMessage[code]);
        this.message = ExceptionMessage[code];
        if (Error.captureStackTrace) Error.captureStackTrace(this, DOMException);
      }
      error.code = code;
      if (message) this.message = this.message + ": " + message;
      return error;
    }
    DOMException.prototype = Error.prototype;
    copy(ExceptionCode, DOMException);
    function NodeList() {
    }
    NodeList.prototype = {
      /**
       * The number of nodes in the list. The range of valid child node indices is 0 to length-1 inclusive.
       * @standard level1
       */
      length: 0,
      /**
       * Returns the indexth item in the collection. If index is greater than or equal to the number of nodes in the list, this returns null.
       * @standard level1
       * @param index  unsigned long
       *   Index into the collection.
       * @return Node
       * 	The node at the indexth position in the NodeList, or null if that is not a valid index.
       */
      item: function(index) {
        return index >= 0 && index < this.length ? this[index] : null;
      },
      toString: function(isHTML, nodeFilter) {
        for (var buf = [], i = 0; i < this.length; i++) {
          serializeToString(this[i], buf, isHTML, nodeFilter);
        }
        return buf.join("");
      },
      /**
       * @private
       * @param {function (Node):boolean} predicate
       * @returns {Node[]}
       */
      filter: function(predicate) {
        return Array.prototype.filter.call(this, predicate);
      },
      /**
       * @private
       * @param {Node} item
       * @returns {number}
       */
      indexOf: function(item) {
        return Array.prototype.indexOf.call(this, item);
      }
    };
    function LiveNodeList(node, refresh) {
      this._node = node;
      this._refresh = refresh;
      _updateLiveList(this);
    }
    function _updateLiveList(list) {
      var inc = list._node._inc || list._node.ownerDocument._inc;
      if (list._inc !== inc) {
        var ls = list._refresh(list._node);
        __set__(list, "length", ls.length);
        if (!list.$$length || ls.length < list.$$length) {
          for (var i = ls.length; i in list; i++) {
            if (Object.prototype.hasOwnProperty.call(list, i)) {
              delete list[i];
            }
          }
        }
        copy(ls, list);
        list._inc = inc;
      }
    }
    LiveNodeList.prototype.item = function(i) {
      _updateLiveList(this);
      return this[i] || null;
    };
    _extends(LiveNodeList, NodeList);
    function NamedNodeMap() {
    }
    function _findNodeIndex(list, node) {
      var i = list.length;
      while (i--) {
        if (list[i] === node) {
          return i;
        }
      }
    }
    function _addNamedNode(el, list, newAttr, oldAttr) {
      if (oldAttr) {
        list[_findNodeIndex(list, oldAttr)] = newAttr;
      } else {
        list[list.length++] = newAttr;
      }
      if (el) {
        newAttr.ownerElement = el;
        var doc = el.ownerDocument;
        if (doc) {
          oldAttr && _onRemoveAttribute(doc, el, oldAttr);
          _onAddAttribute(doc, el, newAttr);
        }
      }
    }
    function _removeNamedNode(el, list, attr) {
      var i = _findNodeIndex(list, attr);
      if (i >= 0) {
        var lastIndex = list.length - 1;
        while (i < lastIndex) {
          list[i] = list[++i];
        }
        list.length = lastIndex;
        if (el) {
          var doc = el.ownerDocument;
          if (doc) {
            _onRemoveAttribute(doc, el, attr);
            attr.ownerElement = null;
          }
        }
      } else {
        throw new DOMException(NOT_FOUND_ERR, new Error(el.tagName + "@" + attr));
      }
    }
    NamedNodeMap.prototype = {
      length: 0,
      item: NodeList.prototype.item,
      getNamedItem: function(key) {
        var i = this.length;
        while (i--) {
          var attr = this[i];
          if (attr.nodeName == key) {
            return attr;
          }
        }
      },
      setNamedItem: function(attr) {
        var el = attr.ownerElement;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        var oldAttr = this.getNamedItem(attr.nodeName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      setNamedItemNS: function(attr) {
        var el = attr.ownerElement, oldAttr;
        if (el && el != this._ownerElement) {
          throw new DOMException(INUSE_ATTRIBUTE_ERR);
        }
        oldAttr = this.getNamedItemNS(attr.namespaceURI, attr.localName);
        _addNamedNode(this._ownerElement, this, attr, oldAttr);
        return oldAttr;
      },
      /* returns Node */
      removeNamedItem: function(key) {
        var attr = this.getNamedItem(key);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      // raises: NOT_FOUND_ERR,NO_MODIFICATION_ALLOWED_ERR
      //for level2
      removeNamedItemNS: function(namespaceURI, localName) {
        var attr = this.getNamedItemNS(namespaceURI, localName);
        _removeNamedNode(this._ownerElement, this, attr);
        return attr;
      },
      getNamedItemNS: function(namespaceURI, localName) {
        var i = this.length;
        while (i--) {
          var node = this[i];
          if (node.localName == localName && node.namespaceURI == namespaceURI) {
            return node;
          }
        }
        return null;
      }
    };
    function DOMImplementation() {
    }
    DOMImplementation.prototype = {
      /**
       * The DOMImplementation.hasFeature() method returns a Boolean flag indicating if a given feature is supported.
       * The different implementations fairly diverged in what kind of features were reported.
       * The latest version of the spec settled to force this method to always return true, where the functionality was accurate and in use.
       *
       * @deprecated It is deprecated and modern browsers return true in all cases.
       *
       * @param {string} feature
       * @param {string} [version]
       * @returns {boolean} always true
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/hasFeature MDN
       * @see https://www.w3.org/TR/REC-DOM-Level-1/level-one-core.html#ID-5CED94D7 DOM Level 1 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-hasfeature DOM Living Standard
       */
      hasFeature: function(feature, version) {
        return true;
      },
      /**
       * Creates an XML Document object of the specified type with its document element.
       *
       * __It behaves slightly different from the description in the living standard__:
       * - There is no interface/class `XMLDocument`, it returns a `Document` instance.
       * - `contentType`, `encoding`, `mode`, `origin`, `url` fields are currently not declared.
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string|null} namespaceURI
       * @param {string} qualifiedName
       * @param {DocumentType=null} doctype
       * @returns {Document}
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocument MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocument DOM Level 2 Core (initial)
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocument  DOM Level 2 Core
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocument: function(namespaceURI, qualifiedName, doctype) {
        var doc = new Document();
        doc.implementation = this;
        doc.childNodes = new NodeList();
        doc.doctype = doctype || null;
        if (doctype) {
          doc.appendChild(doctype);
        }
        if (qualifiedName) {
          var root = doc.createElementNS(namespaceURI, qualifiedName);
          doc.appendChild(root);
        }
        return doc;
      },
      /**
       * Returns a doctype, with the given `qualifiedName`, `publicId`, and `systemId`.
       *
       * __This behavior is slightly different from the in the specs__:
       * - this implementation is not validating names or qualified names
       *   (when parsing XML strings, the SAX parser takes care of that)
       *
       * @param {string} qualifiedName
       * @param {string} [publicId]
       * @param {string} [systemId]
       * @returns {DocumentType} which can either be used with `DOMImplementation.createDocument` upon document creation
       * 				  or can be put into the document via methods like `Node.insertBefore()` or `Node.replaceChild()`
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/DOMImplementation/createDocumentType MDN
       * @see https://www.w3.org/TR/DOM-Level-2-Core/core.html#Level-2-Core-DOM-createDocType DOM Level 2 Core
       * @see https://dom.spec.whatwg.org/#dom-domimplementation-createdocumenttype DOM Living Standard
       *
       * @see https://dom.spec.whatwg.org/#validate-and-extract DOM: Validate and extract
       * @see https://www.w3.org/TR/xml/#NT-NameStartChar XML Spec: Names
       * @see https://www.w3.org/TR/xml-names/#ns-qualnames XML Namespaces: Qualified names
       */
      createDocumentType: function(qualifiedName, publicId, systemId) {
        var node = new DocumentType();
        node.name = qualifiedName;
        node.nodeName = qualifiedName;
        node.publicId = publicId || "";
        node.systemId = systemId || "";
        return node;
      }
    };
    function Node() {
    }
    Node.prototype = {
      firstChild: null,
      lastChild: null,
      previousSibling: null,
      nextSibling: null,
      attributes: null,
      parentNode: null,
      childNodes: null,
      ownerDocument: null,
      nodeValue: null,
      namespaceURI: null,
      prefix: null,
      localName: null,
      // Modified in DOM Level 2:
      insertBefore: function(newChild, refChild) {
        return _insertBefore(this, newChild, refChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        if (oldChild) {
          this.removeChild(oldChild);
        }
      },
      removeChild: function(oldChild) {
        return _removeChild(this, oldChild);
      },
      appendChild: function(newChild) {
        return this.insertBefore(newChild, null);
      },
      hasChildNodes: function() {
        return this.firstChild != null;
      },
      cloneNode: function(deep) {
        return cloneNode(this.ownerDocument || this, this, deep);
      },
      // Modified in DOM Level 2:
      normalize: function() {
        var child = this.firstChild;
        while (child) {
          var next = child.nextSibling;
          if (next && next.nodeType == TEXT_NODE && child.nodeType == TEXT_NODE) {
            this.removeChild(next);
            child.appendData(next.data);
          } else {
            child.normalize();
            child = next;
          }
        }
      },
      // Introduced in DOM Level 2:
      isSupported: function(feature, version) {
        return this.ownerDocument.implementation.hasFeature(feature, version);
      },
      // Introduced in DOM Level 2:
      hasAttributes: function() {
        return this.attributes.length > 0;
      },
      /**
       * Look up the prefix associated to the given namespace URI, starting from this node.
       * **The default namespace declarations are ignored by this method.**
       * See Namespace Prefix Lookup for details on the algorithm used by this method.
       *
       * _Note: The implementation seems to be incomplete when compared to the algorithm described in the specs._
       *
       * @param {string | null} namespaceURI
       * @returns {string | null}
       * @see https://www.w3.org/TR/DOM-Level-3-Core/core.html#Node3-lookupNamespacePrefix
       * @see https://www.w3.org/TR/DOM-Level-3-Core/namespaces-algorithms.html#lookupNamespacePrefixAlgo
       * @see https://dom.spec.whatwg.org/#dom-node-lookupprefix
       * @see https://github.com/xmldom/xmldom/issues/322
       */
      lookupPrefix: function(namespaceURI) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            for (var n in map) {
              if (Object.prototype.hasOwnProperty.call(map, n) && map[n] === namespaceURI) {
                return n;
              }
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      lookupNamespaceURI: function(prefix) {
        var el = this;
        while (el) {
          var map = el._nsMap;
          if (map) {
            if (Object.prototype.hasOwnProperty.call(map, prefix)) {
              return map[prefix];
            }
          }
          el = el.nodeType == ATTRIBUTE_NODE ? el.ownerDocument : el.parentNode;
        }
        return null;
      },
      // Introduced in DOM Level 3:
      isDefaultNamespace: function(namespaceURI) {
        var prefix = this.lookupPrefix(namespaceURI);
        return prefix == null;
      }
    };
    function _xmlEncoder(c) {
      return c == "<" && "&lt;" || c == ">" && "&gt;" || c == "&" && "&amp;" || c == '"' && "&quot;" || "&#" + c.charCodeAt() + ";";
    }
    copy(NodeType, Node);
    copy(NodeType, Node.prototype);
    function _visitNode(node, callback) {
      if (callback(node)) {
        return true;
      }
      if (node = node.firstChild) {
        do {
          if (_visitNode(node, callback)) {
            return true;
          }
        } while (node = node.nextSibling);
      }
    }
    function Document() {
      this.ownerDocument = this;
    }
    function _onAddAttribute(doc, el, newAttr) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        el._nsMap[newAttr.prefix ? newAttr.localName : ""] = newAttr.value;
      }
    }
    function _onRemoveAttribute(doc, el, newAttr, remove) {
      doc && doc._inc++;
      var ns = newAttr.namespaceURI;
      if (ns === NAMESPACE.XMLNS) {
        delete el._nsMap[newAttr.prefix ? newAttr.localName : ""];
      }
    }
    function _onUpdateChild(doc, el, newChild) {
      if (doc && doc._inc) {
        doc._inc++;
        var cs = el.childNodes;
        if (newChild) {
          cs[cs.length++] = newChild;
        } else {
          var child = el.firstChild;
          var i = 0;
          while (child) {
            cs[i++] = child;
            child = child.nextSibling;
          }
          cs.length = i;
          delete cs[cs.length];
        }
      }
    }
    function _removeChild(parentNode, child) {
      var previous = child.previousSibling;
      var next = child.nextSibling;
      if (previous) {
        previous.nextSibling = next;
      } else {
        parentNode.firstChild = next;
      }
      if (next) {
        next.previousSibling = previous;
      } else {
        parentNode.lastChild = previous;
      }
      child.parentNode = null;
      child.previousSibling = null;
      child.nextSibling = null;
      _onUpdateChild(parentNode.ownerDocument, parentNode);
      return child;
    }
    function hasValidParentNodeType(node) {
      return node && (node.nodeType === Node.DOCUMENT_NODE || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.ELEMENT_NODE);
    }
    function hasInsertableNodeType(node) {
      return node && (isElementNode(node) || isTextNode(node) || isDocTypeNode(node) || node.nodeType === Node.DOCUMENT_FRAGMENT_NODE || node.nodeType === Node.COMMENT_NODE || node.nodeType === Node.PROCESSING_INSTRUCTION_NODE);
    }
    function isDocTypeNode(node) {
      return node && node.nodeType === Node.DOCUMENT_TYPE_NODE;
    }
    function isElementNode(node) {
      return node && node.nodeType === Node.ELEMENT_NODE;
    }
    function isTextNode(node) {
      return node && node.nodeType === Node.TEXT_NODE;
    }
    function isElementInsertionPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      if (find(parentChildNodes, isElementNode) || isDocTypeNode(child)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function isElementReplacementPossible(doc, child) {
      var parentChildNodes = doc.childNodes || [];
      function hasElementChildThatIsNotChild(node) {
        return isElementNode(node) && node !== child;
      }
      if (find(parentChildNodes, hasElementChildThatIsNotChild)) {
        return false;
      }
      var docTypeNode = find(parentChildNodes, isDocTypeNode);
      return !(child && docTypeNode && parentChildNodes.indexOf(docTypeNode) > parentChildNodes.indexOf(child));
    }
    function assertPreInsertionValidity1to5(parent, node, child) {
      if (!hasValidParentNodeType(parent)) {
        throw new DOMException(HIERARCHY_REQUEST_ERR, "Unexpected parent node type " + parent.nodeType);
      }
      if (child && child.parentNode !== parent) {
        throw new DOMException(NOT_FOUND_ERR, "child not in parent");
      }
      if (
        // 4. If `node` is not a DocumentFragment, DocumentType, Element, or CharacterData node, then throw a "HierarchyRequestError" DOMException.
        !hasInsertableNodeType(node) || // 5. If either `node` is a Text node and `parent` is a document,
        // the sax parser currently adds top level text nodes, this will be fixed in 0.9.0
        // || (node.nodeType === Node.TEXT_NODE && parent.nodeType === Node.DOCUMENT_NODE)
        // or `node` is a doctype and `parent` is not a document, then throw a "HierarchyRequestError" DOMException.
        isDocTypeNode(node) && parent.nodeType !== Node.DOCUMENT_NODE
      ) {
        throw new DOMException(
          HIERARCHY_REQUEST_ERR,
          "Unexpected node type " + node.nodeType + " for parent node type " + parent.nodeType
        );
      }
    }
    function assertPreInsertionValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementInsertionPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        if (find(parentChildNodes, isDocTypeNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
        if (!child && parentElementChild) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can not be appended since element is present");
        }
      }
    }
    function assertPreReplacementValidityInDocument(parent, node, child) {
      var parentChildNodes = parent.childNodes || [];
      var nodeChildNodes = node.childNodes || [];
      if (node.nodeType === Node.DOCUMENT_FRAGMENT_NODE) {
        var nodeChildElements = nodeChildNodes.filter(isElementNode);
        if (nodeChildElements.length > 1 || find(nodeChildNodes, isTextNode)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "More than one element or text in fragment");
        }
        if (nodeChildElements.length === 1 && !isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Element in fragment can not be inserted before doctype");
        }
      }
      if (isElementNode(node)) {
        if (!isElementReplacementPossible(parent, child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one element can be added and only after doctype");
        }
      }
      if (isDocTypeNode(node)) {
        let hasDoctypeChildThatIsNotChild2 = function(node2) {
          return isDocTypeNode(node2) && node2 !== child;
        };
        var hasDoctypeChildThatIsNotChild = hasDoctypeChildThatIsNotChild2;
        if (find(parentChildNodes, hasDoctypeChildThatIsNotChild2)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Only one doctype is allowed");
        }
        var parentElementChild = find(parentChildNodes, isElementNode);
        if (child && parentChildNodes.indexOf(parentElementChild) < parentChildNodes.indexOf(child)) {
          throw new DOMException(HIERARCHY_REQUEST_ERR, "Doctype can only be inserted before an element");
        }
      }
    }
    function _insertBefore(parent, node, child, _inDocumentAssertion) {
      assertPreInsertionValidity1to5(parent, node, child);
      if (parent.nodeType === Node.DOCUMENT_NODE) {
        (_inDocumentAssertion || assertPreInsertionValidityInDocument)(parent, node, child);
      }
      var cp = node.parentNode;
      if (cp) {
        cp.removeChild(node);
      }
      if (node.nodeType === DOCUMENT_FRAGMENT_NODE) {
        var newFirst = node.firstChild;
        if (newFirst == null) {
          return node;
        }
        var newLast = node.lastChild;
      } else {
        newFirst = newLast = node;
      }
      var pre = child ? child.previousSibling : parent.lastChild;
      newFirst.previousSibling = pre;
      newLast.nextSibling = child;
      if (pre) {
        pre.nextSibling = newFirst;
      } else {
        parent.firstChild = newFirst;
      }
      if (child == null) {
        parent.lastChild = newLast;
      } else {
        child.previousSibling = newLast;
      }
      do {
        newFirst.parentNode = parent;
        var targetDoc = parent.ownerDocument || parent;
        _updateOwnerDocument(newFirst, targetDoc);
      } while (newFirst !== newLast && (newFirst = newFirst.nextSibling));
      _onUpdateChild(parent.ownerDocument || parent, parent);
      if (node.nodeType == DOCUMENT_FRAGMENT_NODE) {
        node.firstChild = node.lastChild = null;
      }
      return node;
    }
    function _updateOwnerDocument(node, newOwnerDocument) {
      if (node.ownerDocument === newOwnerDocument) {
        return;
      }
      node.ownerDocument = newOwnerDocument;
      if (node.nodeType === ELEMENT_NODE && node.attributes) {
        for (var i = 0; i < node.attributes.length; i++) {
          var attr = node.attributes.item(i);
          if (attr) {
            attr.ownerDocument = newOwnerDocument;
          }
        }
      }
      var child = node.firstChild;
      while (child) {
        _updateOwnerDocument(child, newOwnerDocument);
        child = child.nextSibling;
      }
    }
    function _appendSingleChild(parentNode, newChild) {
      if (newChild.parentNode) {
        newChild.parentNode.removeChild(newChild);
      }
      newChild.parentNode = parentNode;
      newChild.previousSibling = parentNode.lastChild;
      newChild.nextSibling = null;
      if (newChild.previousSibling) {
        newChild.previousSibling.nextSibling = newChild;
      } else {
        parentNode.firstChild = newChild;
      }
      parentNode.lastChild = newChild;
      _onUpdateChild(parentNode.ownerDocument, parentNode, newChild);
      var targetDoc = parentNode.ownerDocument || parentNode;
      _updateOwnerDocument(newChild, targetDoc);
      return newChild;
    }
    Document.prototype = {
      //implementation : null,
      nodeName: "#document",
      nodeType: DOCUMENT_NODE,
      /**
       * The DocumentType node of the document.
       *
       * @readonly
       * @type DocumentType
       */
      doctype: null,
      documentElement: null,
      _inc: 1,
      insertBefore: function(newChild, refChild) {
        if (newChild.nodeType == DOCUMENT_FRAGMENT_NODE) {
          var child = newChild.firstChild;
          while (child) {
            var next = child.nextSibling;
            this.insertBefore(child, refChild);
            child = next;
          }
          return newChild;
        }
        _insertBefore(this, newChild, refChild);
        _updateOwnerDocument(newChild, this);
        if (this.documentElement === null && newChild.nodeType === ELEMENT_NODE) {
          this.documentElement = newChild;
        }
        return newChild;
      },
      removeChild: function(oldChild) {
        if (this.documentElement == oldChild) {
          this.documentElement = null;
        }
        return _removeChild(this, oldChild);
      },
      replaceChild: function(newChild, oldChild) {
        _insertBefore(this, newChild, oldChild, assertPreReplacementValidityInDocument);
        _updateOwnerDocument(newChild, this);
        if (oldChild) {
          this.removeChild(oldChild);
        }
        if (isElementNode(newChild)) {
          this.documentElement = newChild;
        }
      },
      // Introduced in DOM Level 2:
      importNode: function(importedNode, deep) {
        return importNode(this, importedNode, deep);
      },
      // Introduced in DOM Level 2:
      getElementById: function(id) {
        var rtv = null;
        _visitNode(this.documentElement, function(node) {
          if (node.nodeType == ELEMENT_NODE) {
            if (node.getAttribute("id") == id) {
              rtv = node;
              return true;
            }
          }
        });
        return rtv;
      },
      /**
       * The `getElementsByClassName` method of `Document` interface returns an array-like object
       * of all child elements which have **all** of the given class name(s).
       *
       * Returns an empty list if `classeNames` is an empty string or only contains HTML white space characters.
       *
       *
       * Warning: This is a live LiveNodeList.
       * Changes in the DOM will reflect in the array as the changes occur.
       * If an element selected by this array no longer qualifies for the selector,
       * it will automatically be removed. Be aware of this for iteration purposes.
       *
       * @param {string} classNames is a string representing the class name(s) to match; multiple class names are separated by (ASCII-)whitespace
       *
       * @see https://developer.mozilla.org/en-US/docs/Web/API/Document/getElementsByClassName
       * @see https://dom.spec.whatwg.org/#concept-getelementsbyclassname
       */
      getElementsByClassName: function(classNames) {
        var classNamesSet = toOrderedSet(classNames);
        return new LiveNodeList(this, function(base) {
          var ls = [];
          if (classNamesSet.length > 0) {
            _visitNode(base.documentElement, function(node) {
              if (node !== base && node.nodeType === ELEMENT_NODE) {
                var nodeClassNames = node.getAttribute("class");
                if (nodeClassNames) {
                  var matches = classNames === nodeClassNames;
                  if (!matches) {
                    var nodeClassNamesSet = toOrderedSet(nodeClassNames);
                    matches = classNamesSet.every(arrayIncludes(nodeClassNamesSet));
                  }
                  if (matches) {
                    ls.push(node);
                  }
                }
              }
            });
          }
          return ls;
        });
      },
      //document factory method:
      createElement: function(tagName) {
        var node = new Element();
        node.ownerDocument = this;
        node.nodeName = tagName;
        node.tagName = tagName;
        node.localName = tagName;
        node.childNodes = new NodeList();
        var attrs = node.attributes = new NamedNodeMap();
        attrs._ownerElement = node;
        return node;
      },
      createDocumentFragment: function() {
        var node = new DocumentFragment();
        node.ownerDocument = this;
        node.childNodes = new NodeList();
        return node;
      },
      createTextNode: function(data) {
        var node = new Text();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createComment: function(data) {
        var node = new Comment();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createCDATASection: function(data) {
        var node = new CDATASection();
        node.ownerDocument = this;
        node.appendData(data);
        return node;
      },
      createProcessingInstruction: function(target, data) {
        var node = new ProcessingInstruction();
        node.ownerDocument = this;
        node.tagName = node.nodeName = node.target = target;
        node.nodeValue = node.data = data;
        return node;
      },
      createAttribute: function(name) {
        var node = new Attr();
        node.ownerDocument = this;
        node.name = name;
        node.nodeName = name;
        node.localName = name;
        node.specified = true;
        return node;
      },
      createEntityReference: function(name) {
        var node = new EntityReference();
        node.ownerDocument = this;
        node.nodeName = name;
        return node;
      },
      // Introduced in DOM Level 2:
      createElementNS: function(namespaceURI, qualifiedName) {
        var node = new Element();
        var pl = qualifiedName.split(":");
        var attrs = node.attributes = new NamedNodeMap();
        node.childNodes = new NodeList();
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.tagName = qualifiedName;
        node.namespaceURI = namespaceURI;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        attrs._ownerElement = node;
        return node;
      },
      // Introduced in DOM Level 2:
      createAttributeNS: function(namespaceURI, qualifiedName) {
        var node = new Attr();
        var pl = qualifiedName.split(":");
        node.ownerDocument = this;
        node.nodeName = qualifiedName;
        node.name = qualifiedName;
        node.namespaceURI = namespaceURI;
        node.specified = true;
        if (pl.length == 2) {
          node.prefix = pl[0];
          node.localName = pl[1];
        } else {
          node.localName = qualifiedName;
        }
        return node;
      }
    };
    _extends(Document, Node);
    function Element() {
      this._nsMap = {};
    }
    Element.prototype = {
      nodeType: ELEMENT_NODE,
      hasAttribute: function(name) {
        return this.getAttributeNode(name) != null;
      },
      getAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        return attr && attr.value || "";
      },
      getAttributeNode: function(name) {
        return this.attributes.getNamedItem(name);
      },
      setAttribute: function(name, value) {
        var attr = this.ownerDocument.createAttribute(name);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      removeAttribute: function(name) {
        var attr = this.getAttributeNode(name);
        attr && this.removeAttributeNode(attr);
      },
      //four real opeartion method
      appendChild: function(newChild) {
        if (newChild.nodeType === DOCUMENT_FRAGMENT_NODE) {
          return this.insertBefore(newChild, null);
        } else {
          return _appendSingleChild(this, newChild);
        }
      },
      setAttributeNode: function(newAttr) {
        return this.attributes.setNamedItem(newAttr);
      },
      setAttributeNodeNS: function(newAttr) {
        return this.attributes.setNamedItemNS(newAttr);
      },
      removeAttributeNode: function(oldAttr) {
        return this.attributes.removeNamedItem(oldAttr.nodeName);
      },
      //get real attribute name,and remove it by removeAttributeNode
      removeAttributeNS: function(namespaceURI, localName) {
        var old = this.getAttributeNodeNS(namespaceURI, localName);
        old && this.removeAttributeNode(old);
      },
      hasAttributeNS: function(namespaceURI, localName) {
        return this.getAttributeNodeNS(namespaceURI, localName) != null;
      },
      getAttributeNS: function(namespaceURI, localName) {
        var attr = this.getAttributeNodeNS(namespaceURI, localName);
        return attr && attr.value || "";
      },
      setAttributeNS: function(namespaceURI, qualifiedName, value) {
        var attr = this.ownerDocument.createAttributeNS(namespaceURI, qualifiedName);
        attr.value = attr.nodeValue = "" + value;
        this.setAttributeNode(attr);
      },
      getAttributeNodeNS: function(namespaceURI, localName) {
        return this.attributes.getNamedItemNS(namespaceURI, localName);
      },
      getElementsByTagName: function(tagName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType == ELEMENT_NODE && (tagName === "*" || node.tagName == tagName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      },
      getElementsByTagNameNS: function(namespaceURI, localName) {
        return new LiveNodeList(this, function(base) {
          var ls = [];
          _visitNode(base, function(node) {
            if (node !== base && node.nodeType === ELEMENT_NODE && (namespaceURI === "*" || node.namespaceURI === namespaceURI) && (localName === "*" || node.localName == localName)) {
              ls.push(node);
            }
          });
          return ls;
        });
      }
    };
    Document.prototype.getElementsByTagName = Element.prototype.getElementsByTagName;
    Document.prototype.getElementsByTagNameNS = Element.prototype.getElementsByTagNameNS;
    _extends(Element, Node);
    function Attr() {
    }
    Attr.prototype.nodeType = ATTRIBUTE_NODE;
    _extends(Attr, Node);
    function CharacterData() {
    }
    CharacterData.prototype = {
      data: "",
      substringData: function(offset, count) {
        return this.data.substring(offset, offset + count);
      },
      appendData: function(text) {
        text = this.data + text;
        this.nodeValue = this.data = text;
        this.length = text.length;
      },
      insertData: function(offset, text) {
        this.replaceData(offset, 0, text);
      },
      appendChild: function(newChild) {
        throw new Error(ExceptionMessage[HIERARCHY_REQUEST_ERR]);
      },
      deleteData: function(offset, count) {
        this.replaceData(offset, count, "");
      },
      replaceData: function(offset, count, text) {
        var start = this.data.substring(0, offset);
        var end = this.data.substring(offset + count);
        text = start + text + end;
        this.nodeValue = this.data = text;
        this.length = text.length;
      }
    };
    _extends(CharacterData, Node);
    function Text() {
    }
    Text.prototype = {
      nodeName: "#text",
      nodeType: TEXT_NODE,
      splitText: function(offset) {
        var text = this.data;
        var newText = text.substring(offset);
        text = text.substring(0, offset);
        this.data = this.nodeValue = text;
        this.length = text.length;
        var newNode = this.ownerDocument.createTextNode(newText);
        if (this.parentNode) {
          this.parentNode.insertBefore(newNode, this.nextSibling);
        }
        return newNode;
      }
    };
    _extends(Text, CharacterData);
    function Comment() {
    }
    Comment.prototype = {
      nodeName: "#comment",
      nodeType: COMMENT_NODE
    };
    _extends(Comment, CharacterData);
    function CDATASection() {
    }
    CDATASection.prototype = {
      nodeName: "#cdata-section",
      nodeType: CDATA_SECTION_NODE
    };
    _extends(CDATASection, CharacterData);
    function DocumentType() {
    }
    DocumentType.prototype.nodeType = DOCUMENT_TYPE_NODE;
    _extends(DocumentType, Node);
    function Notation() {
    }
    Notation.prototype.nodeType = NOTATION_NODE;
    _extends(Notation, Node);
    function Entity() {
    }
    Entity.prototype.nodeType = ENTITY_NODE;
    _extends(Entity, Node);
    function EntityReference() {
    }
    EntityReference.prototype.nodeType = ENTITY_REFERENCE_NODE;
    _extends(EntityReference, Node);
    function DocumentFragment() {
    }
    DocumentFragment.prototype.nodeName = "#document-fragment";
    DocumentFragment.prototype.nodeType = DOCUMENT_FRAGMENT_NODE;
    _extends(DocumentFragment, Node);
    function ProcessingInstruction() {
    }
    ProcessingInstruction.prototype.nodeType = PROCESSING_INSTRUCTION_NODE;
    _extends(ProcessingInstruction, Node);
    function XMLSerializer2() {
    }
    XMLSerializer2.prototype.serializeToString = function(node, isHtml, nodeFilter) {
      return nodeSerializeToString.call(node, isHtml, nodeFilter);
    };
    Node.prototype.toString = nodeSerializeToString;
    function nodeSerializeToString(isHtml, nodeFilter) {
      var buf = [];
      var refNode = this.nodeType == 9 && this.documentElement || this;
      var prefix = refNode.prefix;
      var uri = refNode.namespaceURI;
      if (uri && prefix == null) {
        var prefix = refNode.lookupPrefix(uri);
        if (prefix == null) {
          var visibleNamespaces = [
            { namespace: uri, prefix: null }
            //{namespace:uri,prefix:''}
          ];
        }
      }
      serializeToString(this, buf, isHtml, nodeFilter, visibleNamespaces);
      return buf.join("");
    }
    function needNamespaceDefine(node, isHTML, visibleNamespaces) {
      var prefix = node.prefix || "";
      var uri = node.namespaceURI;
      if (!uri) {
        return false;
      }
      if (prefix === "xml" && uri === NAMESPACE.XML || uri === NAMESPACE.XMLNS) {
        return false;
      }
      var i = visibleNamespaces.length;
      while (i--) {
        var ns = visibleNamespaces[i];
        if (ns.prefix === prefix) {
          return ns.namespace !== uri;
        }
      }
      return true;
    }
    function addSerializedAttribute(buf, qualifiedName, value) {
      buf.push(" ", qualifiedName, '="', value.replace(/[<>&"\t\n\r]/g, _xmlEncoder), '"');
    }
    function serializeToString(node, buf, isHTML, nodeFilter, visibleNamespaces) {
      if (!visibleNamespaces) {
        visibleNamespaces = [];
      }
      if (nodeFilter) {
        node = nodeFilter(node);
        if (node) {
          if (typeof node == "string") {
            buf.push(node);
            return;
          }
        } else {
          return;
        }
      }
      switch (node.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var len = attrs.length;
          var child = node.firstChild;
          var nodeName = node.tagName;
          isHTML = NAMESPACE.isHTML(node.namespaceURI) || isHTML;
          var prefixedNodeName = nodeName;
          if (!isHTML && !node.prefix && node.namespaceURI) {
            var defaultNS;
            for (var ai = 0; ai < attrs.length; ai++) {
              if (attrs.item(ai).name === "xmlns") {
                defaultNS = attrs.item(ai).value;
                break;
              }
            }
            if (!defaultNS) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.prefix === "" && namespace.namespace === node.namespaceURI) {
                  defaultNS = namespace.namespace;
                  break;
                }
              }
            }
            if (defaultNS !== node.namespaceURI) {
              for (var nsi = visibleNamespaces.length - 1; nsi >= 0; nsi--) {
                var namespace = visibleNamespaces[nsi];
                if (namespace.namespace === node.namespaceURI) {
                  if (namespace.prefix) {
                    prefixedNodeName = namespace.prefix + ":" + nodeName;
                  }
                  break;
                }
              }
            }
          }
          buf.push("<", prefixedNodeName);
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (attr.prefix == "xmlns") {
              visibleNamespaces.push({ prefix: attr.localName, namespace: attr.value });
            } else if (attr.nodeName == "xmlns") {
              visibleNamespaces.push({ prefix: "", namespace: attr.value });
            }
          }
          for (var i = 0; i < len; i++) {
            var attr = attrs.item(i);
            if (needNamespaceDefine(attr, isHTML, visibleNamespaces)) {
              var prefix = attr.prefix || "";
              var uri = attr.namespaceURI;
              addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
              visibleNamespaces.push({ prefix, namespace: uri });
            }
            serializeToString(attr, buf, isHTML, nodeFilter, visibleNamespaces);
          }
          if (nodeName === prefixedNodeName && needNamespaceDefine(node, isHTML, visibleNamespaces)) {
            var prefix = node.prefix || "";
            var uri = node.namespaceURI;
            addSerializedAttribute(buf, prefix ? "xmlns:" + prefix : "xmlns", uri);
            visibleNamespaces.push({ prefix, namespace: uri });
          }
          if (child || isHTML && !/^(?:meta|link|img|br|hr|input)$/i.test(nodeName)) {
            buf.push(">");
            if (isHTML && /^script$/i.test(nodeName)) {
              while (child) {
                if (child.data) {
                  buf.push(child.data);
                } else {
                  serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                }
                child = child.nextSibling;
              }
            } else {
              while (child) {
                serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
                child = child.nextSibling;
              }
            }
            buf.push("</", prefixedNodeName, ">");
          } else {
            buf.push("/>");
          }
          return;
        case DOCUMENT_NODE:
        case DOCUMENT_FRAGMENT_NODE:
          var child = node.firstChild;
          while (child) {
            serializeToString(child, buf, isHTML, nodeFilter, visibleNamespaces.slice());
            child = child.nextSibling;
          }
          return;
        case ATTRIBUTE_NODE:
          return addSerializedAttribute(buf, node.name, node.value);
        case TEXT_NODE:
          return buf.push(
            node.data.replace(/[<&>]/g, _xmlEncoder)
          );
        case CDATA_SECTION_NODE:
          return buf.push("<![CDATA[", node.data, "]]>");
        case COMMENT_NODE:
          return buf.push("<!--", node.data, "-->");
        case DOCUMENT_TYPE_NODE:
          var pubid = node.publicId;
          var sysid = node.systemId;
          buf.push("<!DOCTYPE ", node.name);
          if (pubid) {
            buf.push(" PUBLIC ", pubid);
            if (sysid && sysid != ".") {
              buf.push(" ", sysid);
            }
            buf.push(">");
          } else if (sysid && sysid != ".") {
            buf.push(" SYSTEM ", sysid, ">");
          } else {
            var sub = node.internalSubset;
            if (sub) {
              buf.push(" [", sub, "]");
            }
            buf.push(">");
          }
          return;
        case PROCESSING_INSTRUCTION_NODE:
          return buf.push("<?", node.target, " ", node.data, "?>");
        case ENTITY_REFERENCE_NODE:
          return buf.push("&", node.nodeName, ";");
        //case ENTITY_NODE:
        //case NOTATION_NODE:
        default:
          buf.push("??", node.nodeName);
      }
    }
    function importNode(doc, node, deep) {
      var node2;
      switch (node.nodeType) {
        case ELEMENT_NODE:
          node2 = node.cloneNode(false);
          node2.ownerDocument = doc;
        //var attrs = node2.attributes;
        //var len = attrs.length;
        //for(var i=0;i<len;i++){
        //node2.setAttributeNodeNS(importNode(doc,attrs.item(i),deep));
        //}
        case DOCUMENT_FRAGMENT_NODE:
          break;
        case ATTRIBUTE_NODE:
          deep = true;
          break;
      }
      if (!node2) {
        node2 = node.cloneNode(false);
      }
      node2.ownerDocument = doc;
      node2.parentNode = null;
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(importNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function cloneNode(doc, node, deep) {
      var node2 = new node.constructor();
      for (var n in node) {
        if (Object.prototype.hasOwnProperty.call(node, n)) {
          var v = node[n];
          if (typeof v != "object") {
            if (v != node2[n]) {
              node2[n] = v;
            }
          }
        }
      }
      if (node.childNodes) {
        node2.childNodes = new NodeList();
      }
      node2.ownerDocument = doc;
      switch (node2.nodeType) {
        case ELEMENT_NODE:
          var attrs = node.attributes;
          var attrs2 = node2.attributes = new NamedNodeMap();
          var len = attrs.length;
          attrs2._ownerElement = node2;
          for (var i = 0; i < len; i++) {
            node2.setAttributeNode(cloneNode(doc, attrs.item(i), true));
          }
          break;
          ;
        case ATTRIBUTE_NODE:
          deep = true;
      }
      if (deep) {
        var child = node.firstChild;
        while (child) {
          node2.appendChild(cloneNode(doc, child, deep));
          child = child.nextSibling;
        }
      }
      return node2;
    }
    function __set__(object, key, value) {
      object[key] = value;
    }
    try {
      if (Object.defineProperty) {
        let getTextContent2 = function(node) {
          switch (node.nodeType) {
            case ELEMENT_NODE:
            case DOCUMENT_FRAGMENT_NODE:
              var buf = [];
              node = node.firstChild;
              while (node) {
                if (node.nodeType !== 7 && node.nodeType !== 8) {
                  buf.push(getTextContent2(node));
                }
                node = node.nextSibling;
              }
              return buf.join("");
            default:
              return node.nodeValue;
          }
        };
        getTextContent = getTextContent2;
        Object.defineProperty(LiveNodeList.prototype, "length", {
          get: function() {
            _updateLiveList(this);
            return this.$$length;
          }
        });
        Object.defineProperty(Node.prototype, "textContent", {
          get: function() {
            return getTextContent2(this);
          },
          set: function(data) {
            switch (this.nodeType) {
              case ELEMENT_NODE:
              case DOCUMENT_FRAGMENT_NODE:
                while (this.firstChild) {
                  this.removeChild(this.firstChild);
                }
                if (data || String(data)) {
                  this.appendChild(this.ownerDocument.createTextNode(data));
                }
                break;
              default:
                this.data = data;
                this.value = data;
                this.nodeValue = data;
            }
          }
        });
        __set__ = function(object, key, value) {
          object["$$" + key] = value;
        };
      }
    } catch (e) {
    }
    var getTextContent;
    exports2.DocumentType = DocumentType;
    exports2.DOMException = DOMException;
    exports2.DOMImplementation = DOMImplementation;
    exports2.Element = Element;
    exports2.Node = Node;
    exports2.NodeList = NodeList;
    exports2.XMLSerializer = XMLSerializer2;
  }
});

// node_modules/@xmldom/xmldom/lib/entities.js
var require_entities = __commonJS({
  "node_modules/@xmldom/xmldom/lib/entities.js"(exports2) {
    "use strict";
    var freeze = require_conventions().freeze;
    exports2.XML_ENTITIES = freeze({
      amp: "&",
      apos: "'",
      gt: ">",
      lt: "<",
      quot: '"'
    });
    exports2.HTML_ENTITIES = freeze({
      Aacute: "\xC1",
      aacute: "\xE1",
      Abreve: "\u0102",
      abreve: "\u0103",
      ac: "\u223E",
      acd: "\u223F",
      acE: "\u223E\u0333",
      Acirc: "\xC2",
      acirc: "\xE2",
      acute: "\xB4",
      Acy: "\u0410",
      acy: "\u0430",
      AElig: "\xC6",
      aelig: "\xE6",
      af: "\u2061",
      Afr: "\u{1D504}",
      afr: "\u{1D51E}",
      Agrave: "\xC0",
      agrave: "\xE0",
      alefsym: "\u2135",
      aleph: "\u2135",
      Alpha: "\u0391",
      alpha: "\u03B1",
      Amacr: "\u0100",
      amacr: "\u0101",
      amalg: "\u2A3F",
      AMP: "&",
      amp: "&",
      And: "\u2A53",
      and: "\u2227",
      andand: "\u2A55",
      andd: "\u2A5C",
      andslope: "\u2A58",
      andv: "\u2A5A",
      ang: "\u2220",
      ange: "\u29A4",
      angle: "\u2220",
      angmsd: "\u2221",
      angmsdaa: "\u29A8",
      angmsdab: "\u29A9",
      angmsdac: "\u29AA",
      angmsdad: "\u29AB",
      angmsdae: "\u29AC",
      angmsdaf: "\u29AD",
      angmsdag: "\u29AE",
      angmsdah: "\u29AF",
      angrt: "\u221F",
      angrtvb: "\u22BE",
      angrtvbd: "\u299D",
      angsph: "\u2222",
      angst: "\xC5",
      angzarr: "\u237C",
      Aogon: "\u0104",
      aogon: "\u0105",
      Aopf: "\u{1D538}",
      aopf: "\u{1D552}",
      ap: "\u2248",
      apacir: "\u2A6F",
      apE: "\u2A70",
      ape: "\u224A",
      apid: "\u224B",
      apos: "'",
      ApplyFunction: "\u2061",
      approx: "\u2248",
      approxeq: "\u224A",
      Aring: "\xC5",
      aring: "\xE5",
      Ascr: "\u{1D49C}",
      ascr: "\u{1D4B6}",
      Assign: "\u2254",
      ast: "*",
      asymp: "\u2248",
      asympeq: "\u224D",
      Atilde: "\xC3",
      atilde: "\xE3",
      Auml: "\xC4",
      auml: "\xE4",
      awconint: "\u2233",
      awint: "\u2A11",
      backcong: "\u224C",
      backepsilon: "\u03F6",
      backprime: "\u2035",
      backsim: "\u223D",
      backsimeq: "\u22CD",
      Backslash: "\u2216",
      Barv: "\u2AE7",
      barvee: "\u22BD",
      Barwed: "\u2306",
      barwed: "\u2305",
      barwedge: "\u2305",
      bbrk: "\u23B5",
      bbrktbrk: "\u23B6",
      bcong: "\u224C",
      Bcy: "\u0411",
      bcy: "\u0431",
      bdquo: "\u201E",
      becaus: "\u2235",
      Because: "\u2235",
      because: "\u2235",
      bemptyv: "\u29B0",
      bepsi: "\u03F6",
      bernou: "\u212C",
      Bernoullis: "\u212C",
      Beta: "\u0392",
      beta: "\u03B2",
      beth: "\u2136",
      between: "\u226C",
      Bfr: "\u{1D505}",
      bfr: "\u{1D51F}",
      bigcap: "\u22C2",
      bigcirc: "\u25EF",
      bigcup: "\u22C3",
      bigodot: "\u2A00",
      bigoplus: "\u2A01",
      bigotimes: "\u2A02",
      bigsqcup: "\u2A06",
      bigstar: "\u2605",
      bigtriangledown: "\u25BD",
      bigtriangleup: "\u25B3",
      biguplus: "\u2A04",
      bigvee: "\u22C1",
      bigwedge: "\u22C0",
      bkarow: "\u290D",
      blacklozenge: "\u29EB",
      blacksquare: "\u25AA",
      blacktriangle: "\u25B4",
      blacktriangledown: "\u25BE",
      blacktriangleleft: "\u25C2",
      blacktriangleright: "\u25B8",
      blank: "\u2423",
      blk12: "\u2592",
      blk14: "\u2591",
      blk34: "\u2593",
      block: "\u2588",
      bne: "=\u20E5",
      bnequiv: "\u2261\u20E5",
      bNot: "\u2AED",
      bnot: "\u2310",
      Bopf: "\u{1D539}",
      bopf: "\u{1D553}",
      bot: "\u22A5",
      bottom: "\u22A5",
      bowtie: "\u22C8",
      boxbox: "\u29C9",
      boxDL: "\u2557",
      boxDl: "\u2556",
      boxdL: "\u2555",
      boxdl: "\u2510",
      boxDR: "\u2554",
      boxDr: "\u2553",
      boxdR: "\u2552",
      boxdr: "\u250C",
      boxH: "\u2550",
      boxh: "\u2500",
      boxHD: "\u2566",
      boxHd: "\u2564",
      boxhD: "\u2565",
      boxhd: "\u252C",
      boxHU: "\u2569",
      boxHu: "\u2567",
      boxhU: "\u2568",
      boxhu: "\u2534",
      boxminus: "\u229F",
      boxplus: "\u229E",
      boxtimes: "\u22A0",
      boxUL: "\u255D",
      boxUl: "\u255C",
      boxuL: "\u255B",
      boxul: "\u2518",
      boxUR: "\u255A",
      boxUr: "\u2559",
      boxuR: "\u2558",
      boxur: "\u2514",
      boxV: "\u2551",
      boxv: "\u2502",
      boxVH: "\u256C",
      boxVh: "\u256B",
      boxvH: "\u256A",
      boxvh: "\u253C",
      boxVL: "\u2563",
      boxVl: "\u2562",
      boxvL: "\u2561",
      boxvl: "\u2524",
      boxVR: "\u2560",
      boxVr: "\u255F",
      boxvR: "\u255E",
      boxvr: "\u251C",
      bprime: "\u2035",
      Breve: "\u02D8",
      breve: "\u02D8",
      brvbar: "\xA6",
      Bscr: "\u212C",
      bscr: "\u{1D4B7}",
      bsemi: "\u204F",
      bsim: "\u223D",
      bsime: "\u22CD",
      bsol: "\\",
      bsolb: "\u29C5",
      bsolhsub: "\u27C8",
      bull: "\u2022",
      bullet: "\u2022",
      bump: "\u224E",
      bumpE: "\u2AAE",
      bumpe: "\u224F",
      Bumpeq: "\u224E",
      bumpeq: "\u224F",
      Cacute: "\u0106",
      cacute: "\u0107",
      Cap: "\u22D2",
      cap: "\u2229",
      capand: "\u2A44",
      capbrcup: "\u2A49",
      capcap: "\u2A4B",
      capcup: "\u2A47",
      capdot: "\u2A40",
      CapitalDifferentialD: "\u2145",
      caps: "\u2229\uFE00",
      caret: "\u2041",
      caron: "\u02C7",
      Cayleys: "\u212D",
      ccaps: "\u2A4D",
      Ccaron: "\u010C",
      ccaron: "\u010D",
      Ccedil: "\xC7",
      ccedil: "\xE7",
      Ccirc: "\u0108",
      ccirc: "\u0109",
      Cconint: "\u2230",
      ccups: "\u2A4C",
      ccupssm: "\u2A50",
      Cdot: "\u010A",
      cdot: "\u010B",
      cedil: "\xB8",
      Cedilla: "\xB8",
      cemptyv: "\u29B2",
      cent: "\xA2",
      CenterDot: "\xB7",
      centerdot: "\xB7",
      Cfr: "\u212D",
      cfr: "\u{1D520}",
      CHcy: "\u0427",
      chcy: "\u0447",
      check: "\u2713",
      checkmark: "\u2713",
      Chi: "\u03A7",
      chi: "\u03C7",
      cir: "\u25CB",
      circ: "\u02C6",
      circeq: "\u2257",
      circlearrowleft: "\u21BA",
      circlearrowright: "\u21BB",
      circledast: "\u229B",
      circledcirc: "\u229A",
      circleddash: "\u229D",
      CircleDot: "\u2299",
      circledR: "\xAE",
      circledS: "\u24C8",
      CircleMinus: "\u2296",
      CirclePlus: "\u2295",
      CircleTimes: "\u2297",
      cirE: "\u29C3",
      cire: "\u2257",
      cirfnint: "\u2A10",
      cirmid: "\u2AEF",
      cirscir: "\u29C2",
      ClockwiseContourIntegral: "\u2232",
      CloseCurlyDoubleQuote: "\u201D",
      CloseCurlyQuote: "\u2019",
      clubs: "\u2663",
      clubsuit: "\u2663",
      Colon: "\u2237",
      colon: ":",
      Colone: "\u2A74",
      colone: "\u2254",
      coloneq: "\u2254",
      comma: ",",
      commat: "@",
      comp: "\u2201",
      compfn: "\u2218",
      complement: "\u2201",
      complexes: "\u2102",
      cong: "\u2245",
      congdot: "\u2A6D",
      Congruent: "\u2261",
      Conint: "\u222F",
      conint: "\u222E",
      ContourIntegral: "\u222E",
      Copf: "\u2102",
      copf: "\u{1D554}",
      coprod: "\u2210",
      Coproduct: "\u2210",
      COPY: "\xA9",
      copy: "\xA9",
      copysr: "\u2117",
      CounterClockwiseContourIntegral: "\u2233",
      crarr: "\u21B5",
      Cross: "\u2A2F",
      cross: "\u2717",
      Cscr: "\u{1D49E}",
      cscr: "\u{1D4B8}",
      csub: "\u2ACF",
      csube: "\u2AD1",
      csup: "\u2AD0",
      csupe: "\u2AD2",
      ctdot: "\u22EF",
      cudarrl: "\u2938",
      cudarrr: "\u2935",
      cuepr: "\u22DE",
      cuesc: "\u22DF",
      cularr: "\u21B6",
      cularrp: "\u293D",
      Cup: "\u22D3",
      cup: "\u222A",
      cupbrcap: "\u2A48",
      CupCap: "\u224D",
      cupcap: "\u2A46",
      cupcup: "\u2A4A",
      cupdot: "\u228D",
      cupor: "\u2A45",
      cups: "\u222A\uFE00",
      curarr: "\u21B7",
      curarrm: "\u293C",
      curlyeqprec: "\u22DE",
      curlyeqsucc: "\u22DF",
      curlyvee: "\u22CE",
      curlywedge: "\u22CF",
      curren: "\xA4",
      curvearrowleft: "\u21B6",
      curvearrowright: "\u21B7",
      cuvee: "\u22CE",
      cuwed: "\u22CF",
      cwconint: "\u2232",
      cwint: "\u2231",
      cylcty: "\u232D",
      Dagger: "\u2021",
      dagger: "\u2020",
      daleth: "\u2138",
      Darr: "\u21A1",
      dArr: "\u21D3",
      darr: "\u2193",
      dash: "\u2010",
      Dashv: "\u2AE4",
      dashv: "\u22A3",
      dbkarow: "\u290F",
      dblac: "\u02DD",
      Dcaron: "\u010E",
      dcaron: "\u010F",
      Dcy: "\u0414",
      dcy: "\u0434",
      DD: "\u2145",
      dd: "\u2146",
      ddagger: "\u2021",
      ddarr: "\u21CA",
      DDotrahd: "\u2911",
      ddotseq: "\u2A77",
      deg: "\xB0",
      Del: "\u2207",
      Delta: "\u0394",
      delta: "\u03B4",
      demptyv: "\u29B1",
      dfisht: "\u297F",
      Dfr: "\u{1D507}",
      dfr: "\u{1D521}",
      dHar: "\u2965",
      dharl: "\u21C3",
      dharr: "\u21C2",
      DiacriticalAcute: "\xB4",
      DiacriticalDot: "\u02D9",
      DiacriticalDoubleAcute: "\u02DD",
      DiacriticalGrave: "`",
      DiacriticalTilde: "\u02DC",
      diam: "\u22C4",
      Diamond: "\u22C4",
      diamond: "\u22C4",
      diamondsuit: "\u2666",
      diams: "\u2666",
      die: "\xA8",
      DifferentialD: "\u2146",
      digamma: "\u03DD",
      disin: "\u22F2",
      div: "\xF7",
      divide: "\xF7",
      divideontimes: "\u22C7",
      divonx: "\u22C7",
      DJcy: "\u0402",
      djcy: "\u0452",
      dlcorn: "\u231E",
      dlcrop: "\u230D",
      dollar: "$",
      Dopf: "\u{1D53B}",
      dopf: "\u{1D555}",
      Dot: "\xA8",
      dot: "\u02D9",
      DotDot: "\u20DC",
      doteq: "\u2250",
      doteqdot: "\u2251",
      DotEqual: "\u2250",
      dotminus: "\u2238",
      dotplus: "\u2214",
      dotsquare: "\u22A1",
      doublebarwedge: "\u2306",
      DoubleContourIntegral: "\u222F",
      DoubleDot: "\xA8",
      DoubleDownArrow: "\u21D3",
      DoubleLeftArrow: "\u21D0",
      DoubleLeftRightArrow: "\u21D4",
      DoubleLeftTee: "\u2AE4",
      DoubleLongLeftArrow: "\u27F8",
      DoubleLongLeftRightArrow: "\u27FA",
      DoubleLongRightArrow: "\u27F9",
      DoubleRightArrow: "\u21D2",
      DoubleRightTee: "\u22A8",
      DoubleUpArrow: "\u21D1",
      DoubleUpDownArrow: "\u21D5",
      DoubleVerticalBar: "\u2225",
      DownArrow: "\u2193",
      Downarrow: "\u21D3",
      downarrow: "\u2193",
      DownArrowBar: "\u2913",
      DownArrowUpArrow: "\u21F5",
      DownBreve: "\u0311",
      downdownarrows: "\u21CA",
      downharpoonleft: "\u21C3",
      downharpoonright: "\u21C2",
      DownLeftRightVector: "\u2950",
      DownLeftTeeVector: "\u295E",
      DownLeftVector: "\u21BD",
      DownLeftVectorBar: "\u2956",
      DownRightTeeVector: "\u295F",
      DownRightVector: "\u21C1",
      DownRightVectorBar: "\u2957",
      DownTee: "\u22A4",
      DownTeeArrow: "\u21A7",
      drbkarow: "\u2910",
      drcorn: "\u231F",
      drcrop: "\u230C",
      Dscr: "\u{1D49F}",
      dscr: "\u{1D4B9}",
      DScy: "\u0405",
      dscy: "\u0455",
      dsol: "\u29F6",
      Dstrok: "\u0110",
      dstrok: "\u0111",
      dtdot: "\u22F1",
      dtri: "\u25BF",
      dtrif: "\u25BE",
      duarr: "\u21F5",
      duhar: "\u296F",
      dwangle: "\u29A6",
      DZcy: "\u040F",
      dzcy: "\u045F",
      dzigrarr: "\u27FF",
      Eacute: "\xC9",
      eacute: "\xE9",
      easter: "\u2A6E",
      Ecaron: "\u011A",
      ecaron: "\u011B",
      ecir: "\u2256",
      Ecirc: "\xCA",
      ecirc: "\xEA",
      ecolon: "\u2255",
      Ecy: "\u042D",
      ecy: "\u044D",
      eDDot: "\u2A77",
      Edot: "\u0116",
      eDot: "\u2251",
      edot: "\u0117",
      ee: "\u2147",
      efDot: "\u2252",
      Efr: "\u{1D508}",
      efr: "\u{1D522}",
      eg: "\u2A9A",
      Egrave: "\xC8",
      egrave: "\xE8",
      egs: "\u2A96",
      egsdot: "\u2A98",
      el: "\u2A99",
      Element: "\u2208",
      elinters: "\u23E7",
      ell: "\u2113",
      els: "\u2A95",
      elsdot: "\u2A97",
      Emacr: "\u0112",
      emacr: "\u0113",
      empty: "\u2205",
      emptyset: "\u2205",
      EmptySmallSquare: "\u25FB",
      emptyv: "\u2205",
      EmptyVerySmallSquare: "\u25AB",
      emsp: "\u2003",
      emsp13: "\u2004",
      emsp14: "\u2005",
      ENG: "\u014A",
      eng: "\u014B",
      ensp: "\u2002",
      Eogon: "\u0118",
      eogon: "\u0119",
      Eopf: "\u{1D53C}",
      eopf: "\u{1D556}",
      epar: "\u22D5",
      eparsl: "\u29E3",
      eplus: "\u2A71",
      epsi: "\u03B5",
      Epsilon: "\u0395",
      epsilon: "\u03B5",
      epsiv: "\u03F5",
      eqcirc: "\u2256",
      eqcolon: "\u2255",
      eqsim: "\u2242",
      eqslantgtr: "\u2A96",
      eqslantless: "\u2A95",
      Equal: "\u2A75",
      equals: "=",
      EqualTilde: "\u2242",
      equest: "\u225F",
      Equilibrium: "\u21CC",
      equiv: "\u2261",
      equivDD: "\u2A78",
      eqvparsl: "\u29E5",
      erarr: "\u2971",
      erDot: "\u2253",
      Escr: "\u2130",
      escr: "\u212F",
      esdot: "\u2250",
      Esim: "\u2A73",
      esim: "\u2242",
      Eta: "\u0397",
      eta: "\u03B7",
      ETH: "\xD0",
      eth: "\xF0",
      Euml: "\xCB",
      euml: "\xEB",
      euro: "\u20AC",
      excl: "!",
      exist: "\u2203",
      Exists: "\u2203",
      expectation: "\u2130",
      ExponentialE: "\u2147",
      exponentiale: "\u2147",
      fallingdotseq: "\u2252",
      Fcy: "\u0424",
      fcy: "\u0444",
      female: "\u2640",
      ffilig: "\uFB03",
      fflig: "\uFB00",
      ffllig: "\uFB04",
      Ffr: "\u{1D509}",
      ffr: "\u{1D523}",
      filig: "\uFB01",
      FilledSmallSquare: "\u25FC",
      FilledVerySmallSquare: "\u25AA",
      fjlig: "fj",
      flat: "\u266D",
      fllig: "\uFB02",
      fltns: "\u25B1",
      fnof: "\u0192",
      Fopf: "\u{1D53D}",
      fopf: "\u{1D557}",
      ForAll: "\u2200",
      forall: "\u2200",
      fork: "\u22D4",
      forkv: "\u2AD9",
      Fouriertrf: "\u2131",
      fpartint: "\u2A0D",
      frac12: "\xBD",
      frac13: "\u2153",
      frac14: "\xBC",
      frac15: "\u2155",
      frac16: "\u2159",
      frac18: "\u215B",
      frac23: "\u2154",
      frac25: "\u2156",
      frac34: "\xBE",
      frac35: "\u2157",
      frac38: "\u215C",
      frac45: "\u2158",
      frac56: "\u215A",
      frac58: "\u215D",
      frac78: "\u215E",
      frasl: "\u2044",
      frown: "\u2322",
      Fscr: "\u2131",
      fscr: "\u{1D4BB}",
      gacute: "\u01F5",
      Gamma: "\u0393",
      gamma: "\u03B3",
      Gammad: "\u03DC",
      gammad: "\u03DD",
      gap: "\u2A86",
      Gbreve: "\u011E",
      gbreve: "\u011F",
      Gcedil: "\u0122",
      Gcirc: "\u011C",
      gcirc: "\u011D",
      Gcy: "\u0413",
      gcy: "\u0433",
      Gdot: "\u0120",
      gdot: "\u0121",
      gE: "\u2267",
      ge: "\u2265",
      gEl: "\u2A8C",
      gel: "\u22DB",
      geq: "\u2265",
      geqq: "\u2267",
      geqslant: "\u2A7E",
      ges: "\u2A7E",
      gescc: "\u2AA9",
      gesdot: "\u2A80",
      gesdoto: "\u2A82",
      gesdotol: "\u2A84",
      gesl: "\u22DB\uFE00",
      gesles: "\u2A94",
      Gfr: "\u{1D50A}",
      gfr: "\u{1D524}",
      Gg: "\u22D9",
      gg: "\u226B",
      ggg: "\u22D9",
      gimel: "\u2137",
      GJcy: "\u0403",
      gjcy: "\u0453",
      gl: "\u2277",
      gla: "\u2AA5",
      glE: "\u2A92",
      glj: "\u2AA4",
      gnap: "\u2A8A",
      gnapprox: "\u2A8A",
      gnE: "\u2269",
      gne: "\u2A88",
      gneq: "\u2A88",
      gneqq: "\u2269",
      gnsim: "\u22E7",
      Gopf: "\u{1D53E}",
      gopf: "\u{1D558}",
      grave: "`",
      GreaterEqual: "\u2265",
      GreaterEqualLess: "\u22DB",
      GreaterFullEqual: "\u2267",
      GreaterGreater: "\u2AA2",
      GreaterLess: "\u2277",
      GreaterSlantEqual: "\u2A7E",
      GreaterTilde: "\u2273",
      Gscr: "\u{1D4A2}",
      gscr: "\u210A",
      gsim: "\u2273",
      gsime: "\u2A8E",
      gsiml: "\u2A90",
      Gt: "\u226B",
      GT: ">",
      gt: ">",
      gtcc: "\u2AA7",
      gtcir: "\u2A7A",
      gtdot: "\u22D7",
      gtlPar: "\u2995",
      gtquest: "\u2A7C",
      gtrapprox: "\u2A86",
      gtrarr: "\u2978",
      gtrdot: "\u22D7",
      gtreqless: "\u22DB",
      gtreqqless: "\u2A8C",
      gtrless: "\u2277",
      gtrsim: "\u2273",
      gvertneqq: "\u2269\uFE00",
      gvnE: "\u2269\uFE00",
      Hacek: "\u02C7",
      hairsp: "\u200A",
      half: "\xBD",
      hamilt: "\u210B",
      HARDcy: "\u042A",
      hardcy: "\u044A",
      hArr: "\u21D4",
      harr: "\u2194",
      harrcir: "\u2948",
      harrw: "\u21AD",
      Hat: "^",
      hbar: "\u210F",
      Hcirc: "\u0124",
      hcirc: "\u0125",
      hearts: "\u2665",
      heartsuit: "\u2665",
      hellip: "\u2026",
      hercon: "\u22B9",
      Hfr: "\u210C",
      hfr: "\u{1D525}",
      HilbertSpace: "\u210B",
      hksearow: "\u2925",
      hkswarow: "\u2926",
      hoarr: "\u21FF",
      homtht: "\u223B",
      hookleftarrow: "\u21A9",
      hookrightarrow: "\u21AA",
      Hopf: "\u210D",
      hopf: "\u{1D559}",
      horbar: "\u2015",
      HorizontalLine: "\u2500",
      Hscr: "\u210B",
      hscr: "\u{1D4BD}",
      hslash: "\u210F",
      Hstrok: "\u0126",
      hstrok: "\u0127",
      HumpDownHump: "\u224E",
      HumpEqual: "\u224F",
      hybull: "\u2043",
      hyphen: "\u2010",
      Iacute: "\xCD",
      iacute: "\xED",
      ic: "\u2063",
      Icirc: "\xCE",
      icirc: "\xEE",
      Icy: "\u0418",
      icy: "\u0438",
      Idot: "\u0130",
      IEcy: "\u0415",
      iecy: "\u0435",
      iexcl: "\xA1",
      iff: "\u21D4",
      Ifr: "\u2111",
      ifr: "\u{1D526}",
      Igrave: "\xCC",
      igrave: "\xEC",
      ii: "\u2148",
      iiiint: "\u2A0C",
      iiint: "\u222D",
      iinfin: "\u29DC",
      iiota: "\u2129",
      IJlig: "\u0132",
      ijlig: "\u0133",
      Im: "\u2111",
      Imacr: "\u012A",
      imacr: "\u012B",
      image: "\u2111",
      ImaginaryI: "\u2148",
      imagline: "\u2110",
      imagpart: "\u2111",
      imath: "\u0131",
      imof: "\u22B7",
      imped: "\u01B5",
      Implies: "\u21D2",
      in: "\u2208",
      incare: "\u2105",
      infin: "\u221E",
      infintie: "\u29DD",
      inodot: "\u0131",
      Int: "\u222C",
      int: "\u222B",
      intcal: "\u22BA",
      integers: "\u2124",
      Integral: "\u222B",
      intercal: "\u22BA",
      Intersection: "\u22C2",
      intlarhk: "\u2A17",
      intprod: "\u2A3C",
      InvisibleComma: "\u2063",
      InvisibleTimes: "\u2062",
      IOcy: "\u0401",
      iocy: "\u0451",
      Iogon: "\u012E",
      iogon: "\u012F",
      Iopf: "\u{1D540}",
      iopf: "\u{1D55A}",
      Iota: "\u0399",
      iota: "\u03B9",
      iprod: "\u2A3C",
      iquest: "\xBF",
      Iscr: "\u2110",
      iscr: "\u{1D4BE}",
      isin: "\u2208",
      isindot: "\u22F5",
      isinE: "\u22F9",
      isins: "\u22F4",
      isinsv: "\u22F3",
      isinv: "\u2208",
      it: "\u2062",
      Itilde: "\u0128",
      itilde: "\u0129",
      Iukcy: "\u0406",
      iukcy: "\u0456",
      Iuml: "\xCF",
      iuml: "\xEF",
      Jcirc: "\u0134",
      jcirc: "\u0135",
      Jcy: "\u0419",
      jcy: "\u0439",
      Jfr: "\u{1D50D}",
      jfr: "\u{1D527}",
      jmath: "\u0237",
      Jopf: "\u{1D541}",
      jopf: "\u{1D55B}",
      Jscr: "\u{1D4A5}",
      jscr: "\u{1D4BF}",
      Jsercy: "\u0408",
      jsercy: "\u0458",
      Jukcy: "\u0404",
      jukcy: "\u0454",
      Kappa: "\u039A",
      kappa: "\u03BA",
      kappav: "\u03F0",
      Kcedil: "\u0136",
      kcedil: "\u0137",
      Kcy: "\u041A",
      kcy: "\u043A",
      Kfr: "\u{1D50E}",
      kfr: "\u{1D528}",
      kgreen: "\u0138",
      KHcy: "\u0425",
      khcy: "\u0445",
      KJcy: "\u040C",
      kjcy: "\u045C",
      Kopf: "\u{1D542}",
      kopf: "\u{1D55C}",
      Kscr: "\u{1D4A6}",
      kscr: "\u{1D4C0}",
      lAarr: "\u21DA",
      Lacute: "\u0139",
      lacute: "\u013A",
      laemptyv: "\u29B4",
      lagran: "\u2112",
      Lambda: "\u039B",
      lambda: "\u03BB",
      Lang: "\u27EA",
      lang: "\u27E8",
      langd: "\u2991",
      langle: "\u27E8",
      lap: "\u2A85",
      Laplacetrf: "\u2112",
      laquo: "\xAB",
      Larr: "\u219E",
      lArr: "\u21D0",
      larr: "\u2190",
      larrb: "\u21E4",
      larrbfs: "\u291F",
      larrfs: "\u291D",
      larrhk: "\u21A9",
      larrlp: "\u21AB",
      larrpl: "\u2939",
      larrsim: "\u2973",
      larrtl: "\u21A2",
      lat: "\u2AAB",
      lAtail: "\u291B",
      latail: "\u2919",
      late: "\u2AAD",
      lates: "\u2AAD\uFE00",
      lBarr: "\u290E",
      lbarr: "\u290C",
      lbbrk: "\u2772",
      lbrace: "{",
      lbrack: "[",
      lbrke: "\u298B",
      lbrksld: "\u298F",
      lbrkslu: "\u298D",
      Lcaron: "\u013D",
      lcaron: "\u013E",
      Lcedil: "\u013B",
      lcedil: "\u013C",
      lceil: "\u2308",
      lcub: "{",
      Lcy: "\u041B",
      lcy: "\u043B",
      ldca: "\u2936",
      ldquo: "\u201C",
      ldquor: "\u201E",
      ldrdhar: "\u2967",
      ldrushar: "\u294B",
      ldsh: "\u21B2",
      lE: "\u2266",
      le: "\u2264",
      LeftAngleBracket: "\u27E8",
      LeftArrow: "\u2190",
      Leftarrow: "\u21D0",
      leftarrow: "\u2190",
      LeftArrowBar: "\u21E4",
      LeftArrowRightArrow: "\u21C6",
      leftarrowtail: "\u21A2",
      LeftCeiling: "\u2308",
      LeftDoubleBracket: "\u27E6",
      LeftDownTeeVector: "\u2961",
      LeftDownVector: "\u21C3",
      LeftDownVectorBar: "\u2959",
      LeftFloor: "\u230A",
      leftharpoondown: "\u21BD",
      leftharpoonup: "\u21BC",
      leftleftarrows: "\u21C7",
      LeftRightArrow: "\u2194",
      Leftrightarrow: "\u21D4",
      leftrightarrow: "\u2194",
      leftrightarrows: "\u21C6",
      leftrightharpoons: "\u21CB",
      leftrightsquigarrow: "\u21AD",
      LeftRightVector: "\u294E",
      LeftTee: "\u22A3",
      LeftTeeArrow: "\u21A4",
      LeftTeeVector: "\u295A",
      leftthreetimes: "\u22CB",
      LeftTriangle: "\u22B2",
      LeftTriangleBar: "\u29CF",
      LeftTriangleEqual: "\u22B4",
      LeftUpDownVector: "\u2951",
      LeftUpTeeVector: "\u2960",
      LeftUpVector: "\u21BF",
      LeftUpVectorBar: "\u2958",
      LeftVector: "\u21BC",
      LeftVectorBar: "\u2952",
      lEg: "\u2A8B",
      leg: "\u22DA",
      leq: "\u2264",
      leqq: "\u2266",
      leqslant: "\u2A7D",
      les: "\u2A7D",
      lescc: "\u2AA8",
      lesdot: "\u2A7F",
      lesdoto: "\u2A81",
      lesdotor: "\u2A83",
      lesg: "\u22DA\uFE00",
      lesges: "\u2A93",
      lessapprox: "\u2A85",
      lessdot: "\u22D6",
      lesseqgtr: "\u22DA",
      lesseqqgtr: "\u2A8B",
      LessEqualGreater: "\u22DA",
      LessFullEqual: "\u2266",
      LessGreater: "\u2276",
      lessgtr: "\u2276",
      LessLess: "\u2AA1",
      lesssim: "\u2272",
      LessSlantEqual: "\u2A7D",
      LessTilde: "\u2272",
      lfisht: "\u297C",
      lfloor: "\u230A",
      Lfr: "\u{1D50F}",
      lfr: "\u{1D529}",
      lg: "\u2276",
      lgE: "\u2A91",
      lHar: "\u2962",
      lhard: "\u21BD",
      lharu: "\u21BC",
      lharul: "\u296A",
      lhblk: "\u2584",
      LJcy: "\u0409",
      ljcy: "\u0459",
      Ll: "\u22D8",
      ll: "\u226A",
      llarr: "\u21C7",
      llcorner: "\u231E",
      Lleftarrow: "\u21DA",
      llhard: "\u296B",
      lltri: "\u25FA",
      Lmidot: "\u013F",
      lmidot: "\u0140",
      lmoust: "\u23B0",
      lmoustache: "\u23B0",
      lnap: "\u2A89",
      lnapprox: "\u2A89",
      lnE: "\u2268",
      lne: "\u2A87",
      lneq: "\u2A87",
      lneqq: "\u2268",
      lnsim: "\u22E6",
      loang: "\u27EC",
      loarr: "\u21FD",
      lobrk: "\u27E6",
      LongLeftArrow: "\u27F5",
      Longleftarrow: "\u27F8",
      longleftarrow: "\u27F5",
      LongLeftRightArrow: "\u27F7",
      Longleftrightarrow: "\u27FA",
      longleftrightarrow: "\u27F7",
      longmapsto: "\u27FC",
      LongRightArrow: "\u27F6",
      Longrightarrow: "\u27F9",
      longrightarrow: "\u27F6",
      looparrowleft: "\u21AB",
      looparrowright: "\u21AC",
      lopar: "\u2985",
      Lopf: "\u{1D543}",
      lopf: "\u{1D55D}",
      loplus: "\u2A2D",
      lotimes: "\u2A34",
      lowast: "\u2217",
      lowbar: "_",
      LowerLeftArrow: "\u2199",
      LowerRightArrow: "\u2198",
      loz: "\u25CA",
      lozenge: "\u25CA",
      lozf: "\u29EB",
      lpar: "(",
      lparlt: "\u2993",
      lrarr: "\u21C6",
      lrcorner: "\u231F",
      lrhar: "\u21CB",
      lrhard: "\u296D",
      lrm: "\u200E",
      lrtri: "\u22BF",
      lsaquo: "\u2039",
      Lscr: "\u2112",
      lscr: "\u{1D4C1}",
      Lsh: "\u21B0",
      lsh: "\u21B0",
      lsim: "\u2272",
      lsime: "\u2A8D",
      lsimg: "\u2A8F",
      lsqb: "[",
      lsquo: "\u2018",
      lsquor: "\u201A",
      Lstrok: "\u0141",
      lstrok: "\u0142",
      Lt: "\u226A",
      LT: "<",
      lt: "<",
      ltcc: "\u2AA6",
      ltcir: "\u2A79",
      ltdot: "\u22D6",
      lthree: "\u22CB",
      ltimes: "\u22C9",
      ltlarr: "\u2976",
      ltquest: "\u2A7B",
      ltri: "\u25C3",
      ltrie: "\u22B4",
      ltrif: "\u25C2",
      ltrPar: "\u2996",
      lurdshar: "\u294A",
      luruhar: "\u2966",
      lvertneqq: "\u2268\uFE00",
      lvnE: "\u2268\uFE00",
      macr: "\xAF",
      male: "\u2642",
      malt: "\u2720",
      maltese: "\u2720",
      Map: "\u2905",
      map: "\u21A6",
      mapsto: "\u21A6",
      mapstodown: "\u21A7",
      mapstoleft: "\u21A4",
      mapstoup: "\u21A5",
      marker: "\u25AE",
      mcomma: "\u2A29",
      Mcy: "\u041C",
      mcy: "\u043C",
      mdash: "\u2014",
      mDDot: "\u223A",
      measuredangle: "\u2221",
      MediumSpace: "\u205F",
      Mellintrf: "\u2133",
      Mfr: "\u{1D510}",
      mfr: "\u{1D52A}",
      mho: "\u2127",
      micro: "\xB5",
      mid: "\u2223",
      midast: "*",
      midcir: "\u2AF0",
      middot: "\xB7",
      minus: "\u2212",
      minusb: "\u229F",
      minusd: "\u2238",
      minusdu: "\u2A2A",
      MinusPlus: "\u2213",
      mlcp: "\u2ADB",
      mldr: "\u2026",
      mnplus: "\u2213",
      models: "\u22A7",
      Mopf: "\u{1D544}",
      mopf: "\u{1D55E}",
      mp: "\u2213",
      Mscr: "\u2133",
      mscr: "\u{1D4C2}",
      mstpos: "\u223E",
      Mu: "\u039C",
      mu: "\u03BC",
      multimap: "\u22B8",
      mumap: "\u22B8",
      nabla: "\u2207",
      Nacute: "\u0143",
      nacute: "\u0144",
      nang: "\u2220\u20D2",
      nap: "\u2249",
      napE: "\u2A70\u0338",
      napid: "\u224B\u0338",
      napos: "\u0149",
      napprox: "\u2249",
      natur: "\u266E",
      natural: "\u266E",
      naturals: "\u2115",
      nbsp: "\xA0",
      nbump: "\u224E\u0338",
      nbumpe: "\u224F\u0338",
      ncap: "\u2A43",
      Ncaron: "\u0147",
      ncaron: "\u0148",
      Ncedil: "\u0145",
      ncedil: "\u0146",
      ncong: "\u2247",
      ncongdot: "\u2A6D\u0338",
      ncup: "\u2A42",
      Ncy: "\u041D",
      ncy: "\u043D",
      ndash: "\u2013",
      ne: "\u2260",
      nearhk: "\u2924",
      neArr: "\u21D7",
      nearr: "\u2197",
      nearrow: "\u2197",
      nedot: "\u2250\u0338",
      NegativeMediumSpace: "\u200B",
      NegativeThickSpace: "\u200B",
      NegativeThinSpace: "\u200B",
      NegativeVeryThinSpace: "\u200B",
      nequiv: "\u2262",
      nesear: "\u2928",
      nesim: "\u2242\u0338",
      NestedGreaterGreater: "\u226B",
      NestedLessLess: "\u226A",
      NewLine: "\n",
      nexist: "\u2204",
      nexists: "\u2204",
      Nfr: "\u{1D511}",
      nfr: "\u{1D52B}",
      ngE: "\u2267\u0338",
      nge: "\u2271",
      ngeq: "\u2271",
      ngeqq: "\u2267\u0338",
      ngeqslant: "\u2A7E\u0338",
      nges: "\u2A7E\u0338",
      nGg: "\u22D9\u0338",
      ngsim: "\u2275",
      nGt: "\u226B\u20D2",
      ngt: "\u226F",
      ngtr: "\u226F",
      nGtv: "\u226B\u0338",
      nhArr: "\u21CE",
      nharr: "\u21AE",
      nhpar: "\u2AF2",
      ni: "\u220B",
      nis: "\u22FC",
      nisd: "\u22FA",
      niv: "\u220B",
      NJcy: "\u040A",
      njcy: "\u045A",
      nlArr: "\u21CD",
      nlarr: "\u219A",
      nldr: "\u2025",
      nlE: "\u2266\u0338",
      nle: "\u2270",
      nLeftarrow: "\u21CD",
      nleftarrow: "\u219A",
      nLeftrightarrow: "\u21CE",
      nleftrightarrow: "\u21AE",
      nleq: "\u2270",
      nleqq: "\u2266\u0338",
      nleqslant: "\u2A7D\u0338",
      nles: "\u2A7D\u0338",
      nless: "\u226E",
      nLl: "\u22D8\u0338",
      nlsim: "\u2274",
      nLt: "\u226A\u20D2",
      nlt: "\u226E",
      nltri: "\u22EA",
      nltrie: "\u22EC",
      nLtv: "\u226A\u0338",
      nmid: "\u2224",
      NoBreak: "\u2060",
      NonBreakingSpace: "\xA0",
      Nopf: "\u2115",
      nopf: "\u{1D55F}",
      Not: "\u2AEC",
      not: "\xAC",
      NotCongruent: "\u2262",
      NotCupCap: "\u226D",
      NotDoubleVerticalBar: "\u2226",
      NotElement: "\u2209",
      NotEqual: "\u2260",
      NotEqualTilde: "\u2242\u0338",
      NotExists: "\u2204",
      NotGreater: "\u226F",
      NotGreaterEqual: "\u2271",
      NotGreaterFullEqual: "\u2267\u0338",
      NotGreaterGreater: "\u226B\u0338",
      NotGreaterLess: "\u2279",
      NotGreaterSlantEqual: "\u2A7E\u0338",
      NotGreaterTilde: "\u2275",
      NotHumpDownHump: "\u224E\u0338",
      NotHumpEqual: "\u224F\u0338",
      notin: "\u2209",
      notindot: "\u22F5\u0338",
      notinE: "\u22F9\u0338",
      notinva: "\u2209",
      notinvb: "\u22F7",
      notinvc: "\u22F6",
      NotLeftTriangle: "\u22EA",
      NotLeftTriangleBar: "\u29CF\u0338",
      NotLeftTriangleEqual: "\u22EC",
      NotLess: "\u226E",
      NotLessEqual: "\u2270",
      NotLessGreater: "\u2278",
      NotLessLess: "\u226A\u0338",
      NotLessSlantEqual: "\u2A7D\u0338",
      NotLessTilde: "\u2274",
      NotNestedGreaterGreater: "\u2AA2\u0338",
      NotNestedLessLess: "\u2AA1\u0338",
      notni: "\u220C",
      notniva: "\u220C",
      notnivb: "\u22FE",
      notnivc: "\u22FD",
      NotPrecedes: "\u2280",
      NotPrecedesEqual: "\u2AAF\u0338",
      NotPrecedesSlantEqual: "\u22E0",
      NotReverseElement: "\u220C",
      NotRightTriangle: "\u22EB",
      NotRightTriangleBar: "\u29D0\u0338",
      NotRightTriangleEqual: "\u22ED",
      NotSquareSubset: "\u228F\u0338",
      NotSquareSubsetEqual: "\u22E2",
      NotSquareSuperset: "\u2290\u0338",
      NotSquareSupersetEqual: "\u22E3",
      NotSubset: "\u2282\u20D2",
      NotSubsetEqual: "\u2288",
      NotSucceeds: "\u2281",
      NotSucceedsEqual: "\u2AB0\u0338",
      NotSucceedsSlantEqual: "\u22E1",
      NotSucceedsTilde: "\u227F\u0338",
      NotSuperset: "\u2283\u20D2",
      NotSupersetEqual: "\u2289",
      NotTilde: "\u2241",
      NotTildeEqual: "\u2244",
      NotTildeFullEqual: "\u2247",
      NotTildeTilde: "\u2249",
      NotVerticalBar: "\u2224",
      npar: "\u2226",
      nparallel: "\u2226",
      nparsl: "\u2AFD\u20E5",
      npart: "\u2202\u0338",
      npolint: "\u2A14",
      npr: "\u2280",
      nprcue: "\u22E0",
      npre: "\u2AAF\u0338",
      nprec: "\u2280",
      npreceq: "\u2AAF\u0338",
      nrArr: "\u21CF",
      nrarr: "\u219B",
      nrarrc: "\u2933\u0338",
      nrarrw: "\u219D\u0338",
      nRightarrow: "\u21CF",
      nrightarrow: "\u219B",
      nrtri: "\u22EB",
      nrtrie: "\u22ED",
      nsc: "\u2281",
      nsccue: "\u22E1",
      nsce: "\u2AB0\u0338",
      Nscr: "\u{1D4A9}",
      nscr: "\u{1D4C3}",
      nshortmid: "\u2224",
      nshortparallel: "\u2226",
      nsim: "\u2241",
      nsime: "\u2244",
      nsimeq: "\u2244",
      nsmid: "\u2224",
      nspar: "\u2226",
      nsqsube: "\u22E2",
      nsqsupe: "\u22E3",
      nsub: "\u2284",
      nsubE: "\u2AC5\u0338",
      nsube: "\u2288",
      nsubset: "\u2282\u20D2",
      nsubseteq: "\u2288",
      nsubseteqq: "\u2AC5\u0338",
      nsucc: "\u2281",
      nsucceq: "\u2AB0\u0338",
      nsup: "\u2285",
      nsupE: "\u2AC6\u0338",
      nsupe: "\u2289",
      nsupset: "\u2283\u20D2",
      nsupseteq: "\u2289",
      nsupseteqq: "\u2AC6\u0338",
      ntgl: "\u2279",
      Ntilde: "\xD1",
      ntilde: "\xF1",
      ntlg: "\u2278",
      ntriangleleft: "\u22EA",
      ntrianglelefteq: "\u22EC",
      ntriangleright: "\u22EB",
      ntrianglerighteq: "\u22ED",
      Nu: "\u039D",
      nu: "\u03BD",
      num: "#",
      numero: "\u2116",
      numsp: "\u2007",
      nvap: "\u224D\u20D2",
      nVDash: "\u22AF",
      nVdash: "\u22AE",
      nvDash: "\u22AD",
      nvdash: "\u22AC",
      nvge: "\u2265\u20D2",
      nvgt: ">\u20D2",
      nvHarr: "\u2904",
      nvinfin: "\u29DE",
      nvlArr: "\u2902",
      nvle: "\u2264\u20D2",
      nvlt: "<\u20D2",
      nvltrie: "\u22B4\u20D2",
      nvrArr: "\u2903",
      nvrtrie: "\u22B5\u20D2",
      nvsim: "\u223C\u20D2",
      nwarhk: "\u2923",
      nwArr: "\u21D6",
      nwarr: "\u2196",
      nwarrow: "\u2196",
      nwnear: "\u2927",
      Oacute: "\xD3",
      oacute: "\xF3",
      oast: "\u229B",
      ocir: "\u229A",
      Ocirc: "\xD4",
      ocirc: "\xF4",
      Ocy: "\u041E",
      ocy: "\u043E",
      odash: "\u229D",
      Odblac: "\u0150",
      odblac: "\u0151",
      odiv: "\u2A38",
      odot: "\u2299",
      odsold: "\u29BC",
      OElig: "\u0152",
      oelig: "\u0153",
      ofcir: "\u29BF",
      Ofr: "\u{1D512}",
      ofr: "\u{1D52C}",
      ogon: "\u02DB",
      Ograve: "\xD2",
      ograve: "\xF2",
      ogt: "\u29C1",
      ohbar: "\u29B5",
      ohm: "\u03A9",
      oint: "\u222E",
      olarr: "\u21BA",
      olcir: "\u29BE",
      olcross: "\u29BB",
      oline: "\u203E",
      olt: "\u29C0",
      Omacr: "\u014C",
      omacr: "\u014D",
      Omega: "\u03A9",
      omega: "\u03C9",
      Omicron: "\u039F",
      omicron: "\u03BF",
      omid: "\u29B6",
      ominus: "\u2296",
      Oopf: "\u{1D546}",
      oopf: "\u{1D560}",
      opar: "\u29B7",
      OpenCurlyDoubleQuote: "\u201C",
      OpenCurlyQuote: "\u2018",
      operp: "\u29B9",
      oplus: "\u2295",
      Or: "\u2A54",
      or: "\u2228",
      orarr: "\u21BB",
      ord: "\u2A5D",
      order: "\u2134",
      orderof: "\u2134",
      ordf: "\xAA",
      ordm: "\xBA",
      origof: "\u22B6",
      oror: "\u2A56",
      orslope: "\u2A57",
      orv: "\u2A5B",
      oS: "\u24C8",
      Oscr: "\u{1D4AA}",
      oscr: "\u2134",
      Oslash: "\xD8",
      oslash: "\xF8",
      osol: "\u2298",
      Otilde: "\xD5",
      otilde: "\xF5",
      Otimes: "\u2A37",
      otimes: "\u2297",
      otimesas: "\u2A36",
      Ouml: "\xD6",
      ouml: "\xF6",
      ovbar: "\u233D",
      OverBar: "\u203E",
      OverBrace: "\u23DE",
      OverBracket: "\u23B4",
      OverParenthesis: "\u23DC",
      par: "\u2225",
      para: "\xB6",
      parallel: "\u2225",
      parsim: "\u2AF3",
      parsl: "\u2AFD",
      part: "\u2202",
      PartialD: "\u2202",
      Pcy: "\u041F",
      pcy: "\u043F",
      percnt: "%",
      period: ".",
      permil: "\u2030",
      perp: "\u22A5",
      pertenk: "\u2031",
      Pfr: "\u{1D513}",
      pfr: "\u{1D52D}",
      Phi: "\u03A6",
      phi: "\u03C6",
      phiv: "\u03D5",
      phmmat: "\u2133",
      phone: "\u260E",
      Pi: "\u03A0",
      pi: "\u03C0",
      pitchfork: "\u22D4",
      piv: "\u03D6",
      planck: "\u210F",
      planckh: "\u210E",
      plankv: "\u210F",
      plus: "+",
      plusacir: "\u2A23",
      plusb: "\u229E",
      pluscir: "\u2A22",
      plusdo: "\u2214",
      plusdu: "\u2A25",
      pluse: "\u2A72",
      PlusMinus: "\xB1",
      plusmn: "\xB1",
      plussim: "\u2A26",
      plustwo: "\u2A27",
      pm: "\xB1",
      Poincareplane: "\u210C",
      pointint: "\u2A15",
      Popf: "\u2119",
      popf: "\u{1D561}",
      pound: "\xA3",
      Pr: "\u2ABB",
      pr: "\u227A",
      prap: "\u2AB7",
      prcue: "\u227C",
      prE: "\u2AB3",
      pre: "\u2AAF",
      prec: "\u227A",
      precapprox: "\u2AB7",
      preccurlyeq: "\u227C",
      Precedes: "\u227A",
      PrecedesEqual: "\u2AAF",
      PrecedesSlantEqual: "\u227C",
      PrecedesTilde: "\u227E",
      preceq: "\u2AAF",
      precnapprox: "\u2AB9",
      precneqq: "\u2AB5",
      precnsim: "\u22E8",
      precsim: "\u227E",
      Prime: "\u2033",
      prime: "\u2032",
      primes: "\u2119",
      prnap: "\u2AB9",
      prnE: "\u2AB5",
      prnsim: "\u22E8",
      prod: "\u220F",
      Product: "\u220F",
      profalar: "\u232E",
      profline: "\u2312",
      profsurf: "\u2313",
      prop: "\u221D",
      Proportion: "\u2237",
      Proportional: "\u221D",
      propto: "\u221D",
      prsim: "\u227E",
      prurel: "\u22B0",
      Pscr: "\u{1D4AB}",
      pscr: "\u{1D4C5}",
      Psi: "\u03A8",
      psi: "\u03C8",
      puncsp: "\u2008",
      Qfr: "\u{1D514}",
      qfr: "\u{1D52E}",
      qint: "\u2A0C",
      Qopf: "\u211A",
      qopf: "\u{1D562}",
      qprime: "\u2057",
      Qscr: "\u{1D4AC}",
      qscr: "\u{1D4C6}",
      quaternions: "\u210D",
      quatint: "\u2A16",
      quest: "?",
      questeq: "\u225F",
      QUOT: '"',
      quot: '"',
      rAarr: "\u21DB",
      race: "\u223D\u0331",
      Racute: "\u0154",
      racute: "\u0155",
      radic: "\u221A",
      raemptyv: "\u29B3",
      Rang: "\u27EB",
      rang: "\u27E9",
      rangd: "\u2992",
      range: "\u29A5",
      rangle: "\u27E9",
      raquo: "\xBB",
      Rarr: "\u21A0",
      rArr: "\u21D2",
      rarr: "\u2192",
      rarrap: "\u2975",
      rarrb: "\u21E5",
      rarrbfs: "\u2920",
      rarrc: "\u2933",
      rarrfs: "\u291E",
      rarrhk: "\u21AA",
      rarrlp: "\u21AC",
      rarrpl: "\u2945",
      rarrsim: "\u2974",
      Rarrtl: "\u2916",
      rarrtl: "\u21A3",
      rarrw: "\u219D",
      rAtail: "\u291C",
      ratail: "\u291A",
      ratio: "\u2236",
      rationals: "\u211A",
      RBarr: "\u2910",
      rBarr: "\u290F",
      rbarr: "\u290D",
      rbbrk: "\u2773",
      rbrace: "}",
      rbrack: "]",
      rbrke: "\u298C",
      rbrksld: "\u298E",
      rbrkslu: "\u2990",
      Rcaron: "\u0158",
      rcaron: "\u0159",
      Rcedil: "\u0156",
      rcedil: "\u0157",
      rceil: "\u2309",
      rcub: "}",
      Rcy: "\u0420",
      rcy: "\u0440",
      rdca: "\u2937",
      rdldhar: "\u2969",
      rdquo: "\u201D",
      rdquor: "\u201D",
      rdsh: "\u21B3",
      Re: "\u211C",
      real: "\u211C",
      realine: "\u211B",
      realpart: "\u211C",
      reals: "\u211D",
      rect: "\u25AD",
      REG: "\xAE",
      reg: "\xAE",
      ReverseElement: "\u220B",
      ReverseEquilibrium: "\u21CB",
      ReverseUpEquilibrium: "\u296F",
      rfisht: "\u297D",
      rfloor: "\u230B",
      Rfr: "\u211C",
      rfr: "\u{1D52F}",
      rHar: "\u2964",
      rhard: "\u21C1",
      rharu: "\u21C0",
      rharul: "\u296C",
      Rho: "\u03A1",
      rho: "\u03C1",
      rhov: "\u03F1",
      RightAngleBracket: "\u27E9",
      RightArrow: "\u2192",
      Rightarrow: "\u21D2",
      rightarrow: "\u2192",
      RightArrowBar: "\u21E5",
      RightArrowLeftArrow: "\u21C4",
      rightarrowtail: "\u21A3",
      RightCeiling: "\u2309",
      RightDoubleBracket: "\u27E7",
      RightDownTeeVector: "\u295D",
      RightDownVector: "\u21C2",
      RightDownVectorBar: "\u2955",
      RightFloor: "\u230B",
      rightharpoondown: "\u21C1",
      rightharpoonup: "\u21C0",
      rightleftarrows: "\u21C4",
      rightleftharpoons: "\u21CC",
      rightrightarrows: "\u21C9",
      rightsquigarrow: "\u219D",
      RightTee: "\u22A2",
      RightTeeArrow: "\u21A6",
      RightTeeVector: "\u295B",
      rightthreetimes: "\u22CC",
      RightTriangle: "\u22B3",
      RightTriangleBar: "\u29D0",
      RightTriangleEqual: "\u22B5",
      RightUpDownVector: "\u294F",
      RightUpTeeVector: "\u295C",
      RightUpVector: "\u21BE",
      RightUpVectorBar: "\u2954",
      RightVector: "\u21C0",
      RightVectorBar: "\u2953",
      ring: "\u02DA",
      risingdotseq: "\u2253",
      rlarr: "\u21C4",
      rlhar: "\u21CC",
      rlm: "\u200F",
      rmoust: "\u23B1",
      rmoustache: "\u23B1",
      rnmid: "\u2AEE",
      roang: "\u27ED",
      roarr: "\u21FE",
      robrk: "\u27E7",
      ropar: "\u2986",
      Ropf: "\u211D",
      ropf: "\u{1D563}",
      roplus: "\u2A2E",
      rotimes: "\u2A35",
      RoundImplies: "\u2970",
      rpar: ")",
      rpargt: "\u2994",
      rppolint: "\u2A12",
      rrarr: "\u21C9",
      Rrightarrow: "\u21DB",
      rsaquo: "\u203A",
      Rscr: "\u211B",
      rscr: "\u{1D4C7}",
      Rsh: "\u21B1",
      rsh: "\u21B1",
      rsqb: "]",
      rsquo: "\u2019",
      rsquor: "\u2019",
      rthree: "\u22CC",
      rtimes: "\u22CA",
      rtri: "\u25B9",
      rtrie: "\u22B5",
      rtrif: "\u25B8",
      rtriltri: "\u29CE",
      RuleDelayed: "\u29F4",
      ruluhar: "\u2968",
      rx: "\u211E",
      Sacute: "\u015A",
      sacute: "\u015B",
      sbquo: "\u201A",
      Sc: "\u2ABC",
      sc: "\u227B",
      scap: "\u2AB8",
      Scaron: "\u0160",
      scaron: "\u0161",
      sccue: "\u227D",
      scE: "\u2AB4",
      sce: "\u2AB0",
      Scedil: "\u015E",
      scedil: "\u015F",
      Scirc: "\u015C",
      scirc: "\u015D",
      scnap: "\u2ABA",
      scnE: "\u2AB6",
      scnsim: "\u22E9",
      scpolint: "\u2A13",
      scsim: "\u227F",
      Scy: "\u0421",
      scy: "\u0441",
      sdot: "\u22C5",
      sdotb: "\u22A1",
      sdote: "\u2A66",
      searhk: "\u2925",
      seArr: "\u21D8",
      searr: "\u2198",
      searrow: "\u2198",
      sect: "\xA7",
      semi: ";",
      seswar: "\u2929",
      setminus: "\u2216",
      setmn: "\u2216",
      sext: "\u2736",
      Sfr: "\u{1D516}",
      sfr: "\u{1D530}",
      sfrown: "\u2322",
      sharp: "\u266F",
      SHCHcy: "\u0429",
      shchcy: "\u0449",
      SHcy: "\u0428",
      shcy: "\u0448",
      ShortDownArrow: "\u2193",
      ShortLeftArrow: "\u2190",
      shortmid: "\u2223",
      shortparallel: "\u2225",
      ShortRightArrow: "\u2192",
      ShortUpArrow: "\u2191",
      shy: "\xAD",
      Sigma: "\u03A3",
      sigma: "\u03C3",
      sigmaf: "\u03C2",
      sigmav: "\u03C2",
      sim: "\u223C",
      simdot: "\u2A6A",
      sime: "\u2243",
      simeq: "\u2243",
      simg: "\u2A9E",
      simgE: "\u2AA0",
      siml: "\u2A9D",
      simlE: "\u2A9F",
      simne: "\u2246",
      simplus: "\u2A24",
      simrarr: "\u2972",
      slarr: "\u2190",
      SmallCircle: "\u2218",
      smallsetminus: "\u2216",
      smashp: "\u2A33",
      smeparsl: "\u29E4",
      smid: "\u2223",
      smile: "\u2323",
      smt: "\u2AAA",
      smte: "\u2AAC",
      smtes: "\u2AAC\uFE00",
      SOFTcy: "\u042C",
      softcy: "\u044C",
      sol: "/",
      solb: "\u29C4",
      solbar: "\u233F",
      Sopf: "\u{1D54A}",
      sopf: "\u{1D564}",
      spades: "\u2660",
      spadesuit: "\u2660",
      spar: "\u2225",
      sqcap: "\u2293",
      sqcaps: "\u2293\uFE00",
      sqcup: "\u2294",
      sqcups: "\u2294\uFE00",
      Sqrt: "\u221A",
      sqsub: "\u228F",
      sqsube: "\u2291",
      sqsubset: "\u228F",
      sqsubseteq: "\u2291",
      sqsup: "\u2290",
      sqsupe: "\u2292",
      sqsupset: "\u2290",
      sqsupseteq: "\u2292",
      squ: "\u25A1",
      Square: "\u25A1",
      square: "\u25A1",
      SquareIntersection: "\u2293",
      SquareSubset: "\u228F",
      SquareSubsetEqual: "\u2291",
      SquareSuperset: "\u2290",
      SquareSupersetEqual: "\u2292",
      SquareUnion: "\u2294",
      squarf: "\u25AA",
      squf: "\u25AA",
      srarr: "\u2192",
      Sscr: "\u{1D4AE}",
      sscr: "\u{1D4C8}",
      ssetmn: "\u2216",
      ssmile: "\u2323",
      sstarf: "\u22C6",
      Star: "\u22C6",
      star: "\u2606",
      starf: "\u2605",
      straightepsilon: "\u03F5",
      straightphi: "\u03D5",
      strns: "\xAF",
      Sub: "\u22D0",
      sub: "\u2282",
      subdot: "\u2ABD",
      subE: "\u2AC5",
      sube: "\u2286",
      subedot: "\u2AC3",
      submult: "\u2AC1",
      subnE: "\u2ACB",
      subne: "\u228A",
      subplus: "\u2ABF",
      subrarr: "\u2979",
      Subset: "\u22D0",
      subset: "\u2282",
      subseteq: "\u2286",
      subseteqq: "\u2AC5",
      SubsetEqual: "\u2286",
      subsetneq: "\u228A",
      subsetneqq: "\u2ACB",
      subsim: "\u2AC7",
      subsub: "\u2AD5",
      subsup: "\u2AD3",
      succ: "\u227B",
      succapprox: "\u2AB8",
      succcurlyeq: "\u227D",
      Succeeds: "\u227B",
      SucceedsEqual: "\u2AB0",
      SucceedsSlantEqual: "\u227D",
      SucceedsTilde: "\u227F",
      succeq: "\u2AB0",
      succnapprox: "\u2ABA",
      succneqq: "\u2AB6",
      succnsim: "\u22E9",
      succsim: "\u227F",
      SuchThat: "\u220B",
      Sum: "\u2211",
      sum: "\u2211",
      sung: "\u266A",
      Sup: "\u22D1",
      sup: "\u2283",
      sup1: "\xB9",
      sup2: "\xB2",
      sup3: "\xB3",
      supdot: "\u2ABE",
      supdsub: "\u2AD8",
      supE: "\u2AC6",
      supe: "\u2287",
      supedot: "\u2AC4",
      Superset: "\u2283",
      SupersetEqual: "\u2287",
      suphsol: "\u27C9",
      suphsub: "\u2AD7",
      suplarr: "\u297B",
      supmult: "\u2AC2",
      supnE: "\u2ACC",
      supne: "\u228B",
      supplus: "\u2AC0",
      Supset: "\u22D1",
      supset: "\u2283",
      supseteq: "\u2287",
      supseteqq: "\u2AC6",
      supsetneq: "\u228B",
      supsetneqq: "\u2ACC",
      supsim: "\u2AC8",
      supsub: "\u2AD4",
      supsup: "\u2AD6",
      swarhk: "\u2926",
      swArr: "\u21D9",
      swarr: "\u2199",
      swarrow: "\u2199",
      swnwar: "\u292A",
      szlig: "\xDF",
      Tab: "	",
      target: "\u2316",
      Tau: "\u03A4",
      tau: "\u03C4",
      tbrk: "\u23B4",
      Tcaron: "\u0164",
      tcaron: "\u0165",
      Tcedil: "\u0162",
      tcedil: "\u0163",
      Tcy: "\u0422",
      tcy: "\u0442",
      tdot: "\u20DB",
      telrec: "\u2315",
      Tfr: "\u{1D517}",
      tfr: "\u{1D531}",
      there4: "\u2234",
      Therefore: "\u2234",
      therefore: "\u2234",
      Theta: "\u0398",
      theta: "\u03B8",
      thetasym: "\u03D1",
      thetav: "\u03D1",
      thickapprox: "\u2248",
      thicksim: "\u223C",
      ThickSpace: "\u205F\u200A",
      thinsp: "\u2009",
      ThinSpace: "\u2009",
      thkap: "\u2248",
      thksim: "\u223C",
      THORN: "\xDE",
      thorn: "\xFE",
      Tilde: "\u223C",
      tilde: "\u02DC",
      TildeEqual: "\u2243",
      TildeFullEqual: "\u2245",
      TildeTilde: "\u2248",
      times: "\xD7",
      timesb: "\u22A0",
      timesbar: "\u2A31",
      timesd: "\u2A30",
      tint: "\u222D",
      toea: "\u2928",
      top: "\u22A4",
      topbot: "\u2336",
      topcir: "\u2AF1",
      Topf: "\u{1D54B}",
      topf: "\u{1D565}",
      topfork: "\u2ADA",
      tosa: "\u2929",
      tprime: "\u2034",
      TRADE: "\u2122",
      trade: "\u2122",
      triangle: "\u25B5",
      triangledown: "\u25BF",
      triangleleft: "\u25C3",
      trianglelefteq: "\u22B4",
      triangleq: "\u225C",
      triangleright: "\u25B9",
      trianglerighteq: "\u22B5",
      tridot: "\u25EC",
      trie: "\u225C",
      triminus: "\u2A3A",
      TripleDot: "\u20DB",
      triplus: "\u2A39",
      trisb: "\u29CD",
      tritime: "\u2A3B",
      trpezium: "\u23E2",
      Tscr: "\u{1D4AF}",
      tscr: "\u{1D4C9}",
      TScy: "\u0426",
      tscy: "\u0446",
      TSHcy: "\u040B",
      tshcy: "\u045B",
      Tstrok: "\u0166",
      tstrok: "\u0167",
      twixt: "\u226C",
      twoheadleftarrow: "\u219E",
      twoheadrightarrow: "\u21A0",
      Uacute: "\xDA",
      uacute: "\xFA",
      Uarr: "\u219F",
      uArr: "\u21D1",
      uarr: "\u2191",
      Uarrocir: "\u2949",
      Ubrcy: "\u040E",
      ubrcy: "\u045E",
      Ubreve: "\u016C",
      ubreve: "\u016D",
      Ucirc: "\xDB",
      ucirc: "\xFB",
      Ucy: "\u0423",
      ucy: "\u0443",
      udarr: "\u21C5",
      Udblac: "\u0170",
      udblac: "\u0171",
      udhar: "\u296E",
      ufisht: "\u297E",
      Ufr: "\u{1D518}",
      ufr: "\u{1D532}",
      Ugrave: "\xD9",
      ugrave: "\xF9",
      uHar: "\u2963",
      uharl: "\u21BF",
      uharr: "\u21BE",
      uhblk: "\u2580",
      ulcorn: "\u231C",
      ulcorner: "\u231C",
      ulcrop: "\u230F",
      ultri: "\u25F8",
      Umacr: "\u016A",
      umacr: "\u016B",
      uml: "\xA8",
      UnderBar: "_",
      UnderBrace: "\u23DF",
      UnderBracket: "\u23B5",
      UnderParenthesis: "\u23DD",
      Union: "\u22C3",
      UnionPlus: "\u228E",
      Uogon: "\u0172",
      uogon: "\u0173",
      Uopf: "\u{1D54C}",
      uopf: "\u{1D566}",
      UpArrow: "\u2191",
      Uparrow: "\u21D1",
      uparrow: "\u2191",
      UpArrowBar: "\u2912",
      UpArrowDownArrow: "\u21C5",
      UpDownArrow: "\u2195",
      Updownarrow: "\u21D5",
      updownarrow: "\u2195",
      UpEquilibrium: "\u296E",
      upharpoonleft: "\u21BF",
      upharpoonright: "\u21BE",
      uplus: "\u228E",
      UpperLeftArrow: "\u2196",
      UpperRightArrow: "\u2197",
      Upsi: "\u03D2",
      upsi: "\u03C5",
      upsih: "\u03D2",
      Upsilon: "\u03A5",
      upsilon: "\u03C5",
      UpTee: "\u22A5",
      UpTeeArrow: "\u21A5",
      upuparrows: "\u21C8",
      urcorn: "\u231D",
      urcorner: "\u231D",
      urcrop: "\u230E",
      Uring: "\u016E",
      uring: "\u016F",
      urtri: "\u25F9",
      Uscr: "\u{1D4B0}",
      uscr: "\u{1D4CA}",
      utdot: "\u22F0",
      Utilde: "\u0168",
      utilde: "\u0169",
      utri: "\u25B5",
      utrif: "\u25B4",
      uuarr: "\u21C8",
      Uuml: "\xDC",
      uuml: "\xFC",
      uwangle: "\u29A7",
      vangrt: "\u299C",
      varepsilon: "\u03F5",
      varkappa: "\u03F0",
      varnothing: "\u2205",
      varphi: "\u03D5",
      varpi: "\u03D6",
      varpropto: "\u221D",
      vArr: "\u21D5",
      varr: "\u2195",
      varrho: "\u03F1",
      varsigma: "\u03C2",
      varsubsetneq: "\u228A\uFE00",
      varsubsetneqq: "\u2ACB\uFE00",
      varsupsetneq: "\u228B\uFE00",
      varsupsetneqq: "\u2ACC\uFE00",
      vartheta: "\u03D1",
      vartriangleleft: "\u22B2",
      vartriangleright: "\u22B3",
      Vbar: "\u2AEB",
      vBar: "\u2AE8",
      vBarv: "\u2AE9",
      Vcy: "\u0412",
      vcy: "\u0432",
      VDash: "\u22AB",
      Vdash: "\u22A9",
      vDash: "\u22A8",
      vdash: "\u22A2",
      Vdashl: "\u2AE6",
      Vee: "\u22C1",
      vee: "\u2228",
      veebar: "\u22BB",
      veeeq: "\u225A",
      vellip: "\u22EE",
      Verbar: "\u2016",
      verbar: "|",
      Vert: "\u2016",
      vert: "|",
      VerticalBar: "\u2223",
      VerticalLine: "|",
      VerticalSeparator: "\u2758",
      VerticalTilde: "\u2240",
      VeryThinSpace: "\u200A",
      Vfr: "\u{1D519}",
      vfr: "\u{1D533}",
      vltri: "\u22B2",
      vnsub: "\u2282\u20D2",
      vnsup: "\u2283\u20D2",
      Vopf: "\u{1D54D}",
      vopf: "\u{1D567}",
      vprop: "\u221D",
      vrtri: "\u22B3",
      Vscr: "\u{1D4B1}",
      vscr: "\u{1D4CB}",
      vsubnE: "\u2ACB\uFE00",
      vsubne: "\u228A\uFE00",
      vsupnE: "\u2ACC\uFE00",
      vsupne: "\u228B\uFE00",
      Vvdash: "\u22AA",
      vzigzag: "\u299A",
      Wcirc: "\u0174",
      wcirc: "\u0175",
      wedbar: "\u2A5F",
      Wedge: "\u22C0",
      wedge: "\u2227",
      wedgeq: "\u2259",
      weierp: "\u2118",
      Wfr: "\u{1D51A}",
      wfr: "\u{1D534}",
      Wopf: "\u{1D54E}",
      wopf: "\u{1D568}",
      wp: "\u2118",
      wr: "\u2240",
      wreath: "\u2240",
      Wscr: "\u{1D4B2}",
      wscr: "\u{1D4CC}",
      xcap: "\u22C2",
      xcirc: "\u25EF",
      xcup: "\u22C3",
      xdtri: "\u25BD",
      Xfr: "\u{1D51B}",
      xfr: "\u{1D535}",
      xhArr: "\u27FA",
      xharr: "\u27F7",
      Xi: "\u039E",
      xi: "\u03BE",
      xlArr: "\u27F8",
      xlarr: "\u27F5",
      xmap: "\u27FC",
      xnis: "\u22FB",
      xodot: "\u2A00",
      Xopf: "\u{1D54F}",
      xopf: "\u{1D569}",
      xoplus: "\u2A01",
      xotime: "\u2A02",
      xrArr: "\u27F9",
      xrarr: "\u27F6",
      Xscr: "\u{1D4B3}",
      xscr: "\u{1D4CD}",
      xsqcup: "\u2A06",
      xuplus: "\u2A04",
      xutri: "\u25B3",
      xvee: "\u22C1",
      xwedge: "\u22C0",
      Yacute: "\xDD",
      yacute: "\xFD",
      YAcy: "\u042F",
      yacy: "\u044F",
      Ycirc: "\u0176",
      ycirc: "\u0177",
      Ycy: "\u042B",
      ycy: "\u044B",
      yen: "\xA5",
      Yfr: "\u{1D51C}",
      yfr: "\u{1D536}",
      YIcy: "\u0407",
      yicy: "\u0457",
      Yopf: "\u{1D550}",
      yopf: "\u{1D56A}",
      Yscr: "\u{1D4B4}",
      yscr: "\u{1D4CE}",
      YUcy: "\u042E",
      yucy: "\u044E",
      Yuml: "\u0178",
      yuml: "\xFF",
      Zacute: "\u0179",
      zacute: "\u017A",
      Zcaron: "\u017D",
      zcaron: "\u017E",
      Zcy: "\u0417",
      zcy: "\u0437",
      Zdot: "\u017B",
      zdot: "\u017C",
      zeetrf: "\u2128",
      ZeroWidthSpace: "\u200B",
      Zeta: "\u0396",
      zeta: "\u03B6",
      Zfr: "\u2128",
      zfr: "\u{1D537}",
      ZHcy: "\u0416",
      zhcy: "\u0436",
      zigrarr: "\u21DD",
      Zopf: "\u2124",
      zopf: "\u{1D56B}",
      Zscr: "\u{1D4B5}",
      zscr: "\u{1D4CF}",
      zwj: "\u200D",
      zwnj: "\u200C"
    });
    exports2.entityMap = exports2.HTML_ENTITIES;
  }
});

// node_modules/@xmldom/xmldom/lib/sax.js
var require_sax2 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/sax.js"(exports2) {
    var NAMESPACE = require_conventions().NAMESPACE;
    var nameStartChar = /[A-Z_a-z\xC0-\xD6\xD8-\xF6\u00F8-\u02FF\u0370-\u037D\u037F-\u1FFF\u200C-\u200D\u2070-\u218F\u2C00-\u2FEF\u3001-\uD7FF\uF900-\uFDCF\uFDF0-\uFFFD]/;
    var nameChar = new RegExp("[\\-\\.0-9" + nameStartChar.source.slice(1, -1) + "\\u00B7\\u0300-\\u036F\\u203F-\\u2040]");
    var tagNamePattern = new RegExp("^" + nameStartChar.source + nameChar.source + "*(?::" + nameStartChar.source + nameChar.source + "*)?$");
    var S_TAG = 0;
    var S_ATTR = 1;
    var S_ATTR_SPACE = 2;
    var S_EQ = 3;
    var S_ATTR_NOQUOT_VALUE = 4;
    var S_ATTR_END = 5;
    var S_TAG_SPACE = 6;
    var S_TAG_CLOSE = 7;
    function ParseError(message, locator) {
      this.message = message;
      this.locator = locator;
      if (Error.captureStackTrace) Error.captureStackTrace(this, ParseError);
    }
    ParseError.prototype = new Error();
    ParseError.prototype.name = ParseError.name;
    function XMLReader() {
    }
    XMLReader.prototype = {
      parse: function(source, defaultNSMap, entityMap) {
        var domBuilder = this.domBuilder;
        domBuilder.startDocument();
        _copy(defaultNSMap, defaultNSMap = {});
        parse(
          source,
          defaultNSMap,
          entityMap,
          domBuilder,
          this.errorHandler
        );
        domBuilder.endDocument();
      }
    };
    function parse(source, defaultNSMapCopy, entityMap, domBuilder, errorHandler) {
      function fixedFromCharCode(code) {
        if (code > 65535) {
          code -= 65536;
          var surrogate1 = 55296 + (code >> 10), surrogate2 = 56320 + (code & 1023);
          return String.fromCharCode(surrogate1, surrogate2);
        } else {
          return String.fromCharCode(code);
        }
      }
      function entityReplacer(a2) {
        var k = a2.slice(1, -1);
        if (Object.hasOwnProperty.call(entityMap, k)) {
          return entityMap[k];
        } else if (k.charAt(0) === "#") {
          return fixedFromCharCode(parseInt(k.substr(1).replace("x", "0x")));
        } else {
          errorHandler.error("entity not found:" + a2);
          return a2;
        }
      }
      function appendText(end2) {
        if (end2 > start) {
          var xt = source.substring(start, end2).replace(/&#?\w+;/g, entityReplacer);
          locator && position(start);
          domBuilder.characters(xt, 0, end2 - start);
          start = end2;
        }
      }
      function position(p, m) {
        while (p >= lineEnd && (m = linePattern.exec(source))) {
          lineStart = m.index;
          lineEnd = lineStart + m[0].length;
          locator.lineNumber++;
        }
        locator.columnNumber = p - lineStart + 1;
      }
      var lineStart = 0;
      var lineEnd = 0;
      var linePattern = /.*(?:\r\n?|\n)|.*$/g;
      var locator = domBuilder.locator;
      var parseStack = [{ currentNSMap: defaultNSMapCopy }];
      var closeMap = {};
      var start = 0;
      while (true) {
        try {
          var tagStart = source.indexOf("<", start);
          if (tagStart < 0) {
            if (!source.substr(start).match(/^\s*$/)) {
              var doc = domBuilder.doc;
              var text = doc.createTextNode(source.substr(start));
              doc.appendChild(text);
              domBuilder.currentElement = text;
            }
            return;
          }
          if (tagStart > start) {
            appendText(tagStart);
          }
          switch (source.charAt(tagStart + 1)) {
            case "/":
              var end = source.indexOf(">", tagStart + 3);
              var tagName = source.substring(tagStart + 2, end).replace(/[ \t\n\r]+$/g, "");
              var config = parseStack.pop();
              if (end < 0) {
                tagName = source.substring(tagStart + 2).replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " is not complete:" + config.tagName);
                end = tagStart + 1 + tagName.length;
              } else if (tagName.match(/\s</)) {
                tagName = tagName.replace(/[\s<].*/, "");
                errorHandler.error("end tag name: " + tagName + " maybe not complete");
                end = tagStart + 1 + tagName.length;
              }
              var localNSMap = config.localNSMap;
              var endMatch = config.tagName == tagName;
              var endIgnoreCaseMach = endMatch || config.tagName && config.tagName.toLowerCase() == tagName.toLowerCase();
              if (endIgnoreCaseMach) {
                domBuilder.endElement(config.uri, config.localName, tagName);
                if (localNSMap) {
                  for (var prefix in localNSMap) {
                    if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
                      domBuilder.endPrefixMapping(prefix);
                    }
                  }
                }
                if (!endMatch) {
                  errorHandler.fatalError("end tag name: " + tagName + " is not match the current start tagName:" + config.tagName);
                }
              } else {
                parseStack.push(config);
              }
              end++;
              break;
            // end elment
            case "?":
              locator && position(tagStart);
              end = parseInstruction(source, tagStart, domBuilder);
              break;
            case "!":
              locator && position(tagStart);
              end = parseDCC(source, tagStart, domBuilder, errorHandler);
              break;
            default:
              locator && position(tagStart);
              var el = new ElementAttributes();
              var currentNSMap = parseStack[parseStack.length - 1].currentNSMap;
              var end = parseElementStartPart(source, tagStart, el, currentNSMap, entityReplacer, errorHandler);
              var len = el.length;
              if (!el.closed && fixSelfClosed(source, end, el.tagName, closeMap)) {
                el.closed = true;
                if (!entityMap.nbsp) {
                  errorHandler.warning("unclosed xml attribute");
                }
              }
              if (locator && len) {
                var locator2 = copyLocator(locator, {});
                for (var i = 0; i < len; i++) {
                  var a = el[i];
                  position(a.offset);
                  a.locator = copyLocator(locator, {});
                }
                domBuilder.locator = locator2;
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
                domBuilder.locator = locator;
              } else {
                if (appendElement(el, domBuilder, currentNSMap)) {
                  parseStack.push(el);
                }
              }
              if (NAMESPACE.isHTML(el.uri) && !el.closed) {
                end = parseHtmlSpecialContent(source, end, el.tagName, entityReplacer, domBuilder);
              } else {
                end++;
              }
          }
        } catch (e) {
          if (e instanceof ParseError) {
            throw e;
          }
          errorHandler.error("element parse error: " + e);
          end = -1;
        }
        if (end > start) {
          start = end;
        } else {
          appendText(Math.max(tagStart, start) + 1);
        }
      }
    }
    function copyLocator(f, t2) {
      t2.lineNumber = f.lineNumber;
      t2.columnNumber = f.columnNumber;
      return t2;
    }
    function parseElementStartPart(source, start, el, currentNSMap, entityReplacer, errorHandler) {
      function addAttribute(qname, value2, startIndex) {
        if (el.attributeNames.hasOwnProperty(qname)) {
          errorHandler.fatalError("Attribute " + qname + " redefined");
        }
        el.addValue(
          qname,
          // @see https://www.w3.org/TR/xml/#AVNormalize
          // since the xmldom sax parser does not "interpret" DTD the following is not implemented:
          // - recursive replacement of (DTD) entity references
          // - trimming and collapsing multiple spaces into a single one for attributes that are not of type CDATA
          value2.replace(/[\t\n\r]/g, " ").replace(/&#?\w+;/g, entityReplacer),
          startIndex
        );
      }
      var attrName;
      var value;
      var p = ++start;
      var s = S_TAG;
      while (true) {
        var c = source.charAt(p);
        switch (c) {
          case "=":
            if (s === S_ATTR) {
              attrName = source.slice(start, p);
              s = S_EQ;
            } else if (s === S_ATTR_SPACE) {
              s = S_EQ;
            } else {
              throw new Error("attribute equal must after attrName");
            }
            break;
          case "'":
          case '"':
            if (s === S_EQ || s === S_ATTR) {
              if (s === S_ATTR) {
                errorHandler.warning('attribute value must after "="');
                attrName = source.slice(start, p);
              }
              start = p + 1;
              p = source.indexOf(c, start);
              if (p > 0) {
                value = source.slice(start, p);
                addAttribute(attrName, value, start - 1);
                s = S_ATTR_END;
              } else {
                throw new Error("attribute value no end '" + c + "' match");
              }
            } else if (s == S_ATTR_NOQUOT_VALUE) {
              value = source.slice(start, p);
              addAttribute(attrName, value, start);
              errorHandler.warning('attribute "' + attrName + '" missed start quot(' + c + ")!!");
              start = p + 1;
              s = S_ATTR_END;
            } else {
              throw new Error('attribute value must after "="');
            }
            break;
          case "/":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                s = S_TAG_CLOSE;
                el.closed = true;
              case S_ATTR_NOQUOT_VALUE:
              case S_ATTR:
                break;
              case S_ATTR_SPACE:
                el.closed = true;
                break;
              //case S_EQ:
              default:
                throw new Error("attribute invalid close char('/')");
            }
            break;
          case "":
            errorHandler.error("unexpected end of input");
            if (s == S_TAG) {
              el.setTagName(source.slice(start, p));
            }
            return p;
          case ">":
            switch (s) {
              case S_TAG:
                el.setTagName(source.slice(start, p));
              case S_ATTR_END:
              case S_TAG_SPACE:
              case S_TAG_CLOSE:
                break;
              //normal
              case S_ATTR_NOQUOT_VALUE:
              //Compatible state
              case S_ATTR:
                value = source.slice(start, p);
                if (value.slice(-1) === "/") {
                  el.closed = true;
                  value = value.slice(0, -1);
                }
              case S_ATTR_SPACE:
                if (s === S_ATTR_SPACE) {
                  value = attrName;
                }
                if (s == S_ATTR_NOQUOT_VALUE) {
                  errorHandler.warning('attribute "' + value + '" missed quot(")!');
                  addAttribute(attrName, value, start);
                } else {
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !value.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + value + '" missed value!! "' + value + '" instead!!');
                  }
                  addAttribute(value, value, start);
                }
                break;
              case S_EQ:
                throw new Error("attribute value missed!!");
            }
            return p;
          /*xml space '\x20' | #x9 | #xD | #xA; */
          case "\x80":
            c = " ";
          default:
            if (c <= " ") {
              switch (s) {
                case S_TAG:
                  el.setTagName(source.slice(start, p));
                  s = S_TAG_SPACE;
                  break;
                case S_ATTR:
                  attrName = source.slice(start, p);
                  s = S_ATTR_SPACE;
                  break;
                case S_ATTR_NOQUOT_VALUE:
                  var value = source.slice(start, p);
                  errorHandler.warning('attribute "' + value + '" missed quot(")!!');
                  addAttribute(attrName, value, start);
                case S_ATTR_END:
                  s = S_TAG_SPACE;
                  break;
              }
            } else {
              switch (s) {
                //case S_TAG:void();break;
                //case S_ATTR:void();break;
                //case S_ATTR_NOQUOT_VALUE:void();break;
                case S_ATTR_SPACE:
                  var tagName = el.tagName;
                  if (!NAMESPACE.isHTML(currentNSMap[""]) || !attrName.match(/^(?:disabled|checked|selected)$/i)) {
                    errorHandler.warning('attribute "' + attrName + '" missed value!! "' + attrName + '" instead2!!');
                  }
                  addAttribute(attrName, attrName, start);
                  start = p;
                  s = S_ATTR;
                  break;
                case S_ATTR_END:
                  errorHandler.warning('attribute space is required"' + attrName + '"!!');
                case S_TAG_SPACE:
                  s = S_ATTR;
                  start = p;
                  break;
                case S_EQ:
                  s = S_ATTR_NOQUOT_VALUE;
                  start = p;
                  break;
                case S_TAG_CLOSE:
                  throw new Error("elements closed character '/' and '>' must be connected to");
              }
            }
        }
        p++;
      }
    }
    function appendElement(el, domBuilder, currentNSMap) {
      var tagName = el.tagName;
      var localNSMap = null;
      var i = el.length;
      while (i--) {
        var a = el[i];
        var qName = a.qName;
        var value = a.value;
        var nsp = qName.indexOf(":");
        if (nsp > 0) {
          var prefix = a.prefix = qName.slice(0, nsp);
          var localName = qName.slice(nsp + 1);
          var nsPrefix = prefix === "xmlns" && localName;
        } else {
          localName = qName;
          prefix = null;
          nsPrefix = qName === "xmlns" && "";
        }
        a.localName = localName;
        if (nsPrefix !== false) {
          if (localNSMap == null) {
            localNSMap = {};
            _copy(currentNSMap, currentNSMap = {});
          }
          currentNSMap[nsPrefix] = localNSMap[nsPrefix] = value;
          a.uri = NAMESPACE.XMLNS;
          domBuilder.startPrefixMapping(nsPrefix, value);
        }
      }
      var i = el.length;
      while (i--) {
        a = el[i];
        var prefix = a.prefix;
        if (prefix) {
          if (prefix === "xml") {
            a.uri = NAMESPACE.XML;
          }
          if (prefix !== "xmlns") {
            a.uri = currentNSMap[prefix || ""];
          }
        }
      }
      var nsp = tagName.indexOf(":");
      if (nsp > 0) {
        prefix = el.prefix = tagName.slice(0, nsp);
        localName = el.localName = tagName.slice(nsp + 1);
      } else {
        prefix = null;
        localName = el.localName = tagName;
      }
      var ns = el.uri = currentNSMap[prefix || ""];
      domBuilder.startElement(ns, localName, tagName, el);
      if (el.closed) {
        domBuilder.endElement(ns, localName, tagName);
        if (localNSMap) {
          for (prefix in localNSMap) {
            if (Object.prototype.hasOwnProperty.call(localNSMap, prefix)) {
              domBuilder.endPrefixMapping(prefix);
            }
          }
        }
      } else {
        el.currentNSMap = currentNSMap;
        el.localNSMap = localNSMap;
        return true;
      }
    }
    function parseHtmlSpecialContent(source, elStartEnd, tagName, entityReplacer, domBuilder) {
      if (/^(?:script|textarea)$/i.test(tagName)) {
        var elEndStart = source.indexOf("</" + tagName + ">", elStartEnd);
        var text = source.substring(elStartEnd + 1, elEndStart);
        if (/[&<]/.test(text)) {
          if (/^script$/i.test(tagName)) {
            domBuilder.characters(text, 0, text.length);
            return elEndStart;
          }
          text = text.replace(/&#?\w+;/g, entityReplacer);
          domBuilder.characters(text, 0, text.length);
          return elEndStart;
        }
      }
      return elStartEnd + 1;
    }
    function fixSelfClosed(source, elStartEnd, tagName, closeMap) {
      var pos = closeMap[tagName];
      if (pos == null) {
        pos = source.lastIndexOf("</" + tagName + ">");
        if (pos < elStartEnd) {
          pos = source.lastIndexOf("</" + tagName);
        }
        closeMap[tagName] = pos;
      }
      return pos < elStartEnd;
    }
    function _copy(source, target) {
      for (var n in source) {
        if (Object.prototype.hasOwnProperty.call(source, n)) {
          target[n] = source[n];
        }
      }
    }
    function parseDCC(source, start, domBuilder, errorHandler) {
      var next = source.charAt(start + 2);
      switch (next) {
        case "-":
          if (source.charAt(start + 3) === "-") {
            var end = source.indexOf("-->", start + 4);
            if (end > start) {
              domBuilder.comment(source, start + 4, end - start - 4);
              return end + 3;
            } else {
              errorHandler.error("Unclosed comment");
              return -1;
            }
          } else {
            return -1;
          }
        default:
          if (source.substr(start + 3, 6) == "CDATA[") {
            var end = source.indexOf("]]>", start + 9);
            domBuilder.startCDATA();
            domBuilder.characters(source, start + 9, end - start - 9);
            domBuilder.endCDATA();
            return end + 3;
          }
          var matchs = split(source, start);
          var len = matchs.length;
          if (len > 1 && /!doctype/i.test(matchs[0][0])) {
            var name = matchs[1][0];
            var pubid = false;
            var sysid = false;
            if (len > 3) {
              if (/^public$/i.test(matchs[2][0])) {
                pubid = matchs[3][0];
                sysid = len > 4 && matchs[4][0];
              } else if (/^system$/i.test(matchs[2][0])) {
                sysid = matchs[3][0];
              }
            }
            var lastMatch = matchs[len - 1];
            domBuilder.startDTD(name, pubid, sysid);
            domBuilder.endDTD();
            return lastMatch.index + lastMatch[0].length;
          }
      }
      return -1;
    }
    function parseInstruction(source, start, domBuilder) {
      var end = source.indexOf("?>", start);
      if (end) {
        var match = source.substring(start, end).match(/^<\?(\S*)\s*([\s\S]*?)\s*$/);
        if (match) {
          var len = match[0].length;
          domBuilder.processingInstruction(match[1], match[2]);
          return end + 2;
        } else {
          return -1;
        }
      }
      return -1;
    }
    function ElementAttributes() {
      this.attributeNames = {};
    }
    ElementAttributes.prototype = {
      setTagName: function(tagName) {
        if (!tagNamePattern.test(tagName)) {
          throw new Error("invalid tagName:" + tagName);
        }
        this.tagName = tagName;
      },
      addValue: function(qName, value, offset) {
        if (!tagNamePattern.test(qName)) {
          throw new Error("invalid attribute:" + qName);
        }
        this.attributeNames[qName] = this.length;
        this[this.length++] = { qName, value, offset };
      },
      length: 0,
      getLocalName: function(i) {
        return this[i].localName;
      },
      getLocator: function(i) {
        return this[i].locator;
      },
      getQName: function(i) {
        return this[i].qName;
      },
      getURI: function(i) {
        return this[i].uri;
      },
      getValue: function(i) {
        return this[i].value;
      }
      //	,getIndex:function(uri, localName)){
      //		if(localName){
      //
      //		}else{
      //			var qName = uri
      //		}
      //	},
      //	getValue:function(){return this.getValue(this.getIndex.apply(this,arguments))},
      //	getType:function(uri,localName){}
      //	getType:function(i){},
    };
    function split(source, start) {
      var match;
      var buf = [];
      var reg = /'[^']+'|"[^"]+"|[^\s<>\/=]+=?|(\/?\s*>|<)/g;
      reg.lastIndex = start;
      reg.exec(source);
      while (match = reg.exec(source)) {
        buf.push(match);
        if (match[1]) return buf;
      }
    }
    exports2.XMLReader = XMLReader;
    exports2.ParseError = ParseError;
  }
});

// node_modules/@xmldom/xmldom/lib/dom-parser.js
var require_dom_parser = __commonJS({
  "node_modules/@xmldom/xmldom/lib/dom-parser.js"(exports2) {
    var conventions = require_conventions();
    var dom = require_dom();
    var entities = require_entities();
    var sax = require_sax2();
    var DOMImplementation = dom.DOMImplementation;
    var NAMESPACE = conventions.NAMESPACE;
    var ParseError = sax.ParseError;
    var XMLReader = sax.XMLReader;
    function normalizeLineEndings(input) {
      return input.replace(/\r[\n\u0085]/g, "\n").replace(/[\r\u0085\u2028]/g, "\n");
    }
    function DOMParser2(options) {
      this.options = options || { locator: {} };
    }
    DOMParser2.prototype.parseFromString = function(source, mimeType) {
      var options = this.options;
      var sax2 = new XMLReader();
      var domBuilder = options.domBuilder || new DOMHandler();
      var errorHandler = options.errorHandler;
      var locator = options.locator;
      var defaultNSMap = options.xmlns || {};
      var isHTML = /\/x?html?$/.test(mimeType);
      var entityMap = isHTML ? entities.HTML_ENTITIES : entities.XML_ENTITIES;
      if (locator) {
        domBuilder.setDocumentLocator(locator);
      }
      sax2.errorHandler = buildErrorHandler(errorHandler, domBuilder, locator);
      sax2.domBuilder = options.domBuilder || domBuilder;
      if (isHTML) {
        defaultNSMap[""] = NAMESPACE.HTML;
      }
      defaultNSMap.xml = defaultNSMap.xml || NAMESPACE.XML;
      var normalize = options.normalizeLineEndings || normalizeLineEndings;
      if (source && typeof source === "string") {
        sax2.parse(
          normalize(source),
          defaultNSMap,
          entityMap
        );
      } else {
        sax2.errorHandler.error("invalid doc source");
      }
      return domBuilder.doc;
    };
    function buildErrorHandler(errorImpl, domBuilder, locator) {
      if (!errorImpl) {
        if (domBuilder instanceof DOMHandler) {
          return domBuilder;
        }
        errorImpl = domBuilder;
      }
      var errorHandler = {};
      var isCallback = errorImpl instanceof Function;
      locator = locator || {};
      function build(key) {
        var fn = errorImpl[key];
        if (!fn && isCallback) {
          fn = errorImpl.length == 2 ? function(msg) {
            errorImpl(key, msg);
          } : errorImpl;
        }
        errorHandler[key] = fn && function(msg) {
          fn("[xmldom " + key + "]	" + msg + _locator(locator));
        } || function() {
        };
      }
      build("warning");
      build("error");
      build("fatalError");
      return errorHandler;
    }
    function DOMHandler() {
      this.cdata = false;
    }
    function position(locator, node) {
      node.lineNumber = locator.lineNumber;
      node.columnNumber = locator.columnNumber;
    }
    DOMHandler.prototype = {
      startDocument: function() {
        this.doc = new DOMImplementation().createDocument(null, null, null);
        if (this.locator) {
          this.doc.documentURI = this.locator.systemId;
        }
      },
      startElement: function(namespaceURI, localName, qName, attrs) {
        var doc = this.doc;
        var el = doc.createElementNS(namespaceURI, qName || localName);
        var len = attrs.length;
        appendElement(this, el);
        this.currentElement = el;
        this.locator && position(this.locator, el);
        for (var i = 0; i < len; i++) {
          var namespaceURI = attrs.getURI(i);
          var value = attrs.getValue(i);
          var qName = attrs.getQName(i);
          var attr = doc.createAttributeNS(namespaceURI, qName);
          this.locator && position(attrs.getLocator(i), attr);
          attr.value = attr.nodeValue = value;
          el.setAttributeNode(attr);
        }
      },
      endElement: function(namespaceURI, localName, qName) {
        var current = this.currentElement;
        var tagName = current.tagName;
        this.currentElement = current.parentNode;
      },
      startPrefixMapping: function(prefix, uri) {
      },
      endPrefixMapping: function(prefix) {
      },
      processingInstruction: function(target, data) {
        var ins = this.doc.createProcessingInstruction(target, data);
        this.locator && position(this.locator, ins);
        appendElement(this, ins);
      },
      ignorableWhitespace: function(ch, start, length) {
      },
      characters: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        if (chars) {
          if (this.cdata) {
            var charNode = this.doc.createCDATASection(chars);
          } else {
            var charNode = this.doc.createTextNode(chars);
          }
          if (this.currentElement) {
            this.currentElement.appendChild(charNode);
          } else if (/^\s*$/.test(chars)) {
            this.doc.appendChild(charNode);
          }
          this.locator && position(this.locator, charNode);
        }
      },
      skippedEntity: function(name) {
      },
      endDocument: function() {
        this.doc.normalize();
      },
      setDocumentLocator: function(locator) {
        if (this.locator = locator) {
          locator.lineNumber = 0;
        }
      },
      //LexicalHandler
      comment: function(chars, start, length) {
        chars = _toString.apply(this, arguments);
        var comm = this.doc.createComment(chars);
        this.locator && position(this.locator, comm);
        appendElement(this, comm);
      },
      startCDATA: function() {
        this.cdata = true;
      },
      endCDATA: function() {
        this.cdata = false;
      },
      startDTD: function(name, publicId, systemId) {
        var impl = this.doc.implementation;
        if (impl && impl.createDocumentType) {
          var dt = impl.createDocumentType(name, publicId, systemId);
          this.locator && position(this.locator, dt);
          appendElement(this, dt);
          this.doc.doctype = dt;
        }
      },
      /**
       * @see org.xml.sax.ErrorHandler
       * @link http://www.saxproject.org/apidoc/org/xml/sax/ErrorHandler.html
       */
      warning: function(error) {
        console.warn("[xmldom warning]	" + error, _locator(this.locator));
      },
      error: function(error) {
        console.error("[xmldom error]	" + error, _locator(this.locator));
      },
      fatalError: function(error) {
        throw new ParseError(error, this.locator);
      }
    };
    function _locator(l) {
      if (l) {
        return "\n@" + (l.systemId || "") + "#[line:" + l.lineNumber + ",col:" + l.columnNumber + "]";
      }
    }
    function _toString(chars, start, length) {
      if (typeof chars == "string") {
        return chars.substr(start, length);
      } else {
        if (chars.length >= start + length || start) {
          return new java.lang.String(chars, start, length) + "";
        }
        return chars;
      }
    }
    "endDTD,startEntity,endEntity,attributeDecl,elementDecl,externalEntityDecl,internalEntityDecl,resolveEntity,getExternalSubset,notationDecl,unparsedEntityDecl".replace(/\w+/g, function(key) {
      DOMHandler.prototype[key] = function() {
        return null;
      };
    });
    function appendElement(hander, node) {
      if (!hander.currentElement) {
        hander.doc.appendChild(node);
      } else {
        hander.currentElement.appendChild(node);
      }
    }
    exports2.__DOMHandler = DOMHandler;
    exports2.normalizeLineEndings = normalizeLineEndings;
    exports2.DOMParser = DOMParser2;
  }
});

// node_modules/@xmldom/xmldom/lib/index.js
var require_lib8 = __commonJS({
  "node_modules/@xmldom/xmldom/lib/index.js"(exports2) {
    var dom = require_dom();
    exports2.DOMImplementation = dom.DOMImplementation;
    exports2.XMLSerializer = dom.XMLSerializer;
    exports2.DOMParser = require_dom_parser().DOMParser;
  }
});

// src/extension.ts
var extension_exports = {};
__export(extension_exports, {
  activate: () => activate,
  deactivate: () => deactivate
});
module.exports = __toCommonJS(extension_exports);
var vscode54 = __toESM(require("vscode"));

// src/providers/WorkspaceSvgProvider.ts
var vscode17 = __toESM(require("vscode"));
var path16 = __toESM(require("path"));
var fs13 = __toESM(require("fs"));
init_config();

// src/providers/IgnorePatterns.ts
var vscode2 = __toESM(require("vscode"));
var path = __toESM(require("path"));
var fs = __toESM(require("fs"));
var ignorePatterns = [];
var ignoreFileWatcher;
function loadIgnorePatterns() {
  const workspaceRoot = vscode2.workspace.workspaceFolders?.[0]?.uri.fsPath;
  if (!workspaceRoot) return [];
  const ignoreFile = path.join(workspaceRoot, ".bezierignore");
  if (!fs.existsSync(ignoreFile)) {
    return [];
  }
  try {
    const content = fs.readFileSync(ignoreFile, "utf-8");
    const patterns = content.split("\n").map((line) => line.trim()).filter((line) => line && !line.startsWith("#"));
    return patterns;
  } catch {
    return [];
  }
}
function shouldIgnorePath(filePath) {
  if (ignorePatterns.length === 0) return false;
  const workspaceRoot = vscode2.workspace.workspaceFolders?.[0]?.uri.fsPath;
  if (!workspaceRoot) return false;
  const relativePath = path.relative(workspaceRoot, filePath).replace(/\\/g, "/");
  for (const pattern of ignorePatterns) {
    if (matchIgnorePattern(relativePath, pattern)) {
      return true;
    }
  }
  return false;
}
function matchIgnorePattern(relativePath, pattern) {
  let normalizedPattern = pattern.replace(/\\/g, "/");
  const isDirectoryPattern = normalizedPattern.endsWith("/");
  if (isDirectoryPattern) {
    normalizedPattern = normalizedPattern.slice(0, -1);
  }
  const isRootRelative = normalizedPattern.startsWith("/");
  if (isRootRelative) {
    normalizedPattern = normalizedPattern.slice(1);
  }
  const regexPattern = normalizedPattern.replace(/\./g, "\\.").replace(/\*\*/g, "{{DOUBLESTAR}}").replace(/\*/g, "[^/]*").replace(/{{DOUBLESTAR}}/g, ".*").replace(/\?/g, "[^/]");
  let regex;
  if (isRootRelative) {
    regex = new RegExp(`^${regexPattern}(?:/|$)`);
  } else if (isDirectoryPattern) {
    regex = new RegExp(`(?:^|/)${regexPattern}(?:/|$)`);
  } else {
    regex = new RegExp(`(?:^|/)${regexPattern}(?:/|$)|^${regexPattern}$`);
  }
  return regex.test(relativePath);
}
function initIgnoreFileWatcher(context) {
  ignorePatterns = loadIgnorePatterns();
  const workspaceRoot = vscode2.workspace.workspaceFolders?.[0]?.uri.fsPath;
  if (workspaceRoot) {
    ignoreFileWatcher = vscode2.workspace.createFileSystemWatcher(
      new vscode2.RelativePattern(workspaceRoot, ".bezierignore")
    );
    const reloadPatterns = () => {
      ignorePatterns = loadIgnorePatterns();
      vscode2.commands.executeCommand("sageboxIconStudio.refresh");
    };
    ignoreFileWatcher.onDidCreate(reloadPatterns);
    ignoreFileWatcher.onDidChange(reloadPatterns);
    ignoreFileWatcher.onDidDelete(reloadPatterns);
    context.subscriptions.push(ignoreFileWatcher);
  }
}
function reloadIgnorePatterns() {
  ignorePatterns = loadIgnorePatterns();
}

// src/providers/TempIconStudio.ts
var path2 = __toESM(require("path"));
var fs3 = __toESM(require("fs"));
var os = __toESM(require("os"));
var crypto2 = __toESM(require("crypto"));

// src/providers/SvgContentCache.ts
var fs2 = __toESM(require("fs"));
var crypto = __toESM(require("crypto"));
var SvgContentCache = class _SvgContentCache {
  static instance;
  cache = /* @__PURE__ */ new Map();
  tempPathCache = /* @__PURE__ */ new Map();
  // hash -> temp file path
  maxCacheSize = 500;
  // Maximum number of cached entries
  cleanupThreshold = 0.8;
  // Start cleanup when cache is 80% full
  constructor() {
  }
  static getInstance() {
    if (!_SvgContentCache.instance) {
      _SvgContentCache.instance = new _SvgContentCache();
    }
    return _SvgContentCache.instance;
  }
  /**
   * Get SVG content from cache or load from file
   * Returns undefined if file doesn't exist or can't be read
   */
  getContent(filePath) {
    const cached = this.cache.get(filePath);
    if (cached) {
      try {
        const stats = fs2.statSync(filePath);
        if (stats.mtimeMs === cached.lastModified) {
          return cached.content;
        }
      } catch {
        this.cache.delete(filePath);
        return void 0;
      }
    }
    return this.loadAndCache(filePath);
  }
  /**
   * Get SVG content hash (for temp file naming)
   */
  getContentHash(filePath) {
    const content = this.getContent(filePath);
    if (!content) return void 0;
    const cached = this.cache.get(filePath);
    return cached?.hash;
  }
  /**
   * Get or compute content hash directly from content
   */
  computeHash(content) {
    return crypto.createHash("md5").update(content).digest("hex").substring(0, 8);
  }
  /**
   * Check if SVG is rasterized (cached result)
   */
  isRasterized(filePath) {
    const cached = this.cache.get(filePath);
    if (cached && cached.isRasterized !== void 0) {
      return cached.isRasterized;
    }
    const content = this.getContent(filePath);
    if (!content) return false;
    const colorCount = this.countColors(content);
    const isRasterized = colorCount > 50;
    const entry = this.cache.get(filePath);
    if (entry) {
      entry.isRasterized = isRasterized;
      entry.colorCount = colorCount;
    }
    return isRasterized;
  }
  /**
   * Get animation type (cached result)
   */
  getAnimationType(filePath) {
    const cached = this.cache.get(filePath);
    if (cached && cached.animationType !== void 0) {
      return cached.animationType;
    }
    const content = this.getContent(filePath);
    if (!content) return null;
    const animationType = this.detectAnimation(content);
    const entry = this.cache.get(filePath);
    if (entry) {
      entry.animationType = animationType;
    }
    return animationType;
  }
  /**
   * Cache a temp file path for a content hash
   */
  cacheTempPath(hash, tempPath) {
    this.tempPathCache.set(hash, tempPath);
  }
  /**
   * Get cached temp file path
   */
  getTempPath(hash) {
    return this.tempPathCache.get(hash);
  }
  /**
   * Check if temp path exists for hash
   */
  hasTempPath(hash) {
    const path44 = this.tempPathCache.get(hash);
    if (!path44) return false;
    try {
      return fs2.existsSync(path44);
    } catch {
      this.tempPathCache.delete(hash);
      return false;
    }
  }
  /**
   * Pre-cache content for a batch of files (for folder expansion)
   */
  preloadBatch(filePaths) {
    const batch = filePaths.slice(0, 50);
    for (const filePath of batch) {
      if (!this.cache.has(filePath)) {
        this.loadAndCache(filePath);
      }
    }
  }
  /**
   * Invalidate cache for a specific file
   */
  invalidate(filePath) {
    this.cache.delete(filePath);
  }
  /**
   * Clear entire cache
   */
  clear() {
    this.cache.clear();
    this.tempPathCache.clear();
  }
  /**
   * Clear only temp path cache (when temp dir is cleaned)
   */
  clearTempPaths() {
    this.tempPathCache.clear();
  }
  loadAndCache(filePath) {
    try {
      if (!fs2.existsSync(filePath)) {
        return void 0;
      }
      const stats = fs2.statSync(filePath);
      const content = fs2.readFileSync(filePath, "utf-8");
      const hash = this.computeHash(content);
      if (this.cache.size >= this.maxCacheSize * this.cleanupThreshold) {
        this.cleanup();
      }
      this.cache.set(filePath, {
        content,
        hash,
        lastModified: stats.mtimeMs
      });
      return content;
    } catch {
      return void 0;
    }
  }
  /**
   * Remove oldest entries when cache is getting full
   */
  cleanup() {
    const entriesToRemove = Math.floor(this.maxCacheSize * 0.2);
    const keys = Array.from(this.cache.keys());
    for (let i = 0; i < Math.min(entriesToRemove, keys.length); i++) {
      this.cache.delete(keys[i]);
    }
  }
  /**
   * Count unique colors in SVG
   */
  countColors(svg) {
    const colorRegex = /#(?:[0-9a-fA-F]{3,4}){1,2}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)/gi;
    const colors = /* @__PURE__ */ new Set();
    let match;
    while ((match = colorRegex.exec(svg)) !== null) {
      colors.add(match[0].toLowerCase());
    }
    return colors.size;
  }
  /**
   * Detect animation type in SVG
   */
  detectAnimation(svg) {
    const hasStyleAnimation = /<style[^>]*>[\s\S]*@keyframes[\s\S]*<\/style>/i.test(svg);
    const hasInlineAnimation = /animation\s*:/i.test(svg);
    const hasAnimate = /<animate\b/i.test(svg);
    const hasAnimateTransform = /<animateTransform\b/i.test(svg);
    const hasAnimateMotion = /<animateMotion\b/i.test(svg);
    const hasSet = /<set\b/i.test(svg);
    if (hasStyleAnimation || hasInlineAnimation) {
      if (/spin|rotate/i.test(svg)) return "spin (CSS)";
      if (/pulse|scale/i.test(svg)) return "pulse (CSS)";
      if (/fade|opacity/i.test(svg)) return "fade (CSS)";
      if (/bounce/i.test(svg)) return "bounce (CSS)";
      if (/shake/i.test(svg)) return "shake (CSS)";
      if (/draw|stroke-dash/i.test(svg)) return "draw (CSS)";
      return "CSS";
    }
    if (hasAnimateTransform) return "SMIL transform";
    if (hasAnimateMotion) return "SMIL motion";
    if (hasAnimate || hasSet) return "SMIL";
    return null;
  }
};

// src/providers/TempIconStudio.ts
var tempIconDir;
var tempIconPathCache = /* @__PURE__ */ new Map();
function getTempIconDir() {
  if (!tempIconDir) {
    tempIconDir = path2.join(os.tmpdir(), "icon-manager-previews");
    if (!fs3.existsSync(tempIconDir)) {
      fs3.mkdirSync(tempIconDir, { recursive: true });
    }
  }
  return tempIconDir;
}
function clearTempIcons() {
  const iconDir = getTempIconDir();
  try {
    const files = fs3.readdirSync(iconDir);
    for (const file of files) {
      try {
        fs3.unlinkSync(path2.join(iconDir, file));
      } catch {
      }
    }
  } catch {
  }
  tempIconPathCache.clear();
  SvgContentCache.getInstance().clearTempPaths();
}
function normalizeSvgForDisplay(svgContent) {
  let normalizedSvg = svgContent;
  if (!normalizedSvg.includes("xmlns=")) {
    normalizedSvg = normalizedSvg.replace("<svg", '<svg xmlns="http://www.w3.org/2000/svg"');
  }
  if (!normalizedSvg.includes("width=") && !normalizedSvg.includes("height=")) {
    normalizedSvg = normalizedSvg.replace("<svg", '<svg width="16" height="16"');
  }
  const hasGradient = /url\(#/.test(normalizedSvg);
  const colorPattern = /(?:fill|stroke)="([^"]+)"/gi;
  let match;
  let hasRealColors = hasGradient;
  while ((match = colorPattern.exec(normalizedSvg)) !== null) {
    const color = match[1].toLowerCase().trim();
    if (color === "none" || color === "currentcolor") continue;
    if (color === "#000" || color === "#000000" || color === "black" || color === "rgb(0,0,0)" || color === "rgb(0, 0, 0)")
      continue;
    hasRealColors = true;
    break;
  }
  if (!hasRealColors) {
    normalizedSvg = normalizedSvg.replace(/fill="(#000|#000000|black|rgb\(0,\s*0,\s*0\))"/gi, 'fill="currentColor"').replace(/stroke="(#000|#000000|black|rgb\(0,\s*0,\s*0\))"/gi, 'stroke="currentColor"');
    if (!normalizedSvg.includes('fill="')) {
      normalizedSvg = normalizedSvg.replace("<svg", '<svg fill="currentColor"');
    }
  }
  return normalizedSvg;
}
function saveTempSvgIcon(name, svgContent) {
  const contentHash = crypto2.createHash("md5").update(svgContent).digest("hex").substring(0, 8);
  const cacheKey = `${name}_${contentHash}`;
  const cachedPath = tempIconPathCache.get(cacheKey);
  if (cachedPath) {
    return cachedPath;
  }
  const svgCache = SvgContentCache.getInstance();
  const cachedTempPath = svgCache.getTempPath(contentHash);
  if (cachedTempPath && fs3.existsSync(cachedTempPath)) {
    tempIconPathCache.set(cacheKey, cachedTempPath);
    return cachedTempPath;
  }
  const iconDir = getTempIconDir();
  const safeName = name.replace(/[^a-z0-9-]/gi, "_");
  const iconPath = path2.join(iconDir, `${safeName}_${contentHash}.svg`);
  if (fs3.existsSync(iconPath)) {
    tempIconPathCache.set(cacheKey, iconPath);
    svgCache.cacheTempPath(contentHash, iconPath);
    return iconPath;
  }
  const normalizedSvg = normalizeSvgForDisplay(svgContent);
  fs3.writeFileSync(iconPath, normalizedSvg);
  tempIconPathCache.set(cacheKey, iconPath);
  svgCache.cacheTempPath(contentHash, iconPath);
  return iconPath;
}

// src/providers/SvgItem.ts
var vscode5 = __toESM(require("vscode"));
var path4 = __toESM(require("path"));
var fs5 = __toESM(require("fs"));
init_i18n();

// src/services/AnimationAssignmentService.ts
var vscode4 = __toESM(require("vscode"));
var fs4 = __toESM(require("node:fs"));
var path3 = __toESM(require("node:path"));
init_config();
var AnimationAssignmentService = class {
  _animationsCache = null;
  /**
   * Reset the cache
   */
  resetCache() {
    this._animationsCache = null;
  }
  /**
   * Safely parse a JS object literal string into an object
   * Converts JS syntax to JSON (single quotes to double, unquoted keys to quoted)
   */
  _parseJsObjectLiteral(jsObjectStr) {
    try {
      const jsonStr = jsObjectStr.replace(/'/g, '"').replace(/(\w+)\s*:/g, '"$1":').replace(/,\s*}/g, "}").replace(/,\s*]/g, "]");
      return JSON.parse(jsonStr);
    } catch {
      return {};
    }
  }
  /**
   * Get the path to the animations.js file
   */
  _getAnimationsFilePath() {
    const outputDir = getSvgConfig("outputDirectory", "bezier-icons");
    const workspaceFolders = vscode4.workspace.workspaceFolders;
    if (!workspaceFolders || !outputDir) return void 0;
    return path3.join(workspaceFolders[0].uri.fsPath, outputDir, "animations.js");
  }
  /**
   * Read all animations from file (or cache)
   */
  _readAnimationsFromFile() {
    if (this._animationsCache !== null) {
      return { ...this._animationsCache };
    }
    try {
      const filePath = this._getAnimationsFilePath();
      if (!filePath) {
        this._animationsCache = {};
        return {};
      }
      if (!fs4.existsSync(filePath)) {
        this._animationsCache = {};
        return {};
      }
      const content = fs4.readFileSync(filePath, "utf-8");
      const regex = /export\s+const\s+animations\s*=\s*(\{[\s\S]*\});?\s*$/;
      const match = regex.exec(content);
      if (match) {
        const parsed = this._parseJsObjectLiteral(match[1]);
        this._animationsCache = parsed || {};
        return { ...this._animationsCache };
      }
      this._animationsCache = {};
      return {};
    } catch {
      this._animationsCache = {};
      return {};
    }
  }
  /**
   * Write animations to file
   */
  _writeAnimationsToFile(animations) {
    try {
      const filePath = this._getAnimationsFilePath();
      if (!filePath) return false;
      const dir = path3.dirname(filePath);
      if (!fs4.existsSync(dir)) {
        fs4.mkdirSync(dir, { recursive: true });
      }
      const content = this._generateAnimationsContent(animations);
      fs4.writeFileSync(filePath, content, "utf-8");
      this._animationsCache = { ...animations };
      return true;
    } catch {
      return false;
    }
  }
  /**
   * Generate the animations.js file content
   */
  _generateAnimationsContent(animations) {
    const lines = [
      "/**",
      " * Icon Animation Assignments",
      " * Auto-generated by Icon Studio",
      " * ",
      " * This file defines which animation is assigned to each icon.",
      " * Format: { iconName: { type, duration?, timing?, iteration?, delay?, direction? } }",
      " */",
      "",
      "export const animations = {"
    ];
    const iconNames = Object.keys(animations).sort((a, b) => a.localeCompare(b));
    const iconEntries = iconNames.map((iconName, i) => {
      const anim = animations[iconName];
      const comma = i < iconNames.length - 1 ? "," : "";
      const props = [`type: '${anim.type}'`];
      if (anim.duration !== void 0) props.push(`duration: ${anim.duration}`);
      if (anim.timing) props.push(`timing: '${anim.timing}'`);
      if (anim.iteration) props.push(`iteration: '${anim.iteration}'`);
      if (anim.delay !== void 0) props.push(`delay: ${anim.delay}`);
      if (anim.direction) props.push(`direction: '${anim.direction}'`);
      return `  '${iconName}': { ${props.join(", ")} }${comma}`;
    });
    return [...lines, ...iconEntries, "};", ""].join("\n");
  }
  /**
   * Get animation for a specific icon
   */
  getAnimation(iconName) {
    const animations = this._readAnimationsFromFile();
    return animations[iconName];
  }
  /**
   * Get all animations
   */
  getAllAnimations() {
    return this._readAnimationsFromFile();
  }
  /**
   * Set animation for an icon
   */
  setAnimation(iconName, animation) {
    const animations = this._readAnimationsFromFile();
    if (animation.type === "none" || !animation.type) {
      delete animations[iconName];
    } else {
      animations[iconName] = animation;
    }
    return this._writeAnimationsToFile(animations);
  }
  /**
   * Remove animation from an icon
   */
  removeAnimation(iconName) {
    const animations = this._readAnimationsFromFile();
    if (animations[iconName]) {
      delete animations[iconName];
      return this._writeAnimationsToFile(animations);
    }
    return true;
  }
  /**
   * Check if an icon has an animation assigned
   */
  hasAnimation(iconName) {
    const animations = this._readAnimationsFromFile();
    return iconName in animations && animations[iconName].type !== "none";
  }
};
var animationServiceInstance = null;
function getAnimationService() {
  animationServiceInstance ??= new AnimationAssignmentService();
  return animationServiceInstance;
}

// src/providers/SvgItem.ts
var SvgItem = class _SvgItem extends vscode5.TreeItem {
  constructor(label, count, collapsibleState, type, icon, category, usage) {
    super(label, collapsibleState);
    this.label = label;
    this.count = count;
    this.collapsibleState = collapsibleState;
    this.type = type;
    this.icon = icon;
    this.category = category;
    this.usage = usage;
    const instanceId = _SvgItem.instanceCounter++;
    if (type === "section" && category) {
      this.id = `${instanceId}/section:${category}`;
    } else if (type === "category" && category) {
      this.id = `${instanceId}/category:${category}`;
    } else if (type === "icon" && icon) {
      this.id = `${instanceId}/icon:${icon.name}:${icon.source || "unknown"}:${icon.path || ""}`;
      if (icon.line !== void 0) {
        this.id += `:L${icon.line}`;
      }
    } else if (type === "usage" && usage) {
      this.id = `${instanceId}/usage:${usage.file}:${usage.line}`;
    } else if (type === "action") {
      this.id = `${instanceId}/action:scan`;
    }
    if (type === "section") {
      this.description = `${count}`;
      this.contextValue = "svgSection";
      if (category === "built") {
        this.iconPath = new vscode5.ThemeIcon("package");
      } else if (category === "files") {
        this.iconPath = new vscode5.ThemeIcon("folder-library");
      } else if (category === "inline") {
        this.iconPath = new vscode5.ThemeIcon("code");
      } else if (category === "references") {
        this.iconPath = new vscode5.ThemeIcon("references");
      } else if (category === "icon_usages_section") {
        this.iconPath = new vscode5.ThemeIcon("references");
      }
    } else if (type === "category") {
      this.description = `${count}`;
      if (category?.startsWith("built:")) {
        this.iconPath = new vscode5.ThemeIcon("file-code");
      } else if (category?.startsWith("folder:")) {
        this.iconPath = new vscode5.ThemeIcon("folder");
      } else if (category?.startsWith("inlinedir:") || category?.startsWith("refsdir:")) {
        this.iconPath = new vscode5.ThemeIcon("folder");
      } else if (category?.startsWith("inline:")) {
        this.iconPath = new vscode5.ThemeIcon("file-code");
      } else if (category?.startsWith("refs:")) {
        this.iconPath = new vscode5.ThemeIcon("file-media");
      } else if (category?.startsWith("\u{1F4E6} ")) {
        this.iconPath = new vscode5.ThemeIcon("package");
      } else if (category?.startsWith("\u{1F4C4} ")) {
        this.iconPath = new vscode5.ThemeIcon("file-code");
      } else {
        this.iconPath = new vscode5.ThemeIcon("folder");
      }
      this.contextValue = "svgCategory";
    } else if (type === "action") {
      this.iconPath = new vscode5.ThemeIcon("refresh");
      this.contextValue = "svgAction";
      this.command = {
        command: "sageboxIconStudio.scanWorkspace",
        title: t("commands.scanWorkspace")
      };
    } else if (type === "usage" && usage) {
      this.iconPath = new vscode5.ThemeIcon("go-to-file");
      this.contextValue = "iconUsage";
      this.tooltip = usage.preview;
      this.command = {
        command: "sageboxIconStudio.goToUsage",
        title: t("commands.goToUsage"),
        arguments: [usage.file, usage.line]
      };
    } else if (icon) {
      this.setupIconItem(icon);
    }
  }
  static instanceCounter = 0;
  static svgCache = SvgContentCache.getInstance();
  /**
   * Setup icon-specific item properties
   */
  setupIconItem(icon) {
    const isMissingRef = icon.category === "img-ref" && icon.exists === false;
    let svgContent = icon.svg;
    if (!svgContent && icon.path) {
      svgContent = _SvgItem.svgCache.getContent(icon.path);
    }
    const isRasterized = icon.path ? _SvgItem.svgCache.isRasterized(icon.path) : this.isRasterizedSvg(svgContent);
    let animationType = null;
    if (icon.isBuilt) {
      const animService = getAnimationService();
      const assigned = animService.getAnimation(icon.name);
      if (assigned?.type && assigned.type !== "none") {
        animationType = assigned.type;
      }
      if (!animationType && icon.animation?.type && icon.animation.type !== "none") {
        animationType = icon.animation.type;
      }
    } else {
      animationType = icon.animation?.type || (icon.path ? _SvgItem.svgCache.getAnimationType(icon.path) : this.detectAnimationType(icon));
    }
    if (isMissingRef) {
      this.description = "\u26A0 File not found";
    } else if (isRasterized) {
      this.description = "\u26A0 Rasterized (not buildable)";
    } else if (icon.isBuilt) {
      const parts = [];
      if (animationType) {
        parts.push(`\u26A1 ${animationType}`);
      }
      if (icon.usageCount !== void 0) {
        if (icon.usageCount === 0) {
          parts.push("\u26A0 unused");
        } else {
          parts.push(`${icon.usageCount} use${icon.usageCount > 1 ? "s" : ""}`);
        }
      }
      this.description = parts.join(" \xB7 ");
    } else if (icon.line !== void 0) {
      this.description = `L${icon.line + 1}`;
    }
    this.contextValue = this.determineContextValue(icon, isMissingRef, isRasterized);
    const tooltipLines = [icon.name];
    if (isRasterized) {
      tooltipLines.push("\u26A0 Rasterized SVG - Too many colors");
      tooltipLines.push("   Not suitable for icon library");
    }
    if (icon.source === "workspace" && icon.path) {
      this.resourceUri = vscode5.Uri.file(icon.path);
    }
    if (isMissingRef) {
      tooltipLines.push("\u274C SVG file not found");
      tooltipLines.push(`Expected path: ${icon.path}`);
      if (icon.filePath) {
        tooltipLines.push(`Referenced in: ${path4.basename(icon.filePath)}:${(icon.line || 0) + 1}`);
      }
    } else if (icon.isBuilt) {
      tooltipLines.push("\u2713 Built");
      if (animationType) {
        tooltipLines.push(`\u26A1 Animation: ${animationType}`);
        if (icon.animation) {
          tooltipLines.push(`   Duration: ${icon.animation.duration}s`);
          tooltipLines.push(`   Timing: ${icon.animation.timing}`);
          tooltipLines.push(`   Iteration: ${icon.animation.iteration}`);
        }
      }
    }
    if (icon.usages && icon.usages.length > 0) {
      tooltipLines.push("");
      tooltipLines.push(`\u{1F4CD} ${icon.usages.length} usage${icon.usages.length > 1 ? "s" : ""}:`);
      for (const usage of icon.usages.slice(0, 5)) {
        const shortFile = usage.file.split(/[\\/]/).slice(-2).join("/");
        tooltipLines.push(`  \u2022 ${shortFile}:${usage.line}`);
      }
      if (icon.usages.length > 5) {
        tooltipLines.push(`  + ${icon.usages.length - 5} more...`);
      }
    }
    this.setupTooltipAndCommand(icon, tooltipLines, isMissingRef);
    this.setupIconPath(icon, svgContent, isMissingRef);
  }
  /**
   * Determine the contextValue based on icon properties
   */
  determineContextValue(icon, isMissingRef, isRasterized) {
    if (isMissingRef) {
      return "missingRef";
    } else if (isRasterized) {
      if (icon.source === "workspace") {
        return icon.isBuilt ? "svgIconRasterizedBuilt" : "svgIconRasterized";
      } else if (icon.category === "img-ref") {
        return "imgRefRasterized";
      } else if (icon.source === "inline") {
        return icon.isBuilt ? "inlineSvgRasterizedBuilt" : "inlineSvgRasterized";
      } else {
        return "builtIconRasterized";
      }
    } else if (icon.category === "img-ref") {
      return "imgRef";
    } else if (icon.source === "inline") {
      return icon.isBuilt ? "inlineSvgBuilt" : "inlineSvg";
    } else if (icon.isBuilt) {
      return icon.source === "workspace" ? "svgIconBuilt" : "builtIcon";
    } else {
      return "svgIcon";
    }
  }
  /**
   * Setup tooltip and click command
   */
  setupTooltipAndCommand(icon, tooltipLines, isMissingRef) {
    if (isMissingRef) {
      this.tooltip = tooltipLines.join("\n");
      if (icon.filePath && icon.line !== void 0) {
        this.command = {
          command: "sageboxIconStudio.goToInlineSvg",
          title: t("commands.goToReference"),
          arguments: [icon]
        };
      }
    } else if (icon.source === "library") {
      this.tooltip = tooltipLines.join("\n");
      this.command = {
        command: "sageboxIconStudio.showDetails",
        title: t("commands.showDetails"),
        arguments: [icon]
      };
    } else if (icon.source === "inline" && icon.filePath && icon.line !== void 0) {
      const fileName = path4.basename(icon.filePath);
      this.tooltip = `${icon.name}
${fileName}:${icon.line + 1}`;
      this.command = {
        command: "sageboxIconStudio.goToInlineSvg",
        title: t("commands.goToSvg"),
        arguments: [icon]
      };
    } else {
      this.tooltip = `${icon.name}
${icon.path}`;
      this.command = {
        command: "sageboxIconStudio.showDetails",
        title: t("commands.showDetails"),
        arguments: [icon]
      };
    }
  }
  /**
   * Setup the icon path for display in tree view
   */
  setupIconPath(icon, svgContent, isMissingRef) {
    if (isMissingRef) {
      this.iconPath = new vscode5.ThemeIcon("error", new vscode5.ThemeColor("errorForeground"));
      return;
    }
    if (!svgContent && icon.path) {
      try {
        if (fs5.existsSync(icon.path)) {
          svgContent = fs5.readFileSync(icon.path, "utf-8");
        }
      } catch (err) {
        console.error("[Icon Studio] Error reading SVG file:", icon.path, err);
      }
    }
    if (svgContent) {
      try {
        const tempPath = saveTempSvgIcon(icon.name, svgContent);
        this.iconPath = vscode5.Uri.file(tempPath);
      } catch (err) {
        console.error("[Icon Studio] Error saving temp SVG:", icon.name, err);
        this.iconPath = icon.isBuilt ? new vscode5.ThemeIcon("pass", new vscode5.ThemeColor("charts.green")) : new vscode5.ThemeIcon("circle-outline");
      }
    } else {
      this.iconPath = new vscode5.ThemeIcon("symbol-misc");
    }
  }
  /**
   * Detect animation type from icon data or SVG content
   * Returns a human-readable animation type string
   */
  detectAnimationType(icon) {
    if (icon.animation?.type) {
      return icon.animation.type;
    }
    const svg = icon.svg;
    if (!svg) return null;
    const hasStyleAnimation = /<style[^>]*>[\s\S]*@keyframes[\s\S]*<\/style>/i.test(svg);
    const hasInlineAnimation = /animation\s*:/i.test(svg);
    const hasAnimate = /<animate\b/i.test(svg);
    const hasAnimateTransform = /<animateTransform\b/i.test(svg);
    const hasAnimateMotion = /<animateMotion\b/i.test(svg);
    const hasSet = /<set\b/i.test(svg);
    if (hasStyleAnimation || hasInlineAnimation) {
      const styleMatch = svg.match(/<style[^>]*>([\s\S]*?)<\/style>/i);
      const styleContent = styleMatch ? styleMatch[1] : "";
      const animationNameMatch = svg.match(/animation(?:-name)?\s*:\s*([^;}\s]+)/i);
      const animationName = animationNameMatch ? animationNameMatch[1] : "";
      const searchContext = styleContent + " " + animationName;
      if (/spin|rotate/i.test(searchContext)) return "spin (CSS)";
      if (/pulse|scale/i.test(searchContext)) return "pulse (CSS)";
      if (/fade/i.test(searchContext)) return "fade (CSS)";
      if (/bounce/i.test(searchContext)) return "bounce (CSS)";
      if (/shake/i.test(searchContext)) return "shake (CSS)";
      if (/draw|stroke-dash/i.test(searchContext)) return "draw (CSS)";
      if (/@keyframes[\s\S]*opacity/i.test(styleContent)) return "fade (CSS)";
      return "CSS";
    }
    if (hasAnimateTransform) {
      return "SMIL transform";
    }
    if (hasAnimateMotion) {
      return "SMIL motion";
    }
    if (hasAnimate || hasSet) {
      return "SMIL";
    }
    return null;
  }
  /**
   * Count unique colors in SVG content to detect rasterized images
   */
  countSvgColors(svg) {
    const colorRegex = /#(?:[0-9a-fA-F]{3,4}){1,2}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)/gi;
    const colors = /* @__PURE__ */ new Set();
    let match;
    while ((match = colorRegex.exec(svg)) !== null) {
      colors.add(match[0].toLowerCase());
    }
    return colors.size;
  }
  /**
   * Check if SVG is a rasterized image (too many colors for icon editing)
   */
  isRasterizedSvg(svg) {
    if (!svg) return false;
    const MAX_COLORS_FOR_ICONS = 50;
    return this.countSvgColors(svg) > MAX_COLORS_FOR_ICONS;
  }
};

// src/providers/BuiltIconsProvider.ts
var vscode6 = __toESM(require("vscode"));
var path5 = __toESM(require("path"));
var fs6 = __toESM(require("fs"));
init_config();
init_i18n();
var BuiltIconsProvider = class {
  constructor(workspaceProvider) {
    this.workspaceProvider = workspaceProvider;
  }
  _onDidChangeTreeData = new vscode6.EventEmitter();
  onDidChangeTreeData = this._onDidChangeTreeData.event;
  itemCache = /* @__PURE__ */ new Map();
  builtIcons = /* @__PURE__ */ new Map();
  spriteIcons = /* @__PURE__ */ new Set();
  jsIcons = /* @__PURE__ */ new Set();
  isInitialized = false;
  isScanning = false;
  refresh() {
    this.builtIcons.clear();
    this.spriteIcons.clear();
    this.jsIcons.clear();
    this.itemCache.clear();
    this.isInitialized = false;
    this._onDidChangeTreeData.fire();
  }
  /**
   * Soft refresh - re-renders tree without clearing cache
   * This preserves expansion state better than full refresh
   * Use for updates that don't change the icon list significantly
   */
  softRefresh() {
    this._onDidChangeTreeData.fire();
  }
  /**
   * Refresh a specific file container (icons.js or sprite.svg) without collapsing other containers
   */
  refreshContainer(fileName) {
    const containerKey = `built:${fileName}`;
    const cachedContainer = this.itemCache.get(containerKey);
    if (cachedContainer) {
      this._onDidChangeTreeData.fire(cachedContainer);
    } else {
      this.softRefresh();
    }
  }
  /**
   * Refresh only a specific file category - invalidates cache to reload from disk
   * Note: This will collapse the tree. Use refreshContainer for partial updates.
   */
  refreshFile(_fileName) {
    this.builtIcons.clear();
    this.spriteIcons.clear();
    this.jsIcons.clear();
    this.isInitialized = false;
    this._onDidChangeTreeData.fire();
  }
  /**
   * Refresh a specific item by icon name without collapsing tree branches
   */
  refreshItemByName(iconName) {
    const icon = this.builtIcons.get(iconName);
    if (icon) {
      const item = new SvgItem(icon.name, 0, vscode6.TreeItemCollapsibleState.None, "icon", icon);
      this._onDidChangeTreeData.fire(item);
    } else {
      this._onDidChangeTreeData.fire();
    }
  }
  /**
   * Add a new icon to the cache and refresh the icons.js container only
   * This preserves tree expansion state when adding new icons
   */
  addIconAndRefresh(iconName, svg, iconsFilePath, animation) {
    const newIcon = {
      name: iconName,
      path: iconsFilePath,
      source: "library",
      svg,
      isBuilt: true,
      animation
    };
    this.builtIcons.set(iconName, newIcon);
    this.jsIcons.add(iconName);
    this.itemCache.delete(`built:icons.js:${iconName}`);
    const containerItem = this.itemCache.get("built:icons.js");
    if (containerItem) {
      const jsIconCount = Array.from(this.builtIcons.values()).filter(
        (icon) => icon.path.endsWith("icons.js") || icon.path.endsWith("icons.ts")
      ).length;
      containerItem.description = `(${jsIconCount})`;
      this._onDidChangeTreeData.fire(containerItem);
    } else {
      this._onDidChangeTreeData.fire();
    }
  }
  /**
   * Remove an icon from the cache and refresh the icons.js container only
   * This preserves tree expansion state when removing icons
   */
  removeIconAndRefresh(iconName) {
    this.builtIcons.delete(iconName);
    this.jsIcons.delete(iconName);
    const containerItem = this.itemCache.get("built:icons.js");
    if (containerItem) {
      const jsIconCount = Array.from(this.builtIcons.values()).filter(
        (icon) => icon.path.endsWith("icons.js") || icon.path.endsWith("icons.ts")
      ).length;
      containerItem.description = jsIconCount > 0 ? `(${jsIconCount})` : "";
      this._onDidChangeTreeData.fire(containerItem);
    } else {
      this._onDidChangeTreeData.fire();
    }
  }
  /**
   * Get built icons list
   */
  getBuiltIconsList() {
    return Array.from(this.builtIcons.values());
  }
  /**
   * Check if an icon name is in the sprite.svg
   */
  isInSprite(iconName) {
    return this.spriteIcons.has(iconName);
  }
  /**
   * Check if an icon name is in icons.js (built)
   */
  isInBuilt(iconName) {
    return this.jsIcons.has(iconName);
  }
  /**
   * Get the build status label for an icon
   */
  getBuildStatusLabel(iconName) {
    if (this.jsIcons.has(iconName)) {
      return "(built)";
    } else if (this.spriteIcons.has(iconName)) {
      return "(sprite)";
    }
    return "";
  }
  /**
   * Check if an icon is built
   */
  isIconBuilt(iconName) {
    return this.jsIcons.has(iconName) || this.spriteIcons.has(iconName);
  }
  /**
   * Ensure the provider is initialized before accessing data
   */
  async ensureReady() {
    await this.ensureInitialized();
  }
  async ensureInitialized() {
    if (!this.isInitialized && !this.isScanning) {
      this.isScanning = true;
      await this.loadBuiltIcons();
      this.isInitialized = true;
      this.isScanning = false;
    }
  }
  async loadBuiltIcons() {
    this.builtIcons.clear();
    const outputDir = getSvgConfig("outputDirectory", "bezier-svg");
    const workspaceFolders = vscode6.workspace.workspaceFolders;
    if (!workspaceFolders) return;
    const workspaceRoot = workspaceFolders[0].uri.fsPath;
    const fullOutputPath = path5.join(workspaceRoot, outputDir);
    for (const name of ["icons.js", "icons.ts", "icons.js"]) {
      const iconsFile = path5.join(fullOutputPath, name);
      if (fs6.existsSync(iconsFile)) {
        await this.parseIconsFile(iconsFile);
        break;
      }
    }
    const spriteSvg = path5.join(fullOutputPath, "sprite.svg");
    if (fs6.existsSync(spriteSvg)) {
      await this.parseSpriteFile(spriteSvg);
    }
  }
  async parseSpriteFile(filePath) {
    try {
      const content = fs6.readFileSync(filePath, "utf-8");
      const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*viewBox=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
      let match;
      while ((match = symbolRegex.exec(content)) !== null) {
        const iconName = match[1];
        const viewBox = match[2];
        const body = match[3];
        if (this.builtIcons.has(iconName)) {
          continue;
        }
        const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">${body}</svg>`;
        this.builtIcons.set(iconName, {
          name: iconName,
          path: filePath,
          source: "library",
          svg: svgContent,
          isBuilt: true
        });
        this.spriteIcons.add(iconName);
      }
    } catch (error) {
      console.error("[Icon Studio] BuiltIconsProvider: Error parsing sprite file:", error);
    }
  }
  async parseIconsFile(filePath) {
    try {
      const content = fs6.readFileSync(filePath, "utf-8");
      const iconPattern = /export\s+const\s+(\w+)\s*=\s*\{\s*name:\s*['"]([^'"]+)['"]\s*,\s*body:\s*`([^`]*)`\s*,\s*viewBox:\s*['"]([^'"]+)['"](?:\s*,\s*animation:\s*\{([^}]*)\})?\s*\}/g;
      let match;
      while ((match = iconPattern.exec(content)) !== null) {
        const _varName = match[1];
        const iconName = match[2];
        const body = match[3];
        const viewBox = match[4];
        const animationStr = match[5];
        const svgContent = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">${body}</svg>`;
        let animation;
        if (animationStr) {
          try {
            const typeMatch = animationStr.match(/type:\s*['"]([^'"]+)['"]/);
            const durationMatch = animationStr.match(/duration:\s*([\d.]+)/);
            const timingMatch = animationStr.match(/timing:\s*['"]([^'"]+)['"]/);
            const iterationMatch = animationStr.match(/iteration:\s*['"]([^'"]+)['"]/);
            const delayMatch = animationStr.match(/delay:\s*([\d.]+)/);
            const directionMatch = animationStr.match(/direction:\s*['"]([^'"]+)['"]/);
            if (typeMatch) {
              animation = {
                type: typeMatch[1],
                duration: durationMatch ? parseFloat(durationMatch[1]) : 1,
                timing: timingMatch ? timingMatch[1] : "ease",
                iteration: iterationMatch ? iterationMatch[1] : "infinite",
                delay: delayMatch ? parseFloat(delayMatch[1]) : void 0,
                direction: directionMatch ? directionMatch[1] : void 0
              };
            }
          } catch (_e) {
          }
        }
        this.builtIcons.set(iconName, {
          name: iconName,
          path: filePath,
          source: "library",
          svg: svgContent,
          isBuilt: true,
          animation
        });
        this.jsIcons.add(iconName);
      }
    } catch (error) {
      console.error("[Icon Studio] BuiltIconsProvider: Error parsing icons file:", error);
    }
  }
  getTreeItem(element) {
    if (element.category?.startsWith("built:")) {
      this.itemCache.set(element.category, element);
    }
    return element;
  }
  async getChildren(element) {
    if (!isFullyConfigured()) {
      if (!element) {
        const setupItem = new SvgItem(
          t("treeView.configureFirst"),
          0,
          vscode6.TreeItemCollapsibleState.None,
          "action",
          void 0,
          "configure"
        );
        setupItem.command = {
          command: "sageboxIconStudio.showWelcome",
          title: t("commands.openSetup")
        };
        setupItem.iconPath = new vscode6.ThemeIcon("gear");
        return [setupItem];
      }
      return [];
    }
    await this.ensureInitialized();
    if (element) {
      if (element.category?.startsWith("built:")) {
        const fileName = element.category.replace("built:", "");
        return this.getIconsForFile(fileName);
      }
      return [];
    }
    if (this.builtIcons.size === 0) {
      const config = vscode6.workspace.getConfiguration("sageboxIconStudio");
      const outputDir = config.get("outputDirectory", "");
      if (!outputDir) {
        const setupItem = new SvgItem(
          t("treeView.configureFirst"),
          0,
          vscode6.TreeItemCollapsibleState.None,
          "action",
          void 0,
          void 0
        );
        setupItem.command = {
          command: "sageboxIconStudio.openWelcome",
          title: t("commands.openSetup")
        };
        setupItem.tooltip = t("messages.clickToConfigureOutput");
        return [setupItem];
      }
      return [
        new SvgItem(
          t("treeView.noBuiltIcons"),
          0,
          vscode6.TreeItemCollapsibleState.None,
          "action",
          void 0,
          void 0
        )
      ];
    }
    const byFile = /* @__PURE__ */ new Map();
    for (const [_name, icon] of this.builtIcons) {
      const fileName = path5.basename(icon.path);
      if (!byFile.has(fileName)) {
        byFile.set(fileName, []);
      }
      byFile.get(fileName).push(icon);
    }
    const items = [];
    for (const [fileName, icons] of byFile) {
      const item = new SvgItem(
        fileName,
        icons.length,
        vscode6.TreeItemCollapsibleState.Collapsed,
        "category",
        void 0,
        `built:${fileName}`
      );
      if (fileName === "sprite.svg") {
        item.contextValue = "builtSpriteFile";
      } else if (fileName === "icons.js" || fileName === "icons.ts" || fileName === "icons.js") {
        item.contextValue = "builtIconsFile";
      } else {
        item.contextValue = "builtFile";
      }
      items.push(item);
    }
    return items;
  }
  getIconsForFile(fileName) {
    const items = [];
    for (const [_name, icon] of this.builtIcons) {
      if (path5.basename(icon.path) === fileName) {
        items.push(
          new SvgItem(
            icon.name,
            0,
            vscode6.TreeItemCollapsibleState.None,
            "icon",
            icon,
            `built:${fileName}`
          )
        );
      }
    }
    return items.sort((a, b) => a.label.toString().localeCompare(b.label.toString()));
  }
};

// src/providers/SvgFilesProvider.ts
var vscode7 = __toESM(require("vscode"));
var path6 = __toESM(require("path"));
var fs7 = __toESM(require("fs"));
init_config();
var SvgFilesProvider = class {
  constructor(workspaceProvider) {
    this.workspaceProvider = workspaceProvider;
  }
  _onDidChangeTreeData = new vscode7.EventEmitter();
  onDidChangeTreeData = this._onDidChangeTreeData.event;
  folderCache = /* @__PURE__ */ new Map();
  svgFiles = /* @__PURE__ */ new Map();
  isInitialized = false;
  isScanning = false;
  builtIconsProvider = null;
  scanPromise = null;
  /**
   * Set the BuiltIconsProvider reference (to avoid circular dependency in constructor)
   */
  setBuiltIconsProvider(provider) {
    this.builtIconsProvider = provider;
  }
  refresh() {
    this.svgFiles.clear();
    this.folderCache.clear();
    this.isInitialized = false;
    this.scanPromise = null;
    this._onDidChangeTreeData.fire();
  }
  /**
   * Soft refresh - re-renders tree without clearing cache
   * This preserves expansion state better than full refresh
   * Use for updates that don't change the file list (e.g., build status updates)
   */
  softRefresh() {
    this._onDidChangeTreeData.fire();
  }
  /**
   * Refresh a specific folder without collapsing other folders
   */
  refreshFolder(folderPath) {
    const folderKey = `folder:${folderPath}`;
    const cachedFolder = this.folderCache.get(folderKey);
    if (cachedFolder) {
      this._onDidChangeTreeData.fire(cachedFolder);
    } else {
      this.softRefresh();
    }
  }
  /**
   * Refresh view after a file was modified or build status changed
   * Note: Does NOT clear svgFiles cache as files haven't changed,
   * but triggers re-render to update build status labels
   */
  refreshFile(_iconPath) {
    this.softRefresh();
  }
  /**
   * Remove a single item from the tree
   */
  removeItem(iconPath) {
    const iconName = path6.basename(iconPath, ".svg");
    this.svgFiles.delete(iconName);
    this._onDidChangeTreeData.fire();
  }
  /**
   * Refresh a specific item by icon name without collapsing tree branches
   * This triggers a partial refresh that preserves expanded state
   */
  refreshItemByName(iconName) {
    const icon = this.svgFiles.get(iconName);
    if (icon) {
      const item = new SvgItem(icon.name, 0, vscode7.TreeItemCollapsibleState.None, "icon", icon);
      this._onDidChangeTreeData.fire(item);
    }
  }
  /**
   * Get the SVG files map (for other components)
   */
  getSvgFilesMap() {
    return this.svgFiles;
  }
  /**
   * Ensure the provider is initialized before accessing data
   */
  async ensureReady() {
    await this.ensureInitialized();
  }
  async ensureInitialized() {
    if (this.scanPromise) {
      await this.scanPromise;
      return;
    }
    if (!this.isInitialized && !this.isScanning) {
      this.isScanning = true;
      if (this.builtIconsProvider) {
        await this.builtIconsProvider.ensureReady();
      }
      this.scanPromise = this.scanSvgFiles();
      await this.scanPromise;
      this.scanPromise = null;
      this.isInitialized = true;
      this.isScanning = false;
    }
  }
  async scanSvgFiles() {
    this.svgFiles.clear();
    const workspaceFolders = vscode7.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return;
    }
    for (const folder of workspaceFolders) {
      await this.scanFolder(folder.uri.fsPath);
    }
  }
  async scanFolder(folderPath) {
    const svgFolders = getSvgConfig("svgFolders", []);
    let foundAny = false;
    for (const svgFolder of svgFolders) {
      const fullPath = path6.join(folderPath, svgFolder);
      if (fs7.existsSync(fullPath)) {
        await this.scanDirectory(fullPath, svgFolder);
        foundAny = true;
      }
    }
    if (!foundAny) {
      await this.scanAllSvgs(folderPath);
    }
  }
  async scanDirectory(dirPath, category) {
    if (!fs7.existsSync(dirPath) || shouldIgnorePath(dirPath)) return;
    try {
      const entries = fs7.readdirSync(dirPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path6.join(dirPath, entry.name);
        if (entry.isDirectory()) {
          await this.scanDirectory(fullPath, `${category}/${entry.name}`);
        } else if (entry.isFile() && entry.name.endsWith(".svg")) {
          if (shouldIgnorePath(fullPath)) continue;
          const iconName = path6.basename(entry.name, ".svg");
          this.svgFiles.set(iconName, {
            name: iconName,
            path: fullPath,
            source: "workspace",
            category,
            svg: void 0
          });
        }
      }
    } catch (error) {
      console.error(`[Icon Studio] SvgFilesProvider: Error scanning ${dirPath}:`, error);
    }
  }
  async scanAllSvgs(folderPath, relativePath = "") {
    if (!fs7.existsSync(folderPath) || shouldIgnorePath(folderPath)) return;
    const skipDirs = [
      "node_modules",
      ".git",
      "dist",
      "build",
      ".next",
      ".nuxt",
      "coverage",
      ".svelte-kit"
    ];
    try {
      const entries = fs7.readdirSync(folderPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path6.join(folderPath, entry.name);
        const relPath = relativePath ? `${relativePath}/${entry.name}` : entry.name;
        if (entry.isDirectory()) {
          if (!skipDirs.includes(entry.name)) {
            await this.scanAllSvgs(fullPath, relPath);
          }
        } else if (entry.isFile() && entry.name.endsWith(".svg")) {
          if (shouldIgnorePath(fullPath)) continue;
          const iconName = path6.basename(entry.name, ".svg");
          const category = path6.dirname(relPath) || "root";
          this.svgFiles.set(iconName, {
            name: iconName,
            path: fullPath,
            source: "workspace",
            category: category === "." ? "root" : category,
            svg: void 0
          });
        }
      }
    } catch (error) {
      console.error(`[Icon Studio] SvgFilesProvider: Error scanning ${folderPath}:`, error);
    }
  }
  getTreeItem(element) {
    if (element.category?.startsWith("folder:")) {
      this.folderCache.set(element.category, element);
    }
    return element;
  }
  getParent(element) {
    if (element.type === "icon" && element.icon) {
      const workspaceRoot = vscode7.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
      const relativePath = path6.relative(workspaceRoot, element.icon.path);
      const parts = relativePath.split(path6.sep);
      if (parts.length > 1) {
        const parentPath = path6.dirname(element.icon.path);
        const folderName = path6.basename(parentPath);
        return new SvgItem(
          folderName,
          0,
          vscode7.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${parentPath}`
        );
      }
    }
    return void 0;
  }
  async getChildren(element) {
    if (!isFullyConfigured()) {
      if (!element) {
        const configureItem = new SvgItem(
          "Configurar Icon Studio",
          0,
          vscode7.TreeItemCollapsibleState.None,
          "action",
          void 0,
          "configure"
        );
        configureItem.command = {
          command: "sageboxIconStudio.showWelcome",
          title: "Configurar Icon Studio"
        };
        configureItem.iconPath = new vscode7.ThemeIcon("gear");
        return [configureItem];
      }
      return [];
    }
    await this.ensureInitialized();
    if (element) {
      if (element.category?.startsWith("folder:")) {
        const folderPath = element.category.replace("folder:", "");
        return this.getFolderChildren(folderPath);
      }
      return [];
    }
    if (this.svgFiles.size === 0) {
      return [
        new SvgItem(
          "No SVG files found",
          0,
          vscode7.TreeItemCollapsibleState.None,
          "action",
          void 0,
          void 0
        )
      ];
    }
    return this.buildFolderHierarchy();
  }
  buildFolderHierarchy() {
    const workspaceRoot = vscode7.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
    const items = [];
    const topLevelFolders = /* @__PURE__ */ new Map();
    const rootFiles = [];
    for (const [_iconName, icon] of this.svgFiles) {
      const filePath = icon.path;
      const relativePath = path6.relative(workspaceRoot, filePath).replace(/\\/g, "/");
      const parts = relativePath.split("/");
      if (parts.length === 1) {
        rootFiles.push(icon);
      } else {
        const topFolder = parts[0];
        topLevelFolders.set(topFolder, (topLevelFolders.get(topFolder) || 0) + 1);
      }
    }
    const sortedFolders = Array.from(topLevelFolders.entries()).sort(
      (a, b) => a[0].localeCompare(b[0])
    );
    for (const [folderName, count] of sortedFolders) {
      const folderPath = path6.join(workspaceRoot, folderName);
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode7.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${folderPath}`
        )
      );
    }
    for (const icon of rootFiles.sort((a, b) => a.name.localeCompare(b.name))) {
      items.push(this.createIconItem(icon));
    }
    return items;
  }
  /**
   * Create an SvgItem for an icon with build status label
   */
  createIconItem(icon) {
    const statusLabel = this.builtIconsProvider?.getBuildStatusLabel(icon.name) || "";
    const displayName = statusLabel ? `${icon.name} ${statusLabel}` : icon.name;
    if (this.builtIconsProvider) {
      icon.isBuilt = this.builtIconsProvider.isIconBuilt(icon.name);
    }
    const item = new SvgItem(
      displayName,
      0,
      vscode7.TreeItemCollapsibleState.None,
      "icon",
      icon,
      void 0
    );
    if (statusLabel) {
      item.description = "";
    }
    return item;
  }
  getFolderChildren(folderPath) {
    const items = [];
    const subFolders = /* @__PURE__ */ new Map();
    const filesInFolder = [];
    const normalizedFolderPath = folderPath.replace(/\\/g, "/");
    for (const [_iconName, icon] of this.svgFiles) {
      const iconPath = icon.path.replace(/\\/g, "/");
      if (!iconPath.startsWith(normalizedFolderPath + "/")) {
        continue;
      }
      const relativePath = iconPath.substring(normalizedFolderPath.length + 1);
      const parts = relativePath.split("/");
      if (parts.length === 1) {
        filesInFolder.push(icon);
      } else {
        const subFolder = parts[0];
        subFolders.set(subFolder, (subFolders.get(subFolder) || 0) + 1);
      }
    }
    const filePaths = filesInFolder.map((icon) => icon.path);
    if (filePaths.length > 0) {
      SvgContentCache.getInstance().preloadBatch(filePaths);
    }
    const sortedFolders = Array.from(subFolders.entries()).sort((a, b) => a[0].localeCompare(b[0]));
    for (const [folderName, count] of sortedFolders) {
      const subFolderPath = path6.join(folderPath, folderName);
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode7.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${subFolderPath}`
        )
      );
    }
    for (const icon of filesInFolder.sort((a, b) => a.name.localeCompare(b.name))) {
      items.push(this.createIconItem(icon));
    }
    return items;
  }
};

// src/providers/FileSvgScanner.ts
var path7 = __toESM(require("node:path"));
var fs8 = __toESM(require("node:fs"));
var import_node_fs = require("node:fs");
init_config();

// src/types/scanner.ts
var DEFAULT_SCANNER_CONFIG = {
  concurrencyLimit: 10,
  maxDepth: 20,
  maxFiles: 5e3,
  batchSize: 50,
  enableProgress: true,
  fileTimeout: 5e3
};

// src/utils/ConcurrentProcessor.ts
var ConcurrentProcessor = class {
  /**
   * Process items concurrently with a limit on simultaneous operations
   * Uses a pool-based approach for optimal performance
   */
  static async processConcurrent(options) {
    const { items, processor, concurrency, onProgress } = options;
    const results = new Array(items.length);
    let currentIndex = 0;
    let completedCount = 0;
    const total = items.length;
    const worker = async () => {
      while (true) {
        const index = currentIndex++;
        if (index >= total) break;
        try {
          results[index] = await processor(items[index]);
        } catch (_error) {
          results[index] = void 0;
        }
        completedCount++;
        if (onProgress) {
          onProgress(completedCount, total);
        }
      }
    };
    const workerCount = Math.min(concurrency, total);
    const workers = [];
    for (let i = 0; i < workerCount; i++) {
      workers.push(worker());
    }
    await Promise.all(workers);
    return results;
  }
  /**
   * Process items in batches with concurrent processing within each batch
   * Useful for very large datasets to prevent memory issues
   */
  static async processBatches(options) {
    const { items, processor, batchSize, concurrency, onBatchComplete } = options;
    const results = [];
    const totalBatches = Math.ceil(items.length / batchSize);
    for (let i = 0; i < totalBatches; i++) {
      const start = i * batchSize;
      const end = Math.min(start + batchSize, items.length);
      const batch = items.slice(start, end);
      const batchResults = await this.processConcurrent({
        items: batch,
        processor,
        concurrency
      });
      results.push(...batchResults);
      if (onBatchComplete) {
        onBatchComplete(i + 1, totalBatches);
      }
    }
    return results;
  }
  /**
   * Process items with timeout per item
   * Prevents hanging on slow file operations
   */
  static async processWithTimeout(item, processor, timeoutMs, defaultValue) {
    return Promise.race([
      processor(item),
      new Promise((resolve3) => setTimeout(() => resolve3(defaultValue), timeoutMs))
    ]);
  }
  /**
   * Chunk an array into smaller arrays of specified size
   */
  static chunk(array, size) {
    const chunks = [];
    for (let i = 0; i < array.length; i += size) {
      chunks.push(array.slice(i, i + size));
    }
    return chunks;
  }
};

// src/providers/FileSvgScanner.ts
var FileSvgScanner = class {
  /**
   * Directories to skip when scanning
   */
  static SKIP_DIRS = /* @__PURE__ */ new Set([
    "node_modules",
    ".git",
    "dist",
    "build",
    ".next",
    ".nuxt",
    "coverage",
    ".svelte-kit",
    "__pycache__",
    ".cache",
    ".turbo",
    ".output",
    "out",
    ".vercel",
    ".netlify",
    "vendor",
    "target"
  ]);
  /**
   * Current scanner configuration
   */
  static config = DEFAULT_SCANNER_CONFIG;
  /**
   * Configure scanner options
   */
  static configure(config) {
    this.config = { ...DEFAULT_SCANNER_CONFIG, ...config };
  }
  /**
   * Reset configuration to defaults
   */
  static resetConfig() {
    this.config = DEFAULT_SCANNER_CONFIG;
  }
  /**
   * Scan a folder for SVG files with progress reporting
   */
  static async scanFolder(folderPath, svgFiles, onProgress) {
    const startTime = Date.now();
    const errors = [];
    let filesScanned = 0;
    let truncated = false;
    const svgFolders = getSvgConfig("svgFolders", []);
    onProgress?.({ phase: "preparing", processed: 0 });
    let foundAny = false;
    const existingFolders = [];
    for (const svgFolder of svgFolders) {
      const fullPath = path7.join(folderPath, svgFolder);
      if (fs8.existsSync(fullPath)) {
        existingFolders.push(fullPath);
        foundAny = true;
      }
    }
    if (foundAny) {
      const scanResults = await ConcurrentProcessor.processConcurrent({
        items: existingFolders.map((fp, i) => ({ fullPath: fp, category: svgFolders[i] })),
        processor: async ({ fullPath, category }) => {
          const folderSvgs = /* @__PURE__ */ new Map();
          await this.scanDirectoryOptimized(fullPath, category, folderSvgs, 0, errors);
          return folderSvgs;
        },
        concurrency: this.config.concurrencyLimit,
        onProgress: (processed, total) => {
          onProgress?.({
            phase: "scanning",
            processed,
            total,
            percentage: Math.round(processed / total * 100)
          });
        }
      });
      for (const result of scanResults) {
        if (result) {
          for (const [key, value] of result) {
            if (svgFiles.size >= this.config.maxFiles) {
              truncated = true;
              break;
            }
            svgFiles.set(key, value);
          }
        }
      }
      filesScanned = svgFiles.size;
    } else {
      const result = await this.scanAllSvgsOptimized(
        folderPath,
        "",
        svgFiles,
        0,
        errors,
        onProgress
      );
      filesScanned = result.filesScanned;
      truncated = result.truncated;
    }
    onProgress?.({
      phase: "complete",
      processed: svgFiles.size,
      total: svgFiles.size,
      percentage: 100
    });
    return {
      items: svgFiles,
      filesScanned,
      itemsFound: svgFiles.size,
      duration: Date.now() - startTime,
      truncated,
      errors
    };
  }
  /**
   * Optimized scan for entire folder using async directory reading
   * Uses batched processing for better performance with large directories
   */
  static async scanAllSvgsOptimized(folderPath, relativePath, svgFiles, depth, errors, onProgress) {
    let filesScanned = 0;
    let truncated = false;
    if (!fs8.existsSync(folderPath)) {
      return { filesScanned, truncated };
    }
    if (depth > this.config.maxDepth) {
      return { filesScanned, truncated: true };
    }
    if (shouldIgnorePath(folderPath)) {
      return { filesScanned, truncated };
    }
    try {
      const entries = await import_node_fs.promises.readdir(folderPath, { withFileTypes: true });
      const svgFiles_list = [];
      const directories = [];
      for (const entry of entries) {
        const fullPath = path7.join(folderPath, entry.name);
        const relPath = relativePath ? `${relativePath}/${entry.name}` : entry.name;
        if (entry.isDirectory()) {
          if (!this.SKIP_DIRS.has(entry.name) && !entry.name.startsWith(".")) {
            directories.push({ fullPath, relPath });
          }
        } else if (entry.isFile() && entry.name.endsWith(".svg")) {
          svgFiles_list.push({ fullPath, relPath, name: entry.name });
        }
      }
      for (const file of svgFiles_list) {
        if (svgFiles.size >= this.config.maxFiles) {
          truncated = true;
          break;
        }
        if (shouldIgnorePath(file.fullPath)) {
          continue;
        }
        const iconName = path7.basename(file.name, ".svg");
        const category = path7.dirname(file.relPath) || "root";
        svgFiles.set(iconName, {
          name: iconName,
          path: file.fullPath,
          source: "workspace",
          category: category === "." ? "root" : category,
          svg: void 0
        });
        filesScanned++;
        if (onProgress && filesScanned % 100 === 0) {
          onProgress({
            phase: "scanning",
            processed: filesScanned,
            currentFile: file.fullPath
          });
        }
      }
      if (!truncated && directories.length > 0) {
        const subResults = await ConcurrentProcessor.processConcurrent({
          items: directories,
          processor: async (dir) => {
            if (svgFiles.size >= this.config.maxFiles) {
              return { filesScanned: 0, truncated: true };
            }
            return this.scanAllSvgsOptimized(
              dir.fullPath,
              dir.relPath,
              svgFiles,
              depth + 1,
              errors,
              onProgress
            );
          },
          concurrency: Math.min(this.config.concurrencyLimit, directories.length)
        });
        for (const result of subResults) {
          if (result) {
            filesScanned += result.filesScanned;
            if (result.truncated) truncated = true;
          }
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Error scanning folder ${folderPath}:`, error);
      errors.push({
        filePath: folderPath,
        message: errorMessage,
        code: error.code
      });
    }
    return { filesScanned, truncated };
  }
  /**
   * Scan entire folder for any SVG files (legacy method for backward compatibility)
   * @deprecated Use scanAllSvgsOptimized instead
   */
  static async scanAllSvgsInFolder(folderPath, relativePath, svgFiles) {
    const errors = [];
    await this.scanAllSvgsOptimized(folderPath, relativePath, svgFiles, 0, errors);
  }
  /**
   * Optimized directory scan with async operations
   */
  static async scanDirectoryOptimized(dirPath, category, svgFiles, depth, errors) {
    if (!fs8.existsSync(dirPath)) return;
    if (depth > this.config.maxDepth) return;
    if (shouldIgnorePath(dirPath)) {
      return;
    }
    try {
      const entries = await import_node_fs.promises.readdir(dirPath, { withFileTypes: true });
      const directories = [];
      for (const entry of entries) {
        const fullPath = path7.join(dirPath, entry.name);
        if (entry.isDirectory()) {
          if (!this.SKIP_DIRS.has(entry.name)) {
            directories.push({
              fullPath,
              category: `${category}/${entry.name}`
            });
          }
        } else if (entry.isFile() && entry.name.endsWith(".svg")) {
          if (svgFiles.size >= this.config.maxFiles) break;
          if (shouldIgnorePath(fullPath)) {
            continue;
          }
          const iconName = path7.basename(entry.name, ".svg");
          svgFiles.set(iconName, {
            name: iconName,
            path: fullPath,
            source: "workspace",
            category,
            svg: void 0
            // Lazy load
          });
        }
      }
      if (directories.length > 0) {
        await ConcurrentProcessor.processConcurrent({
          items: directories,
          processor: async (dir) => {
            await this.scanDirectoryOptimized(
              dir.fullPath,
              dir.category,
              svgFiles,
              depth + 1,
              errors
            );
          },
          concurrency: Math.min(this.config.concurrencyLimit, directories.length)
        });
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      console.error(`Error scanning directory ${dirPath}:`, error);
      errors.push({
        filePath: dirPath,
        message: errorMessage,
        code: error.code
      });
    }
  }
  /**
   * Scan a specific directory for SVG files (legacy method for backward compatibility)
   * @deprecated Use scanDirectoryOptimized instead
   */
  static async scanDirectory(dirPath, category, svgFiles) {
    const errors = [];
    await this.scanDirectoryOptimized(dirPath, category, svgFiles, 0, errors);
  }
  /**
   * Get scanner statistics
   */
  static getConfig() {
    return { ...this.config };
  }
};

// src/providers/InlineSvgScanner.ts
var vscode8 = __toESM(require("vscode"));
var path8 = __toESM(require("node:path"));
var fs9 = __toESM(require("node:fs"));
var import_node_fs2 = require("node:fs");
var InlineSvgScanner = class {
  /**
   * File patterns to include in search
   */
  static INCLUDE_PATTERN = "**/*.{tsx,jsx,vue,svelte,astro,html,ts,js}";
  /**
   * File patterns to exclude from search
   */
  static EXCLUDE_PATTERN = "**/node_modules/**";
  /**
   * Generated icon files to skip
   */
  static SKIP_FILES = /* @__PURE__ */ new Set(["icon.js", "icons.js", "icon.ts", "icons.ts"]);
  /**
   * Current scanner configuration
   */
  static config = DEFAULT_SCANNER_CONFIG;
  /**
   * Pre-compiled regex patterns for better performance
   */
  static SVG_REGEX = /<svg\s[^>]*>[\s\S]*?<\/svg>/gi;
  static IMG_SVG_REGEX = /<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/gi;
  static GENERATED_MARKER = "Auto-generated by Icon Studio";
  /**
   * Configure scanner options
   */
  static configure(config) {
    this.config = { ...DEFAULT_SCANNER_CONFIG, ...config };
  }
  /**
   * Reset configuration to defaults
   */
  static resetConfig() {
    this.config = DEFAULT_SCANNER_CONFIG;
  }
  /**
   * Scan all code files for inline <svg> elements and <img src="...svg"> references
   * Optimized with concurrent file processing and direct file reading
   */
  static async scanInlineSvgs(inlineSvgs, svgReferences, builtIcons, onProgress) {
    const startTime = Date.now();
    const errors = [];
    let truncated = false;
    inlineSvgs.clear();
    svgReferences.clear();
    const workspaceFolders = vscode8.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return {
        items: { inlineSvgs, svgReferences },
        filesScanned: 0,
        itemsFound: 0,
        duration: Date.now() - startTime,
        truncated: false,
        errors: []
      };
    }
    reloadIgnorePatterns();
    onProgress?.({ phase: "preparing", processed: 0 });
    const files = await vscode8.workspace.findFiles(
      this.INCLUDE_PATTERN,
      this.EXCLUDE_PATTERN,
      this.config.maxFiles
    );
    if (files.length >= this.config.maxFiles) {
      truncated = true;
    }
    const filesToProcess = files.filter((file) => {
      if (shouldIgnorePath(file.fsPath)) return false;
      const fileName = path8.basename(file.fsPath);
      if (this.SKIP_FILES.has(fileName)) return false;
      return true;
    });
    onProgress?.({
      phase: "scanning",
      processed: 0,
      total: filesToProcess.length,
      percentage: 0
    });
    const workspaceRoot = workspaceFolders[0].uri.fsPath;
    const results = await ConcurrentProcessor.processBatches({
      items: filesToProcess,
      processor: async (file) => this.processFileOptimized(file, workspaceRoot, builtIcons),
      batchSize: this.config.batchSize,
      concurrency: this.config.concurrencyLimit,
      onBatchComplete: (batchIndex, _totalBatches) => {
        const processed = Math.min(batchIndex * this.config.batchSize, filesToProcess.length);
        onProgress?.({
          phase: "processing",
          processed,
          total: filesToProcess.length,
          percentage: Math.round(processed / filesToProcess.length * 100)
        });
      }
    });
    for (const result of results) {
      if (!result) continue;
      if (result.error) {
        errors.push(result.error);
      }
      for (const [key, value] of result.inlineSvgs) {
        inlineSvgs.set(key, value);
      }
      if (result.imgReferences.length > 0) {
        const filePath = result.imgReferences[0].filePath;
        svgReferences.set(filePath, result.imgReferences);
      }
    }
    onProgress?.({
      phase: "complete",
      processed: filesToProcess.length,
      total: filesToProcess.length,
      percentage: 100
    });
    return {
      items: { inlineSvgs, svgReferences },
      filesScanned: filesToProcess.length,
      itemsFound: inlineSvgs.size + svgReferences.size,
      duration: Date.now() - startTime,
      truncated,
      errors
    };
  }
  /**
   * Process a single file optimized - uses direct file reading instead of VS Code document API
   */
  static async processFileOptimized(file, workspaceRoot, builtIcons) {
    const result = {
      inlineSvgs: /* @__PURE__ */ new Map(),
      imgReferences: []
    };
    try {
      const text = await import_node_fs2.promises.readFile(file.fsPath, "utf-8");
      if (text.includes(this.GENERATED_MARKER)) {
        return null;
      }
      this.extractInlineSvgsOptimized(text, file, result.inlineSvgs, builtIcons);
      this.extractImgReferencesOptimized(text, file, result.imgReferences, workspaceRoot);
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      result.error = {
        filePath: file.fsPath,
        message: errorMessage,
        code: error.code
      };
    }
    return result;
  }
  /**
   * Extract inline SVGs from text content (optimized - no document API)
   */
  static extractInlineSvgsOptimized(text, file, inlineSvgs, builtIcons) {
    this.SVG_REGEX.lastIndex = 0;
    let match;
    while ((match = this.SVG_REGEX.exec(text)) !== null) {
      const svgContent = match[0];
      if (svgContent.includes("${")) {
        continue;
      }
      const textBeforeMatch = text.substring(0, match.index);
      const lineNumber = (textBeforeMatch.match(/\n/g) || []).length;
      const lastNewlineIndex = textBeforeMatch.lastIndexOf("\n");
      const columnNumber = match.index - lastNewlineIndex - 1;
      const fullMatchText = text.substring(0, match.index + match[0].length);
      const endLineNumber = (fullMatchText.match(/\n/g) || []).length;
      const lastNewlineInMatch = fullMatchText.lastIndexOf("\n");
      const endColumnNumber = match.index + match[0].length - lastNewlineInMatch - 1;
      const iconName = this.extractSvgNameFromText(svgContent, text, lineNumber);
      const fileBaseName = path8.basename(file.fsPath, path8.extname(file.fsPath));
      const uniqueKey = `${fileBaseName}:${iconName}:${lineNumber}`;
      inlineSvgs.set(uniqueKey, {
        name: iconName,
        path: file.fsPath,
        source: "inline",
        category: "icons",
        svg: svgContent,
        filePath: file.fsPath,
        line: lineNumber,
        column: columnNumber,
        endLine: endLineNumber,
        endColumn: endColumnNumber,
        isBuilt: builtIcons.has(iconName)
      });
    }
  }
  /**
   * Extract SVG name from content and surrounding text (optimized - no document API)
   */
  static extractSvgNameFromText(svgContent, fullText, lineNumber) {
    const idMatch = svgContent.match(/id=["']([^"']+)["']/);
    if (idMatch) return idMatch[1];
    const ariaMatch = svgContent.match(/aria-label=["']([^"']+)["']/);
    if (ariaMatch) return ariaMatch[1].toLowerCase().replace(/\s+/g, "-");
    const classMatch = svgContent.match(/class=["']([^"']*icon[^"']*)["']/i);
    if (classMatch) {
      const iconClass = classMatch[1].split(/\s+/).find((c) => c.includes("icon"));
      if (iconClass) return iconClass.replace(/icon-?/i, "") || "icon";
    }
    if (lineNumber > 0) {
      const lines = fullText.split("\n");
      if (lineNumber > 0 && lineNumber <= lines.length) {
        const prevLine = lines[lineNumber - 1];
        const varMatch = prevLine.match(/(?:const|let|var)\s+(\w+Icon|\w+Svg)\s*=/i);
        if (varMatch) return varMatch[1].replace(/Icon$|Svg$/i, "").toLowerCase();
      }
    }
    return `svg-${lineNumber + 1}`;
  }
  /**
   * Extract IMG references from text content (optimized)
   */
  static extractImgReferencesOptimized(text, file, imgReferences, workspaceRoot) {
    this.IMG_SVG_REGEX.lastIndex = 0;
    let match;
    while ((match = this.IMG_SVG_REGEX.exec(text)) !== null) {
      const svgPath = match[1];
      const textBeforeMatch = text.substring(0, match.index);
      const lineNumber = (textBeforeMatch.match(/\n/g) || []).length;
      const lastNewlineIndex = textBeforeMatch.lastIndexOf("\n");
      const columnNumber = match.index - lastNewlineIndex - 1;
      const iconName = path8.basename(svgPath, ".svg");
      let resolvedPath = svgPath;
      let svgContent;
      if (svgPath.startsWith("./") || svgPath.startsWith("../")) {
        const fileDir = path8.dirname(file.fsPath);
        resolvedPath = path8.resolve(fileDir, svgPath);
        if (!fs9.existsSync(resolvedPath)) {
          const cleanPath = svgPath.replace(/^\.\//, "");
          const rootPath = path8.join(workspaceRoot, cleanPath);
          if (fs9.existsSync(rootPath)) {
            resolvedPath = rootPath;
          }
        }
      } else if (!path8.isAbsolute(svgPath)) {
        resolvedPath = path8.join(workspaceRoot, svgPath);
      }
      const fileExists = fs9.existsSync(resolvedPath);
      if (fileExists) {
        try {
          svgContent = fs9.readFileSync(resolvedPath, "utf-8");
        } catch {
        }
      }
      imgReferences.push({
        name: iconName,
        path: resolvedPath,
        source: "inline",
        category: "img-ref",
        svg: svgContent,
        filePath: file.fsPath,
        line: lineNumber,
        column: columnNumber,
        exists: fileExists
      });
    }
  }
  /**
   * Extract SVG name from content and context
   * @deprecated Use extractSvgNameFromText instead
   */
  static extractSvgName(svgContent, document, line) {
    return this.extractSvgNameFromText(svgContent, document.getText(), line);
  }
  /**
   * Get current scanner configuration
   */
  static getConfig() {
    return { ...this.config };
  }
  /**
   * Legacy method for backward compatibility - wraps to new implementation
   * @deprecated Use extractInlineSvgsOptimized instead
   */
  static extractInlineSvgs(document, text, file, inlineSvgs, builtIcons) {
    this.extractInlineSvgsOptimized(text, file, inlineSvgs, builtIcons);
  }
  /**
   * Legacy method for backward compatibility - wraps to new implementation
   * @deprecated Use extractImgReferencesOptimized instead
   */
  static extractImgReferences(document, text, file, svgReferences, workspaceRoot) {
    const imgReferences = [];
    this.extractImgReferencesOptimized(text, file, imgReferences, workspaceRoot);
    if (imgReferences.length > 0) {
      svgReferences.set(file.fsPath, imgReferences);
    }
  }
};

// src/providers/BuiltIconLoader.ts
var vscode9 = __toESM(require("vscode"));
var path9 = __toESM(require("path"));
var fs10 = __toESM(require("fs"));
init_config();
var BuiltIconLoader = class {
  /**
   * Load library icons from JSON file
   */
  static loadLibraryIcons(libraryIcons) {
    const libraryPath = getSvgConfig("libraryPath", "");
    if (!libraryPath) {
      const appDataPath = process.env.APPDATA || process.env.HOME || "";
      const defaultPath = path9.join(appDataPath, "icon-manager", "icons.json");
      if (fs10.existsSync(defaultPath)) {
        this.loadIconsFromJson(defaultPath, libraryIcons);
      }
    } else if (fs10.existsSync(libraryPath)) {
      this.loadIconsFromJson(libraryPath, libraryIcons);
    }
  }
  /**
   * Load icons from JSON file
   */
  static loadIconsFromJson(jsonPath, libraryIcons) {
    try {
      const content = fs10.readFileSync(jsonPath, "utf-8");
      const icons = JSON.parse(content);
      if (Array.isArray(icons)) {
        for (const icon of icons) {
          libraryIcons.set(icon.name, {
            name: icon.name,
            path: jsonPath,
            source: "library",
            category: icon.name.includes(":") ? icon.name.split(":")[0] : "custom",
            svg: icon.svg || icon.body
          });
        }
      }
    } catch (error) {
      console.error("Error loading library icons:", error);
    }
  }
  /**
   * Load built icons from the output directory (icons.js or sprite.svg)
   */
  static async loadBuiltIcons(libraryIcons, builtIcons) {
    builtIcons.clear();
    const outputDir = getSvgConfig("outputDirectory", "");
    if (!outputDir) return;
    const workspaceFolders = vscode9.workspace.workspaceFolders;
    if (!workspaceFolders) return;
    const fullOutputPath = path9.join(workspaceFolders[0].uri.fsPath, outputDir);
    const iconsBzJs = path9.join(fullOutputPath, "icons.js");
    const iconsJs = path9.join(fullOutputPath, "icons.js");
    const iconsTs = path9.join(fullOutputPath, "icons.ts");
    const iconsFile = fs10.existsSync(iconsBzJs) ? iconsBzJs : fs10.existsSync(iconsJs) ? iconsJs : fs10.existsSync(iconsTs) ? iconsTs : null;
    if (iconsFile) {
      await this.loadIconsFromJsFile(iconsFile, libraryIcons, builtIcons);
    } else {
    }
    const spriteSvg = path9.join(fullOutputPath, "sprite.svg");
    if (fs10.existsSync(spriteSvg)) {
      this.loadIconsFromSprite(spriteSvg, libraryIcons, builtIcons);
    }
  }
  /**
   * Load icons from JS file
   */
  static async loadIconsFromJsFile(iconsFile, libraryIcons, builtIcons) {
    try {
      const uri = vscode9.Uri.file(iconsFile);
      const fileContent = await vscode9.workspace.fs.readFile(uri);
      const content = Buffer.from(fileContent).toString("utf-8");
      const iconRegex = /export\s+const\s+(\w+)\s*=\s*\{\s*name:\s*['"]([^'"]+)['"]\s*,\s*body:\s*`([\s\S]*?)`\s*,\s*viewBox:\s*['"]([^'"]+)['"](?:\s*,\s*animation:\s*\{([^}]*)\})?\s*\}/g;
      let match;
      while ((match = iconRegex.exec(content)) !== null) {
        const iconName = match[2];
        const body = match[3];
        const viewBox = match[4];
        const animationStr = match[5];
        builtIcons.add(iconName);
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">${body}</svg>`;
        const animation = this.parseAnimation(animationStr);
        libraryIcons.set(iconName, {
          name: iconName,
          path: iconsFile,
          source: "library",
          category: "built",
          svg,
          isBuilt: true,
          animation
        });
      }
    } catch (error) {
      console.error("Error loading built icons:", error);
    }
  }
  /**
   * Parse animation string from icon definition
   */
  static parseAnimation(animationStr) {
    if (!animationStr) return void 0;
    try {
      const typeMatch = animationStr.match(/type:\s*['"]([^'"]+)['"]/);
      const durationMatch = animationStr.match(/duration:\s*([\d.]+)/);
      const timingMatch = animationStr.match(/timing:\s*['"]([^'"]+)['"]/);
      const iterationMatch = animationStr.match(/iteration:\s*['"]([^'"]+)['"]/);
      const delayMatch = animationStr.match(/delay:\s*([\d.]+)/);
      const directionMatch = animationStr.match(/direction:\s*['"]([^'"]+)['"]/);
      if (typeMatch) {
        return {
          type: typeMatch[1],
          duration: durationMatch ? parseFloat(durationMatch[1]) : 1,
          timing: timingMatch ? timingMatch[1] : "ease",
          iteration: iterationMatch ? iterationMatch[1] : "infinite",
          delay: delayMatch ? parseFloat(delayMatch[1]) : void 0,
          direction: directionMatch ? directionMatch[1] : void 0
        };
      }
    } catch (_e) {
    }
    return void 0;
  }
  /**
   * Load icons from sprite SVG
   */
  static loadIconsFromSprite(spriteSvg, libraryIcons, builtIcons) {
    try {
      const content = fs10.readFileSync(spriteSvg, "utf-8");
      const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*viewBox=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
      let match;
      while ((match = symbolRegex.exec(content)) !== null) {
        const iconName = match[1];
        const viewBox = match[2];
        const body = match[3];
        builtIcons.add(iconName);
        const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${viewBox}">${body}</svg>`;
        if (!libraryIcons.has(iconName)) {
          libraryIcons.set(iconName, {
            name: iconName,
            path: spriteSvg,
            source: "library",
            category: "built",
            svg,
            isBuilt: true
          });
        }
      }
    } catch (error) {
      console.error("Error loading built icons from sprite.svg:", error);
    }
  }
};

// src/providers/IconUsageScanner.ts
var vscode10 = __toESM(require("vscode"));
var import_node_fs3 = require("node:fs");
var IconUsageScanner = class {
  /**
   * File patterns to include in search
   */
  static INCLUDE_PATTERN = "**/*.{ts,tsx,js,jsx,vue,html,svelte,astro}";
  /**
   * File patterns to exclude from search
   */
  static EXCLUDE_PATTERN = "**/node_modules/**,**/dist/**,**/build/**,**/.git/**,**/svgs/**";
  /**
   * Maximum number of files to search (legacy - now uses config)
   */
  static MAX_FILES = 500;
  /**
   * Current scanner configuration
   */
  static config = DEFAULT_SCANNER_CONFIG;
  /**
   * Configure scanner options
   */
  static configure(config) {
    this.config = { ...DEFAULT_SCANNER_CONFIG, ...config };
  }
  /**
   * Reset configuration to defaults
   */
  static resetConfig() {
    this.config = DEFAULT_SCANNER_CONFIG;
  }
  /**
   * Scan workspace for icon usages with optimized single-pass algorithm
   */
  static async scanIconUsages(libraryIcons, iconUsages, onProgress) {
    const startTime = Date.now();
    const errors = [];
    let truncated = false;
    const workspaceFolders = vscode10.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return {
        items: iconUsages,
        filesScanned: 0,
        itemsFound: 0,
        duration: Date.now() - startTime,
        truncated: false,
        errors: []
      };
    }
    iconUsages.clear();
    const iconNames = [];
    for (const [name, icon] of libraryIcons) {
      if (icon.isBuilt) {
        iconNames.push(name);
      }
    }
    if (iconNames.length === 0) {
      return {
        items: iconUsages,
        filesScanned: 0,
        itemsFound: 0,
        duration: Date.now() - startTime,
        truncated: false,
        errors: []
      };
    }
    onProgress?.({ phase: "preparing", processed: 0 });
    const escapedNames = iconNames.map((name) => this.escapeRegex(name));
    const combinedPattern = new RegExp(`name=["'\`](${escapedNames.join("|")})["'\`]`, "g");
    try {
      const files = await vscode10.workspace.findFiles(
        this.INCLUDE_PATTERN,
        this.EXCLUDE_PATTERN,
        this.config.maxFiles
      );
      if (files.length >= this.config.maxFiles) {
        truncated = true;
      }
      onProgress?.({
        phase: "scanning",
        processed: 0,
        total: files.length,
        percentage: 0
      });
      const results = await ConcurrentProcessor.processBatches({
        items: files,
        processor: async (file) => this.processFileForUsages(file, combinedPattern),
        batchSize: this.config.batchSize,
        concurrency: this.config.concurrencyLimit,
        onBatchComplete: (batchIndex, _totalBatches) => {
          const processed = Math.min(batchIndex * this.config.batchSize, files.length);
          onProgress?.({
            phase: "processing",
            processed,
            total: files.length,
            percentage: Math.round(processed / files.length * 100)
          });
        }
      });
      for (const result of results) {
        if (!result) continue;
        if (result.error) {
          errors.push(result.error);
        }
        for (const [iconName, usages] of result.usages) {
          const existing = iconUsages.get(iconName) || [];
          iconUsages.set(iconName, [...existing, ...usages]);
        }
      }
      for (const [name, icon] of libraryIcons) {
        if (icon.isBuilt) {
          const usages = iconUsages.get(name) || [];
          icon.usages = usages;
          icon.usageCount = usages.length;
        }
      }
      onProgress?.({
        phase: "complete",
        processed: files.length,
        total: files.length,
        percentage: 100
      });
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      errors.push({
        filePath: "workspace",
        message: errorMessage
      });
    }
    return {
      items: iconUsages,
      filesScanned: 0,
      itemsFound: iconUsages.size,
      duration: Date.now() - startTime,
      truncated,
      errors
    };
  }
  /**
   * Process a single file for icon usages using combined regex
   */
  static async processFileForUsages(file, combinedPattern) {
    const result = {
      usages: /* @__PURE__ */ new Map()
    };
    try {
      const text = await import_node_fs3.promises.readFile(file.fsPath, "utf-8");
      if (!text.includes("name=")) {
        return null;
      }
      combinedPattern.lastIndex = 0;
      let match;
      const lines = text.split("\n");
      while ((match = combinedPattern.exec(text)) !== null) {
        const iconName = match[1];
        const textBeforeMatch = text.substring(0, match.index);
        const lineNumber = (textBeforeMatch.match(/\n/g) || []).length;
        const lineText = lines[lineNumber]?.trim() || "";
        if (!result.usages.has(iconName)) {
          result.usages.set(iconName, []);
        }
        const usages = result.usages.get(iconName);
        const existing = usages.find((u) => u.file === file.fsPath && u.line === lineNumber + 1);
        if (!existing) {
          usages.push({
            file: file.fsPath,
            line: lineNumber + 1,
            preview: lineText.substring(0, 80)
          });
        }
      }
    } catch (error) {
      const errorMessage = error instanceof Error ? error.message : String(error);
      result.error = {
        filePath: file.fsPath,
        message: errorMessage,
        code: error.code
      };
    }
    return result.usages.size > 0 ? result : null;
  }
  /**
   * Escape special regex characters in icon names
   */
  static escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Legacy method for backward compatibility
   * @deprecated Use findIconUsagesInFile instead
   */
  static findIconUsagesInText(iconName, text, document, file, iconUsages) {
    const patterns = [
      `name="${iconName}"`,
      `name='${iconName}'`,
      `name={\`${iconName}\`}`,
      `name={['"]${iconName}['"]}`
    ];
    for (const pattern of patterns) {
      let index = 0;
      while ((index = text.indexOf(pattern.replace(/\[.+?\]/g, ""), index)) !== -1) {
        const actualMatch = text.indexOf(`name="${iconName}"`, index) !== -1 || text.indexOf(`name='${iconName}'`, index) !== -1;
        if (actualMatch) {
          const position = document.positionAt(index);
          const line = position.line;
          const lineText = document.lineAt(line).text.trim();
          if (!iconUsages.has(iconName)) {
            iconUsages.set(iconName, []);
          }
          const usages = iconUsages.get(iconName);
          const existing = usages.find((u) => u.file === file.fsPath && u.line === line + 1);
          if (!existing) {
            usages.push({
              file: file.fsPath,
              line: line + 1,
              preview: lineText.substring(0, 80)
            });
          }
        }
        index += iconName.length;
      }
    }
  }
  /**
   * Get current scanner configuration
   */
  static getConfig() {
    return { ...this.config };
  }
};

// src/providers/SvgScanner.ts
var SvgScanner = class {
  context;
  constructor(context) {
    this.context = context;
  }
  /**
   * Configure all scanners with the same settings
   */
  static configure(config) {
    FileSvgScanner.configure(config);
    InlineSvgScanner.configure(config);
    IconUsageScanner.configure(config);
  }
  /**
   * Reset all scanner configurations to defaults
   */
  static resetConfig() {
    FileSvgScanner.resetConfig();
    InlineSvgScanner.resetConfig();
    IconUsageScanner.resetConfig();
  }
  /**
   * Scan a folder for SVG files with optional progress reporting
   */
  async scanFolder(folderPath, svgFiles, onProgress) {
    return FileSvgScanner.scanFolder(folderPath, svgFiles, onProgress);
  }
  /**
   * Load library icons from JSON file
   */
  loadLibraryIcons(libraryIcons) {
    return BuiltIconLoader.loadLibraryIcons(libraryIcons);
  }
  /**
   * Load built icons from the output directory (icons.js or sprite.svg)
   */
  async loadBuiltIcons(libraryIcons, builtIcons) {
    return BuiltIconLoader.loadBuiltIcons(libraryIcons, builtIcons);
  }
  /**
   * Scan all code files for inline <svg> elements and <img src="...svg"> references
   * with optional progress reporting
   */
  async scanInlineSvgs(inlineSvgs, svgReferences, builtIcons, onProgress) {
    return InlineSvgScanner.scanInlineSvgs(inlineSvgs, svgReferences, builtIcons, onProgress);
  }
  /**
   * Scan workspace for icon usages with optional progress reporting
   */
  async scanIconUsages(libraryIcons, iconUsages, onProgress) {
    return IconUsageScanner.scanIconUsages(libraryIcons, iconUsages, onProgress);
  }
};

// src/providers/FolderTreeBuilder.ts
var vscode11 = __toESM(require("vscode"));
var path10 = __toESM(require("path"));
var FolderTreeBuilder = class {
  /**
   * Build a tree structure from paths
   */
  static buildFolderTree(paths) {
    const tree = /* @__PURE__ */ new Map();
    for (const p of paths) {
      const parts = p.split("/");
      let currentPath = "";
      for (let i = 0; i < parts.length - 1; i++) {
        const parentPath = currentPath;
        currentPath = currentPath ? `${currentPath}/${parts[i]}` : parts[i];
        if (!tree.has(parentPath)) {
          tree.set(parentPath, { subfolders: /* @__PURE__ */ new Set(), files: [] });
        }
        tree.get(parentPath).subfolders.add(currentPath);
        if (!tree.has(currentPath)) {
          tree.set(currentPath, { subfolders: /* @__PURE__ */ new Set(), files: [] });
        }
      }
      const parentDir = parts.slice(0, -1).join("/");
      if (!tree.has(parentDir)) {
        tree.set(parentDir, { subfolders: /* @__PURE__ */ new Set(), files: [] });
      }
      tree.get(parentDir).files.push(p);
    }
    return tree;
  }
  /**
   * Get workspace root path
   */
  static getWorkspaceRoot() {
    return vscode11.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
  }
  /**
   * Convert absolute paths to relative paths
   */
  static toRelativePaths(absolutePaths, workspaceRoot) {
    const root = workspaceRoot || this.getWorkspaceRoot();
    return absolutePaths.map((p) => path10.relative(root, p).replace(/\\\\/g, "/"));
  }
  /**
   * Convert relative path to absolute path
   */
  static toAbsolutePath(relativePath, workspaceRoot) {
    const root = workspaceRoot || this.getWorkspaceRoot();
    return path10.join(root, relativePath);
  }
  /**
   * Get sorted subfolders from a tree node
   */
  static getSortedSubfolders(node) {
    return Array.from(node.subfolders).sort((a, b) => a.localeCompare(b));
  }
  /**
   * Get sorted files from a tree node
   */
  static getSortedFiles(node) {
    return [...node.files].sort((a, b) => a.localeCompare(b));
  }
  /**
   * Count items in a subtree
   */
  static countInSubtree(subfolder, allPaths, matcher) {
    let count = 0;
    for (const p of allPaths) {
      if (p.startsWith(subfolder + "/") || p === subfolder) {
        if (!matcher || matcher(p)) {
          count++;
        }
      }
    }
    return count;
  }
};

// src/providers/SectionChildrenBuilder.ts
var vscode12 = __toESM(require("vscode"));
var path11 = __toESM(require("path"));
init_i18n();
var SectionChildrenBuilder = class {
  /**
   * Get children for SVG Files folder hierarchy
   */
  static getFolderChildren(folderPath, svgFiles) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const allPaths = [];
    for (const icon of svgFiles.values()) {
      const relativePath = path11.relative(workspaceRoot, icon.path).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const node = tree.get(folderPath);
    if (!node) return items;
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(node);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      const count = FolderTreeBuilder.countInSubtree(subfolder, allPaths);
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode12.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(node);
    for (const filePath of sortedFiles) {
      const fileName = path11.basename(filePath, ".svg");
      const fullPath = path11.join(workspaceRoot, filePath);
      const icon = Array.from(svgFiles.values()).find((i) => i.path === fullPath);
      if (icon) {
        items.push(
          new SvgItem(
            fileName,
            0,
            vscode12.TreeItemCollapsibleState.None,
            "icon",
            icon,
            `folder:${folderPath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Get children for Inline SVGs folder hierarchy
   */
  static getInlineDirChildren(dirPath, inlineSvgs) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const filePathsSet = /* @__PURE__ */ new Set();
    for (const icon of inlineSvgs.values()) {
      if (icon.filePath) {
        const relativePath = path11.relative(workspaceRoot, icon.filePath).replace(/\\\\/g, "/");
        filePathsSet.add(relativePath);
      }
    }
    const allPaths = Array.from(filePathsSet);
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const normalizedDir = dirPath === "(root)" ? "" : dirPath;
    const node = tree.get(normalizedDir);
    if (!node) return items;
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(node);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const icon of inlineSvgs.values()) {
        if (icon.filePath) {
          const relativePath = path11.relative(workspaceRoot, icon.filePath).replace(/\\\\/g, "/");
          if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
            count++;
          }
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode12.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `inlinedir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(node);
    for (const filePath of sortedFiles) {
      const fileName = path11.basename(filePath);
      const fullPath = path11.join(workspaceRoot, filePath);
      let count = 0;
      for (const icon of inlineSvgs.values()) {
        if (icon.filePath === fullPath) count++;
      }
      items.push(
        new SvgItem(
          fileName,
          count,
          vscode12.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `inline:${fullPath}`
        )
      );
    }
    return items;
  }
  /**
   * Get children (inline SVGs) for a specific file
   */
  static getInlineFileChildren(filePath, inlineSvgs) {
    const items = [];
    for (const icon of inlineSvgs.values()) {
      if (icon.filePath === filePath) {
        items.push(
          new SvgItem(
            icon.name,
            0,
            vscode12.TreeItemCollapsibleState.None,
            "icon",
            icon,
            `inline:${filePath}`
          )
        );
      }
    }
    return items.sort((a, b) => (a.icon?.line || 0) - (b.icon?.line || 0));
  }
  /**
   * Get children for IMG References folder hierarchy
   */
  static getRefsDirChildren(dirPath, svgReferences) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const allPaths = [];
    for (const filePath of svgReferences.keys()) {
      const relativePath = path11.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const normalizedDir = dirPath === "(root)" ? "" : dirPath;
    const node = tree.get(normalizedDir);
    if (!node) return items;
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(node);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const [filePath, refs] of svgReferences) {
        const relativePath = path11.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
        if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
          count += refs.length;
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode12.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `refsdir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(node);
    for (const relPath of sortedFiles) {
      const fileName = path11.basename(relPath);
      const fullPath = path11.join(workspaceRoot, relPath);
      const refs = svgReferences.get(fullPath);
      if (refs) {
        items.push(
          new SvgItem(
            fileName,
            refs.length,
            vscode12.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `refs:${fullPath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Get children (SVG references) for a specific file
   */
  static getRefsFileChildren(filePath, svgReferences) {
    const items = [];
    const refs = svgReferences.get(filePath);
    if (refs) {
      for (const icon of refs) {
        items.push(
          new SvgItem(
            icon.name,
            0,
            vscode12.TreeItemCollapsibleState.None,
            "icon",
            icon,
            `refs:${filePath}`
          )
        );
      }
    }
    return items.sort((a, b) => (a.icon?.line || 0) - (b.icon?.line || 0));
  }
  /**
   * Get children for Icon Component usages folder hierarchy
   */
  static getUsagesDirChildren(dirPath, iconUsages) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const usagesByFile = this.groupUsagesByFile(iconUsages);
    const allPaths = [];
    for (const filePath of usagesByFile.keys()) {
      const relativePath = path11.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const normalizedDir = dirPath === "(root)" ? "" : dirPath;
    const node = tree.get(normalizedDir);
    if (!node) return items;
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(node);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const [filePath, usageList] of usagesByFile) {
        const relativePath = path11.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
        if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
          count += usageList.length;
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode12.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `usagesdir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(node);
    for (const relPath of sortedFiles) {
      const fileName = path11.basename(relPath);
      const fullPath = path11.join(workspaceRoot, relPath);
      const usageList = usagesByFile.get(fullPath);
      if (usageList) {
        items.push(
          new SvgItem(
            fileName,
            usageList.length,
            vscode12.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `usages:${fullPath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Get children (icon usages) for a specific file
   */
  static getUsagesFileChildren(filePath, iconUsages, libraryIcons) {
    const items = [];
    const fileUsages = [];
    for (const [iconName, usages] of iconUsages) {
      for (const usage of usages) {
        if (usage.file === filePath) {
          fileUsages.push({ iconName, usage });
        }
      }
    }
    fileUsages.sort((a, b) => a.usage.line - b.usage.line);
    for (const { iconName, usage } of fileUsages) {
      const builtIcon = libraryIcons.get(iconName);
      const lineZeroBased = usage.line - 1;
      const iconNotInLibrary = !builtIcon;
      const item = new SvgItem(
        iconName,
        0,
        vscode12.TreeItemCollapsibleState.None,
        "icon",
        builtIcon ? { ...builtIcon, line: lineZeroBased, filePath } : {
          name: iconName,
          path: filePath,
          svg: "",
          source: "library",
          line: lineZeroBased,
          filePath,
          exists: false
          // Mark as not existing in library
        },
        `usages:${filePath}`
      );
      if (iconNotInLibrary) {
        item.description = `Line ${usage.line} \xB7 \u26A0 Not in library`;
        item.iconPath = new vscode12.ThemeIcon("warning", new vscode12.ThemeColor("editorWarning.foreground"));
      } else {
        item.description = `Line ${usage.line}`;
      }
      item.tooltip = iconNotInLibrary ? `${usage.preview}

\u26A0 Icon "${iconName}" is not in your library.
Click to import from Iconify.` : usage.preview;
      item.contextValue = iconNotInLibrary ? "iconUsageMissing" : "iconUsage";
      item.command = {
        command: "sageboxIconStudio.goToInlineSvg",
        title: t("commands.goToUsage"),
        arguments: [{ icon: { filePath, line: lineZeroBased } }]
      };
      items.push(item);
    }
    return items;
  }
  /**
   * Group icon usages by file
   */
  static groupUsagesByFile(iconUsages) {
    const usagesByFile = /* @__PURE__ */ new Map();
    for (const [iconName, usages] of iconUsages) {
      for (const usage of usages) {
        if (!usagesByFile.has(usage.file)) {
          usagesByFile.set(usage.file, []);
        }
        usagesByFile.get(usage.file).push({ iconName, usage });
      }
    }
    return usagesByFile;
  }
};

// src/providers/CategorySectionBuilder.ts
var vscode13 = __toESM(require("vscode"));
var path12 = __toESM(require("path"));
var CategorySectionBuilder = class {
  /**
   * Build children for the SVG Files section
   */
  static buildFilesSectionChildren(svgFiles) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const allPaths = [];
    for (const icon of svgFiles.values()) {
      const relativePath = path12.relative(workspaceRoot, icon.path).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const root = tree.get("");
    if (!root) {
      return this.buildFlatFilesList(svgFiles);
    }
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(root);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      const count = FolderTreeBuilder.countInSubtree(subfolder, allPaths);
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode13.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(root);
    for (const filePath of sortedFiles) {
      const fileName = path12.basename(filePath, ".svg");
      const fullPath = path12.join(workspaceRoot, filePath);
      const icon = Array.from(svgFiles.values()).find((i) => i.path === fullPath);
      if (icon) {
        items.push(
          new SvgItem(
            fileName,
            0,
            vscode13.TreeItemCollapsibleState.None,
            "icon",
            icon,
            "files-section"
          )
        );
      }
    }
    return items;
  }
  /**
   * Build a flat list of files when there's no folder structure
   */
  static buildFlatFilesList(svgFiles) {
    const items = [];
    const sortedIcons = Array.from(svgFiles.values()).sort((a, b) => a.name.localeCompare(b.name));
    for (const icon of sortedIcons) {
      items.push(
        new SvgItem(
          icon.name,
          0,
          vscode13.TreeItemCollapsibleState.None,
          "icon",
          icon,
          "files-section"
        )
      );
    }
    return items;
  }
  /**
   * Build children for the Inline SVGs section
   */
  static buildInlineSectionChildren(inlineSvgs) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const filePathsSet = /* @__PURE__ */ new Set();
    for (const icon of inlineSvgs.values()) {
      if (icon.filePath) {
        const relativePath = path12.relative(workspaceRoot, icon.filePath).replace(/\\\\/g, "/");
        filePathsSet.add(relativePath);
      }
    }
    const allPaths = Array.from(filePathsSet);
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const root = tree.get("");
    if (!root) {
      return [];
    }
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(root);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const icon of inlineSvgs.values()) {
        if (icon.filePath) {
          const relativePath = path12.relative(workspaceRoot, icon.filePath).replace(/\\\\/g, "/");
          if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
            count++;
          }
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode13.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `inlinedir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(root);
    for (const filePath of sortedFiles) {
      const fileName = path12.basename(filePath);
      const fullPath = path12.join(workspaceRoot, filePath);
      let count = 0;
      for (const icon of inlineSvgs.values()) {
        if (icon.filePath === fullPath) count++;
      }
      items.push(
        new SvgItem(
          fileName,
          count,
          vscode13.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `inline:${fullPath}`
        )
      );
    }
    return items;
  }
  /**
   * Build children for the IMG References section
   */
  static buildReferencesSectionChildren(svgReferences) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const allPaths = [];
    for (const filePath of svgReferences.keys()) {
      const relativePath = path12.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const root = tree.get("");
    if (!root) {
      return this.buildFlatReferencesList(svgReferences, workspaceRoot);
    }
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(root);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const [filePath, refs] of svgReferences) {
        const relativePath = path12.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
        if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
          count += refs.length;
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode13.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `refsdir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(root);
    for (const relPath of sortedFiles) {
      const fileName = path12.basename(relPath);
      const fullPath = path12.join(workspaceRoot, relPath);
      const refs = svgReferences.get(fullPath);
      if (refs) {
        items.push(
          new SvgItem(
            fileName,
            refs.length,
            vscode13.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `refs:${fullPath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Build a flat list of references when there's no folder structure
   */
  static buildFlatReferencesList(svgReferences, _workspaceRoot) {
    const items = [];
    const sortedFiles = Array.from(svgReferences.keys()).sort((a, b) => a.localeCompare(b));
    for (const filePath of sortedFiles) {
      const refs = svgReferences.get(filePath);
      if (refs) {
        const fileName = path12.basename(filePath);
        items.push(
          new SvgItem(
            fileName,
            refs.length,
            vscode13.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `refs:${filePath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Build children for the Icon Component Usages section
   */
  static buildUsagesSectionChildren(iconUsages) {
    const items = [];
    const workspaceRoot = FolderTreeBuilder.getWorkspaceRoot();
    const usagesByFile = SectionChildrenBuilder.groupUsagesByFile(iconUsages);
    const allPaths = [];
    for (const filePath of usagesByFile.keys()) {
      const relativePath = path12.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
      allPaths.push(relativePath);
    }
    const tree = FolderTreeBuilder.buildFolderTree(allPaths);
    const root = tree.get("");
    if (!root) {
      return this.buildFlatUsagesList(usagesByFile);
    }
    const sortedSubfolders = FolderTreeBuilder.getSortedSubfolders(root);
    for (const subfolder of sortedSubfolders) {
      const folderName = subfolder.split("/").pop() || subfolder;
      let count = 0;
      for (const [filePath, usageList] of usagesByFile) {
        const relativePath = path12.relative(workspaceRoot, filePath).replace(/\\\\/g, "/");
        if (relativePath.startsWith(subfolder + "/") || relativePath === subfolder) {
          count += usageList.length;
        }
      }
      items.push(
        new SvgItem(
          folderName,
          count,
          vscode13.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `usagesdir:${subfolder}`
        )
      );
    }
    const sortedFiles = FolderTreeBuilder.getSortedFiles(root);
    for (const relPath of sortedFiles) {
      const fileName = path12.basename(relPath);
      const fullPath = path12.join(workspaceRoot, relPath);
      const usageList = usagesByFile.get(fullPath);
      if (usageList) {
        items.push(
          new SvgItem(
            fileName,
            usageList.length,
            vscode13.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `usages:${fullPath}`
          )
        );
      }
    }
    return items;
  }
  /**
   * Build a flat list of usages when there's no folder structure
   */
  static buildFlatUsagesList(usagesByFile) {
    const items = [];
    const sortedFiles = Array.from(usagesByFile.keys()).sort((a, b) => a.localeCompare(b));
    for (const filePath of sortedFiles) {
      const usageList = usagesByFile.get(filePath);
      if (usageList) {
        const fileName = path12.basename(filePath);
        items.push(
          new SvgItem(
            fileName,
            usageList.length,
            vscode13.TreeItemCollapsibleState.Collapsed,
            "category",
            void 0,
            `usages:${filePath}`
          )
        );
      }
    }
    return items;
  }
};

// src/providers/TreeNavigationHelper.ts
var TreeNavigationHelper = class {
  /**
   * Build a tree structure from paths
   * @deprecated Use FolderTreeBuilder.buildFolderTree instead
   */
  static buildFolderTree(paths) {
    return FolderTreeBuilder.buildFolderTree(paths);
  }
  /**
   * Get workspace root path
   * @deprecated Use FolderTreeBuilder.getWorkspaceRoot instead
   */
  static getWorkspaceRoot() {
    return FolderTreeBuilder.getWorkspaceRoot();
  }
  /**
   * Get children for SVG Files folder hierarchy
   */
  static getFolderChildren(folderPath, svgFiles) {
    return SectionChildrenBuilder.getFolderChildren(folderPath, svgFiles);
  }
  /**
   * Get children for Inline SVGs folder hierarchy
   */
  static getInlineDirChildren(dirPath, inlineSvgs) {
    return SectionChildrenBuilder.getInlineDirChildren(dirPath, inlineSvgs);
  }
  /**
   * Get children (inline SVGs) for a specific file
   */
  static getInlineFileChildren(filePath, inlineSvgs) {
    return SectionChildrenBuilder.getInlineFileChildren(filePath, inlineSvgs);
  }
  /**
   * Get children for IMG References folder hierarchy
   */
  static getRefsDirChildren(dirPath, svgReferences) {
    return SectionChildrenBuilder.getRefsDirChildren(dirPath, svgReferences);
  }
  /**
   * Get children (SVG references) for a specific file
   */
  static getRefsFileChildren(filePath, svgReferences) {
    return SectionChildrenBuilder.getRefsFileChildren(filePath, svgReferences);
  }
  /**
   * Get children for Icon Component usages folder hierarchy
   */
  static getUsagesDirChildren(dirPath, iconUsages) {
    return SectionChildrenBuilder.getUsagesDirChildren(dirPath, iconUsages);
  }
  /**
   * Get children (icon usages) for a specific file
   */
  static getUsagesFileChildren(filePath, iconUsages, libraryIcons) {
    return SectionChildrenBuilder.getUsagesFileChildren(filePath, iconUsages, libraryIcons);
  }
  /**
   * Group icon usages by file
   */
  static groupUsagesByFile(iconUsages) {
    return SectionChildrenBuilder.groupUsagesByFile(iconUsages);
  }
  /**
   * Build section children for files section
   */
  static buildFilesSectionChildren(svgFiles) {
    return CategorySectionBuilder.buildFilesSectionChildren(svgFiles);
  }
  /**
   * Build section children for inline section
   */
  static buildInlineSectionChildren(inlineSvgs) {
    return CategorySectionBuilder.buildInlineSectionChildren(inlineSvgs);
  }
  /**
   * Build section children for references section
   */
  static buildReferencesSectionChildren(svgReferences) {
    return CategorySectionBuilder.buildReferencesSectionChildren(svgReferences);
  }
  /**
   * Build section children for usages section
   */
  static buildUsagesSectionChildren(iconUsages) {
    return CategorySectionBuilder.buildUsagesSectionChildren(iconUsages);
  }
};

// src/providers/IconCacheService.ts
var vscode14 = __toESM(require("vscode"));
var IconCacheService = class {
  itemCache = /* @__PURE__ */ new Map();
  /**
   * Cache an item by its ID
   */
  cacheItem(item) {
    if (item.id) {
      this.itemCache.set(item.id, item);
    }
    return item;
  }
  /**
   * Get a cached item by its ID
   */
  getItemById(id) {
    return this.itemCache.get(id);
  }
  /**
   * Clear all cached items
   */
  clear() {
    this.itemCache.clear();
  }
  /**
   * Delete items matching a filter predicate
   */
  deleteMatching(predicate) {
    for (const [key, item] of this.itemCache.entries()) {
      if (predicate(key, item)) {
        this.itemCache.delete(key);
      }
    }
  }
  /**
   * Find item in cache by icon name or path
   */
  findItemByIconNameOrPath(iconName, filePath, lineNumber) {
    let exactMatchWithLine;
    let exactNameMatch;
    let pathMatch;
    for (const [_id, item] of this.itemCache) {
      if (item.type === "icon" && item.icon) {
        if (item.icon.name === iconName) {
          if (lineNumber !== void 0 && item.icon.line === lineNumber - 1) {
            if (filePath && (item.icon.path === filePath || item.icon.filePath === filePath)) {
              return item;
            }
            exactMatchWithLine = item;
          }
          if (filePath && (item.icon.path === filePath || item.icon.filePath === filePath)) {
            if (!exactNameMatch) {
              exactNameMatch = item;
            }
          } else if (!exactNameMatch && !filePath) {
            exactNameMatch = item;
          }
        }
        if (!pathMatch && filePath && (item.icon.path === filePath || item.icon.filePath === filePath)) {
          if (lineNumber !== void 0 && item.icon.line === lineNumber - 1) {
            pathMatch = item;
          } else if (lineNumber === void 0) {
            pathMatch = item;
          }
        }
      }
    }
    return exactMatchWithLine || exactNameMatch || pathMatch;
  }
  /**
   * Create a SvgItem from a WorkspaceIcon for TreeView reveal
   */
  createSvgItemFromIcon(icon) {
    if (!icon) return void 0;
    const cachedItem = this.findItemByIconNameOrPath(
      icon.name,
      icon.filePath || icon.path,
      icon.line !== void 0 ? icon.line + 1 : void 0
    );
    if (cachedItem) {
      return cachedItem;
    }
    const isBuilt = icon.isBuilt || false;
    const isImgRef = icon.category === "img-ref";
    const isMissingRef = isImgRef && icon.exists === false;
    let contextValue;
    if (isMissingRef) {
      contextValue = "missingRef";
    } else if (isImgRef) {
      contextValue = "imgRef";
    } else if (isBuilt) {
      contextValue = "builtIcon";
    } else if (icon.source === "inline") {
      contextValue = "inlineSvg";
    } else {
      contextValue = "svgIcon";
    }
    const item = new SvgItem(
      icon.name,
      0,
      vscode14.TreeItemCollapsibleState.None,
      "icon",
      icon,
      void 0
    );
    item.contextValue = contextValue;
    return item;
  }
};

// src/providers/IconLookupService.ts
var fs11 = __toESM(require("fs"));
var IconLookupService = class {
  /**
   * Get an icon by name, checking all sources
   * Priority: library (built) > svg files > inline SVGs
   */
  static getIcon(name, storage) {
    const found = storage.libraryIcons.get(name) || storage.svgFiles.get(name);
    if (found && !found.svg && found.path && fs11.existsSync(found.path)) {
      try {
        found.svg = fs11.readFileSync(found.path, "utf-8");
      } catch (err) {
        console.error("[Icon Studio] Error reading SVG for hover:", found.path, err);
      }
    }
    if (found) return found;
    for (const icon of storage.inlineSvgs.values()) {
      if (icon.name === name || icon.name.toLowerCase() === name.toLowerCase()) {
        return icon;
      }
    }
    return void 0;
  }
  /**
   * Get icon by name from any source (library, SVG files, inline, or references)
   */
  static getIconByName(name, storage) {
    const found = storage.libraryIcons.get(name) || storage.svgFiles.get(name) || storage.inlineSvgs.get(name);
    if (found) return found;
    for (const icons of storage.svgReferences.values()) {
      for (const icon of icons) {
        if (icon.name === name) {
          return icon;
        }
      }
    }
    return void 0;
  }
  /**
   * Find icon by file path
   */
  static getIconByPath(filePath, storage) {
    for (const icon of storage.svgFiles.values()) {
      if (icon.path === filePath) {
        return icon;
      }
    }
    for (const icon of storage.inlineSvgs.values()) {
      if (icon.filePath === filePath || icon.path === filePath) {
        return icon;
      }
    }
    for (const icons of storage.svgReferences.values()) {
      for (const icon of icons) {
        if (icon.path === filePath || icon.filePath === filePath) {
          return icon;
        }
      }
    }
    return void 0;
  }
  /**
   * Get SVG data for preview panel
   */
  static getSvgData(item) {
    if (!item.icon) return void 0;
    const icon = item.icon;
    if (icon.svg) {
      return {
        name: icon.name,
        svg: icon.svg,
        location: icon.filePath && icon.line ? { file: icon.filePath, line: icon.line } : void 0,
        animation: icon.animation
      };
    }
    if (icon.path && fs11.existsSync(icon.path)) {
      try {
        const svg = fs11.readFileSync(icon.path, "utf-8");
        return {
          name: icon.name,
          svg,
          location: { file: icon.path, line: 1 }
        };
      } catch {
        return void 0;
      }
    }
    return void 0;
  }
  /**
   * Get all IMG references from the workspace
   */
  static getImgReferences(svgReferences) {
    const refs = [];
    for (const icons of svgReferences.values()) {
      for (const icon of icons) {
        if (!icon.svg && icon.path && icon.exists !== false && fs11.existsSync(icon.path)) {
          try {
            icon.svg = fs11.readFileSync(icon.path, "utf-8");
          } catch (err) {
            console.error("[Icon Studio] Error reading SVG:", icon.path, err);
          }
        }
        refs.push(icon);
      }
    }
    return refs;
  }
  /**
   * Get all icons (workspace + library)
   */
  static getAllIcons(storage) {
    const all = [];
    for (const icon of storage.svgFiles.values()) {
      all.push(icon);
    }
    for (const icon of storage.libraryIcons.values()) {
      all.push(icon);
    }
    return all;
  }
  /**
   * Get list of built icons only
   */
  static getBuiltIconsList(libraryIcons) {
    const builtIcons = [];
    for (const icon of libraryIcons.values()) {
      if (icon.isBuilt) {
        builtIcons.push(icon);
      }
    }
    return builtIcons;
  }
  /**
   * Get inline SVGs as array
   */
  static getInlineSvgs(inlineSvgs) {
    return Array.from(inlineSvgs.values());
  }
  /**
   * Get inline SVG by key
   */
  static getInlineSvgByKey(key, inlineSvgs) {
    return inlineSvgs.get(key);
  }
};

// src/providers/IconCategoryService.ts
var path13 = __toESM(require("path"));
var IconCategoryService = class {
  /**
   * Get all categories with their counts
   */
  static getCategories(storage) {
    const categoryCount = /* @__PURE__ */ new Map();
    for (const icon of storage.svgFiles.values()) {
      const cat = icon.category || "workspace";
      const existing = categoryCount.get(cat);
      categoryCount.set(cat, {
        count: (existing?.count || 0) + 1,
        type: "folder"
      });
    }
    const libraryByFile = /* @__PURE__ */ new Map();
    for (const icon of storage.libraryIcons.values()) {
      const fileName = path13.basename(icon.path);
      libraryByFile.set(fileName, (libraryByFile.get(fileName) || 0) + 1);
    }
    for (const [fileName, count] of libraryByFile) {
      categoryCount.set(`\u{1F4E6} ${fileName}`, { count, type: "library" });
    }
    if (storage.inlineSvgs.size > 0) {
      const inlineByFile = /* @__PURE__ */ new Map();
      for (const icon of storage.inlineSvgs.values()) {
        if (icon.filePath) {
          const fileName = path13.basename(icon.filePath);
          inlineByFile.set(fileName, (inlineByFile.get(fileName) || 0) + 1);
        }
      }
      for (const [fileName, count] of inlineByFile) {
        categoryCount.set(`\u{1F4C4} ${fileName}`, { count, type: "file" });
      }
    }
    if (storage.svgReferences.size > 0) {
      for (const [filePath, refs] of storage.svgReferences) {
        const fileName = path13.basename(filePath);
        categoryCount.set(`\u{1F517} ${fileName}`, { count: refs.length, type: "file" });
      }
    }
    return Array.from(categoryCount.entries()).map(([name, data]) => ({ name, count: data.count, type: data.type })).sort((a, b) => {
      if (a.type !== b.type) {
        if (a.type === "library") return -1;
        if (b.type === "library") return 1;
      }
      return a.name.localeCompare(b.name);
    });
  }
  /**
   * Get icons by category string
   */
  static getIconsByCategory(category, storage) {
    const icons = [];
    if (category.startsWith("built:")) {
      const fileName = category.replace("built:", "");
      for (const icon of storage.libraryIcons.values()) {
        if (icon.isBuilt && path13.basename(icon.path) === fileName) {
          icons.push(icon);
        }
      }
      return icons.sort((a, b) => a.name.localeCompare(b.name));
    }
    if (category.startsWith("folder:")) {
      const folder = category.replace("folder:", "");
      for (const icon of storage.svgFiles.values()) {
        if ((icon.category || "root") === folder) {
          icons.push(icon);
        }
      }
      return icons.sort((a, b) => a.name.localeCompare(b.name));
    }
    if (category.startsWith("inline:")) {
      const filePath = category.replace("inline:", "");
      for (const icon of storage.inlineSvgs.values()) {
        if (icon.filePath === filePath) {
          icons.push(icon);
        }
      }
      return icons.sort((a, b) => (a.line || 0) - (b.line || 0));
    }
    if (category.startsWith("refs:")) {
      const filePath = category.replace("refs:", "");
      const refs = storage.svgReferences.get(filePath);
      if (refs) {
        icons.push(...refs);
      }
      return icons.sort((a, b) => (a.line || 0) - (b.line || 0));
    }
    if (category.startsWith("\u{1F4E6} ")) {
      const fileName = category.replace("\u{1F4E6} ", "");
      for (const icon of storage.libraryIcons.values()) {
        if (path13.basename(icon.path) === fileName) {
          icons.push(icon);
        }
      }
      return icons.sort((a, b) => a.name.localeCompare(b.name));
    }
    if (category.startsWith("\u{1F4C4} ")) {
      const fileName = category.replace("\u{1F4C4} ", "");
      for (const icon of storage.inlineSvgs.values()) {
        if (icon.filePath && path13.basename(icon.filePath) === fileName) {
          icons.push(icon);
        }
      }
      return icons.sort((a, b) => (a.line || 0) - (b.line || 0));
    }
    if (category.startsWith("\u{1F517} ")) {
      const fileName = category.replace("\u{1F517} ", "");
      for (const [filePath, refs] of storage.svgReferences) {
        if (path13.basename(filePath) === fileName) {
          icons.push(...refs);
        }
      }
      return icons.sort((a, b) => (a.line || 0) - (b.line || 0));
    }
    for (const icon of storage.svgFiles.values()) {
      if (icon.category === category) {
        icons.push(icon);
      }
    }
    return icons.sort((a, b) => a.name.localeCompare(b.name));
  }
};

// src/providers/TreeParentResolver.ts
var vscode15 = __toESM(require("vscode"));
var path14 = __toESM(require("path"));
var TreeParentResolver = class {
  static SECTIONS = {
    built: { label: "Built Library", category: "built" },
    files: { label: "SVG Files", category: "files" },
    inline: { label: "Inline SVGs", category: "inline" },
    references: { label: "IMG References", category: "references" }
  };
  /**
   * Get parent item for a given tree element
   */
  static getParent(element) {
    if (!element) return void 0;
    if (!element.category && element.type === "icon") {
      return void 0;
    }
    if (element.type === "section") {
      return void 0;
    }
    if (element.type === "category" && element.category) {
      return this.getCategoryParent(element);
    }
    if (element.type === "icon" && element.icon) {
      return this.getIconParent(element);
    }
    return void 0;
  }
  /**
   * Get parent for category/folder items
   */
  static getCategoryParent(element) {
    const category = element.category;
    if (category.startsWith("built:")) {
      return this.createSectionItem("Built Library", "built");
    }
    if (category.startsWith("folder:")) {
      return this.getFolderParent(category);
    }
    if (category.startsWith("inlinedir:") || category.startsWith("inline:")) {
      return this.createSectionItem("Inline SVGs", "inline");
    }
    if (category.startsWith("refsdir:") || category.startsWith("refs:")) {
      return this.createSectionItem("IMG References", "references");
    }
    return void 0;
  }
  /**
   * Get parent for folder items in SVG Files section
   */
  static getFolderParent(category) {
    const folderPath = category.replace("folder:", "");
    const parentDir = folderPath.substring(0, folderPath.lastIndexOf("/"));
    if (parentDir) {
      return new SvgItem(
        parentDir.split("/").pop() || parentDir,
        0,
        vscode15.TreeItemCollapsibleState.Collapsed,
        "category",
        void 0,
        `folder:${parentDir}`
      );
    }
    return this.createSectionItem("SVG Files", "files");
  }
  /**
   * Get parent for icon items
   */
  static getIconParent(element) {
    const icon = element.icon;
    if (icon.isBuilt && icon.path) {
      const fileName = path14.basename(icon.path);
      return new SvgItem(
        fileName,
        0,
        vscode15.TreeItemCollapsibleState.Collapsed,
        "category",
        void 0,
        `built:${fileName}`
      );
    }
    if (icon.path && !icon.filePath) {
      const relativePath = vscode15.workspace.asRelativePath(icon.path);
      const dir = relativePath.substring(0, relativePath.lastIndexOf("/"));
      if (dir) {
        return new SvgItem(
          dir.split("/").pop() || dir,
          0,
          vscode15.TreeItemCollapsibleState.Collapsed,
          "category",
          void 0,
          `folder:${dir}`
        );
      }
      return this.createSectionItem("SVG Files", "files");
    }
    if (icon.filePath && icon.name.startsWith("svg-") && !icon.path) {
      const relativePath = vscode15.workspace.asRelativePath(icon.filePath);
      return new SvgItem(
        path14.basename(icon.filePath),
        0,
        vscode15.TreeItemCollapsibleState.Collapsed,
        "category",
        void 0,
        `inline:${relativePath}`
      );
    }
    if (icon.category === "img-ref" && icon.filePath) {
      const relativePath = vscode15.workspace.asRelativePath(icon.filePath);
      return new SvgItem(
        path14.basename(icon.filePath),
        0,
        vscode15.TreeItemCollapsibleState.Collapsed,
        "category",
        void 0,
        `refs:${relativePath}`
      );
    }
    return void 0;
  }
  /**
   * Create a section item
   */
  static createSectionItem(label, category) {
    return new SvgItem(
      label,
      0,
      vscode15.TreeItemCollapsibleState.Collapsed,
      "section",
      void 0,
      category
    );
  }
};

// src/providers/IconRemovalService.ts
var vscode16 = __toESM(require("vscode"));
var path15 = __toESM(require("path"));
var fs12 = __toESM(require("fs"));
init_config();

// src/utils/outputFileManager.ts
function toVariableName(name) {
  return name.split(/[-:]/).map((part, i) => i === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)).join("");
}
function generateIconExport(iconName, body, viewBox = "0 0 24 24", animation) {
  const varName = toVariableName(iconName);
  if (animation) {
    const delay = animation.delay ?? 0;
    const direction = animation.direction || "normal";
    return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}',
  animation: { type: '${animation.type}', duration: ${animation.duration}, timing: '${animation.timing}', iteration: '${animation.iteration}', delay: ${delay}, direction: '${direction}' }
};`;
  }
  return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}'
};`;
}
function extractIconsObjectContent(content) {
  const iconsMatch = content.match(/export const icons = \{/);
  if (!iconsMatch || iconsMatch.index === void 0) {
    return null;
  }
  const startIndex = iconsMatch.index + iconsMatch[0].length;
  let braceCount = 1;
  let endIndex = startIndex;
  while (braceCount > 0 && endIndex < content.length) {
    if (content[endIndex] === "{") braceCount++;
    if (content[endIndex] === "}") braceCount--;
    endIndex++;
  }
  return {
    startIndex,
    endIndex: endIndex - 1,
    // Position of closing brace
    inner: content.substring(startIndex, endIndex - 1)
  };
}
function removeIconExportFromContent(content, iconName) {
  const varName = toVariableName(iconName);
  const exportRegex = new RegExp(`export const ${varName}\\s*=\\s*\\{[\\s\\S]*?\\};\\n?\\n?`, "g");
  let result = content.replace(exportRegex, "");
  const objRegex = new RegExp(`\\s*\\b${varName}\\b,?`, "g");
  const iconsMatch = result.match(/export const icons = \{/);
  if (iconsMatch && iconsMatch.index !== void 0) {
    const startIndex = iconsMatch.index + iconsMatch[0].length;
    let braceCount = 1;
    let endIndex = startIndex;
    while (braceCount > 0 && endIndex < result.length) {
      if (result[endIndex] === "{") braceCount++;
      if (result[endIndex] === "}") braceCount--;
      endIndex++;
    }
    const inner = result.substring(startIndex, endIndex - 1);
    let cleaned = inner.replace(objRegex, "").trim();
    cleaned = cleaned.replace(/,\s*$/, "");
    const withoutComments = cleaned.replace(/\/\/[^\n]*/g, "").trim();
    if (!withoutComments || withoutComments === ",") {
      cleaned = "";
    }
    let newInner;
    if (!cleaned) {
      newInner = "";
    } else {
      const iconNames = cleaned.split(",").map((s) => s.trim()).filter(Boolean);
      newInner = "\n  " + iconNames.join(",\n  ") + "\n";
    }
    result = result.substring(0, startIndex) + newInner + result.substring(endIndex - 1);
  }
  result = result.replace(/\n{3,}/g, "\n\n");
  return result;
}
function buildIconsFileContent(icons, transformer) {
  let iconExports = "// Auto-generated by Icon Studio\n// Do not edit manually\n\n";
  const iconNames = [];
  for (const icon of icons) {
    if (!icon.svg) continue;
    const varName = toVariableName(icon.name);
    const body = transformer.extractSvgBody(icon.svg);
    const attrs = transformer.extractSvgAttributes(icon.svg);
    iconExports += generateIconExport(icon.name, body, attrs.viewBox || "0 0 24 24", icon.animation) + "\n\n";
    iconNames.push(varName);
  }
  iconExports += `export const icons = {
  ${iconNames.join(",\n  ")}
};
`;
  return iconExports;
}

// src/providers/IconRemovalService.ts
var IconRemovalService = class {
  /**
   * Remove icons from the icons.js file
   * @param iconNames Names of icons to remove
   * @param builtIcons Set of built icon names (will be modified)
   * @param libraryIcons Map of library icons (will be modified)
   * @returns Result with success status, removed icons, and errors
   */
  static async removeIcons(iconNames, builtIcons, libraryIcons) {
    const outputDir = getSvgConfig("outputDirectory", "");
    const removed = [];
    const errors = [];
    if (!outputDir) {
      return { success: false, removed, errors: ["No output directory configured"] };
    }
    const workspaceFolders = vscode16.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return { success: false, removed, errors: ["No workspace folder found"] };
    }
    const fullOutputPath = path15.join(workspaceFolders[0].uri.fsPath, outputDir);
    const iconsJsPath = path15.join(fullOutputPath, "icons.js");
    if (!fs12.existsSync(iconsJsPath)) {
      return { success: false, removed, errors: ["icons.js not found"] };
    }
    try {
      let content = fs12.readFileSync(iconsJsPath, "utf-8");
      for (const iconName of iconNames) {
        const originalContent = content;
        content = removeIconExportFromContent(content, iconName);
        if (content !== originalContent) {
          removed.push(iconName);
          builtIcons.delete(iconName);
          libraryIcons.delete(iconName);
        } else {
          errors.push(`Could not find icon: ${iconName}`);
        }
      }
      content = content.replace(/\n{3,}/g, "\n\n");
      fs12.writeFileSync(iconsJsPath, content);
      return { success: removed.length > 0, removed, errors };
    } catch (error) {
      return { success: false, removed, errors: [`Error: ${error}`] };
    }
  }
  /**
   * Get the icons.js file path if it exists
   * @returns Path to icons.js or undefined if not found
   */
  static getIconsJsPath() {
    const outputDir = getSvgConfig("outputDirectory", "");
    if (!outputDir) return void 0;
    const workspaceFolders = vscode16.workspace.workspaceFolders;
    if (!workspaceFolders) return void 0;
    const fullOutputPath = path15.join(workspaceFolders[0].uri.fsPath, outputDir);
    const iconsJsPath = path15.join(fullOutputPath, "icons.js");
    return fs12.existsSync(iconsJsPath) ? iconsJsPath : void 0;
  }
};

// src/providers/WorkspaceSvgProvider.ts
var WorkspaceSvgProvider = class {
  _onDidChangeTreeData = new vscode17.EventEmitter();
  onDidChangeTreeData = this._onDidChangeTreeData.event;
  svgFiles = /* @__PURE__ */ new Map();
  libraryIcons = /* @__PURE__ */ new Map();
  inlineSvgs = /* @__PURE__ */ new Map();
  svgReferences = /* @__PURE__ */ new Map();
  // Files with <img src="...svg">
  builtIcons = /* @__PURE__ */ new Set();
  iconUsages = /* @__PURE__ */ new Map();
  context;
  scanner;
  cacheService;
  isInitialized = false;
  isScanning = false;
  usagesScanned = false;
  constructor(context) {
    this.context = context;
    this.scanner = new SvgScanner(context);
    this.cacheService = new IconCacheService();
  }
  refresh() {
    this.svgFiles.clear();
    this.libraryIcons.clear();
    this.inlineSvgs.clear();
    this.svgReferences.clear();
    this.builtIcons.clear();
    this.iconUsages.clear();
    this.cacheService.clear();
    this.isInitialized = false;
    this.usagesScanned = false;
    SvgContentCache.getInstance().clear();
    clearTempIcons();
    this._onDidChangeTreeData.fire();
  }
  /**
   * Soft refresh - re-renders tree without clearing cache
   * This preserves expansion state better than full refresh
   */
  softRefresh() {
    this._onDidChangeTreeData.fire();
  }
  /**
   * Remove an SVG file from the cache without triggering refresh
   * Call the specific provider's refresh method after this
   */
  removeSvgFile(iconName) {
    this.svgFiles.delete(iconName);
  }
  /**
   * Update SVG file content in cache without full refresh
   * Used when a file is modified externally
   */
  updateSvgFileContent(filePath) {
    const iconName = path16.basename(filePath, ".svg");
    const existingIcon = this.svgFiles.get(iconName);
    SvgContentCache.getInstance().invalidate(filePath);
    if (existingIcon && fs13.existsSync(filePath)) {
      try {
        const newContent = SvgContentCache.getInstance().getContent(filePath);
        if (newContent) {
          existingIcon.svg = newContent;
        }
        clearTempIcons();
      } catch {
      }
    }
  }
  /**
   * Add or update an icon in the built icons without triggering refresh
   * Call the specific provider's refresh method after this
   */
  addBuiltIcon(iconName, icon) {
    this.libraryIcons.set(iconName, icon);
    this.builtIcons.add(iconName);
  }
  /**
   * Rename a built icon in the cache (partial refresh)
   * Updates all internal caches and fires a partial tree update
   */
  renameBuiltIcon(oldName, newName) {
    const icon = this.libraryIcons.get(oldName);
    if (icon) {
      icon.name = newName;
      this.libraryIcons.delete(oldName);
      this.libraryIcons.set(newName, icon);
      this.builtIcons.delete(oldName);
      this.builtIcons.add(newName);
      this.cacheService.deleteMatching(
        (key, item) => key.includes(oldName) || key.includes("built:") || (item.category?.startsWith("built:") ?? false)
      );
      clearTempIcons();
      this._onDidChangeTreeData.fire(void 0);
    }
  }
  /**
   * Rename an SVG file in the cache (partial refresh)
   */
  renameSvgFile(oldName, newName, newPath) {
    const icon = this.svgFiles.get(oldName);
    if (icon) {
      icon.name = newName;
      icon.path = newPath;
      this.svgFiles.delete(oldName);
      this.svgFiles.set(newName, icon);
      this.cacheService.deleteMatching(
        (key, item) => key.includes(oldName) || key.includes("folder:") || (item.category?.startsWith("folder:") ?? false)
      );
      clearTempIcons();
      this._onDidChangeTreeData.fire(void 0);
    }
  }
  getTreeItem(element) {
    this.cacheService.cacheItem(element);
    return element;
  }
  // Required for TreeView.reveal() to work with hierarchical structures
  getParent(element) {
    return TreeParentResolver.getParent(element);
  }
  // Ensure the provider is initialized (call before searching for icons)
  async ensureInitialized() {
    if (!this.isInitialized && !this.isScanning) {
      this.isScanning = true;
      await this.initialize();
      this.isInitialized = true;
      this.isScanning = false;
    }
  }
  async getChildren(element) {
    if (!isFullyConfigured()) {
      if (!element) {
        const configureItem = new SvgItem(
          "Configurar Icon Studio",
          0,
          vscode17.TreeItemCollapsibleState.None,
          "action",
          void 0,
          "configure"
        );
        configureItem.command = {
          command: "sageboxIconStudio.showWelcome",
          title: "Configurar Icon Studio"
        };
        configureItem.iconPath = new vscode17.ThemeIcon("gear");
        return [configureItem];
      }
      return [];
    }
    if (!this.isInitialized && !this.isScanning) {
      this.isScanning = true;
      await this.initialize();
      this.isInitialized = true;
      this.isScanning = false;
    }
    if (!element) {
      return this.getRootSections();
    }
    if (element.type === "section") {
      return await this.getSectionChildren(element.category);
    }
    if (element.type === "category") {
      if (element.category?.startsWith("folder:")) {
        return this.getFolderChildren(element.category.replace("folder:", ""));
      }
      if (element.category?.startsWith("inlinedir:")) {
        return this.getInlineDirChildren(element.category.replace("inlinedir:", ""));
      }
      if (element.category?.startsWith("inline:")) {
        return this.getInlineFileChildren(element.category.replace("inline:", ""));
      }
      if (element.category?.startsWith("refsdir:")) {
        return this.getRefsDirChildren(element.category.replace("refsdir:", ""));
      }
      if (element.category?.startsWith("refs:")) {
        return this.getRefsFileChildren(element.category.replace("refs:", ""));
      }
      if (element.category?.startsWith("usagesdir:")) {
        return this.getUsagesDirChildren(element.category.replace("usagesdir:", ""));
      }
      if (element.category?.startsWith("usages:")) {
        return this.getUsagesFileChildren(element.category.replace("usages:", ""));
      }
      if (element.category?.startsWith("built:")) {
        const icons2 = this.getIconsByCategory(element.category);
        return icons2.map((icon) => {
          const hasUsages = icon.usages && icon.usages.length > 0;
          return new SvgItem(
            icon.name,
            0,
            hasUsages ? vscode17.TreeItemCollapsibleState.Collapsed : vscode17.TreeItemCollapsibleState.None,
            "icon",
            icon,
            element.category
          );
        });
      }
      const icons = this.getIconsByCategory(element.category);
      return icons.map((icon) => {
        const hasUsages = icon.usages && icon.usages.length > 0;
        return new SvgItem(
          icon.name,
          0,
          hasUsages ? vscode17.TreeItemCollapsibleState.Collapsed : vscode17.TreeItemCollapsibleState.None,
          "icon",
          icon,
          element.category
        );
      });
    }
    if (element.type === "icon" && element.icon?.usages && element.icon.usages.length > 0) {
      return element.icon.usages.map((usage) => {
        const shortFile = usage.file.split(/[\\/]/).slice(-2).join("/");
        return new SvgItem(
          `${shortFile}:${usage.line}`,
          0,
          vscode17.TreeItemCollapsibleState.None,
          "usage",
          element.icon,
          element.category,
          usage
        );
      });
    }
    return [];
  }
  // Get children for SVG Files folder hierarchy
  getFolderChildren(folderPath) {
    return TreeNavigationHelper.getFolderChildren(folderPath, this.svgFiles);
  }
  // Get children for Inline SVGs folder hierarchy
  getInlineDirChildren(dirPath) {
    return TreeNavigationHelper.getInlineDirChildren(dirPath, this.inlineSvgs);
  }
  // Get children (inline SVGs) for a specific file
  getInlineFileChildren(filePath) {
    return TreeNavigationHelper.getInlineFileChildren(filePath, this.inlineSvgs);
  }
  // Get children for IMG References folder hierarchy
  getRefsDirChildren(dirPath) {
    return TreeNavigationHelper.getRefsDirChildren(dirPath, this.svgReferences);
  }
  // Get children (SVG references) for a specific file
  getRefsFileChildren(filePath) {
    return TreeNavigationHelper.getRefsFileChildren(filePath, this.svgReferences);
  }
  // Get children for Icon Component usages folder hierarchy
  getUsagesDirChildren(dirPath) {
    return TreeNavigationHelper.getUsagesDirChildren(dirPath, this.iconUsages);
  }
  // Get children (icon usages) for a specific file
  getUsagesFileChildren(filePath) {
    return TreeNavigationHelper.getUsagesFileChildren(filePath, this.iconUsages, this.libraryIcons);
  }
  // Get children for a directory category (legacy - kept for compatibility)
  getDirectoryChildren(category) {
    if (category.startsWith("inlinedir:")) {
      return this.getInlineDirChildren(category.replace("inlinedir:", ""));
    } else if (category.startsWith("refsdir:")) {
      return this.getRefsDirChildren(category.replace("refsdir:", ""));
    }
    return [];
  }
  getRootSections() {
    const sections = [];
    if (this.inlineSvgs.size > 0) {
      sections.push(
        new SvgItem(
          "Inline SVGs",
          this.inlineSvgs.size,
          vscode17.TreeItemCollapsibleState.Collapsed,
          "section",
          void 0,
          "inline"
        )
      );
    }
    if (this.svgReferences.size > 0) {
      const totalRefs = Array.from(this.svgReferences.values()).reduce(
        (sum, refs) => sum + refs.length,
        0
      );
      sections.push(
        new SvgItem(
          "IMG References",
          totalRefs,
          vscode17.TreeItemCollapsibleState.Collapsed,
          "section",
          void 0,
          "references"
        )
      );
    }
    const hasBuiltIcons = Array.from(this.libraryIcons.values()).some((icon) => icon.isBuilt);
    if (hasBuiltIcons) {
      const totalUsages = this.usagesScanned ? Array.from(this.iconUsages.values()).reduce((sum, usages) => sum + usages.length, 0) : void 0;
      sections.push(
        new SvgItem(
          "Icon Component",
          totalUsages ?? 0,
          vscode17.TreeItemCollapsibleState.Collapsed,
          "section",
          void 0,
          "icon_usages_section"
        )
      );
    }
    if (sections.length === 0) {
      return [
        new SvgItem(
          "No SVGs in code - Click to scan",
          0,
          vscode17.TreeItemCollapsibleState.None,
          "action",
          void 0,
          void 0
        )
      ];
    }
    return sections;
  }
  async getSectionChildren(sectionId) {
    switch (sectionId) {
      case "built": {
        const items = [];
        const byFile = /* @__PURE__ */ new Map();
        for (const icon of this.libraryIcons.values()) {
          if (icon.isBuilt) {
            const fileName = path16.basename(icon.path);
            byFile.set(fileName, (byFile.get(fileName) || 0) + 1);
          }
        }
        for (const [fileName, count] of byFile) {
          items.push(
            new SvgItem(
              fileName,
              count,
              vscode17.TreeItemCollapsibleState.Collapsed,
              "category",
              void 0,
              `built:${fileName}`
            )
          );
        }
        return items;
      }
      case "files":
        return TreeNavigationHelper.buildFilesSectionChildren(this.svgFiles);
      case "inline":
        return TreeNavigationHelper.buildInlineSectionChildren(this.inlineSvgs);
      case "references":
        return TreeNavigationHelper.buildReferencesSectionChildren(this.svgReferences);
      case "icon_usages_section": {
        if (!this.usagesScanned) {
          await this.scanIconUsages();
          this._onDidChangeTreeData.fire();
        }
        return TreeNavigationHelper.buildUsagesSectionChildren(this.iconUsages);
      }
      default:
        return [];
    }
  }
  async initialize() {
    this.scanner.loadLibraryIcons(this.libraryIcons);
    await this.scanner.loadBuiltIcons(this.libraryIcons, this.builtIcons);
    await vscode17.window.withProgress(
      {
        location: vscode17.ProgressLocation.Notification,
        title: "Icon Studio: Scanning workspace",
        cancellable: false
      },
      async (progress) => {
        progress.report({ message: "Scanning SVG files..." });
        await this.scanWorkspaceWithProgress(progress);
        progress.report({ message: "Scanning inline SVGs..." });
        await this.scanner.scanInlineSvgs(
          this.inlineSvgs,
          this.svgReferences,
          this.builtIcons,
          (scanProgress) => {
            if (scanProgress.percentage !== void 0) {
              progress.report({
                message: `Scanning inline SVGs... ${scanProgress.percentage}%`,
                increment: scanProgress.percentage > 0 ? 1 : 0
              });
            }
          }
        );
        const hasBuiltIcons = Array.from(this.libraryIcons.values()).some((icon) => icon.isBuilt);
        if (hasBuiltIcons) {
          progress.report({ message: "Scanning icon usages..." });
          await this.scanIconUsagesWithProgress(progress);
        }
      }
    );
  }
  async scanFolder(folderPath) {
    await this.scanner.scanFolder(folderPath, this.svgFiles);
    this._onDidChangeTreeData.fire();
  }
  async scanWorkspace() {
    this.svgFiles.clear();
    const workspaceFolders = vscode17.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return;
    }
    for (const folder of workspaceFolders) {
      await this.scanner.scanFolder(folder.uri.fsPath, this.svgFiles);
    }
  }
  async scanWorkspaceWithProgress(progress) {
    this.svgFiles.clear();
    const workspaceFolders = vscode17.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return;
    }
    for (let i = 0; i < workspaceFolders.length; i++) {
      const folder = workspaceFolders[i];
      progress.report({
        message: `Scanning ${folder.name}...`,
        increment: 100 / workspaceFolders.length
      });
      await this.scanner.scanFolder(folder.uri.fsPath, this.svgFiles, (scanProgress) => {
        if (scanProgress.currentFile) {
          const fileName = path16.basename(scanProgress.currentFile);
          progress.report({ message: `Found: ${fileName}` });
        }
      });
    }
  }
  async scanIconUsagesWithProgress(progress) {
    if (this.usagesScanned) return;
    await this.scanner.scanIconUsages(this.libraryIcons, this.iconUsages, (scanProgress) => {
      if (scanProgress.percentage !== void 0) {
        progress.report({
          message: `Scanning icon usages... ${scanProgress.percentage}%`
        });
      }
    });
    this.usagesScanned = true;
  }
  // Check if an icon is built
  isIconBuilt(iconName) {
    return this.builtIcons.has(iconName);
  }
  // Remove icons from the icons.js file
  async removeIcons(iconNames) {
    const result = await IconRemovalService.removeIcons(
      iconNames,
      this.builtIcons,
      this.libraryIcons
    );
    if (result.success) {
      this._onDidChangeTreeData.fire();
    }
    return result;
  }
  async getAllIcons() {
    return IconLookupService.getAllIcons({
      svgFiles: this.svgFiles,
      libraryIcons: this.libraryIcons
    });
  }
  /**
   * Get list of built icons only (for BuiltIconsProvider)
   */
  getBuiltIconsList() {
    return IconLookupService.getBuiltIconsList(this.libraryIcons);
  }
  /**
   * Get SVG files map (for SvgFilesProvider)
   */
  getSvgFilesMap() {
    return this.svgFiles;
  }
  /**
   * Get the hierarchical structure of SVG file folders
   */
  getSvgFilesFolderStructure() {
    const workspaceRoot = vscode17.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
    const folders = /* @__PURE__ */ new Map();
    const rootFiles = [];
    for (const [filePath] of this.svgFiles) {
      const relativePath = path16.relative(workspaceRoot, filePath);
      const parts = relativePath.split(path16.sep);
      if (parts.length === 1) {
        rootFiles.push(filePath);
      } else {
        const topFolder = parts[0];
        if (!folders.has(topFolder)) {
          folders.set(topFolder, []);
        }
        folders.get(topFolder).push(filePath);
      }
    }
    return { folders, rootFiles };
  }
  getIcon(name) {
    return IconLookupService.getIcon(name, this._getStorageMaps());
  }
  /**
   * Get all IMG references from the workspace
   * Used by buildAllReferences command
   */
  getImgReferences() {
    return IconLookupService.getImgReferences(this.svgReferences);
  }
  _getStorageMaps() {
    return {
      svgFiles: this.svgFiles,
      libraryIcons: this.libraryIcons,
      inlineSvgs: this.inlineSvgs,
      svgReferences: this.svgReferences
    };
  }
  getCategories() {
    return IconCategoryService.getCategories(this._getStorageMaps());
  }
  getIconsByCategory(category) {
    return IconCategoryService.getIconsByCategory(category, this._getStorageMaps());
  }
  // Scan all code files for inline <svg> elements and <img src="...svg"> references
  async scanInlineSvgs() {
    await vscode17.window.withProgress(
      {
        location: vscode17.ProgressLocation.Notification,
        title: "Icon Studio: Scanning inline SVGs",
        cancellable: false
      },
      async (progress) => {
        await this.scanner.scanInlineSvgs(
          this.inlineSvgs,
          this.svgReferences,
          this.builtIcons,
          (scanProgress) => {
            if (scanProgress.percentage !== void 0) {
              progress.report({
                message: `${scanProgress.percentage}% complete`,
                increment: scanProgress.percentage > 0 ? 1 : 0
              });
            }
          }
        );
      }
    );
    this._onDidChangeTreeData.fire();
  }
  getInlineSvgs() {
    return IconLookupService.getInlineSvgs(this.inlineSvgs);
  }
  getInlineSvgByKey(key) {
    return IconLookupService.getInlineSvgByKey(key, this.inlineSvgs);
  }
  // Get SVG data for preview panel
  getSvgData(item) {
    return IconLookupService.getSvgData(item);
  }
  // Scan workspace for icon usages
  async scanIconUsages() {
    if (this.usagesScanned) return;
    await vscode17.window.withProgress(
      {
        location: vscode17.ProgressLocation.Notification,
        title: "Icon Studio: Scanning icon usages",
        cancellable: false
      },
      async (progress) => {
        await this.scanner.scanIconUsages(this.libraryIcons, this.iconUsages, (scanProgress) => {
          if (scanProgress.percentage !== void 0) {
            progress.report({
              message: `${scanProgress.percentage}% complete`
            });
          }
        });
      }
    );
    this.usagesScanned = true;
    this._onDidChangeTreeData.fire();
  }
  // Get usages for a specific icon
  getIconUsages(iconName) {
    return this.iconUsages.get(iconName) || [];
  }
  // Check if usages have been scanned
  hasScannedUsages() {
    return this.usagesScanned;
  }
  // Get icon by name from any source
  getIconByName(name) {
    return IconLookupService.getIconByName(name, this._getStorageMaps());
  }
  // Find icon by file path
  getIconByPath(filePath) {
    return IconLookupService.getIconByPath(filePath, this._getStorageMaps());
  }
  // Get a cached item by its ID
  getItemById(id) {
    return this.cacheService.getItemById(id);
  }
  // Find item in cache by icon name or path
  findItemByIconNameOrPath(iconName, filePath, lineNumber) {
    return this.cacheService.findItemByIconNameOrPath(iconName, filePath, lineNumber);
  }
  // Create a SvgItem from a WorkspaceIcon for TreeView reveal
  createSvgItemFromIcon(icon) {
    return this.cacheService.createSvgItemFromIcon(icon);
  }
};

// src/services/SvgTransformer.ts
var SvgTransformer = class {
  /**
   * Transform raw SVG to an Icon component
   */
  async transformToComponent(svg, iconName, options) {
    const { componentName, nameAttribute, format } = options;
    const cleanedSvg = this.cleanSvg(svg);
    let component;
    switch (format) {
      case "vue":
        component = this.generateVueComponent(iconName, componentName, nameAttribute);
        break;
      case "svelte":
        component = this.generateSvelteComponent(iconName, componentName, nameAttribute);
        break;
      case "astro":
        component = this.generateAstroComponent(iconName, componentName, nameAttribute);
        break;
      case "html":
        component = this.generateHtmlComponent(iconName, componentName, nameAttribute);
        break;
      default:
        component = this.generateJsxComponent(iconName, componentName, nameAttribute);
    }
    return {
      component,
      svg: cleanedSvg,
      iconName
    };
  }
  /**
   * Extract icon name from file path or SVG content
   */
  extractIconName(input) {
    if (input.includes("/") || input.includes("\\")) {
      const parts = input.split(/[/\\]/);
      const filename = parts[parts.length - 1];
      return filename.replace(".svg", "").toLowerCase().replace(/[^a-z0-9]+/g, "-");
    }
    const titleMatch = input.match(/<title>([^<]+)<\/title>/i);
    if (titleMatch) {
      return titleMatch[1].toLowerCase().replace(/[^a-z0-9]+/g, "-");
    }
    const idMatch = input.match(/id=["']([^"']+)["']/);
    if (idMatch) {
      return idMatch[1].toLowerCase().replace(/[^a-z0-9]+/g, "-");
    }
    return "icon";
  }
  /**
   * Clean and normalize SVG content
   */
  cleanSvg(svg) {
    return svg.replace(/<\?xml[^>]*\?>/gi, "").replace(/<!DOCTYPE[^>]*>/gi, "").replace(/<!--[\s\S]*?-->/g, "").replace(/\s+/g, " ").replace(/<metadata[\s\S]*?<\/metadata>/gi, "").replace(/data-name="[^"]*"/g, "").replace(/xmlns:xlink="[^"]*"/g, "").replace(/xml:space="[^"]*"/g, "").trim();
  }
  /**
   * Extract SVG body (content inside <svg> tags)
   * Also removes existing animation styles to prevent duplicates when rebuilding
   */
  extractSvgBody(svg) {
    const match = svg.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    let body = match ? match[1].trim() : svg;
    body = body.replace(
      /<style[^>]*id=["']icon-manager-animation["'][^>]*>[\s\S]*?<\/style>/gi,
      ""
    );
    body = body.replace(/<g[^>]*class=["']icon-anim-\d+["'][^>]*>([\s\S]*?)<\/g>/gi, "$1");
    return body.trim();
  }
  /**
   * Extract SVG attributes (viewBox, etc.)
   */
  extractSvgAttributes(svg) {
    const attrs = {};
    const svgTagMatch = svg.match(/<svg([^>]*)>/i);
    if (svgTagMatch) {
      const attrString = svgTagMatch[1];
      const attrRegex = /(\w+)=["']([^"']*)["']/g;
      let match;
      while ((match = attrRegex.exec(attrString)) !== null) {
        attrs[match[1]] = match[2];
      }
    }
    return attrs;
  }
  generateJsxComponent(iconName, componentName, nameAttr) {
    return `<${componentName} ${nameAttr}="${iconName}" />`;
  }
  generateVueComponent(iconName, componentName, nameAttr) {
    return `<${componentName} ${nameAttr}="${iconName}" />`;
  }
  generateSvelteComponent(iconName, componentName, nameAttr) {
    return `<${componentName} ${nameAttr}="${iconName}" />`;
  }
  generateAstroComponent(iconName, componentName, nameAttr) {
    return `<${componentName} ${nameAttr}="${iconName}" />`;
  }
  generateHtmlComponent(iconName, componentName, nameAttr) {
    let tagName = componentName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
    if (!tagName.includes("-")) {
      tagName = `${tagName}-icon`;
    }
    return `<${tagName} ${nameAttr}="${iconName}"></${tagName}>`;
  }
  /**
   * Batch transform multiple SVG files
   */
  async batchTransform(svgFiles, options) {
    const results = [];
    for (const file of svgFiles) {
      const iconName = this.extractIconName(file.path);
      const result = await this.transformToComponent(file.content, iconName, options);
      results.push(result);
    }
    return results;
  }
  /**
   * Generate icons.ts/json export file
   */
  generateIconsFile(icons, format) {
    if (format === "json") {
      return JSON.stringify(icons, null, 2);
    }
    const exports2 = icons.map((icon) => {
      const varName = this.toVariableName(icon.name);
      const body = this.extractSvgBody(icon.svg);
      const attrs = this.extractSvgAttributes(icon.svg);
      return `export const ${varName} = {
  name: '${icon.name}',
  body: \`${body}\`,
  viewBox: '${attrs.viewBox || "0 0 24 24"}'
};`;
    }).join("\n\n");
    const allNames = icons.map((i) => this.toVariableName(i.name)).join(",\n  ");
    return `// Auto-generated by Icon Studio
// Do not edit manually

${exports2}

export const icons = {
  ${allNames}
};

export type IconName = keyof typeof icons;
`;
  }
  toVariableName(name) {
    return name.split(/[-:]/).map((part, i) => i === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)).join("");
  }
};

// src/providers/IconCompletionProvider.ts
var vscode18 = __toESM(require("vscode"));
var fs14 = __toESM(require("fs"));
var path17 = __toESM(require("path"));
init_config();
init_AnimationKeyframes();
var IconCompletionProvider = class {
  constructor(svgProvider) {
    this.svgProvider = svgProvider;
  }
  async provideCompletionItems(document, position, _token, _context) {
    const linePrefix = document.lineAt(position).text.substring(0, position.character);
    const fullLine = document.lineAt(position).text;
    const componentName = getSvgConfig("componentName", "Icon");
    const webComponentName = getSvgConfig("webComponentName", "sg-icon");
    const nameAttr = getSvgConfig("iconNameAttribute", "name");
    const iconTagPatterns = [
      new RegExp(`<${componentName}[^>]*\\s+$`),
      // <Icon ... |
      new RegExp(`<${webComponentName}[^>]*\\s+$`),
      // <sg-icon ... |
      new RegExp(`<${componentName}[^>]*\\s+[a-z]*$`, "i"),
      // <Icon ... var|
      new RegExp(`<${webComponentName}[^>]*\\s+[a-z]*$`, "i")
      // <sg-icon ... var|
    ];
    const shouldCompleteAttribute = iconTagPatterns.some((p) => p.test(linePrefix));
    if (shouldCompleteAttribute) {
      const partialAttrMatch = linePrefix.match(/\s+([a-z]*)$/i);
      const partialText = partialAttrMatch ? partialAttrMatch[1].toLowerCase() : "";
      const existingAttrs = this.getExistingAttributes(linePrefix);
      return this.getAttributeCompletions(partialText, existingAttrs);
    }
    const variantPatterns = [
      new RegExp(`<${componentName}[^>]*variant=["']$`),
      new RegExp(`<${webComponentName}[^>]*variant=["']$`),
      /variant=["']$/
    ];
    const shouldCompleteVariant = variantPatterns.some((p) => p.test(linePrefix));
    if (shouldCompleteVariant) {
      const iconNameMatch = fullLine.match(new RegExp(`${nameAttr}=["']([^"']+)["']`));
      const iconName = iconNameMatch ? iconNameMatch[1] : null;
      return this.getVariantCompletions(iconName);
    }
    const animationPatterns = [
      new RegExp(`<${componentName}[^>]*animation=["']$`),
      new RegExp(`<${webComponentName}[^>]*animation=["']$`),
      /animation=["']$/
    ];
    const shouldCompleteAnimation = animationPatterns.some((p) => p.test(linePrefix));
    if (shouldCompleteAnimation) {
      const iconNameMatch = fullLine.match(new RegExp(`${nameAttr}=["']([^"']+)["']`));
      const iconName = iconNameMatch ? iconNameMatch[1] : null;
      return this.getAnimationCompletions(iconName);
    }
    const patterns = [
      new RegExp(`<${componentName}[^>]*${nameAttr}=["']$`),
      new RegExp(`<${webComponentName}[^>]*${nameAttr}=["']$`),
      new RegExp(`<iconify-icon[^>]*icon=["']$`),
      new RegExp(`${nameAttr}=["']$`),
      /icon=["']$/
    ];
    const shouldComplete = patterns.some((p) => p.test(linePrefix));
    if (!shouldComplete) return [];
    const icons = await this.svgProvider.getAllIcons();
    const items = [];
    for (const icon of icons) {
      const item = new vscode18.CompletionItem(icon.name, vscode18.CompletionItemKind.Value);
      item.detail = `${icon.source} - ${icon.category || "uncategorized"}`;
      item.documentation = new vscode18.MarkdownString(
        `**${icon.name}**

Source: ${icon.source}
Path: ${icon.path}`
      );
      if (icon.svg) {
        const svgPreview = this.createSvgPreview(icon.svg);
        item.documentation = new vscode18.MarkdownString(
          `${svgPreview}

**${icon.name}**

Source: ${icon.source}`
        );
        item.documentation.supportHtml = true;
        item.documentation.isTrusted = true;
      }
      item.sortText = icon.source === "workspace" ? `0${icon.name}` : `1${icon.name}`;
      items.push(item);
    }
    return items;
  }
  getVariantCompletions(iconName) {
    const items = [];
    const allVariants = this.readVariantsFromFile();
    if (iconName && allVariants[iconName]) {
      const iconVariants = allVariants[iconName];
      for (const variantName of Object.keys(iconVariants)) {
        if (variantName.startsWith("_")) continue;
        const colors = iconVariants[variantName];
        const item = new vscode18.CompletionItem(variantName, vscode18.CompletionItemKind.Color);
        item.detail = `\u{1F3A8} Variant for ${iconName}`;
        item.documentation = this.createVariantDocumentation(variantName, colors, iconName);
        item.sortText = `0${variantName}`;
        items.push(item);
      }
    } else {
      for (const [icon, Variants] of Object.entries(allVariants)) {
        for (const variantName of Object.keys(Variants)) {
          if (variantName.startsWith("_")) continue;
          const colors = Variants[variantName];
          const item = new vscode18.CompletionItem(variantName, vscode18.CompletionItemKind.Color);
          item.detail = `\u{1F3A8} Variant from ${icon}`;
          item.documentation = this.createVariantDocumentation(variantName, colors, icon);
          item.sortText = `1${variantName}_${icon}`;
          items.push(item);
        }
      }
      const seen = /* @__PURE__ */ new Set();
      return items.filter((item) => {
        if (seen.has(item.label)) return false;
        seen.add(item.label);
        return true;
      });
    }
    return items;
  }
  /**
   * Create rich documentation for variant with color swatches and preview
   */
  createVariantDocumentation(variantName, colors, iconName) {
    const md = new vscode18.MarkdownString();
    md.supportHtml = true;
    md.supportThemeIcons = true;
    md.isTrusted = true;
    if (iconName) {
      const icon = this.svgProvider.getIcon(iconName);
      if (icon?.svg) {
        const preview = this.createVariantSvgPreview(icon.svg, iconName, variantName);
        md.appendMarkdown(preview + "\n\n");
      }
    }
    md.appendMarkdown(`**\u{1F3A8} ${variantName}**

`);
    const colorSwatches = colors.map((color) => {
      const safeColor = color.replace(/[^#a-fA-F0-9,()rgb]/g, "");
      return `<span style="background-color:${safeColor};color:${safeColor};border:1px solid #888;border-radius:2px;">&nbsp;&nbsp;&nbsp;</span> \`${color}\``;
    }).join("\n\n");
    md.appendMarkdown(`**Colors:**

${colorSwatches}

`);
    md.appendMarkdown(`---
*Use \`variant="${variantName}"\` to apply*`);
    return md;
  }
  /**
   * Create SVG preview with variant colors applied
   */
  createVariantSvgPreview(svg, iconName, variantName) {
    const size = 48;
    const variantsData = this.readVariantsFromFile();
    const iconVariants = variantsData[iconName];
    if (!iconVariants) {
      return this.createSvgPreview(svg);
    }
    const originalColors = iconVariants["_original"] || [];
    const variantColors = iconVariants[variantName] || [];
    let modifiedSvg = svg;
    for (let i = 0; i < originalColors.length && i < variantColors.length; i++) {
      const original = originalColors[i];
      const replacement = variantColors[i];
      const colorRegex = new RegExp(this.escapeRegex(original), "gi");
      modifiedSvg = modifiedSvg.replace(colorRegex, replacement);
    }
    const viewBoxMatch = modifiedSvg.match(/viewBox=["']([^"']+)["']/);
    const viewBox = viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24";
    let cleanSvg = modifiedSvg.replace(/\s+width="[^"]*"/g, "").replace(/\s+height="[^"]*"/g, "").replace(/\s+class="[^"]*"/g, "");
    if (!cleanSvg.includes("viewBox")) {
      cleanSvg = cleanSvg.replace(/<svg/, `<svg viewBox="${viewBox}"`);
    }
    cleanSvg = cleanSvg.replace(/<svg/, `<svg width="${size}" height="${size}"`);
    const encoded = encodeURIComponent(cleanSvg).replace(/'/g, "%27").replace(/"/g, "%22");
    return `![icon](data:image/svg+xml,${encoded})`;
  }
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  getAnimationCompletions(iconName) {
    let iconSvg;
    if (iconName) {
      const icon = this.svgProvider.getIcon(iconName);
      iconSvg = icon?.svg;
    }
    const animationMeta = {
      // Basic
      none: { description: "No animation", icon: "\u23F9\uFE0F" },
      spin: { description: "Continuous 360\xB0 rotation", icon: "\u{1F504}" },
      "spin-reverse": { description: "Counter-clockwise rotation", icon: "\u{1F503}" },
      pulse: { description: "Scale up/down with opacity", icon: "\u{1F493}" },
      "pulse-grow": { description: "Scale up and down", icon: "\u{1F4C8}" },
      bounce: { description: "Vertical bouncing", icon: "\u2B06\uFE0F" },
      "bounce-horizontal": { description: "Horizontal bouncing", icon: "\u2194\uFE0F" },
      shake: { description: "Horizontal shaking", icon: "\u2194\uFE0F" },
      "shake-vertical": { description: "Vertical shaking", icon: "\u2195\uFE0F" },
      fade: { description: "Fade in and out", icon: "\u{1F47B}" },
      float: { description: "Gentle floating", icon: "\u{1F388}" },
      blink: { description: "Blink on/off", icon: "\u{1F4A1}" },
      glow: { description: "Glowing effect", icon: "\u2728" },
      // Attention
      swing: { description: "Pendulum swing", icon: "\u{1F390}" },
      wobble: { description: "Wobbly motion", icon: "\u3030\uFE0F" },
      "rubber-band": { description: "Rubber band stretch", icon: "\u{1F517}" },
      jello: { description: "Jello wiggle", icon: "\u{1F7E1}" },
      heartbeat: { description: "Double-pulse heartbeat", icon: "\u2764\uFE0F" },
      tada: { description: "Celebration effect", icon: "\u{1F389}" },
      // Entrance/Exit
      "fade-in": { description: "Fade in from transparent", icon: "\u{1F305}" },
      "fade-out": { description: "Fade out to transparent", icon: "\u{1F306}" },
      "zoom-in": { description: "Zoom in from small", icon: "\u{1F50D}" },
      "zoom-out": { description: "Zoom out to small", icon: "\u{1F50E}" },
      "slide-in-up": { description: "Slide in from bottom", icon: "\u2B06\uFE0F" },
      "slide-in-down": { description: "Slide in from top", icon: "\u2B07\uFE0F" },
      "slide-in-left": { description: "Slide in from left", icon: "\u2B05\uFE0F" },
      "slide-in-right": { description: "Slide in from right", icon: "\u27A1\uFE0F" },
      flip: { description: "Flip on Y axis", icon: "\u{1F500}" },
      "flip-x": { description: "Flip on X axis", icon: "\u{1F501}" },
      // Draw (for stroke-based SVGs)
      draw: { description: "Draw stroke animation", icon: "\u270F\uFE0F" },
      "draw-reverse": { description: "Undraw stroke animation", icon: "\u{1F9F9}" },
      "draw-loop": { description: "Draw and undraw loop", icon: "\u{1F504}" },
      // Custom
      custom: { description: "Custom CSS animation (define your own keyframes)", icon: "\u{1F3A8}" }
    };
    const items = [];
    let sortIndex = 0;
    const categoryLabels = {
      basic: "\u{1F3AF} Basic",
      attention: "\u{1F440} Attention",
      entrance: "\u{1F6AA} Entrance/Exit",
      draw: "\u270F\uFE0F Draw",
      custom: "\u{1F3A8} Custom"
    };
    for (const [category, animations] of Object.entries(ANIMATION_CATEGORIES)) {
      for (const animName of animations) {
        const meta = animationMeta[animName] || { description: animName, icon: "\u{1F3AC}" };
        const item = new vscode18.CompletionItem(animName, vscode18.CompletionItemKind.EnumMember);
        item.detail = `${meta.icon} ${meta.description}`;
        const md = new vscode18.MarkdownString();
        md.supportHtml = true;
        md.isTrusted = true;
        if (iconSvg && animName !== "none") {
          const preview = this.createAnimatedSvgPreview(iconSvg, animName);
          md.appendMarkdown(preview + "\n\n");
        }
        md.appendMarkdown(`${meta.icon} **${animName}**

`);
        md.appendMarkdown(`${meta.description}

`);
        md.appendMarkdown(`*Category: ${categoryLabels[category] || category}*

`);
        md.appendMarkdown(`---
*Use \`animation="${animName}"\` to apply*`);
        item.documentation = md;
        const categoryIndex = Object.keys(ANIMATION_CATEGORIES).indexOf(category);
        item.sortText = `${categoryIndex}${String(sortIndex).padStart(2, "0")}`;
        items.push(item);
        sortIndex++;
      }
    }
    return items;
  }
  /**
   * Get completions for icon component attribute names
   */
  getAttributeCompletions(partialText, existingAttrs) {
    const nameAttr = getSvgConfig("iconNameAttribute", "name");
    const allAnimations = Object.values(ANIMATION_CATEGORIES).flat();
    const animationTypeHint = allAnimations.slice(0, 6).join(" | ") + " | ... (32 total)";
    const attributes = [
      { name: nameAttr, description: "Icon name identifier", type: "string", required: true },
      { name: "variant", description: "Color variant to apply", type: "string" },
      { name: "animation", description: "Animation effect", type: animationTypeHint },
      { name: "size", description: "Icon size in pixels or CSS units", type: "number | string" },
      { name: "color", description: "Icon color (overrides variant)", type: "string" },
      { name: "light-color", description: "Color for light mode", type: "string" },
      { name: "dark-color", description: "Color for dark mode", type: "string" },
      { name: "class", description: "CSS class name", type: "string" },
      { name: "style", description: "Inline CSS styles", type: "string" }
    ];
    const items = [];
    for (const attr of attributes) {
      if (existingAttrs.has(attr.name)) continue;
      if (partialText && !attr.name.toLowerCase().startsWith(partialText)) continue;
      const item = new vscode18.CompletionItem(attr.name, vscode18.CompletionItemKind.Property);
      item.detail = attr.type;
      item.documentation = new vscode18.MarkdownString(
        `**${attr.name}**

${attr.description}

Type: \`${attr.type}\``
      );
      item.insertText = new vscode18.SnippetString(`${attr.name}="\${1}"`);
      item.command = {
        command: "editor.action.triggerSuggest",
        title: "Trigger Suggest"
      };
      item.sortText = attr.required ? `0${attr.name}` : `1${attr.name}`;
      if (attr.name === "variant" || attr.name === "animation") {
        item.preselect = true;
      }
      items.push(item);
    }
    return items;
  }
  /**
   * Extract existing attributes from the current tag
   */
  getExistingAttributes(linePrefix) {
    const attrs = /* @__PURE__ */ new Set();
    const attrRegex = /([a-z-]+)=["'][^"']*["']/gi;
    let match;
    while ((match = attrRegex.exec(linePrefix)) !== null) {
      attrs.add(match[1].toLowerCase());
    }
    return attrs;
  }
  readVariantsFromFile() {
    try {
      const outputDir = getSvgConfig("outputDirectory", "");
      const workspaceFolders = vscode18.workspace.workspaceFolders;
      if (!workspaceFolders || !outputDir) return {};
      const filePath = path17.join(workspaceFolders[0].uri.fsPath, outputDir, "variants.js");
      if (!fs14.existsSync(filePath)) return {};
      const content = fs14.readFileSync(filePath, "utf-8");
      const match = content.match(/export\s+const\s+Variants\s*=\s*(\{[\s\S]*?\n\});?/);
      if (match) {
        try {
          return new Function(`return ${match[1]}`)();
        } catch (parseError) {
          console.error("Error parsing Variants object:", parseError);
          return {};
        }
      }
      return {};
    } catch {
      return {};
    }
  }
  createSvgPreview(svg) {
    const cleanSvg = svg.replace(/width="[^"]*"/g, 'width="48"').replace(/height="[^"]*"/g, 'height="48"').replace(/class="[^"]*"/g, "").replace(/style="[^"]*"/g, "");
    const encoded = Buffer.from(cleanSvg).toString("base64");
    return `<img src="data:image/svg+xml;base64,${encoded}" width="48" height="48" />`;
  }
  /**
   * Create an animated SVG preview for the completion hover
   */
  createAnimatedSvgPreview(svg, animationName) {
    const size = 48;
    const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/);
    const viewBox = viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24";
    let cleanSvg = svg.replace(/\s+width="[^"]*"/g, "").replace(/\s+height="[^"]*"/g, "").replace(/\s+class="[^"]*"/g, "");
    if (!cleanSvg.includes("viewBox")) {
      cleanSvg = cleanSvg.replace(/<svg/, `<svg viewBox="${viewBox}"`);
    }
    cleanSvg = cleanSvg.replace(/<svg/, `<svg width="${size}" height="${size}"`);
    const keyframes = ANIMATION_KEYFRAMES[animationName];
    if (keyframes) {
      const duration = this.getAnimationDuration(animationName);
      const timing = this.getAnimationTiming(animationName);
      const styleContent = `
        ${keyframes}
        svg { animation: ${animationName} ${duration} ${timing} infinite; }
      `.trim();
      cleanSvg = cleanSvg.replace(/<svg([^>]*)>/, `<svg$1><style>${styleContent}</style>`);
    }
    const encoded = encodeURIComponent(cleanSvg).replace(/'/g, "%27").replace(/"/g, "%22");
    return `![icon](data:image/svg+xml,${encoded})`;
  }
  getAnimationDuration(animationType) {
    const fastAnimations = ["spin", "spin-reverse", "blink"];
    const slowAnimations = ["float", "fade", "glow"];
    if (fastAnimations.includes(animationType)) return "1s";
    if (slowAnimations.includes(animationType)) return "2s";
    return "1.5s";
  }
  getAnimationTiming(animationType) {
    const linearAnimations = ["spin", "spin-reverse"];
    const easeOutAnimations = ["bounce", "bounce-horizontal", "slide-in-up", "slide-in-down"];
    if (linearAnimations.includes(animationType)) return "linear";
    if (easeOutAnimations.includes(animationType)) return "ease-out";
    return "ease-in-out";
  }
};

// src/providers/IconHoverProvider.ts
var vscode19 = __toESM(require("vscode"));
var fs16 = __toESM(require("fs"));
var path19 = __toESM(require("path"));
init_config();
init_AnimationKeyframes();
init_LicenseService();
init_i18n();
var IconHoverProvider = class {
  constructor(svgProvider) {
    this.svgProvider = svgProvider;
  }
  async provideHover(document, position, _token) {
    const componentName = getSvgConfig("componentName", "Icon");
    const webComponentName = getSvgConfig("webComponentName", "sg-icon");
    const nameAttr = getSvgConfig("iconNameAttribute", "name");
    const line = document.lineAt(position).text;
    const patterns = [
      // <Icon name="icon-name" /> or <icon name="icon-name">
      new RegExp(`<${componentName}[^>]*${nameAttr}=["']([^"']+)["']`, "gi"),
      // <sg-icon name="icon-name" /> (web component)
      new RegExp(`<${webComponentName}[^>]*${nameAttr}=["']([^"']+)["']`, "gi"),
      // <iconify-icon icon="prefix:name" />
      /<iconify-icon[^>]*icon=["']([^"']+)["']/gi,
      // Generic name="icon" or icon="icon"
      /(?:name|icon)=["']([a-z0-9:-]+)["']/gi
    ];
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(line)) !== null) {
        const iconName = match[1];
        const startIndex = match.index + match[0].indexOf(iconName);
        const endIndex = startIndex + iconName.length;
        if (position.character >= startIndex && position.character <= endIndex) {
          const icon = this.svgProvider.getIcon(iconName);
          if (icon) {
            const markdown = new vscode19.MarkdownString();
            markdown.supportHtml = true;
            markdown.supportThemeIcons = true;
            markdown.isTrusted = true;
            const variantName = this.extractAttributeFromLine(line, match.index, "variant");
            const animationAttr = this.extractAttributeFromLine(line, match.index, "animation");
            const sizeAttr = this.extractAttributeFromLine(line, match.index, "size");
            const animationService = getAnimationService();
            const assignedAnimation = animationService.getAnimation(iconName);
            const effectiveAnimation = animationAttr || assignedAnimation?.type || null;
            const previewSize = this.parseSize(sizeAttr);
            let svgPreview = "";
            if (icon.svg) {
              let svgToPreview = icon.svg;
              if (variantName) {
                svgToPreview = this.applyVariantToSvg(iconName, svgToPreview, variantName);
              }
              svgPreview = this.createSvgPreview(svgToPreview, effectiveAnimation, previewSize);
            }
            const infoLines = [];
            const licenseInfo = await getIconLicenseInfo(icon.name);
            if (licenseInfo?.isIconify) {
              if (licenseInfo.collection) {
                infoLines.push(`Collection: ${licenseInfo.collection}`);
              }
              if (licenseInfo.author) {
                const authorLink = licenseInfo.author.url ? `[${licenseInfo.author.name}](${licenseInfo.author.url})` : licenseInfo.author.name;
                infoLines.push(`Author: ${authorLink}`);
              }
              if (licenseInfo.license) {
                const licenseLink = licenseInfo.license.url ? `[${licenseInfo.license.title}](${licenseInfo.license.url})` : licenseInfo.license.title;
                infoLines.push(`License: ${licenseLink} \u2705`);
              }
            }
            infoLines.push(`Source: ${icon.source}`);
            if (icon.category && icon.category !== "none") {
              infoLines.push(`Category: ${icon.category}`);
            }
            const displayPath = icon.path.length > 40 ? "..." + icon.path.slice(-37) : icon.path;
            infoLines.push(`Path: ${displayPath}`);
            if (variantName) {
              infoLines.push(`Variant: ${variantName}`);
            }
            if (effectiveAnimation && effectiveAnimation !== "none") {
              const animSource = animationAttr ? "" : " (default)";
              infoLines.push(`Animation: ${effectiveAnimation}${animSource}`);
            }
            if (sizeAttr) {
              infoLines.push(`Size: ${sizeAttr}`);
            }
            markdown.appendMarkdown(`**${icon.name}**

`);
            const infoColumn = infoLines.map((l) => `\u2022 ${l}`).join("<br/>");
            markdown.appendMarkdown(
              `| | |
|:---:|:---|
| ${svgPreview} &nbsp;&nbsp; | ${infoColumn} |`
            );
            const editCmd = `command:sageboxIconStudio.colorEditor?${encodeURIComponent(JSON.stringify(icon.name))}`;
            const detailsData = {
              name: icon.name,
              svg: icon.svg,
              path: icon.path,
              source: icon.source,
              category: icon.category,
              filePath: icon.filePath,
              line: icon.line,
              isBuilt: icon.isBuilt,
              animation: effectiveAnimation ? { type: effectiveAnimation } : void 0
            };
            const detailsCmd = `command:sageboxIconStudio.showDetails?${encodeURIComponent(JSON.stringify(detailsData))}`;
            markdown.appendMarkdown(`

`);
            if (icon.isBuilt) {
              markdown.appendMarkdown(
                `[$(edit) Edit](${editCmd} "Edit icon") \xB7 [$(info) Details](${detailsCmd} "Show details")`
              );
            } else {
              const buildData = {
                iconName: icon.name,
                svgContent: icon.svg,
                filePath: icon.path
              };
              const buildCmd = `command:sageboxIconStudio.buildSingleIcon?${encodeURIComponent(JSON.stringify(buildData))}`;
              markdown.appendMarkdown(
                `[$(package) ${t("commands.build") || "Build"}](${buildCmd} "Add to library") \xB7 [$(edit) Edit](${editCmd} "Edit icon") \xB7 [$(info) Details](${detailsCmd} "Show details")`
              );
            }
            const range = new vscode19.Range(position.line, startIndex, position.line, endIndex);
            return new vscode19.Hover(markdown, range);
          } else {
            const markdown = new vscode19.MarkdownString();
            markdown.isTrusted = true;
            markdown.supportHtml = true;
            markdown.supportThemeIcons = true;
            markdown.appendMarkdown(`\u26A0\uFE0F **Icon not found:** ${iconName}

`);
            markdown.appendMarkdown(`This icon is not in your workspace or library.

`);
            const importCmd = `command:sageboxIconStudio.importIcon?${encodeURIComponent(JSON.stringify([iconName, document.uri.fsPath, position.line]))}`;
            markdown.appendMarkdown(
              `[$(cloud-download) Import](${importCmd} "Import or replace icon")`
            );
            const range = new vscode19.Range(position.line, startIndex, position.line, endIndex);
            return new vscode19.Hover(markdown, range);
          }
        }
      }
    }
    return null;
  }
  /**
   * Extract an attribute value from the same tag
   */
  extractAttributeFromLine(line, tagStartIndex, attrName) {
    let tagStart = tagStartIndex;
    if (line[tagStartIndex] !== "<") {
      const beforeMatch = line.substring(0, tagStartIndex);
      tagStart = beforeMatch.lastIndexOf("<");
      if (tagStart === -1) return null;
    }
    const afterTagStart = line.substring(tagStart);
    const tagEnd = afterTagStart.indexOf(">");
    if (tagEnd === -1) return null;
    const tagContent = afterTagStart.substring(0, tagEnd + 1);
    const attrRegex = new RegExp(`${attrName}=["']([^"']+)["']`);
    const attrMatch = tagContent.match(attrRegex);
    return attrMatch ? attrMatch[1] : null;
  }
  /**
   * Apply variant colors to SVG
   */
  applyVariantToSvg(iconName, svg, variantName) {
    const variantsData = this.readVariantsFromFile();
    const iconVariants = variantsData[iconName];
    if (!iconVariants) return svg;
    const originalColors = iconVariants["_original"] || [];
    const variantColors = iconVariants[variantName] || [];
    if (originalColors.length === 0 || variantColors.length === 0) return svg;
    let modifiedSvg = svg;
    for (let i = 0; i < originalColors.length && i < variantColors.length; i++) {
      const original = originalColors[i];
      const replacement = variantColors[i];
      const colorRegex = new RegExp(this.escapeRegex(original), "gi");
      modifiedSvg = modifiedSvg.replace(colorRegex, replacement);
    }
    return modifiedSvg;
  }
  /**
   * Read variants from file
   */
  readVariantsFromFile() {
    try {
      const outputDir = getSvgConfig("outputDirectory", "");
      const workspaceFolders = vscode19.workspace.workspaceFolders;
      if (!workspaceFolders || !outputDir) return {};
      const filePath = path19.join(workspaceFolders[0].uri.fsPath, outputDir, "variants.js");
      if (!fs16.existsSync(filePath)) return {};
      const content = fs16.readFileSync(filePath, "utf-8");
      const match = content.match(/export\s+const\s+Variants\s*=\s*(\{[\s\S]*?\n\});?/);
      if (match) {
        return new Function(`return ${match[1]}`)();
      }
      return {};
    } catch {
      return {};
    }
  }
  /**
   * Escape special regex characters
   */
  escapeRegex(str) {
    return str.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
  }
  /**
   * Parse size attribute to a number for preview
   */
  parseSize(sizeAttr) {
    if (!sizeAttr) return 48;
    const numericMatch = sizeAttr.match(/^(\d+(?:\.\d+)?)/);
    if (numericMatch) {
      const size = parseFloat(numericMatch[1]);
      return Math.max(16, Math.min(64, size));
    }
    return 64;
  }
  createSvgPreview(svg, animationName, size = 48) {
    const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/);
    const viewBox = viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24";
    let cleanSvg = svg.replace(/\s+width="[^"]*"/g, "").replace(/\s+height="[^"]*"/g, "").replace(/\s+class="[^"]*"/g, "");
    if (!cleanSvg.includes("viewBox")) {
      cleanSvg = cleanSvg.replace(/<svg/, `<svg viewBox="${viewBox}"`);
    }
    cleanSvg = cleanSvg.replace(/<svg/, `<svg width="${size}" height="${size}"`);
    if (animationName && animationName !== "none" && ANIMATION_KEYFRAMES[animationName]) {
      const keyframes = ANIMATION_KEYFRAMES[animationName];
      const animationDuration = this.getAnimationDuration(animationName);
      const animationTiming = this.getAnimationTiming(animationName);
      const styleContent = `
        ${keyframes}
        svg { animation: ${animationName} ${animationDuration} ${animationTiming} infinite; }
      `.trim();
      cleanSvg = cleanSvg.replace(/<svg([^>]*)>/, `<svg$1><style>${styleContent}</style>`);
    }
    const encoded = encodeURIComponent(cleanSvg).replace(/'/g, "%27").replace(/"/g, "%22");
    return `![icon](data:image/svg+xml,${encoded})`;
  }
  /**
   * Get appropriate duration for animation type
   */
  getAnimationDuration(animationType) {
    const fastAnimations = ["spin", "spin-reverse", "blink"];
    const slowAnimations = ["float", "fade", "glow"];
    if (fastAnimations.includes(animationType)) return "1s";
    if (slowAnimations.includes(animationType)) return "2s";
    return "1.5s";
  }
  /**
   * Get appropriate timing function for animation type
   */
  getAnimationTiming(animationType) {
    const linearAnimations = ["spin", "spin-reverse"];
    const easeOutAnimations = ["bounce", "bounce-horizontal", "slide-in-up", "slide-in-down"];
    if (linearAnimations.includes(animationType)) return "linear";
    if (easeOutAnimations.includes(animationType)) return "ease-out";
    return "ease-in-out";
  }
};

// src/providers/SvgToIconCodeActionProvider.ts
var vscode21 = __toESM(require("vscode"));
var path21 = __toESM(require("path"));

// src/utils/configHelper.ts
var vscode20 = __toESM(require("vscode"));
var path20 = __toESM(require("path"));
var fs17 = __toESM(require("fs"));
init_i18n();
function getConfig() {
  const config = vscode20.workspace.getConfiguration("sageboxIconStudio");
  return {
    outputDirectory: config.get("outputDirectory", "sagebox-icons"),
    componentName: config.get("componentName", "Icon"),
    nameAttribute: config.get("nameAttribute", "name"),
    defaultSize: config.get("defaultSize", 24),
    defaultColor: config.get("defaultColor", "currentColor"),
    webComponentName: config.get("webComponentName", "icon-wrap"),
    buildFormat: config.get("buildFormat", "icons.ts")
  };
}
function getOutputDirectory() {
  return getConfig().outputDirectory;
}
function getFullOutputPath() {
  const workspaceFolder = vscode20.workspace.workspaceFolders?.[0];
  const outputDir = getOutputDirectory();
  if (!workspaceFolder || !outputDir) {
    return void 0;
  }
  return path20.join(workspaceFolder.uri.fsPath, outputDir);
}
function isOutputConfigured() {
  return !!getOutputDirectory();
}
function iconsJsExists() {
  const fullPath = getFullOutputPath();
  if (!fullPath) return false;
  return fs17.existsSync(path20.join(fullPath, "icons.js"));
}
function updateIconsJsContext() {
  const exists = iconsJsExists();
  vscode20.commands.executeCommand("setContext", "sageboxIconStudio.iconsJsExists", exists);
}
function ensureOutputDirectory() {
  const fullPath = getFullOutputPath();
  if (!fullPath) {
    return void 0;
  }
  if (!fs17.existsSync(fullPath)) {
    fs17.mkdirSync(fullPath, { recursive: true });
  }
  return fullPath;
}
function checkConfigOrWarn() {
  if (!isOutputConfigured()) {
    vscode20.window.showWarningMessage(t("messages.configureOutputFirst"));
    return false;
  }
  return true;
}
function getOutputPathOrWarn() {
  if (!checkConfigOrWarn()) {
    return void 0;
  }
  const fullPath = getFullOutputPath();
  if (!fullPath) {
    vscode20.window.showWarningMessage(t("messages.noWorkspace"));
    return void 0;
  }
  return fullPath;
}

// src/providers/SvgToIconCodeActionProvider.ts
init_i18n();
var SvgToIconCodeActionProvider = class {
  static providedCodeActionKinds = [
    vscode21.CodeActionKind.QuickFix,
    vscode21.CodeActionKind.Refactor
  ];
  provideCodeActions(document, range, _context, _token) {
    const line = document.lineAt(range.start.line);
    const lineText = line.text;
    const imgSvgPattern = /<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/gi;
    let match;
    while ((match = imgSvgPattern.exec(lineText)) !== null) {
      const svgPath = match[1];
      const iconName = this.extractIconName(svgPath);
      const fullMatch = match[0];
      return [this.createTransformAction(document, svgPath, iconName, fullMatch, range.start.line)];
    }
    if (lineText.includes("<svg")) {
      const inlineSvgAction = this.detectInlineSvg(document, range.start.line);
      if (inlineSvgAction) {
        return [inlineSvgAction];
      }
    }
    return void 0;
  }
  /**
   * Detect and extract inline SVG from document
   */
  detectInlineSvg(document, startLine) {
    const text = document.getText();
    const lineStartOffset = document.offsetAt(new vscode21.Position(startLine, 0));
    const textFromLine = text.substring(lineStartOffset);
    const svgStartMatch = textFromLine.match(/<svg[^>]*>/i);
    if (!svgStartMatch) {
      return void 0;
    }
    const svgStartIndex = lineStartOffset + svgStartMatch.index;
    let depth = 1;
    let searchIndex = svgStartIndex + svgStartMatch[0].length;
    while (depth > 0 && searchIndex < text.length) {
      const openTag = text.indexOf("<svg", searchIndex);
      const closeTag = text.indexOf("</svg>", searchIndex);
      if (closeTag === -1) {
        return void 0;
      }
      if (openTag !== -1 && openTag < closeTag) {
        depth++;
        searchIndex = openTag + 4;
      } else {
        depth--;
        if (depth === 0) {
          const svgEndIndex = closeTag + 6;
          const svgContent = text.substring(svgStartIndex, svgEndIndex);
          const iconName = this.suggestIconName(document, startLine, svgContent);
          return this.createInlineSvgAction(
            document,
            svgContent,
            iconName,
            startLine,
            svgStartIndex,
            svgEndIndex
          );
        }
        searchIndex = closeTag + 6;
      }
    }
    return void 0;
  }
  /**
   * Suggest a name for inline SVG based on context
   */
  suggestIconName(document, line, svgContent) {
    const idMatch = svgContent.match(/id=["']([^"']+)["']/);
    if (idMatch) {
      return this.cleanIconName(idMatch[1]);
    }
    const ariaMatch = svgContent.match(/aria-label=["']([^"']+)["']/);
    if (ariaMatch) {
      return this.cleanIconName(ariaMatch[1]);
    }
    const classMatch = svgContent.match(/class=["'][^"']*icon[- ]?([a-zA-Z0-9-_]+)/i);
    if (classMatch) {
      return this.cleanIconName(classMatch[1]);
    }
    if (line > 0) {
      const prevLine = document.lineAt(line - 1).text;
      const commentMatch = prevLine.match(/<!--\s*([^-]+)\s*-->/);
      if (commentMatch) {
        return this.cleanIconName(commentMatch[1].trim());
      }
    }
    return `inline-icon-${line + 1}`;
  }
  /**
   * Clean a string to be a valid icon name
   */
  cleanIconName(name) {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "").substring(0, 50) || "icon";
  }
  /**
   * Create action for inline SVG transformation
   */
  createInlineSvgAction(document, svgContent, iconName, line, startOffset, endOffset) {
    const config = getConfig();
    const buildFormat = config.buildFormat || "icons.ts";
    const isSprite = buildFormat === "sprite.svg";
    const _formatLabel = isSprite ? t("ui.labels.svgSprite") : t("ui.labels.webComponentJs");
    const action = new vscode21.CodeAction(
      t("messages.extractInlineSvg", { name: iconName }) || `Extract inline SVG as "${iconName}"`,
      vscode21.CodeActionKind.Refactor
    );
    const originalHtml = document.getText().substring(startOffset, endOffset);
    const options = {
      originalPath: "",
      iconName,
      documentUri: document.uri.fsPath,
      line,
      originalHtml,
      isInlineSvg: true,
      svgContent,
      startOffset,
      endOffset
    };
    action.command = {
      command: "sageboxIconStudio.transformSvgReference",
      title: t("commands.transformSvg"),
      arguments: [options]
    };
    return action;
  }
  /**
   * Extract clean icon name from SVG path
   */
  extractIconName(svgPath) {
    const filename = path21.basename(svgPath, ".svg");
    return filename.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
  }
  /**
   * Create the single "Transform to Web Component" action
   */
  createTransformAction(document, svgPath, iconName, originalHtml, line) {
    const config = getConfig();
    const buildFormat = config.buildFormat || "icons.ts";
    const isSprite = buildFormat === "sprite.svg";
    const formatLabel = isSprite ? t("ui.labels.svgSprite") : t("ui.labels.webComponentJs");
    const action = new vscode21.CodeAction(
      t("messages.transformToFormat", { format: formatLabel, name: iconName }),
      vscode21.CodeActionKind.QuickFix
    );
    const options = {
      originalPath: svgPath,
      iconName,
      documentUri: document.uri.fsPath,
      line,
      originalHtml
    };
    action.command = {
      command: "sageboxIconStudio.transformSvgReference",
      title: t("commands.transformSvg"),
      arguments: [options]
    };
    action.isPreferred = true;
    return action;
  }
};
var SvgImgDiagnosticProvider = class {
  diagnosticCollection;
  constructor() {
    this.diagnosticCollection = vscode21.languages.createDiagnosticCollection("sageboxIconStudio");
  }
  updateDiagnostics(document) {
    if (!this.shouldAnalyze(document)) {
      this.diagnosticCollection.delete(document.uri);
      return;
    }
    const diagnostics = [];
    const text = document.getText();
    const imgSvgPattern = /<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/gi;
    let match;
    while ((match = imgSvgPattern.exec(text)) !== null) {
      const startPos = document.positionAt(match.index);
      const endPos = document.positionAt(match.index + match[0].length);
      const range = new vscode21.Range(startPos, endPos);
      const iconName = path21.basename(match[1], ".svg");
      const diagnostic = new vscode21.Diagnostic(
        range,
        t("messages.svgCanBeConverted", { name: iconName }),
        vscode21.DiagnosticSeverity.Hint
      );
      diagnostic.code = "svg-to-icon";
      diagnostic.source = "sageboxIconStudio";
      diagnostics.push(diagnostic);
    }
    this.diagnosticCollection.set(document.uri, diagnostics);
  }
  shouldAnalyze(document) {
    const supportedLanguages = [
      "html",
      "javascript",
      "javascriptreact",
      "typescript",
      "typescriptreact",
      "vue",
      "svelte",
      "astro"
    ];
    return supportedLanguages.includes(document.languageId);
  }
  dispose() {
    this.diagnosticCollection.dispose();
  }
};
var MissingIconCodeActionProvider = class {
  constructor(svgProvider) {
    this.svgProvider = svgProvider;
  }
  static providedCodeActionKinds = [
    vscode21.CodeActionKind.QuickFix,
    vscode21.CodeActionKind.Refactor
  ];
  provideCodeActions(document, range, _context, _token) {
    const config = getConfig();
    const componentName = config.webComponentName || "sg-icon";
    const line = document.lineAt(range.start.line);
    const lineText = line.text;
    const actions = [];
    const tagPattern = new RegExp(`<${componentName}[^>]*>`, "gi");
    let tagMatch;
    while ((tagMatch = tagPattern.exec(lineText)) !== null) {
      const tagStart = tagMatch.index;
      const tagEnd = tagStart + tagMatch[0].length;
      if (range.start.character >= tagStart && range.start.character <= tagEnd) {
        const nameMatch = tagMatch[0].match(/name=["']([^"']*)["']/i);
        const iconName = nameMatch ? nameMatch[1] : "";
        const icon = iconName ? this.svgProvider.getIcon(iconName) : void 0;
        if (!icon) {
          if (iconName) {
            actions.push(this.createImportAction(iconName, document, range.start.line));
          }
          actions.push(this.createSearchIconifyAction(iconName, document, range.start.line));
          actions.push(this.createBrowseWorkspaceAction(iconName, document, range.start.line));
        }
        if (actions.length > 0) {
          return actions;
        }
      }
    }
    const patterns = [
      new RegExp(`<${componentName}[^>]*name=["']([^"']*)["']`, "gi"),
      /<iconify-icon[^>]*icon=["']([^"']*)["']/gi
    ];
    for (const pattern of patterns) {
      let match;
      while ((match = pattern.exec(lineText)) !== null) {
        const iconName = match[1] || "";
        const icon = iconName ? this.svgProvider.getIcon(iconName) : void 0;
        if (!icon) {
          const matchStart = match.index;
          const matchEnd = matchStart + match[0].length;
          if (range.start.character >= matchStart && range.start.character <= matchEnd) {
            if (iconName) {
              actions.push(this.createImportAction(iconName, document, range.start.line));
            }
            actions.push(this.createSearchIconifyAction(iconName, document, range.start.line));
            actions.push(this.createBrowseWorkspaceAction(iconName, document, range.start.line));
            if (actions.length > 0) {
              return actions;
            }
          }
        }
      }
    }
    return actions.length > 0 ? actions : void 0;
  }
  /**
   * Create action for importing missing icon
   */
  createImportAction(iconName, document, line) {
    const action = new vscode21.CodeAction(
      t("messages.importIconName", { name: iconName }),
      vscode21.CodeActionKind.QuickFix
    );
    action.command = {
      command: "sageboxIconStudio.importIcon",
      title: t("commands.importIcon"),
      arguments: [iconName, document.uri.fsPath, line]
    };
    action.isPreferred = true;
    return action;
  }
  /**
   * Create action for searching icons in Iconify
   */
  createSearchIconifyAction(suggestedQuery, document, line) {
    const action = new vscode21.CodeAction(
      t("messages.searchIconify") || "\u{1F50D} Search in Iconify...",
      vscode21.CodeActionKind.Refactor
    );
    action.command = {
      command: "sageboxIconStudio.searchIconifyForComponent",
      title: t("commands.searchIconify") || "Search Iconify",
      arguments: [suggestedQuery, document.uri.fsPath, line]
    };
    return action;
  }
  /**
   * Create action for browsing workspace icons
   */
  createBrowseWorkspaceAction(suggestedName, document, line) {
    const action = new vscode21.CodeAction(
      t("messages.browseWorkspaceIcons") || "\u{1F4C1} Browse workspace icons...",
      vscode21.CodeActionKind.Refactor
    );
    action.command = {
      command: "sageboxIconStudio.browseWorkspaceIcons",
      title: t("commands.browseWorkspaceIcons") || "Browse Icons",
      arguments: [suggestedName, document.uri.fsPath, line]
    };
    return action;
  }
};

// src/providers/IconPreviewProvider.ts
var vscode27 = __toESM(require("vscode"));
var fs21 = __toESM(require("fs"));
var path25 = __toESM(require("path"));
init_config();

// src/services/IconUsageSearchService.ts
var vscode22 = __toESM(require("vscode"));
var IconUsageSearchService = class {
  /**
   * Search patterns for icon usage
   */
  static getSearchPatterns(iconName) {
    return [
      `name="${iconName}"`,
      // <sg-icon name="icon-name">
      `name='${iconName}'`,
      // <sg-icon name='icon-name'>
      `"${iconName}"`,
      // General string reference
      `'${iconName}'`,
      // General string reference
      `icon-${iconName}`,
      // CSS class pattern
      `.${iconName}`,
      // Class selector
      `#${iconName}`
      // ID selector
    ];
  }
  /**
   * File patterns to include in search
   */
  static INCLUDE_PATTERN = "**/*.{ts,tsx,js,jsx,vue,html,css,scss,less,svelte,astro}";
  /**
   * File patterns to exclude from search
   */
  static EXCLUDE_PATTERN = "**/node_modules/**,**/dist/**,**/build/**,**/.git/**";
  /**
   * Maximum number of files to search
   */
  static MAX_FILES = 500;
  /**
   * Maximum results to return
   */
  static MAX_RESULTS = 50;
  /**
   * Find all usages of an icon in the workspace
   */
  static async findUsages(iconName) {
    const workspaceFolders = vscode22.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return { usages: [], total: 0 };
    }
    const usages = [];
    const patterns = this.getSearchPatterns(iconName);
    try {
      const files = await vscode22.workspace.findFiles(
        this.INCLUDE_PATTERN,
        this.EXCLUDE_PATTERN,
        this.MAX_FILES
      );
      for (const file of files) {
        try {
          const document = await vscode22.workspace.openTextDocument(file);
          const text = document.getText();
          for (const pattern of patterns) {
            let index = 0;
            while ((index = text.indexOf(pattern, index)) !== -1) {
              const position = document.positionAt(index);
              const line = position.line;
              const lineText = document.lineAt(line).text.trim();
              const existing = usages.find((u) => u.file === file.fsPath && u.line === line + 1);
              if (!existing) {
                usages.push({
                  file: file.fsPath,
                  line: line + 1,
                  preview: lineText.substring(0, 80) + (lineText.length > 80 ? "..." : "")
                });
              }
              index += pattern.length;
            }
          }
        } catch {
        }
      }
      usages.sort((a, b) => a.file.localeCompare(b.file) || a.line - b.line);
      return {
        usages: usages.slice(0, this.MAX_RESULTS),
        total: usages.length
      };
    } catch {
      return { usages: [], total: 0 };
    }
  }
  /**
   * Navigate to a specific file location
   */
  static async goToLocation(file, line) {
    const uri = vscode22.Uri.file(file);
    const position = new vscode22.Position(line - 1, 0);
    await vscode22.window.showTextDocument(uri, {
      selection: new vscode22.Range(position, position),
      preview: true
    });
  }
};

// src/services/PreviewTemplateService.ts
var fs18 = __toESM(require("fs"));
var path22 = __toESM(require("path"));
var PreviewTemplateService = class {
  constructor(extensionUri) {
    this.extensionUri = extensionUri;
  }
  /**
   * Load CSS from external file
   */
  loadCss() {
    const cssPath = path22.join(
      this.extensionUri.fsPath,
      "src",
      "templates",
      "shared",
      "IconPreview.css"
    );
    return fs18.readFileSync(cssPath, "utf8");
  }
  /**
   * Generate empty state HTML
   */
  generateEmptyState() {
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <style>
    body {
      font-family: var(--vscode-font-family);
      color: var(--vscode-foreground);
      background: var(--vscode-sideBar-background);
      display: flex;
      align-items: center;
      justify-content: center;
      height: 100vh;
      margin: 0;
      text-align: center;
    }
    .empty {
      color: var(--vscode-descriptionForeground);
      font-size: 12px;
    }
    .icon {
      font-size: 32px;
      margin-bottom: 8px;
    }
  </style>
</head>
<body>
  <div class="empty">
    <div class="icon">\u{1F3A8}</div>
    <div>Select an icon to preview</div>
  </div>
</body>
</html>`;
  }
  /**
   * Prepare SVG for display with proper sizing
   */
  prepareSvgForDisplay(svg, animation) {
    let displaySvg = svg;
    if (!svg.includes("width=") && !svg.includes("style=")) {
      displaySvg = svg.replace("<svg", '<svg width="100%" height="100%"');
    }
    if (animation && animation.type && animation.type !== "none") {
      const duration = animation.duration || 1;
      const timing = animation.timing || "ease";
      const iteration = animation.iteration || "infinite";
      const delay = animation.delay || 0;
      const direction = animation.direction || "normal";
      const animationStyle = `animation: icon-${animation.type} ${duration}s ${timing} ${delay}s ${iteration} ${direction};`;
      if (displaySvg.includes('style="')) {
        displaySvg = displaySvg.replace(/style="([^"]*)"/, `style="$1 ${animationStyle}"`);
      } else {
        displaySvg = displaySvg.replace("<svg", `<svg style="${animationStyle}"`);
      }
    }
    return displaySvg;
  }
  /**
   * Generate header section HTML
   */
  generateHeader(name, isBuilt, isRasterized) {
    let badges = "";
    if (isBuilt !== void 0) {
      badges += `<span class="badge ${isBuilt ? "built" : "draft"}">${isBuilt ? "Built" : "Draft"}</span>`;
    }
    if (isRasterized) {
      badges += `<span class="badge rasterized" title="SVG has too many colors for editing">\u26A0</span>`;
    }
    return `<header class="header">
    <span class="icon-name" title="${name}">${name}</span>
    ${badges}
  </header>`;
  }
  /**
   * Generate variants bar HTML
   */
  generateVariantsBar(variants) {
    if (!variants || variants.length === 0) return "";
    const maxVariants = 3;
    const displayVariants = variants.slice(0, maxVariants);
    const hasMore = variants.length > maxVariants;
    const swatches = displayVariants.map((v, i) => {
      const colorDots = v.colors.slice(0, 4).map((c) => `<span style="background:${c}"></span>`).join("");
      return `<button class="variant-swatch ${i === 0 ? "active" : ""}" data-index="${i}" title="${v.name}" onclick="applyVariant(${i})">
          <span class="variant-colors">${colorDots}</span>
        </button>`;
    }).join("");
    const moreIndicator = hasMore ? `<span class="variants-more" title="${variants.length - maxVariants} more variants">+${variants.length - maxVariants}</span>` : "";
    return `<div class="variants-bar" id="variantsPalette">
      ${swatches}${moreIndicator}
    </div>`;
  }
  /**
   * Generate toolbar HTML
   */
  generateToolbar(hasLocation, isRasterized) {
    const buttons = [];
    buttons.push(`<button class="toolbar-btn" onclick="refreshPreview()" title="Refresh">
      <span class="codicon codicon-refresh"></span>
    </button>`);
    buttons.push(`<button class="toolbar-btn" onclick="copySvg()" title="Copy SVG">
      <span class="codicon codicon-copy"></span>
    </button>`);
    buttons.push(`<button class="toolbar-btn" onclick="downloadSvg()" title="Download">
      <span class="codicon codicon-desktop-download"></span>
    </button>`);
    if (!isRasterized) {
      buttons.push(`<button class="toolbar-btn" onclick="previewComponent()" title="Open in Editor">
      <span class="codicon codicon-edit"></span>
    </button>`);
    }
    if (hasLocation) {
      buttons.push(`<button class="toolbar-btn" onclick="goToLocation()" title="Go to Source">
      <span class="codicon codicon-go-to-file"></span>
    </button>`);
    }
    buttons.push(`<button class="toolbar-btn" onclick="openDetails()" title="Details">
      <span class="codicon codicon-info"></span>
    </button>`);
    return `<div class="toolbar-row">
    ${buttons.join("\n    ")}
  </div>`;
  }
  /**
   * Generate the preview script
   */
  generateScript(name, variants) {
    return `<script>
    const vscode = acquireVsCodeApi();
    const colorMap = new Map();
    const savedVariants = ${JSON.stringify(variants || [])};
    const originalSvg = document.querySelector('.icon-container svg')?.outerHTML;
    
    // === SIZE CONTROL ===
    const sizeSlider = document.getElementById('sizeSlider');
    const sizeValue = document.getElementById('sizeValue');
    const root = document.documentElement;
    
    sizeSlider.addEventListener('input', (e) => {
      const size = e.target.value;
      sizeValue.textContent = size;
      root.style.setProperty('--avatar-size', size + 'px');
    });
    
    // === COLOR DETECTION (for variants) ===
    function normalizeColor(color) {
      if (!color || color === 'none' || color === 'currentColor') return null;
      const temp = document.createElement('div');
      temp.style.color = color;
      document.body.appendChild(temp);
      const computed = getComputedStyle(temp).color;
      document.body.removeChild(temp);
      const match = computed.match(/rgb\\((\\d+),\\s*(\\d+),\\s*(\\d+)\\)/);
      if (match) {
        return '#' + [match[1], match[2], match[3]].map(x => parseInt(x).toString(16).padStart(2, '0')).join('');
      }
      return color;
    }
    
    function detectColors() {
      const svg = document.querySelector('.icon-container svg');
      if (!svg) return [];
      const colors = new Map();
      svg.querySelectorAll('*').forEach(el => {
        ['fill', 'stroke'].forEach(attr => {
          const val = el.getAttribute(attr);
          if (val && val !== 'none') {
            const hex = normalizeColor(val);
            if (hex && !colors.has(hex)) colors.set(hex, []);
            if (hex) colors.get(hex).push({ el, attr });
          }
        });
      });
      return Array.from(colors.entries());
    }
    
    // === VARIANTS ===
    // Store original SVG on load
    const originalSvgContent = document.querySelector('.icon-container svg')?.outerHTML || '';
    // Use _original variant colors as reference
    const originalVariant = savedVariants.find(v => v.name === '_original');
    const originalColors = originalVariant ? originalVariant.colors : [];
    
    function applyVariant(index) {
      const variant = savedVariants[index];
      
      if (!variant || !variant.colors || variant.colors.length === 0) {
        return;
      }
      
      const container = document.querySelector('.icon-container');
      if (!container || !originalSvgContent) {
        return;
      }
      
      // Start with original SVG
      let newSvg = originalSvgContent;
      
      // Replace colors directly in SVG string
      if (originalColors.length > 0) {
        originalColors.forEach((origColor, i) => {
          if (i < variant.colors.length) {
            const newColor = variant.colors[i];
            // Replace color in fill and stroke attributes (case insensitive)
            const regex = new RegExp(origColor.replace('#', '#?'), 'gi');
            newSvg = newSvg.replace(regex, newColor);
          }
        });
      }
      
      // Update container
      container.innerHTML = newSvg;
      const svg = container.querySelector('svg');
      if (svg) {
        svg.style.width = 'var(--avatar-size)';
        svg.style.height = 'var(--avatar-size)';
      }
      
      // Update active state
      document.querySelectorAll('.variant-swatch').forEach((btn, i) => {
        btn.classList.toggle('active', i === index);
      });
    }
    
    // === ACTIONS ===
    function goToLocation() { vscode.postMessage({ command: 'goToLocation' }); }
    function copyName() { vscode.postMessage({ command: 'copyName' }); }
    function copySvg() {
      const svgEl = document.querySelector('.icon-container svg');
      vscode.postMessage({ command: 'copySvg', svg: svgEl?.outerHTML });
    }
    function downloadSvg() {
      const svgEl = document.querySelector('.icon-container svg');
      if (svgEl) {
        const blob = new Blob([svgEl.outerHTML], { type: 'image/svg+xml' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = '${name}.svg';
        a.click();
        URL.revokeObjectURL(url);
      }
    }
    function refreshPreview() {
      vscode.postMessage({ command: 'refreshPreview' });
    }
    function optimizeSvg() {
      const svgEl = document.querySelector('.icon-container svg');
      if (svgEl) {
        vscode.postMessage({ command: 'optimizeSvg', svg: svgEl.outerHTML });
      }
    }
    function previewComponent() {
      vscode.postMessage({ command: 'previewComponent' });
    }
    function openDetails() {
      vscode.postMessage({ command: 'openDetails' });
    }
    
    // Listen for messages from extension
    window.addEventListener('message', event => {
      const message = event.data;
      if (message.command === 'resetSvg') {
        const container = document.querySelector('.icon-container');
        if (container && message.svg) {
          let svg = message.svg;
          if (!svg.includes('width=') && !svg.includes('style=')) {
            svg = svg.replace('<svg', '<svg width="100%" height="100%"');
          }
          container.innerHTML = svg;
          const svgEl = container.querySelector('svg');
          if (svgEl) {
            svgEl.style.width = 'var(--avatar-size)';
            svgEl.style.height = 'var(--avatar-size)';
          }
          colorMap.clear();
        }
      } else if (message.command === 'updateSvgContent') {
        // Update SVG content from Editor color changes
        const container = document.querySelector('.icon-container');
        if (container && message.svg) {
          let svg = message.svg;
          if (!svg.includes('width=') && !svg.includes('style=')) {
            svg = svg.replace('<svg', '<svg width="100%" height="100%"');
          }
          container.innerHTML = svg;
          const svgEl = container.querySelector('svg');
          if (svgEl) {
            svgEl.style.width = 'var(--avatar-size)';
            svgEl.style.height = 'var(--avatar-size)';
          }
        }        
        // Update variants bar with custom colors if provided
        if (message.customColors && message.customColors.length > 0) {
          const variantsBar = document.querySelector('.variants-bar');
          if (variantsBar) {
            // Create custom variant swatches (max 3)
            const displayColors = message.customColors.slice(0, 3);
            const extraCount = message.customColors.length - 3;
            
            let swatchesHtml = displayColors.map(color => 
              \`<span class="variant-color-dot" style="background-color: \${color};" title="\${color}"></span>\`
            ).join('');
            
            if (extraCount > 0) {
              swatchesHtml += \`<span class="variant-more-indicator">+\${extraCount}</span>\`;
            }
            
            variantsBar.innerHTML = \`<div class="variant-item" title="custom (unsaved)">\${swatchesHtml}</div>\`;
          }
        }      }
    });
  </script>`;
  }
  /**
   * Generate preview surface HTML
   */
  generatePreviewSurface(displaySvg, variants, isRasterized) {
    return `<div class="preview-surface" id="preview">
    <div class="icon-container">
      ${displaySvg}
    </div>
    <div class="bottom-controls">
      ${!isRasterized ? this.generateVariantsBar(variants) : ""}
      <div class="size-bar">
        <input type="range" class="size-slider" id="sizeSlider" min="16" max="128" value="64" />
        <span class="size-value" id="sizeValue">64</span>
      </div>
    </div>
  </div>`;
  }
  /**
   * Generate full HTML for webview
   */
  generateHtml(options) {
    const { name, svg, location, isBuilt, animation, isRasterized, variants } = options;
    if (!svg) {
      return this.generateEmptyState();
    }
    const css = this.loadCss();
    const displaySvg = this.prepareSvgForDisplay(svg, animation);
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link rel="stylesheet" href="https://unpkg.com/@vscode/codicons/dist/codicon.css" />
  <style>
    ${css}
  </style>
</head>
<body>
  ${this.generateHeader(name, isBuilt, isRasterized)}
  
  ${this.generatePreviewSurface(displaySvg, variants, isRasterized)}
  
  ${this.generateToolbar(!!location, isRasterized)}
  
  ${this.generateScript(name, variants)}
</body>
</html>`;
  }
};

// src/providers/IconPreviewProvider.ts
init_i18n();
var IconPreviewProvider = class {
  constructor(_extensionUri) {
    this._extensionUri = _extensionUri;
    this._templateService = new PreviewTemplateService(_extensionUri);
  }
  static viewType = "sageboxIconStudio.preview";
  _view;
  _currentSvg;
  _currentName;
  _currentLocation;
  _isBuilt;
  _currentAnimation;
  _templateService;
  // Read variants from variants.js file
  _getVariantsFilePath() {
    const outputDir = getSvgConfig("outputDirectory", "");
    const workspaceFolders = vscode27.workspace.workspaceFolders;
    if (!workspaceFolders || !outputDir) return void 0;
    return path25.join(workspaceFolders[0].uri.fsPath, outputDir, "variants.js");
  }
  _readVariantsFromFile() {
    try {
      const filePath = this._getVariantsFilePath();
      if (!filePath || !fs21.existsSync(filePath)) return {};
      const content = fs21.readFileSync(filePath, "utf-8");
      const match = content.match(/export\s+const\s+Variants\s*=\s*(\{[\s\S]*\});/);
      if (match) {
        return new Function(`return ${match[1]}`)();
      }
      return {};
    } catch {
      return {};
    }
  }
  _readColorMappings() {
    try {
      const filePath = this._getVariantsFilePath();
      if (!filePath || !fs21.existsSync(filePath)) return {};
      const content = fs21.readFileSync(filePath, "utf-8");
      const match = content.match(/export\s+const\s+colorMappings\s*=\s*(\{[\s\S]*?\});/);
      if (match) {
        return new Function(`return ${match[1]}`)();
      }
      return {};
    } catch {
      return {};
    }
  }
  _applyColorMappings(svg, iconName) {
    const mappings = this._readColorMappings()[iconName];
    if (!mappings || Object.keys(mappings).length === 0) return svg;
    let result = svg;
    for (const [originalColor, newColor] of Object.entries(mappings)) {
      const regex = new RegExp(originalColor.replace("#", "#?"), "gi");
      result = result.replace(regex, newColor);
    }
    return result;
  }
  _getSavedVariants(iconName) {
    const allVariants = this._readVariantsFromFile();
    const iconVariants = allVariants[iconName] || {};
    const colorMappings = this._readColorMappings()[iconName] || {};
    const hasColorChanges = Object.keys(colorMappings).length > 0;
    return Object.entries(iconVariants).filter(([name]) => {
      if (name.startsWith("_") && name !== "_original") return false;
      if (name === "custom" && !hasColorChanges) return false;
      return true;
    }).map(([name, colors]) => ({ name, colors }));
  }
  resolveWebviewView(webviewView, _context, _token) {
    this._view = webviewView;
    webviewView.webview.options = {
      enableScripts: true,
      localResourceRoots: [this._extensionUri]
    };
    webviewView.webview.html = this._templateService.generateHtml({ name: "", svg: "" });
    webviewView.webview.onDidReceiveMessage(async (message) => {
      switch (message.command) {
        case "goToLocation":
          if (this._currentLocation) {
            const uri = vscode27.Uri.file(this._currentLocation.file);
            const doc = await vscode27.workspace.openTextDocument(uri);
            const editor = await vscode27.window.showTextDocument(doc);
            const position = new vscode27.Position(this._currentLocation.line - 1, 0);
            editor.selection = new vscode27.Selection(position, position);
            editor.revealRange(
              new vscode27.Range(position, position),
              vscode27.TextEditorRevealType.InCenter
            );
          }
          break;
        case "copyName":
          if (this._currentName) {
            vscode27.env.clipboard.writeText(this._currentName);
            vscode27.window.showInformationMessage(
              t("messages.copiedNameToClipboard", { name: this._currentName })
            );
          }
          break;
        case "copySvg": {
          const svgToCopy = message.svg || this._currentSvg;
          if (svgToCopy) {
            vscode27.env.clipboard.writeText(svgToCopy);
            vscode27.window.showInformationMessage(t("messages.svgCopiedToClipboard"));
          }
          break;
        }
        case "refreshPreview":
          if (this._view && this._currentName && this._currentSvg) {
            this.updatePreview(
              this._currentName,
              this._currentSvg,
              this._currentLocation,
              this._isBuilt,
              this._currentAnimation
            );
          }
          break;
        case "optimizeSvg":
          if (message.svg) {
            try {
              const svgo = await Promise.resolve().then(() => __toESM(require_svgo_node()));
              const result = svgo.optimize(message.svg, {
                multipass: true,
                plugins: [
                  {
                    name: "preset-default",
                    params: {
                      overrides: {
                        removeViewBox: false
                      }
                    }
                  },
                  "removeDimensions"
                ]
              });
              webviewView.webview.postMessage({
                command: "svgOptimized",
                svg: result.data,
                originalSize: message.svg.length,
                optimizedSize: result.data.length
              });
            } catch (error) {
              vscode27.window.showErrorMessage(
                t("messages.failedToOptimize", { error: String(error) })
              );
            }
          }
          break;
        case "previewComponent":
          if (this._currentName && this._currentSvg) {
            vscode27.commands.executeCommand("sageboxIconStudio.colorEditor", {
              icon: {
                name: this._currentName,
                svg: this._currentSvg,
                filePath: this._currentLocation?.file,
                line: this._currentLocation?.line ? this._currentLocation.line - 1 : void 0
              }
            });
          }
          break;
        case "openDetails":
          if (this._currentName && this._currentSvg) {
            const { IconDetailsPanel: IconDetailsPanel2 } = await Promise.resolve().then(() => (init_IconDetailsPanel(), IconDetailsPanel_exports));
            IconDetailsPanel2.createOrShow(this._extensionUri, {
              name: this._currentName,
              svg: this._currentSvg,
              location: this._currentLocation,
              isBuilt: this._isBuilt,
              animation: this._currentAnimation
            });
          }
          break;
        case "findUsages":
          if (this._currentName) {
            const result = await IconUsageSearchService.findUsages(this._currentName);
            webviewView.webview.postMessage({
              command: "usagesResult",
              usages: result.usages,
              total: result.total
            });
          }
          break;
        case "goToUsage":
          if (message.file && message.line) {
            await IconUsageSearchService.goToLocation(message.file, message.line);
          }
          break;
      }
    });
  }
  updatePreview(name, svg, location, isBuilt, animation) {
    this._currentSvg = svg;
    this._currentName = name;
    this._currentLocation = location;
    this._isBuilt = isBuilt;
    this._currentAnimation = animation;
    let displaySvg = svg;
    if (isBuilt) {
      displaySvg = this._applyColorMappings(svg, name);
    }
    const MAX_COLORS_FOR_EDIT = 50;
    const colorMatches = displaySvg.match(
      /#[0-9a-fA-F]{3,8}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)/gi
    );
    const isRasterized = colorMatches ? new Set(colorMatches.map((c) => c.toLowerCase())).size > MAX_COLORS_FOR_EDIT : false;
    const variants = this._getSavedVariants(name);
    if (this._view) {
      this._view.webview.html = this._templateService.generateHtml({
        name,
        svg: displaySvg,
        location,
        isBuilt,
        animation,
        isRasterized,
        variants
      });
    }
  }
  clearPreview() {
    this._currentSvg = void 0;
    this._currentName = void 0;
    this._currentLocation = void 0;
    this._currentAnimation = void 0;
    if (this._view) {
      this._view.webview.html = this._templateService.generateHtml({ name: "", svg: "" });
    }
  }
  /**
   * Update only the SVG content without regenerating the entire HTML.
   * Used when Editor changes colors and needs to sync with TreeView preview.
   * @param currentColors - Optional colors from Editor to show as "custom" variant in real-time
   */
  updateSvgContent(name, svg, currentColors) {
    if (this._currentName === name && this._view) {
      this._currentSvg = svg;
      this._view.webview.postMessage({
        command: "updateSvgContent",
        svg,
        customColors: currentColors
      });
    }
  }
};

// src/panels/WelcomePanel.ts
var vscode29 = __toESM(require("vscode"));
var path28 = __toESM(require("path"));
var fs23 = __toESM(require("fs"));

// src/utils/iconsFileManager.ts
var path27 = __toESM(require("node:path"));
var fs22 = __toESM(require("node:fs"));

// src/utils/extensionHelpers.ts
var path26 = __toESM(require("node:path"));
var templateCache = /* @__PURE__ */ new Map();
function loadTemplate(templateName) {
  const cached = templateCache.get(templateName);
  if (cached) {
    return cached;
  }
  const realFs = require("fs");
  const possibleDirs = [
    path26.join(__dirname, "templates", "shared"),
    // dist/templates/shared
    path26.join(__dirname, "templates"),
    // dist/templates
    path26.join(__dirname, "..", "templates", "shared"),
    // out/templates/shared (from out/utils)
    path26.join(__dirname, "..", "templates")
    // out/templates (from out/utils)
  ];
  let templatePath = null;
  for (const dir of possibleDirs) {
    const candidate = path26.join(dir, templateName);
    if (realFs.existsSync(candidate)) {
      templatePath = candidate;
      break;
    }
  }
  if (!templatePath) {
    throw new Error(`Template not found: ${templateName}. Searched in: ${possibleDirs.join(", ")}`);
  }
  const content = realFs.readFileSync(templatePath, "utf-8");
  templateCache.set(templateName, content);
  return content;
}
function toVariableName2(name) {
  return name.split(/[-:]/).map((part, i) => i === 0 ? part : part.charAt(0).toUpperCase() + part.slice(1)).join("");
}

// src/utils/errorHandler.ts
var vscode28 = __toESM(require("vscode"));
var ErrorHandler = class {
  /**
   * Handles an error by logging it to the console and showing an error message to the user.
   * @param error The error object or message.
   * @param context A description of what was happening when the error occurred.
   * @param showNotification Whether to show a VS Code notification (default: true).
   */
  static handleError(error, context, showNotification = true) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    const fullMessage = `Icon Studio: Error during ${context}: ${errorMessage}`;
    console.error(fullMessage);
    if (error instanceof Error && error.stack) {
      console.error(error.stack);
    }
    if (showNotification) {
      vscode28.window.showErrorMessage(`Icon Studio: ${errorMessage}`);
    }
  }
  /**
   * Wraps an async operation with error handling.
   * @param operation The async function to execute.
   * @param contextDescription A description of the operation for the error message.
   * @returns The result of the operation, or undefined if it failed.
   */
  static async wrapAsync(operation, contextDescription) {
    try {
      return await operation();
    } catch (error) {
      this.handleError(error, contextDescription);
      return void 0;
    }
  }
  /**
   * Wraps a synchronous operation with error handling.
   * @param operation The function to execute.
   * @param contextDescription A description of the operation for the error message.
   * @returns The result of the operation, or undefined if it failed.
   */
  static wrapSync(operation, contextDescription) {
    try {
      return operation();
    } catch (error) {
      this.handleError(error, contextDescription);
      return void 0;
    }
  }
};

// src/utils/svgValidation.ts
var SVG_PATTERNS = {
  // Full SVG tag detection
  fullSvg: /<svg[^>]*>[\s\S]*?<\/svg>/gi,
  // SVG opening tag
  openingTag: /<svg\b[^>]*>/i,
  // SVG closing tag
  closingTag: /<\/svg>/i,
  // SVG namespace
  namespace: /xmlns=["']http:\/\/www\.w3\.org\/2000\/svg["']/i,
  // ViewBox attribute
  viewBox: /viewBox=["']([^"']+)["']/i,
  // Width attribute
  width: /\bwidth=["']([^"']+)["']/i,
  // Height attribute
  height: /\bheight=["']([^"']+)["']/i,
  // Fill attribute
  fill: /\bfill=["']([^"']+)["']/gi,
  // Stroke attribute
  stroke: /\bstroke=["']([^"']+)["']/gi,
  // Path element
  pathElement: /<path[^>]*>/gi,
  // Circle element
  circleElement: /<circle[^>]*>/gi,
  // Rect element
  rectElement: /<rect[^>]*>/gi,
  // Gradient definitions
  gradient: /<(linear|radial)Gradient/i,
  // Style element
  styleElement: /<style[^>]*>[\s\S]*?<\/style>/gi,
  // Class attribute
  classAttr: /\bclass=["']([^"']+)["']/gi,
  // ID attribute
  idAttr: /\bid=["']([^"']+)["']/i,
  // Title element
  titleElement: /<title[^>]*>([^<]*)<\/title>/i,
  // Desc element
  descElement: /<desc[^>]*>([^<]*)<\/desc>/i
};
var INVALID_CONTENT_PATTERNS = {
  // DOCTYPE declaration (HTML)
  doctype: /<!DOCTYPE\s+html/i,
  // HTML tag
  htmlTag: /<html\b/i,
  // Head tag
  headTag: /<head\b/i,
  // Body tag
  bodyTag: /<body\b/i,
  // Script tag (outside SVG context)
  scriptTag: /<script\b[^>]*>[\s\S]*?<\/script>/i,
  // Meta tag
  metaTag: /<meta\b/i,
  // Link tag (stylesheet)
  linkTag: /<link\b[^>]*rel=["']stylesheet["']/i
};
function isHtmlContent(content) {
  if (!content || typeof content !== "string") {
    return false;
  }
  return INVALID_CONTENT_PATTERNS.doctype.test(content) || INVALID_CONTENT_PATTERNS.htmlTag.test(content) || INVALID_CONTENT_PATTERNS.headTag.test(content) || INVALID_CONTENT_PATTERNS.bodyTag.test(content);
}
function validateSvgContent(content) {
  if (!content || typeof content !== "string") {
    return { valid: false, error: "Content is empty or not a string" };
  }
  if (isHtmlContent(content)) {
    return { valid: false, error: "Content appears to be HTML, not SVG" };
  }
  if (!SVG_PATTERNS.openingTag.test(content)) {
    return { valid: false, error: "Missing <svg> opening tag" };
  }
  if (!SVG_PATTERNS.closingTag.test(content)) {
    return { valid: false, error: "Missing </svg> closing tag" };
  }
  return { valid: true };
}

// src/utils/iconsFileManager.ts
function createIconEntry(options) {
  const { varName, iconName, body, viewBox, animation } = options;
  if (animation) {
    const delay = animation.delay || 0;
    const direction = animation.direction || "normal";
    return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}',
  animation: { type: '${animation.type}', duration: ${animation.duration}, timing: '${animation.timing}', iteration: '${animation.iteration}', delay: ${delay}, direction: '${direction}' }
};`;
  }
  return `export const ${varName} = {
  name: '${iconName}',
  body: \`${body}\`,
  viewBox: '${viewBox}'
};`;
}
function updateExistingIcon(content, varName, iconEntry) {
  const regex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};`, "g");
  return content.replace(regex, iconEntry);
}
function addNewIconToContent(content, varName, iconEntry) {
  const iconsObjMatch = /export const icons = \{/.exec(content);
  if (iconsObjMatch?.index === void 0) {
    return content + "\n\n" + iconEntry;
  }
  let updatedContent = content.slice(0, iconsObjMatch.index) + iconEntry + "\n\n" + content.slice(iconsObjMatch.index);
  const objData = extractIconsObjectContent(updatedContent);
  if (objData) {
    const existingIcons = objData.inner.trim();
    const newInner = existingIcons ? `${existingIcons},
  ${varName}` : `
  ${varName}
`;
    updatedContent = updatedContent.substring(0, objData.startIndex) + newInner + updatedContent.substring(objData.endIndex);
  }
  return updatedContent;
}
function createNewIconsFileContent(iconEntry, varName) {
  return `// Auto-generated by Icon Studio
// Do not edit manually

${iconEntry}

export const icons = {
  ${varName}
};
`;
}
async function addToIconsJs(options) {
  const {
    outputPath,
    iconName,
    svgContent,
    transformer,
    animation,
    skipWebComponentGeneration = false
  } = options;
  return ErrorHandler.wrapAsync(async () => {
    const validation = validateSvgContent(svgContent);
    if (!validation.valid) {
      throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
    }
    const iconsPath = path27.join(outputPath, "icons.js");
    const varName = toVariableName2(iconName);
    const body = transformer.extractSvgBody(svgContent);
    const attrs = transformer.extractSvgAttributes(svgContent);
    const iconEntry = createIconEntry({
      varName,
      iconName,
      body,
      viewBox: attrs.viewBox || "0 0 24 24",
      animation
    });
    if (!fs22.existsSync(outputPath)) {
      fs22.mkdirSync(outputPath, { recursive: true });
    }
    if (fs22.existsSync(iconsPath)) {
      let content = fs22.readFileSync(iconsPath, "utf-8");
      content = content.includes(`export const ${varName}`) ? updateExistingIcon(content, varName, iconEntry) : addNewIconToContent(content, varName, iconEntry);
      fs22.writeFileSync(iconsPath, content);
    } else {
      fs22.writeFileSync(iconsPath, createNewIconsFileContent(iconEntry, varName));
    }
    if (!skipWebComponentGeneration) {
      await generateWebComponent(outputPath);
    }
  }, `adding icon ${iconName} to icons.js`);
}
async function updateIconAnimation(outputPath, iconName, animation) {
  const iconsPath = path27.join(outputPath, "icons.js");
  if (!fs22.existsSync(iconsPath)) return false;
  const varName = toVariableName2(iconName);
  let content = fs22.readFileSync(iconsPath, "utf-8");
  const iconPattern = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};`, "g");
  const match = iconPattern.exec(content);
  if (!match) return false;
  const iconBlock = match[0];
  const nameMatch = /name:\s*['"]([^'"]+)['"]/.exec(iconBlock);
  const bodyMatch = /body:\s*`([^`]*)`/.exec(iconBlock);
  const viewBoxMatch = /viewBox:\s*['"]([^'"]+)['"]/.exec(iconBlock);
  if (!nameMatch || !bodyMatch || !viewBoxMatch) return false;
  const name = nameMatch[1];
  const body = bodyMatch[1];
  const viewBox = viewBoxMatch[1];
  const newEntry = createIconEntry({
    varName,
    iconName: name,
    body,
    viewBox,
    animation: animation || void 0
  });
  content = content.replace(iconBlock, newEntry);
  fs22.writeFileSync(iconsPath, content);
  await generateWebComponent(outputPath);
  return true;
}
async function generateWebComponent(outputPath) {
  const config = getConfig();
  const tagName = config.webComponentName;
  const componentPath = path27.join(outputPath, "icon.js");
  const template = loadTemplate("IconWebComponent.js");
  const content = template.replace(/\$\{TAG_NAME\}/g, tagName);
  return { path: componentPath, content };
}
async function addToSpriteSvg(outputPath, iconName, svgContent, transformer) {
  const validation = validateSvgContent(svgContent);
  if (!validation.valid) {
    throw new Error(`Invalid SVG content for "${iconName}": ${validation.error}`);
  }
  const spritePath = path27.join(outputPath, "sprite.svg");
  const body = transformer.extractSvgBody(svgContent);
  const attrs = transformer.extractSvgAttributes(svgContent);
  const symbolEntry = `  <symbol id="${iconName}" viewBox="${attrs.viewBox || "0 0 24 24"}">
    ${body}
  </symbol>`;
  if (!fs22.existsSync(outputPath)) {
    fs22.mkdirSync(outputPath, { recursive: true });
  }
  if (fs22.existsSync(spritePath)) {
    let content = fs22.readFileSync(spritePath, "utf-8");
    const existingSymbol = new RegExp(
      String.raw`<symbol[^>]*id=["']${iconName}["'][\s\S]*?<\/symbol>`,
      "g"
    );
    if (existingSymbol.test(content)) {
      content = content.replace(existingSymbol, symbolEntry);
    } else {
      content = content.replace("</svg>", `${symbolEntry}
</svg>`);
    }
    fs22.writeFileSync(spritePath, content);
  } else {
    const content = `<svg xmlns="http://www.w3.org/2000/svg" style="display: none;">
${symbolEntry}
</svg>
`;
    fs22.writeFileSync(spritePath, content);
  }
}
function removeFromIconsJs(outputPath, iconNames) {
  const iconsPath = path27.join(outputPath, "icons.js");
  if (!fs22.existsSync(iconsPath)) {
    return false;
  }
  let content = fs22.readFileSync(iconsPath, "utf-8");
  for (const name of iconNames) {
    const varName = toVariableName2(name);
    const exportRegex = new RegExp(String.raw`export const ${varName} = \{[\s\S]*?\};\s*`, "g");
    content = content.replace(exportRegex, "");
    const iconsObjRegex = new RegExp(String.raw`,?\s*${varName}\s*,?`, "g");
    content = content.replace(iconsObjRegex, (match) => {
      return match.startsWith(",") && match.endsWith(",") ? "," : "";
    });
  }
  content = content.replace(/,\s*,/g, ",");
  content = content.replace(/\{\s*,/g, "{");
  content = content.replace(/,\s*\}/g, "\n}");
  fs22.writeFileSync(iconsPath, content);
  return true;
}
function cleanSpriteSvg(outputPath) {
  const spritePath = path27.join(outputPath, "sprite.svg");
  const removed = [];
  let kept = 0;
  if (!fs22.existsSync(spritePath)) {
    return { removed, kept };
  }
  const content = fs22.readFileSync(spritePath, "utf-8");
  const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
  const validSymbols = [];
  let match;
  while ((match = symbolRegex.exec(content)) !== null) {
    const symbolId = match[1];
    const symbolContent = match[2];
    const fullSymbol = match[0];
    const hasHtml = /<!DOCTYPE|<html|<head|<body|<meta|<style[^>]*>[\s\S]*?<\/style>[\s\S]*<style/i.test(
      symbolContent
    );
    if (hasHtml) {
      removed.push(symbolId);
    } else {
      validSymbols.push(fullSymbol);
      kept++;
    }
  }
  if (removed.length > 0) {
    const newContent = `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
  <!--
    SVG Sprite Sheet
    Generated by Icon Studio VS Code Extension
    Total icons: ${kept}
  -->
${validSymbols.join("\n\n")}
</svg>`;
    fs22.writeFileSync(spritePath, newContent);
  }
  return { removed, kept };
}

// src/panels/WelcomePanel.ts
init_i18n();
var welcomeCss = null;
var welcomeJs = null;
var welcomeHtml = null;
function loadTemplates() {
  if (!welcomeCss || !welcomeJs || !welcomeHtml) {
    const possibleDirs = [
      path28.join(__dirname, "templates", "welcome"),
      // dist/templates/welcome (bundled)
      path28.join(__dirname, "..", "templates", "welcome")
      // out/templates/welcome (from out/panels)
    ];
    let templatesDir = null;
    for (const dir of possibleDirs) {
      if (fs23.existsSync(path28.join(dir, "Welcome.css"))) {
        templatesDir = dir;
        break;
      }
    }
    if (!templatesDir) {
      throw new Error(`Welcome templates not found. Searched in: ${possibleDirs.join(", ")}`);
    }
    welcomeCss = fs23.readFileSync(path28.join(templatesDir, "Welcome.css"), "utf-8");
    welcomeJs = fs23.readFileSync(path28.join(templatesDir, "Welcome.js"), "utf-8");
    welcomeHtml = fs23.readFileSync(path28.join(templatesDir, "Welcome.html"), "utf-8");
  }
  return { css: welcomeCss, js: welcomeJs, html: welcomeHtml };
}
var WelcomePanel = class _WelcomePanel {
  static currentPanel;
  static viewType = "sageboxIconStudio.welcome";
  _panel;
  _extensionUri;
  _disposables = [];
  // Temporary session state - only persisted on finishSetup
  _sessionConfig;
  static createOrShow(extensionUri) {
    const column = vscode29.window.activeTextEditor ? vscode29.window.activeTextEditor.viewColumn : void 0;
    if (_WelcomePanel.currentPanel) {
      _WelcomePanel.currentPanel._panel.reveal(column);
      return;
    }
    const panel = vscode29.window.createWebviewPanel(
      _WelcomePanel.viewType,
      t("welcome.title"),
      column || vscode29.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [extensionUri]
      }
    );
    _WelcomePanel.currentPanel = new _WelcomePanel(panel, extensionUri);
  }
  static isConfigured() {
    const config = vscode29.workspace.getConfiguration("sageboxIconStudio");
    const outputDir = config.get("outputDirectory", "");
    return !!outputDir;
  }
  constructor(panel, extensionUri) {
    this._panel = panel;
    this._extensionUri = extensionUri;
    const config = vscode29.workspace.getConfiguration("sageboxIconStudio");
    this._sessionConfig = {
      svgFolders: config.get("svgFolders", []),
      outputDirectory: config.get("outputDirectory", ""),
      buildFormat: config.get("buildFormat", ""),
      webComponentName: config.get("webComponentName", ""),
      svgoOptimize: config.get("svgoOptimize", true),
      scanOnStartup: config.get("scanOnStartup", true),
      defaultIconSize: config.get("defaultIconSize", 24),
      previewBackground: config.get("previewBackground", "transparent"),
      autoGenerateLicenses: config.get("autoGenerateLicenses", true)
    };
    this._update();
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    this._panel.webview.onDidReceiveMessage(
      async (message) => {
        switch (message.command) {
          case "setSourceDirectory":
            await this._setSourceDirectory(message.directory);
            break;
          case "chooseSourceFolder":
            await this._chooseSourceFolder();
            break;
          case "setOutputDirectory":
            await this._setOutputDirectory(message.directory);
            break;
          case "chooseFolder":
            await this._chooseFolder();
            break;
          case "setBuildFormat":
            await this._setBuildFormat(message.format);
            break;
          case "setWebComponentName":
            await this._setWebComponentName(message.name);
            break;
          case "setLanguage":
            await this._setLanguage(message.language);
            break;
          case "setSvgoOptimize":
            await this._setSvgoOptimize(message.value);
            break;
          case "setScanOnStartup":
            await this._setScanOnStartup(message.value);
            break;
          case "setDefaultIconSize":
            await this._setDefaultIconSize(message.value);
            break;
          case "setPreviewBackground":
            await this._setPreviewBackground(message.value);
            break;
          case "setLicenseConsent":
            await this._setLicenseConsent(message.value);
            break;
          case "openSettings":
            vscode29.commands.executeCommand("workbench.action.openSettings", "sageboxIconStudio");
            break;
          case "searchIcons":
            vscode29.commands.executeCommand("sageboxIconStudio.searchIcons");
            this._panel.dispose();
            break;
          case "close":
            this._panel.dispose();
            break;
          case "finishSetup":
            await this._finishSetup();
            break;
        }
      },
      null,
      this._disposables
    );
    this._disposables.push(
      i18n.onDidChangeLocale(() => {
        this._update();
      })
    );
    this._disposables.push(
      vscode29.workspace.onDidChangeConfiguration((e) => {
        if (e.affectsConfiguration("sageboxIconStudio")) {
          this._update();
        }
      })
    );
  }
  async _setSourceDirectory(directory) {
    const currentFolders = this._sessionConfig.svgFolders;
    this._sessionConfig.svgFolders = [directory, ...currentFolders.filter((f) => f !== directory)];
    this._update();
  }
  async _chooseSourceFolder() {
    const workspaceFolder = vscode29.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) return;
    const folderUri = await vscode29.window.showOpenDialog({
      canSelectFiles: false,
      canSelectFolders: true,
      canSelectMany: false,
      defaultUri: workspaceFolder.uri,
      openLabel: t("welcome.sourceDirectory")
    });
    if (folderUri && folderUri.length > 0) {
      const fullPath = folderUri[0].fsPath;
      const workspacePath = workspaceFolder.uri.fsPath;
      const relativePath = path28.relative(workspacePath, fullPath).replace(/\\/g, "/");
      await this._setSourceDirectory(relativePath);
    }
  }
  async _setOutputDirectory(directory) {
    this._sessionConfig.outputDirectory = directory;
    const workspaceFolder = vscode29.workspace.workspaceFolders?.[0];
    if (workspaceFolder) {
      const fullPath = path28.join(workspaceFolder.uri.fsPath, directory);
      if (!fs23.existsSync(fullPath)) {
        fs23.mkdirSync(fullPath, { recursive: true });
      }
    }
    this._update();
  }
  async _chooseFolder() {
    const workspaceFolder = vscode29.workspace.workspaceFolders?.[0];
    if (!workspaceFolder) return;
    const folderUri = await vscode29.window.showOpenDialog({
      canSelectFiles: false,
      canSelectFolders: true,
      canSelectMany: false,
      defaultUri: workspaceFolder.uri,
      openLabel: t("welcome.selectFolder")
    });
    if (folderUri && folderUri.length > 0) {
      const fullPath = folderUri[0].fsPath;
      const workspacePath = workspaceFolder.uri.fsPath;
      const relativePath = path28.relative(workspacePath, fullPath).replace(/\\/g, "/");
      await this._setOutputDirectory(relativePath);
    }
  }
  async _setBuildFormat(format) {
    this._sessionConfig.buildFormat = format;
    this._update();
  }
  async _setWebComponentName(name) {
    this._sessionConfig.webComponentName = name;
    this._update();
  }
  async _setLanguage(language) {
    await i18n.setLocale(language);
  }
  async _setSvgoOptimize(value) {
    this._sessionConfig.svgoOptimize = value;
  }
  async _setScanOnStartup(value) {
    this._sessionConfig.scanOnStartup = value;
  }
  async _setDefaultIconSize(value) {
    this._sessionConfig.defaultIconSize = value;
  }
  async _setPreviewBackground(value) {
    this._sessionConfig.previewBackground = value;
  }
  async _setLicenseConsent(value) {
    this._sessionConfig.autoGenerateLicenses = value;
    this._update();
  }
  async _finishSetup() {
    const outputDir = this._sessionConfig.outputDirectory;
    const buildFormat = this._sessionConfig.buildFormat;
    const webComponentName = this._sessionConfig.webComponentName;
    const workspaceFolder = vscode29.workspace.workspaceFolders?.[0];
    if (!workspaceFolder || !outputDir) {
      vscode29.window.showWarningMessage(`\u26A0\uFE0F ${t("welcome.configureOutputFirst")}`);
      return;
    }
    const fullPath = path28.join(workspaceFolder.uri.fsPath, outputDir);
    if (!fs23.existsSync(fullPath)) {
      fs23.mkdirSync(fullPath, { recursive: true });
    }
    try {
      const config = vscode29.workspace.getConfiguration("sageboxIconStudio");
      await config.update(
        "svgFolders",
        this._sessionConfig.svgFolders,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "outputDirectory",
        this._sessionConfig.outputDirectory,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "buildFormat",
        this._sessionConfig.buildFormat,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "webComponentName",
        this._sessionConfig.webComponentName,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "svgoOptimize",
        this._sessionConfig.svgoOptimize,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "scanOnStartup",
        this._sessionConfig.scanOnStartup,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "defaultIconSize",
        this._sessionConfig.defaultIconSize,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "previewBackground",
        this._sessionConfig.previewBackground,
        vscode29.ConfigurationTarget.Workspace
      );
      await config.update(
        "autoGenerateLicenses",
        this._sessionConfig.autoGenerateLicenses,
        vscode29.ConfigurationTarget.Workspace
      );
      if (buildFormat === "sprite.svg") {
        await this._generateEmptySprite(fullPath);
        vscode29.window.showInformationMessage(
          `${t("welcome.setupComplete")} ${t("welcome.spriteCreated", { path: outputDir })}`
        );
      } else {
        await this._generateEmptyIconsModule(fullPath, webComponentName);
        vscode29.window.showInformationMessage(
          `${t("welcome.setupComplete")} ${t("welcome.filesCreated", { path: outputDir })}`
        );
      }
      vscode29.commands.executeCommand("sageboxIconStudio.refreshIcons");
    } catch (error) {
      vscode29.window.showErrorMessage(`\u274C ${t("welcome.errorCreatingFiles")}: ${error.message}`);
    }
    this._panel.dispose();
  }
  /**
   * Generate empty sprite.svg file
   */
  async _generateEmptySprite(outputPath) {
    const spritePath = path28.join(outputPath, "sprite.svg");
    const content = `<?xml version="1.0" encoding="UTF-8"?>
<!-- Auto-generated by Icon Studio -->
<!-- Add icons using "Add to Icon Collection" or drag SVG files here -->
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display: none;">
  <!-- Icons will be added here as <symbol> elements -->
  <!-- Usage: <svg><use href="sprite.svg#icon-name"></use></svg> -->
</svg>
`;
    fs23.writeFileSync(spritePath, content, "utf-8");
  }
  /**
   * Generate empty icons module files (icons.js, icon.js, icons.d.ts)
   */
  async _generateEmptyIconsModule(outputPath, webComponentName) {
    const iconsPath = path28.join(outputPath, "icons.js");
    const iconsContent = `// Auto-generated by Icon Studio
// Add icons using "Add to Icon Collection" or drag SVG files here

// Icon exports will be added here
// Example: export const arrowRight = { name: 'arrow-right', body: '...', viewBox: '0 0 24 24' };

// Collection of all icons
export const icons = {
  // Icons will be added here
};
`;
    fs23.writeFileSync(iconsPath, iconsContent, "utf-8");
    const webComponent = await generateWebComponent(outputPath);
    fs23.writeFileSync(webComponent.path, webComponent.content, "utf-8");
    const typesPath = path28.join(outputPath, "icons.d.ts");
    const typesContent = `// Auto-generated TypeScript definitions by Icon Studio
// This file provides type safety for your icon library

export interface IconData {
  name: string;
  body: string;
  viewBox: string;
  animation?: {
    type: string;
    duration: number;
    timing: string;
    iteration: string;
    delay?: number;
    direction?: string;
  };
}

// Icon names will be added here as you add icons
export type IconName = string;

// Collection of all icons
export declare const icons: Record<IconName, IconData>;

// Web Component
export declare class IconElement extends HTMLElement {
  name: string;
  size: string;
  color: string;
  animation: string;
}

declare global {
  interface HTMLElementTagNameMap {
    '${webComponentName}': IconElement;
  }
}
`;
    fs23.writeFileSync(typesPath, typesContent, "utf-8");
  }
  dispose() {
    _WelcomePanel.currentPanel = void 0;
    this._panel.dispose();
    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }
  _update() {
    this._panel.webview.html = this._getHtmlForWebview();
  }
  _getI18n() {
    return {
      // Language selector
      languageLabel: t("welcome.language"),
      languageDescription: t("welcome.languageDescription"),
      // Header
      appTitle: t("extension.appTitle"),
      headerIcons: "200k+ " + t("treeView.files"),
      headerColors: t("editor.color") + " " + t("features.iconEditor").split(" ")[0],
      headerAnimations: t("animation.title"),
      headerSvgo: "SVGO",
      // Step 1 - Source Directory
      step1SourceTitle: t("welcome.sourceDirectory"),
      step1SourceDesc: t("welcome.sourceDirectoryDescription"),
      step1SourcePlaceholder: t("welcome.sourceDirectoryPlaceholder"),
      step1Apply: t("editor.apply"),
      browse: t("welcome.browse"),
      // Step 2 - Output Directory
      step2Title: t("welcome.outputDirectory"),
      step2Desc: t("welcome.outputDirectoryDescription"),
      step2Placeholder: t("welcome.outputDirectoryPlaceholder"),
      // Step 3 - Build Format
      step3Title: t("settings.outputFormat"),
      step3Desc: t("features.buildSystemDescription"),
      step3Help: "?",
      selectFormat: t("welcome.selectFormat"),
      jsModuleTitle: t("welcome.jsModule"),
      jsModuleDesc: t("features.codeIntegrationDescription"),
      jsModulePro1: t("editor.variants"),
      jsModulePro2: t("editor.custom"),
      spriteTitle: t("sprite.title"),
      spriteDesc: t("features.buildSystemDescription"),
      spritePro1: t("welcome.noRuntime"),
      spritePro2: t("sprite.title"),
      recommended: "\u2B50",
      comingSoon: t("welcome.comingSoon"),
      // Help panel
      helpJsModule: t("features.codeIntegrationDescription"),
      helpSprite: t("features.buildSystemDescription"),
      helpTip: t("welcome.quickStartDescription"),
      // Step 4 - Web Component Name
      step4Title: t("welcome.webComponentName"),
      step4Desc: t("welcome.webComponentDesc"),
      // Step 5 - License Consent
      step5Title: t("welcome.licenseConsentTitle"),
      step5Desc: t("welcome.licenseConsentDesc"),
      step5Checkbox: t("welcome.licenseConsentCheckbox"),
      step5Info: t("welcome.licenseConsentInfo"),
      // Advanced Options
      advancedTitle: t("welcome.advancedOptions"),
      svgoOptimizeLabel: t("welcome.svgoOptimize"),
      scanOnStartupLabel: t("welcome.scanOnStartup"),
      defaultIconSizeLabel: t("welcome.defaultIconSize"),
      previewBackgroundLabel: t("welcome.previewBackground"),
      allSettings: t("welcome.allSettings"),
      // Preview
      previewTitle: t("editor.preview"),
      previewImport: t("welcome.import"),
      previewUse: t("welcome.use"),
      previewRef: t("welcome.reference"),
      previewOutput: t("welcome.outputDirectory"),
      previewFormat: t("settings.outputFormat"),
      previewTag: t("welcome.tag"),
      previewResultLabel: t("welcome.previewResult"),
      buildFirstMessage: t("welcome.buildFirstMessage"),
      selectFormatFirst: t("welcome.selectFormatFirst"),
      // Workflow
      workflowSource: t("welcome.workflowSource"),
      workflowBuild: t("welcome.workflowBuild"),
      workflowOutput: t("welcome.workflowOutput"),
      // Actions
      settings: t("settings.title"),
      skip: t("messages.cancel"),
      getStarted: t("welcome.getStarted"),
      completeStep1: t("welcome.save")
    };
  }
  _getHtmlForWebview() {
    const templates = loadTemplates();
    const svgFolders = this._sessionConfig.svgFolders;
    const sourceDir = svgFolders.length > 0 ? svgFolders[0] : "";
    const outputDir = this._sessionConfig.outputDirectory;
    const buildFormat = this._sessionConfig.buildFormat;
    const webComponentName = this._sessionConfig.webComponentName;
    const svgoOptimize = this._sessionConfig.svgoOptimize;
    const scanOnStartup = this._sessionConfig.scanOnStartup;
    const defaultIconSize = this._sessionConfig.defaultIconSize;
    const previewBackground = this._sessionConfig.previewBackground;
    const isSourceConfigured = !!sourceDir;
    const isOutputConfigured2 = !!outputDir;
    const isBuildFormatConfigured = !!buildFormat;
    const isWebComponentConfigured = webComponentName && webComponentName.includes("-");
    const isStep1Complete = isSourceConfigured;
    const isStep2Unlocked = true;
    const isStep2Complete = isOutputConfigured2;
    const isStep3Unlocked = true;
    const isStep3Complete = isBuildFormatConfigured;
    const isStep4Unlocked = true;
    const isStep4Complete = isWebComponentConfigured;
    const isFullyConfigured2 = isStep1Complete && isStep2Complete && isStep3Complete && isStep4Complete;
    let detectedFramework = "html";
    if (vscode29.workspace.workspaceFolders) {
      const workspaceRoot = vscode29.workspace.workspaceFolders[0].uri.fsPath;
      const packageJsonPath = path28.join(workspaceRoot, "package.json");
      if (fs23.existsSync(packageJsonPath)) {
        try {
          const packageJson = JSON.parse(fs23.readFileSync(packageJsonPath, "utf-8"));
          const deps = { ...packageJson.dependencies, ...packageJson.devDependencies };
          if (deps["react"] || deps["next"] || deps["gatsby"]) {
            detectedFramework = "react";
          } else if (deps["vue"] || deps["nuxt"]) {
            detectedFramework = "vue";
          } else if (deps["svelte"] || deps["@sveltejs/kit"]) {
            detectedFramework = "svelte";
          } else if (deps["@angular/core"]) {
            detectedFramework = "angular";
          } else if (deps["astro"]) {
            detectedFramework = "astro";
          }
        } catch {
        }
      }
    }
    if (isStep2Complete && vscode29.workspace.workspaceFolders) {
      const workspaceRoot = vscode29.workspace.workspaceFolders[0].uri.fsPath;
      const outputFile = buildFormat === "icons.ts" ? path28.join(workspaceRoot, outputDir, "icons.js") : path28.join(workspaceRoot, outputDir, "sprite.svg");
      fs23.existsSync(outputFile);
    }
    const tr = this._getI18n();
    const currentLocale = i18n.getConfiguredLocale();
    const languageOptions = SUPPORTED_LOCALES.map((locale) => {
      const selected = locale.code === currentLocale ? "selected" : "";
      const label = locale.code === "auto" ? `${locale.flag} ${t("settings.languageAuto")}` : `${locale.flag} ${locale.nativeName}`;
      return `<option value="${locale.code}" ${selected}>${label}</option>`;
    }).join("\n          ");
    const step4DisabledClass = isStep4Unlocked ? "" : "step-disabled";
    const step4Section = buildFormat === "icons.ts" ? `
      <div class="step ${step4DisabledClass}">
        <div class="step-header">
          <div class="step-number${isStep4Complete ? " completed" : ""}"><span>4</span></div>
          <div class="step-title">${tr.step4Title}</div>
          ${isStep4Complete ? `<span class="step-summary">&lt;${webComponentName}&gt;</span>` : ""}
        </div>
        <div class="step-content">
          <p class="step-description">${tr.step4Desc}</p>
          <div class="input-group">
            <input type="text" id="webComponentName" value="${webComponentName}" placeholder="sg-icon" onkeypress="handleTagKeypress(event)" ${isStep4Unlocked ? "" : "disabled"} />
            <button class="btn-secondary" onclick="applyWebComponentName()" ${isStep4Unlocked ? "" : "disabled"}>${tr.step1Apply}</button>
          </div>
        </div>
      </div>
    ` : "";
    const autoGenerateLicenses = this._sessionConfig.autoGenerateLicenses;
    const isStep5Complete = autoGenerateLicenses;
    const step5Section = `
      <div class="step">
        <div class="step-header">
          <div class="step-number${isStep5Complete ? " completed" : ""}"><span>5</span></div>
          <div class="step-title">${tr.step5Title}</div>
          ${isStep5Complete ? `<span class="step-summary">\u2713</span>` : ""}
        </div>
        <div class="step-content">
          <p class="step-description">${tr.step5Desc}</p>
          <div class="license-consent-box">
            <label class="consent-checkbox">
              <input type="checkbox" id="licenseConsent" ${autoGenerateLicenses ? "checked" : ""} onchange="setLicenseConsent(this.checked)">
              <span class="consent-checkmark"></span>
              <span class="consent-text">${tr.step5Checkbox}</span>
            </label>
            <p class="consent-info">
              <svg viewBox="0 0 24 24" class="info-icon"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
              ${tr.step5Info}
            </p>
          </div>
        </div>
      </div>
    `;
    const outputDirDisplay = outputDir || "public/icons";
    const webComponentDisplay = webComponentName || "sg-icon";
    const getFrameworkPreview = () => {
      if (!buildFormat) {
        return `<div class="preview-placeholder">
          <div class="preview-placeholder-icon">
            <svg viewBox="0 0 24 24">
              <path d="M9.4 16.6L4.8 12l4.6-4.6L8 6l-6 6 6 6 1.4-1.4zm5.2 0l4.6-4.6-4.6-4.6L16 6l6 6-6 6-1.4-1.4z"/>
            </svg>
          </div>
          <p class="preview-placeholder-text">${tr.selectFormatFirst}</p>
          <p class="preview-placeholder-hint">
            <svg viewBox="0 0 24 24"><path d="M11 7h2v2h-2zm0 4h2v6h-2zm1-9C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm0 18c-4.41 0-8-3.59-8-8s3.59-8 8-8 8 3.59 8 8-3.59 8-8 8z"/></svg>
            Paso 3
          </p>
        </div>`;
      }
      if (buildFormat === "sprite.svg") {
        return `<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="comment">&lt;!-- ${tr.previewRef} --&gt;</span></div>
<div class="code-line"><span class="line-num">2</span><span class="tag">&lt;svg</span> <span class="attr">width</span>=<span class="value">"24"</span> <span class="attr">height</span>=<span class="value">"24"</span><span class="tag">&gt;</span></div>
<div class="code-line"><span class="line-num">3</span>  <span class="tag">&lt;use</span> <span class="attr">href</span>=<span class="value">"${outputDirDisplay}/sprite.svg#home"</span> <span class="tag">/&gt;</span></div>
<div class="code-line"><span class="line-num">4</span><span class="tag">&lt;/svg&gt;</span></div>
</div>`;
      }
      const frameworkBadge = detectedFramework !== "html" ? `<div class="framework-badge">${detectedFramework.charAt(0).toUpperCase() + detectedFramework.slice(1)}</div>` : "";
      switch (detectedFramework) {
        case "react":
          return `${frameworkBadge}<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="comment">// ${tr.previewImport}</span></div>
<div class="code-line"><span class="line-num">2</span><span class="keyword">import</span> <span class="value">'${outputDirDisplay}/icons.js'</span>;</div>
<div class="code-line"><span class="line-num">3</span></div>
<div class="code-line"><span class="line-num">4</span><span class="comment">// ${tr.previewUse}</span></div>
<div class="code-line"><span class="line-num">5</span><span class="keyword">function</span> <span class="func">App</span>() {</div>
<div class="code-line"><span class="line-num">6</span>  <span class="keyword">return</span> <span class="tag">&lt;${webComponentDisplay}</span> <span class="attr">name</span>=<span class="value">"home"</span> <span class="tag">/&gt;</span>;</div>
<div class="code-line"><span class="line-num">7</span>}</div>
</div>`;
        case "vue":
          return `${frameworkBadge}<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="tag">&lt;script</span> <span class="attr">setup</span><span class="tag">&gt;</span></div>
<div class="code-line"><span class="line-num">2</span><span class="keyword">import</span> <span class="value">'${outputDirDisplay}/icons.js'</span>;</div>
<div class="code-line"><span class="line-num">3</span><span class="tag">&lt;/script&gt;</span></div>
<div class="code-line"><span class="line-num">4</span></div>
<div class="code-line"><span class="line-num">5</span><span class="tag">&lt;template&gt;</span></div>
<div class="code-line"><span class="line-num">6</span>  <span class="tag">&lt;${webComponentDisplay}</span> <span class="attr">name</span>=<span class="value">"home"</span> <span class="tag">/&gt;</span></div>
<div class="code-line"><span class="line-num">7</span><span class="tag">&lt;/template&gt;</span></div>
</div>`;
        case "svelte":
          return `${frameworkBadge}<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="tag">&lt;script&gt;</span></div>
<div class="code-line"><span class="line-num">2</span>  <span class="keyword">import</span> <span class="value">'${outputDirDisplay}/icons.js'</span>;</div>
<div class="code-line"><span class="line-num">3</span><span class="tag">&lt;/script&gt;</span></div>
<div class="code-line"><span class="line-num">4</span></div>
<div class="code-line"><span class="line-num">5</span><span class="tag">&lt;${webComponentDisplay}</span> <span class="attr">name</span>=<span class="value">"home"</span> <span class="tag">/&gt;</span></div>
</div>`;
        case "angular":
          return `${frameworkBadge}<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="comment">// main.ts</span></div>
<div class="code-line"><span class="line-num">2</span><span class="keyword">import</span> <span class="value">'${outputDirDisplay}/icons.js'</span>;</div>
<div class="code-line"><span class="line-num">3</span></div>
<div class="code-line"><span class="line-num">4</span><span class="comment">&lt;!-- template.html --&gt;</span></div>
<div class="code-line"><span class="line-num">5</span><span class="tag">&lt;${webComponentDisplay}</span> <span class="attr">name</span>=<span class="value">"home"</span> <span class="tag">/&gt;</span></div>
</div>`;
        case "astro":
          return `${frameworkBadge}<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="tag">---</span></div>
<div class="code-line"><span class="line-num">2</span><span class="keyword">import</span> <span class="value">'${outputDirDisplay}/icons.js'</span>;</div>
<div class="code-line"><span class="line-num">3</span><span class="tag">---</span></div>
<div class="code-line"><span class="line-num">4</span></div>
<div class="code-line"><span class="line-num">5</span><span class="tag">&lt;${webComponentDisplay}</span> <span class="attr">name</span>=<span class="value">"home"</span> <span class="tag">/&gt;</span></div>
</div>`;
        default:
          return `<div class="code-block">
<div class="code-line"><span class="line-num">1</span><span class="comment">&lt;!-- ${tr.previewImport} --&gt;</span></div>
<div class="code-line"><span class="line-num">2</span><span class="tag">&lt;script </span><span class="attr">src</span>=<span class="value">"${outputDirDisplay}/icons.js"</span><span class="tag">&gt;&lt;/script&gt;</span></div>
<div class="code-line"><span class="line-num">3</span></div>
<div class="code-line"><span class="line-num">4</span><span class="comment">&lt;!-- ${tr.previewUse} --&gt;</span></div>
<div class="code-line"><span class="line-num">5</span><span class="tag">&lt;${webComponentDisplay} </span><span class="attr">name</span>=<span class="value">"home"</span><span class="tag">/&gt;</span></div>
<div class="code-line"><span class="line-num">6</span><span class="tag">&lt;${webComponentDisplay} </span><span class="attr">name</span>=<span class="value">"heart"</span><span class="tag">/&gt;</span></div>
<div class="code-line"><span class="line-num">7</span><span class="tag">&lt;${webComponentDisplay} </span><span class="attr">name</span>=<span class="value">"settings"</span><span class="tag">/&gt;</span></div>
<div class="code-line"><span class="line-num">8</span><span class="tag">&lt;${webComponentDisplay} </span><span class="attr">name</span>=<span class="value">"check"</span><span class="tag">/&gt;</span></div>
</div>`;
      }
    };
    const previewCode = getFrameworkPreview();
    const previewGallery = `
          <div class="preview-icons-gallery">
            <div class="preview-icon-item">
              <div class="preview-icon-box small">
                <svg viewBox="0 0 24 24"><path d="M10 20v-6h4v6h5v-8h3L12 3 2 12h3v8z"/></svg>
              </div>
              <span>home</span>
            </div>
            <div class="preview-icon-item">
              <div class="preview-icon-box small">
                <svg viewBox="0 0 24 24"><path d="M12 21.35l-1.45-1.32C5.4 15.36 2 12.28 2 8.5 2 5.42 4.42 3 7.5 3c1.74 0 3.41.81 4.5 2.09C13.09 3.81 14.76 3 16.5 3 19.58 3 22 5.42 22 8.5c0 3.78-3.4 6.86-8.55 11.54L12 21.35z"/></svg>
              </div>
              <span>heart</span>
            </div>
            <div class="preview-icon-item">
              <div class="preview-icon-box small">
                <svg viewBox="0 0 24 24"><path d="M19.14 12.94c.04-.31.06-.63.06-.94 0-.31-.02-.63-.06-.94l2.03-1.58c.18-.14.23-.41.12-.61l-1.92-3.32c-.12-.22-.37-.29-.59-.22l-2.39.96c-.5-.38-1.03-.7-1.62-.94l-.36-2.54c-.04-.24-.24-.41-.48-.41h-3.84c-.24 0-.43.17-.47.41l-.36 2.54c-.59.24-1.13.57-1.62.94l-2.39-.96c-.22-.08-.47 0-.59.22L2.74 8.87c-.12.21-.08.47.12.61l2.03 1.58c-.04.31-.06.63-.06.94s.02.63.06.94l-2.03 1.58c-.18.14-.23.41-.12.61l1.92 3.32c.12.22.37.29.59.22l2.39-.96c.5.38 1.03.7 1.62.94l.36 2.54c.05.24.24.41.48.41h3.84c.24 0 .44-.17.47-.41l.36-2.54c.59-.24 1.13-.56 1.62-.94l2.39.96c.22.08.47 0 .59-.22l1.92-3.32c.12-.22.07-.47-.12-.61l-2.01-1.58zM12 15.6c-1.98 0-3.6-1.62-3.6-3.6s1.62-3.6 3.6-3.6 3.6 1.62 3.6 3.6-1.62 3.6-3.6 3.6z"/></svg>
              </div>
              <span>settings</span>
            </div>
            <div class="preview-icon-item">
              <div class="preview-icon-box small">
                <svg viewBox="0 0 24 24"><path d="M12 2C6.48 2 2 6.48 2 12s4.48 10 10 10 10-4.48 10-10S17.52 2 12 2zm-2 15l-5-5 1.41-1.41L10 14.17l7.59-7.59L19 8l-9 9z"/></svg>
              </div>
              <span>check</span>
            </div>
          </div>
    `;
    const previewSummary = isFullyConfigured2 ? `
      <div class="preview-summary">
        <div class="preview-summary-item">
          <span class="preview-summary-label">${tr.previewOutput}</span>
          <span class="preview-summary-value">${outputDir}</span>
        </div>
        <div class="preview-summary-item">
          <span class="preview-summary-label">${tr.previewFormat}</span>
          <span class="preview-summary-value">${buildFormat === "icons.ts" ? tr.jsModuleTitle : tr.spriteTitle}</span>
        </div>
        <div class="preview-summary-item" style="${buildFormat === "icons.ts" ? "" : "display:none"}">
          <span class="preview-summary-label">${tr.previewTag}</span>
          <span class="preview-summary-value">&lt;${webComponentName}&gt;</span>
        </div>
      </div>
    ` : "";
    const finishButton = isFullyConfigured2 ? `<button class="btn-primary btn-finish" onclick="finishSetup()">
          <svg class="svg-icon" viewBox="0 0 24 24" style="fill: white; width: 20px; height: 20px;"><path d="M9 16.17L4.83 12l-1.42 1.41L9 19 21 7l-1.41-1.41z"/></svg>
          ${tr.getStarted}
        </button>` : `<button class="btn-secondary" disabled>${tr.completeStep1}</button>`;
    const htmlContent = templates.html.replace(/\$\{headerIcons\}/g, tr.headerIcons).replace(/\$\{headerColors\}/g, tr.headerColors).replace(/\$\{headerAnimations\}/g, tr.headerAnimations).replace(/\$\{headerSvgo\}/g, tr.headerSvgo).replace(/\$\{languageOptions\}/g, languageOptions).replace(/\$\{languageLabel\}/g, tr.languageLabel).replace(/\$\{appTitle\}/g, tr.appTitle).replace(/\$\{step1SourceClass\}/g, isSourceConfigured ? "completed-step" : "").replace(/\$\{step1SourceNumberClass\}/g, isSourceConfigured ? "completed" : "").replace(/\$\{step1SourceTitle\}/g, tr.step1SourceTitle).replace(
      /\$\{step1SourceSummary\}/g,
      isSourceConfigured ? `<span class="step-summary">${sourceDir}</span>` : ""
    ).replace(/\$\{step1SourceDesc\}/g, tr.step1SourceDesc).replace(/\$\{step1SourcePlaceholder\}/g, tr.step1SourcePlaceholder).replace(/\$\{sourceDir\}/g, sourceDir).replace(/\$\{srcAssetsSvgSelected\}/g, sourceDir === "src/assets/svg" ? "selected" : "").replace(/\$\{srcIconsSvgSelected\}/g, sourceDir === "src/icons" ? "selected" : "").replace(/\$\{iconsFolderSelected\}/g, sourceDir === "icons" ? "selected" : "").replace(/\$\{browse\}/g, tr.browse).replace(/\$\{step1Apply\}/g, tr.step1Apply).replace(
      /\$\{step2Class\}/g,
      `${isStep2Complete ? "completed-step" : ""} ${isStep2Unlocked ? "" : "step-disabled"}`
    ).replace(/\$\{step2NumberClass\}/g, isStep2Complete ? "completed" : "").replace(/\$\{step2Disabled\}/g, isStep2Unlocked ? "" : "disabled").replace(/\$\{step2Title\}/g, tr.step2Title).replace(
      /\$\{step2Summary\}/g,
      isOutputConfigured2 ? `<span class="step-summary">${outputDir}</span>` : ""
    ).replace(/\$\{step2Desc\}/g, tr.step2Desc).replace(/\$\{step2Placeholder\}/g, tr.step2Placeholder).replace(/\$\{outputDir\}/g, outputDir).replace(/\$\{srcIconsSelected\}/g, outputDir === "src/icons" ? "selected" : "").replace(/\$\{srcAssetsSelected\}/g, outputDir === "src/assets/icons" ? "selected" : "").replace(/\$\{publicIconsSelected\}/g, outputDir === "public/icons" ? "selected" : "").replace(
      /\$\{step3Class\}/g,
      `${isStep3Complete ? "completed-step" : ""} ${isStep3Unlocked ? "" : "step-disabled"}`
    ).replace(/\$\{step3NumberClass\}/g, isStep3Complete ? "completed" : "").replace(/\$\{step3Title\}/g, tr.step3Title).replace(
      /\$\{formatSummary\}/g,
      buildFormat === "icons.ts" ? tr.jsModuleTitle : buildFormat === "sprite.svg" ? tr.spriteTitle : tr.selectFormat || "Seleccionar..."
    ).replace(/\$\{step3Desc\}/g, tr.step3Desc).replace(/\$\{step3Help\}/g, tr.step3Help).replace(/\$\{jsModuleTitle\}/g, tr.jsModuleTitle).replace(/\$\{helpJsModule\}/g, tr.helpJsModule).replace(/\$\{spriteTitle\}/g, tr.spriteTitle).replace(/\$\{helpSprite\}/g, tr.helpSprite).replace(/\$\{helpTip\}/g, tr.helpTip).replace(/\$\{jsModuleSelected\}/g, buildFormat === "icons.ts" ? "selected" : "").replace(/\$\{recommended\}/g, tr.recommended).replace(/\$\{jsModuleDesc\}/g, tr.jsModuleDesc).replace(/\$\{jsModulePro1\}/g, tr.jsModulePro1).replace(/\$\{jsModulePro2\}/g, tr.jsModulePro2).replace(/\$\{spriteSelected\}/g, buildFormat === "sprite.svg" ? "selected" : "").replace(/\$\{spriteDesc\}/g, tr.spriteDesc).replace(/\$\{spritePro1\}/g, tr.spritePro1).replace(/\$\{spritePro2\}/g, tr.spritePro2).replace(/\$\{step4Section\}/g, step4Section).replace(/\$\{step5Section\}/g, step5Section).replace(/\$\{advancedTitle\}/g, tr.advancedTitle).replace(/\$\{svgoOptimizeLabel\}/g, tr.svgoOptimizeLabel).replace(/\$\{scanOnStartupLabel\}/g, tr.scanOnStartupLabel).replace(/\$\{defaultIconSizeLabel\}/g, tr.defaultIconSizeLabel).replace(/\$\{previewBackgroundLabel\}/g, tr.previewBackgroundLabel).replace(/\$\{svgoOptimizeChecked\}/g, svgoOptimize ? "checked" : "").replace(/\$\{scanOnStartupChecked\}/g, scanOnStartup ? "checked" : "").replace(/\$\{defaultIconSize\}/g, String(defaultIconSize)).replace(/\$\{bgTransparent\}/g, previewBackground === "transparent" ? "selected" : "").replace(/\$\{bgLight\}/g, previewBackground === "light" ? "selected" : "").replace(/\$\{bgDark\}/g, previewBackground === "dark" ? "selected" : "").replace(/\$\{bgCheckered\}/g, previewBackground === "checkered" ? "selected" : "").replace(/\$\{allSettings\}/g, tr.allSettings).replace(/\$\{previewTitle\}/g, tr.previewTitle).replace(
      /\$\{previewFileName\}/g,
      buildFormat === "icons.ts" ? "icons.js" : buildFormat === "sprite.svg" ? "sprite.svg" : "..."
    ).replace(/\$\{previewCode\}/g, previewCode).replace(/\$\{previewSummary\}/g, previewSummary).replace(/\$\{previewResultLabel\}/g, tr.previewResultLabel).replace(/\$\{previewGallery\}/g, previewGallery).replace(/\$\{workflowSource\}/g, tr.workflowSource).replace(/\$\{workflowBuild\}/g, tr.workflowBuild).replace(/\$\{workflowOutput\}/g, tr.workflowOutput).replace(/\$\{sourceDirDisplay\}/g, sourceDir || "svgs/").replace(/\$\{comingSoon\}/g, tr.comingSoon).replace(/\$\{settings\}/g, tr.settings).replace(/\$\{skip\}/g, tr.skip).replace(/\$\{finishButton\}/g, finishButton);
    const jsContent = templates.js.replace(/\$\{helpOpenText\}/g, `${tr.step3Help} \u25B4`).replace(/\$\{helpClosedText\}/g, `${tr.step3Help} \u25BE`);
    return `<!DOCTYPE html>
<html lang="${i18n.getLocale()}">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>${t("welcome.title")}</title>
  <style>${templates.css}</style>
</head>
<body>
  ${htmlContent}
  <script>${jsContent}</script>
</body>
</html>`;
  }
};

// src/commands/treeViewCommands.ts
var vscode30 = __toESM(require("vscode"));
function registerTreeViewCommands(context, treeViews, providers) {
  const state = {
    workspaceExpanded: false,
    builtExpanded: false,
    svgFilesExpanded: false
  };
  vscode30.commands.executeCommand("setContext", "sageboxIconStudio.workspaceExpanded", false);
  vscode30.commands.executeCommand("setContext", "sageboxIconStudio.builtExpanded", false);
  vscode30.commands.executeCommand("setContext", "sageboxIconStudio.svgFilesExpanded", false);
  const disposables = [];
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.expandAll", async () => {
      const roots = await providers.workspaceSvgProvider.getChildren();
      for (const root of roots) {
        try {
          await treeViews.workspace.reveal(root, { expand: 2, focus: false, select: false });
        } catch {
        }
      }
      state.workspaceExpanded = true;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.workspaceExpanded", true);
    })
  );
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.collapseAll", async () => {
      await vscode30.commands.executeCommand(
        "workbench.actions.treeView.sageboxIconStudio.workspaceIcons.collapseAll"
      );
      state.workspaceExpanded = false;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.workspaceExpanded", false);
    })
  );
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.expandSvgFiles", async () => {
      const roots = await providers.svgFilesProvider.getChildren();
      for (const root of roots) {
        try {
          await treeViews.svgFiles.reveal(root, { expand: 2, focus: false, select: false });
        } catch {
        }
      }
      state.svgFilesExpanded = true;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.svgFilesExpanded", true);
    })
  );
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.collapseSvgFiles", async () => {
      await vscode30.commands.executeCommand(
        "workbench.actions.treeView.sageboxIconStudio.svgFiles.collapseAll"
      );
      state.svgFilesExpanded = false;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.svgFilesExpanded", false);
    })
  );
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.expandBuiltIcons", async () => {
      const roots = await providers.builtIconsProvider.getChildren();
      for (const root of roots) {
        try {
          await treeViews.builtIcons.reveal(root, { expand: 2, focus: false, select: false });
        } catch {
        }
      }
      state.builtExpanded = true;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.builtExpanded", true);
    })
  );
  disposables.push(
    vscode30.commands.registerCommand("sageboxIconStudio.collapseBuiltIcons", async () => {
      await vscode30.commands.executeCommand(
        "workbench.actions.treeView.sageboxIconStudio.builtIcons.collapseAll"
      );
      state.builtExpanded = false;
      vscode30.commands.executeCommand("setContext", "sageboxIconStudio.builtExpanded", false);
    })
  );
  return disposables;
}

// src/commands/refreshCommands.ts
var vscode31 = __toESM(require("vscode"));
function registerRefreshCommands(providers) {
  const disposables = [];
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshIcons", () => {
      providers.builtIconsProvider.refresh();
      providers.svgFilesProvider.refresh();
      providers.workspaceSvgProvider.refresh();
    })
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshFiles", () => {
      providers.svgFilesProvider.refresh();
    })
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshCode", () => {
      providers.workspaceSvgProvider.refresh();
    })
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshBuilt", () => {
      providers.builtIconsProvider.refresh();
    })
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshSvgFile", (filePath) => {
      if (filePath) {
        providers.svgFilesProvider.refreshFile(filePath);
      }
    })
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshFilesItemByName", (iconName) => {
      if (iconName) {
        providers.svgFilesProvider.refreshItemByName?.(iconName);
      }
    })
  );
  disposables.push(
    vscode31.commands.registerCommand(
      "sageboxIconStudio.addIconToBuiltAndRefresh",
      (iconName, svg, iconsFilePath, animation) => {
        if (iconName && svg && iconsFilePath) {
          providers.builtIconsProvider.addIconAndRefresh?.(iconName, svg, iconsFilePath, animation);
        }
      }
    )
  );
  disposables.push(
    vscode31.commands.registerCommand("sageboxIconStudio.refreshIconByName", (iconName) => {
      if (iconName) {
        providers.svgFilesProvider.refreshItemByName?.(iconName);
        providers.builtIconsProvider.refreshItemByName?.(iconName);
      }
    })
  );
  return disposables;
}

// src/commands/buildCommands.ts
var vscode33 = __toESM(require("vscode"));
var path31 = __toESM(require("path"));
var fs25 = __toESM(require("fs"));

// src/services/SpriteGenerator.ts
var path29 = __toESM(require("path"));
var fs24 = __toESM(require("fs"));
var SpriteGenerator = class {
  /**
   * Generate a sprite sheet from multiple SVG icons
   */
  generate(icons, options) {
    const iconIds = [];
    const symbols = [];
    let totalSize = 0;
    for (const icon of icons) {
      const { id, symbol, size } = this.createSymbol(icon, options);
      iconIds.push(id);
      symbols.push(symbol);
      totalSize += size;
    }
    const sprite = this.wrapInSprite(symbols, options);
    const result = {
      sprite,
      iconIds,
      stats: {
        totalIcons: icons.length,
        totalSize,
        averageSize: Math.round(totalSize / icons.length)
      }
    };
    if (options.generateTypes) {
      result.typeDefinitions = this.generateTypeDefinitions(iconIds);
    }
    if (options.generateHelper && options.helperFormat) {
      result.helperComponent = this.generateHelper(iconIds, options);
    }
    return result;
  }
  /**
   * Generate sprite and save to files
   */
  async generateAndSave(icons, options) {
    const result = this.generate(icons, options);
    const outputDir = options.outputPath;
    const filename = options.filename || "sprite";
    if (!fs24.existsSync(outputDir)) {
      fs24.mkdirSync(outputDir, { recursive: true });
    }
    const spritePath = path29.join(outputDir, `${filename}.svg`);
    fs24.writeFileSync(spritePath, result.sprite, "utf-8");
    if (result.typeDefinitions) {
      const typesPath = path29.join(outputDir, `${filename}.types.ts`);
      fs24.writeFileSync(typesPath, result.typeDefinitions, "utf-8");
    }
    if (result.helperComponent && options.helperFormat) {
      const ext = this.getHelperExtension(options.helperFormat);
      const helperPath = path29.join(outputDir, `Icon.${ext}`);
      fs24.writeFileSync(helperPath, result.helperComponent, "utf-8");
    }
    return result;
  }
  /**
   * Create a <symbol> from an SVG
   */
  createSymbol(icon, options) {
    const id = this.sanitizeId(icon.id || icon.name);
    const svg = icon.svg;
    let viewBox = icon.viewBox;
    if (!viewBox) {
      const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/i);
      viewBox = viewBoxMatch ? viewBoxMatch[1] : "0 0 24 24";
    }
    const innerMatch = svg.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    let inner = innerMatch ? innerMatch[1].trim() : svg;
    if (options.removeStyles) {
      inner = inner.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "");
    }
    let symbol = `  <symbol id="${id}" viewBox="${viewBox}">
`;
    if (options.includeTitle) {
      symbol += `    <title>${icon.name}</title>
`;
    }
    if (options.includeDesc) {
      symbol += `    <desc>Icon: ${icon.name}</desc>
`;
    }
    symbol += `    ${inner}
`;
    symbol += `  </symbol>`;
    return {
      id,
      symbol,
      size: symbol.length
    };
  }
  /**
   * Wrap symbols in SVG sprite container
   */
  wrapInSprite(symbols, _options) {
    return `<?xml version="1.0" encoding="UTF-8"?>
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink" style="display:none">
  <!--
    SVG Sprite Sheet
    Generated by Icon Studio VS Code Extension
    Total icons: ${symbols.length}
  -->
${symbols.join("\n\n")}
</svg>`;
  }
  /**
   * Generate TypeScript type definitions
   */
  generateTypeDefinitions(iconIds) {
    const unionType = iconIds.map((id) => `'${id}'`).join(" | ");
    return `// Auto-generated by Icon Studio
// Do not edit manually

export type IconName = ${unionType};

export const iconNames = [
${iconIds.map((id) => `  '${id}'`).join(",\n")}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
  }
  /**
   * Generate helper component
   */
  generateHelper(iconIds, options) {
    switch (options.helperFormat) {
      case "react":
        return this.generateReactHelper(iconIds, options);
      case "vue":
        return this.generateVueHelper(iconIds, options);
      case "svelte":
        return this.generateSvelteHelper(iconIds, options);
      case "vanilla":
        return this.generateVanillaHelper(iconIds, options);
      default:
        return "";
    }
  }
  generateReactHelper(iconIds, options) {
    const spritePath = options.filename || "sprite";
    return `import React from 'react';

export type IconName = ${iconIds.map((id) => `'${id}'`).join(" | ")};

interface IconProps extends React.SVGProps<SVGSVGElement> {
  name: IconName;
  size?: number | string;
  color?: string;
  title?: string;
}

/**
 * Icon component using SVG sprite
 *
 * @example
 * <Icon name="arrow-left" size={24} color="currentColor" />
 */
export const Icon = React.forwardRef<SVGSVGElement, IconProps>(
  ({ name, size = 24, color = 'currentColor', title, className, ...props }, ref) => {
    return (
      <svg
        ref={ref}
        width={size}
        height={size}
        fill="none"
        stroke={color}
        className={className}
        aria-hidden={!title}
        role={title ? 'img' : undefined}
        {...props}
      >
        {title && <title>{title}</title>}
        <use href={\`/${spritePath}.svg#\${name}\`} />
      </svg>
    );
  }
);

Icon.displayName = 'Icon';

export const iconNames: IconName[] = [
${iconIds.map((id) => `  '${id}'`).join(",\n")}
];

export default Icon;
`;
  }
  generateVueHelper(iconIds, options) {
    const spritePath = options.filename || "sprite";
    return `<script setup lang="ts">
export type IconName = ${iconIds.map((id) => `'${id}'`).join(" | ")};

interface Props {
  name: IconName;
  size?: number | string;
  color?: string;
  title?: string;
}

const props = withDefaults(defineProps<Props>(), {
  size: 24,
  color: 'currentColor'
});
</script>

<template>
  <svg
    :width="size"
    :height="size"
    fill="none"
    :stroke="color"
    :aria-hidden="!title"
    :role="title ? 'img' : undefined"
  >
    <title v-if="title">{{ title }}</title>
    <use :href="\`/${spritePath}.svg#\${name}\`" />
  </svg>
</template>

<script lang="ts">
export const iconNames: IconName[] = [
${iconIds.map((id) => `  '${id}'`).join(",\n")}
];
</script>
`;
  }
  generateSvelteHelper(iconIds, options) {
    const spritePath = options.filename || "sprite";
    return `<script lang="ts">
  export type IconName = ${iconIds.map((id) => `'${id}'`).join(" | ")};

  export let name: IconName;
  export let size: number | string = 24;
  export let color: string = 'currentColor';
  export let title: string | undefined = undefined;

  export const iconNames: IconName[] = [
${iconIds.map((id) => `    '${id}'`).join(",\n")}
  ];
</script>

<svg
  width={size}
  height={size}
  fill="none"
  stroke={color}
  aria-hidden={!title}
  role={title ? 'img' : undefined}
  {...$$restProps}
>
  {#if title}
    <title>{title}</title>
  {/if}
  <use href="/${spritePath}.svg#{name}" />
</svg>
`;
  }
  generateVanillaHelper(iconIds, options) {
    const spritePath = options.filename || "sprite";
    const componentName = options.webComponentName || "bezier-icon";
    return `/**
 * Icon Web Component
 * Auto-generated by Icon Studio
 */

const ICON_NAMES = [
${iconIds.map((id) => `  '${id}'`).join(",\n")}
];

// Path to the sprite file (relative to this file)
const SPRITE_URL = new URL('./${spritePath}.svg', import.meta.url).href;

class IconComponent extends HTMLElement {
  static get observedAttributes() {
    return ['name', 'size', 'color', 'stroke-width'];
  }

  constructor() {
    super();
    this.attachShadow({ mode: 'open' });
  }

  connectedCallback() {
    this.render();
  }

  attributeChangedCallback(name, oldValue, newValue) {
    if (oldValue !== newValue) {
      this.render();
    }
  }

  render() {
    const name = this.getAttribute('name');
    if (!name) return;


    const size = this.getAttribute('size') || '24';
    const color = this.getAttribute('color') || 'currentColor';
    const strokeWidth = this.getAttribute('stroke-width') || '2';

    this.shadowRoot.innerHTML = \`
      <style>
        :host {
          display: inline-flex;
          align-items: center;
          justify-content: center;
          vertical-align: middle;
        }
        svg {
          width: \${size}px;
          height: \${size}px;
          color: \${color};
        }
      </style>
      <svg
        viewBox="0 0 24 24"
        fill="none"
        stroke="currentColor"
        stroke-width="\${strokeWidth}"
        stroke-linecap="round"
        stroke-linejoin="round"
      >
        <use href="\${SPRITE_URL}#\${name}"></use>
      </svg>
    \`;
  }
}

if (!customElements.get('${componentName}')) {
  customElements.define('${componentName}', IconComponent);
}

export { IconComponent, ICON_NAMES };
`;
  }
  getHelperExtension(format) {
    switch (format) {
      case "react":
        return "tsx";
      case "vue":
        return "vue";
      case "svelte":
        return "svelte";
      case "vanilla":
        return "js";
      default:
        return "js";
    }
  }
  sanitizeId(name) {
    return name.toLowerCase().replace(/[^a-z0-9]+/g, "-").replace(/^-|-$/g, "");
  }
};
var generatorInstance;
function getSpriteGenerator() {
  if (!generatorInstance) {
    generatorInstance = new SpriteGenerator();
  }
  return generatorInstance;
}

// src/commands/buildCommands.ts
init_i18n();

// src/commands/licenseCommands.ts
var vscode32 = __toESM(require("vscode"));
var path30 = __toESM(require("path"));
init_LicenseService();
init_i18n();
function getLicenseConfig() {
  const config = vscode32.workspace.getConfiguration("sageboxIconStudio");
  return {
    format: config.get("licenseFormat", "combined"),
    autoGenerate: config.get("autoGenerateLicenses", true),
    folder: config.get("licensesFolder", "icon-licenses")
  };
}
async function autoGenerateLicensesIfEnabled(outputPath) {
  const licenseConfig = getLicenseConfig();
  if (!licenseConfig.autoGenerate) {
    return;
  }
  try {
    const result = await generateLicenseFiles(outputPath, {
      combined: licenseConfig.format === "combined" || licenseConfig.format === "both",
      perCollection: licenseConfig.format === "perCollection" || licenseConfig.format === "both",
      licensesFolder: licenseConfig.folder
    });
    if (result.success && result.files.length > 0) {
      vscode32.window.showInformationMessage(`\u{1F4C4} ${result.message}`);
    } else if (!result.success) {
    }
  } catch (error) {
  }
}
function registerLicenseCommands(_context) {
  const commands26 = [];
  commands26.push(
    vscode32.commands.registerCommand("sageboxIconStudio.generateLicenses", async () => {
      const outputPath = getFullOutputPath();
      const licenseConfig = getLicenseConfig();
      if (!outputPath) {
        vscode32.window.showWarningMessage(
          t("messages.noOutputPath") || "No output path configured. Configure it in settings or use the Welcome panel."
        );
        return;
      }
      const formatOptions = [
        {
          label: "$(file-text) Combined License File",
          description: "Generate a single LICENSES.md with all attributions",
          value: "combined",
          picked: licenseConfig.format === "combined"
        },
        {
          label: "$(files) Per-Collection License Files",
          description: "Generate separate LICENSE-{prefix}.md for each collection",
          value: "perCollection",
          picked: licenseConfig.format === "perCollection"
        },
        {
          label: "$(checklist) Both",
          description: "Generate combined and per-collection files",
          value: "both",
          picked: licenseConfig.format === "both"
        }
      ];
      formatOptions.sort((a, b) => (b.picked ? 1 : 0) - (a.picked ? 1 : 0));
      const options = await vscode32.window.showQuickPick(formatOptions, {
        placeHolder: `Select license file generation option (default: ${licenseConfig.format})`,
        title: "\u{1F4C4} Generate Icon Licenses"
      });
      if (!options) return;
      try {
        await vscode32.window.withProgress(
          {
            location: vscode32.ProgressLocation.Notification,
            title: "Generating license files...",
            cancellable: false
          },
          async () => {
            const result = await generateLicenseFiles(outputPath, {
              combined: options.value === "combined" || options.value === "both",
              perCollection: options.value === "perCollection" || options.value === "both",
              licensesFolder: licenseConfig.folder
            });
            if (result.success) {
              const action = await vscode32.window.showInformationMessage(
                result.message,
                "Open Folder",
                "Open LICENSES.md"
              );
              if (action === "Open Folder") {
                const licensesPath = path30.join(outputPath, licenseConfig.folder);
                vscode32.commands.executeCommand("revealFileInOS", vscode32.Uri.file(licensesPath));
              } else if (action === "Open LICENSES.md") {
                const licensePath = path30.join(outputPath, licenseConfig.folder, "LICENSES.md");
                const doc = await vscode32.workspace.openTextDocument(licensePath);
                await vscode32.window.showTextDocument(doc);
              }
            } else {
              vscode32.window.showWarningMessage(result.message);
            }
          }
        );
      } catch (error) {
        vscode32.window.showErrorMessage(
          `Failed to generate licenses: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    })
  );
  commands26.push(
    vscode32.commands.registerCommand("sageboxIconStudio.showLicenseSummary", async () => {
      const outputPath = getFullOutputPath();
      if (!outputPath) {
        vscode32.window.showWarningMessage(
          t("messages.noOutputPath") || "No output path configured."
        );
        return;
      }
      try {
        const summary = await getLicenseSummary(outputPath);
        if (summary.collections.length === 0) {
          vscode32.window.showInformationMessage("No Iconify icons detected in your icon library.");
          return;
        }
        const items = summary.collections.map((col) => ({
          label: `$(law) ${col.name}`,
          description: `${col.license}`,
          detail: `${col.iconCount} icon(s) \u2022 Prefix: ${col.prefix}`
        }));
        items.unshift({
          label: `$(info) License Summary`,
          description: `${summary.totalIcons} total Iconify icons`,
          detail: `From ${summary.collections.length} collection(s)`
        });
        const selected = await vscode32.window.showQuickPick(items, {
          placeHolder: "License summary for Iconify icons",
          title: "\u{1F4CB} Icon License Summary",
          canPickMany: false
        });
        if (selected?.label.includes("License Summary")) {
          const generate = await vscode32.window.showInformationMessage(
            `You have ${summary.totalIcons} icons from ${summary.collections.length} Iconify collection(s). Would you like to generate license files?`,
            "Generate Licenses",
            "Cancel"
          );
          if (generate === "Generate Licenses") {
            vscode32.commands.executeCommand("sageboxIconStudio.generateLicenses");
          }
        }
      } catch (error) {
        vscode32.window.showErrorMessage(
          `Failed to get license summary: ${error instanceof Error ? error.message : String(error)}`
        );
      }
    })
  );
  return commands26;
}

// src/commands/buildCommands.ts
async function writeFileWithVSCode(filePath, content) {
  const uri = vscode33.Uri.file(filePath);
  const encoder = new TextEncoder();
  await vscode33.workspace.fs.writeFile(uri, encoder.encode(content));
}
function countSvgColors(svg) {
  const colorRegex = /#(?:[0-9a-fA-F]{3,4}){1,2}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)|(?:fill|stroke|stop-color|flood-color|lighting-color)\s*[:=]\s*["']?([a-zA-Z]+)["']?/gi;
  const colors = /* @__PURE__ */ new Set();
  let match;
  while ((match = colorRegex.exec(svg)) !== null) {
    colors.add(match[0].toLowerCase());
  }
  return colors.size;
}
function generateTypesFileContent(iconNames) {
  const sortedNames = [...iconNames].sort();
  return `// Auto-generated by Icon Studio
// Do not edit manually

export type IconName = ${sortedNames.map((n) => `'${n}'`).join(" | ")};

export const iconNames = [
${sortedNames.map((n) => `  '${n}'`).join(",\n")}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
}
function registerBuildCommands(context, providers, svgTransformer) {
  const disposables = [];
  disposables.push(
    vscode33.commands.registerCommand(
      "sageboxIconStudio.buildSingleIcon",
      async (data) => {
        if (!data || !data.iconName || !data.svgContent) {
          vscode33.window.showErrorMessage(t("messages.noIconSelected"));
          return;
        }
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        const config = getConfig();
        const buildFormat = config.buildFormat || "icons.js";
        const isSprite = buildFormat === "sprite.svg";
        try {
          if (isSprite) {
            await addToSpriteSvg(outputPath, data.iconName, data.svgContent, svgTransformer);
          } else {
            await addToIconsJs({
              outputPath,
              iconName: data.iconName,
              svgContent: data.svgContent,
              transformer: svgTransformer
            });
          }
          const builtIcon = {
            name: data.iconName,
            svg: data.svgContent,
            path: outputPath,
            source: "library",
            category: "built",
            isBuilt: true
          };
          providers.workspaceSvgProvider.addBuiltIcon?.(data.iconName, builtIcon);
          providers.builtIconsProvider.refresh();
          providers.workspaceSvgProvider.refresh();
          await autoGenerateLicensesIfEnabled(outputPath);
          vscode33.window.showInformationMessage(
            t("messages.iconBuilt", { name: data.iconName, format: isSprite ? "sprite.svg" : "icons.js" })
          );
        } catch (error) {
          vscode33.window.showErrorMessage(
            t("messages.failedToBuildIcon", { error: error.message || String(error) })
          );
        }
      }
    )
  );
  disposables.push(
    vscode33.commands.registerCommand("sageboxIconStudio.buildAllReferences", async () => {
      const config = getConfig();
      const componentName = config.webComponentName || "sg-icon";
      const buildFormat = config.buildFormat || "icons.js";
      const imgRefs = providers.workspaceSvgProvider.getImgReferences();
      if (!imgRefs || imgRefs.length === 0) {
        vscode33.window.showInformationMessage(t("messages.noImgReferencesFound"));
        return;
      }
      const validRefs = imgRefs.filter((ref) => ref.exists !== false);
      if (validRefs.length === 0) {
        vscode33.window.showWarningMessage(t("messages.allImgReferencesMissing"));
        return;
      }
      const confirm = await vscode33.window.showInformationMessage(
        t("messages.confirmTransformReferences", {
          count: validRefs.length,
          component: componentName
        }),
        t("messages.yesButton"),
        t("messages.noButton")
      );
      if (confirm !== t("messages.yesButton")) return;
      await vscode33.window.withProgress(
        {
          location: vscode33.ProgressLocation.Notification,
          title: t("ui.progress.buildingReferences"),
          cancellable: false
        },
        async (progress) => {
          let transformed = 0;
          let failed = 0;
          const refsByFile = /* @__PURE__ */ new Map();
          for (const ref of validRefs) {
            if (!ref.filePath) continue;
            const list = refsByFile.get(ref.filePath) || [];
            list.push(ref);
            refsByFile.set(ref.filePath, list);
          }
          for (const [filePath, refs] of Array.from(refsByFile.entries())) {
            progress.report({
              message: t("ui.progress.processing", { name: path31.basename(filePath) })
            });
            try {
              const document = await vscode33.workspace.openTextDocument(vscode33.Uri.file(filePath));
              const edit = new vscode33.WorkspaceEdit();
              const sortedRefs = [...refs].sort((a, b) => (b.line || 0) - (a.line || 0));
              for (const ref of sortedRefs) {
                if (ref.line === void 0 || !ref.svg || !ref.path) continue;
                const line = document.lineAt(ref.line);
                const lineText = line.text;
                const imgRegex = new RegExp(
                  `<img\\s+[^>]*src=["'][^"']*${ref.name.replace(/[.*+?^${}()|[\]\\]/g, "\\$&")}\\.svg["'][^>]*>`,
                  "gi"
                );
                const match = imgRegex.exec(lineText);
                if (match) {
                  const startPos = new vscode33.Position(ref.line, match.index);
                  const endPos = new vscode33.Position(ref.line, match.index + match[0].length);
                  const range = new vscode33.Range(startPos, endPos);
                  const iconName = ref.name;
                  const outputPath = getFullOutputPath();
                  if (outputPath) {
                    const transformer = new SvgTransformer();
                    if (buildFormat === "sprite.svg") {
                      await addToSpriteSvg(outputPath, iconName, ref.svg, transformer);
                    } else {
                      await addToIconsJs({
                        outputPath,
                        iconName,
                        svgContent: ref.svg,
                        transformer
                      });
                    }
                  }
                  const replacement = `<${componentName} name="${iconName}"></${componentName}>`;
                  edit.replace(document.uri, range, replacement);
                  transformed++;
                }
              }
              await vscode33.workspace.applyEdit(edit);
              await document.save();
            } catch (err) {
              console.error("[Icon Studio] Error transforming references in", filePath, err);
              failed++;
            }
          }
          providers.workspaceSvgProvider.refresh();
          providers.builtIconsProvider.refresh();
          if (failed > 0) {
            vscode33.window.showWarningMessage(
              t("messages.transformedWithErrors", { transformed, failed })
            );
          } else {
            vscode33.window.showInformationMessage(
              t("messages.transformedSuccessfully", {
                count: transformed,
                component: componentName
              })
            );
          }
        }
      );
    })
  );
  disposables.push(
    vscode33.commands.registerCommand("sageboxIconStudio.buildAllFiles", async () => {
      const config = getConfig();
      const buildFormat = config.buildFormat || "icons.js";
      await providers.svgFilesProvider.ensureReady();
      const svgFilesMap = providers.svgFilesProvider.getSvgFilesMap();
      const allSvgFiles = Array.from(svgFilesMap.values()).filter((icon) => icon.path);
      if (allSvgFiles.length === 0) {
        vscode33.window.showInformationMessage(t("messages.noSvgFilesFound"));
        return;
      }
      const confirm = await vscode33.window.showInformationMessage(
        t("messages.confirmBuildSvgFiles", { count: allSvgFiles.length, format: buildFormat }),
        t("messages.yesButton"),
        t("messages.noButton")
      );
      if (confirm !== t("messages.yesButton")) return;
      await vscode33.window.withProgress(
        {
          location: vscode33.ProgressLocation.Notification,
          title: t("ui.progress.buildingSvgFiles"),
          cancellable: false
        },
        async (progress) => {
          let built = 0;
          let failed = 0;
          const outputPath = getFullOutputPath();
          if (!outputPath) {
            vscode33.window.showErrorMessage(t("messages.outputPathNotConfigured"));
            return;
          }
          const transformer = new SvgTransformer();
          const isIconsJs = buildFormat !== "sprite.svg";
          for (const icon of allSvgFiles) {
            progress.report({ message: t("ui.progress.building", { name: icon.name }) });
            try {
              let svgContent = icon.svg;
              if (!svgContent && icon.path) {
                svgContent = fs25.readFileSync(icon.path, "utf-8");
              }
              if (!svgContent || !icon.name) {
                failed++;
                continue;
              }
              if (isIconsJs) {
                await addToIconsJs({
                  outputPath,
                  iconName: icon.name,
                  svgContent,
                  transformer,
                  skipWebComponentGeneration: true
                });
              } else {
                await addToSpriteSvg(outputPath, icon.name, svgContent, transformer);
              }
              built++;
            } catch (err) {
              console.error("[Icon Studio] Error building", icon.name, err);
              failed++;
            }
          }
          if (isIconsJs && built > 0) {
            progress.report({ message: t("ui.progress.generatingWebComponent") });
            await generateWebComponent(outputPath);
          }
          const deleteOption = await vscode33.window.showInformationMessage(
            t("messages.confirmDeleteOriginals", { count: built }),
            t("messages.deleteAll"),
            t("messages.keepAll")
          );
          if (deleteOption === t("messages.deleteAll")) {
            let deleted = 0;
            for (const icon of allSvgFiles) {
              if (icon.path) {
                try {
                  await vscode33.workspace.fs.delete(vscode33.Uri.file(icon.path));
                  deleted++;
                } catch (err) {
                  console.error("[Icon Studio] Error deleting", icon.path, err);
                }
              }
            }
            vscode33.window.showInformationMessage(
              t("messages.deletedOriginals", { count: deleted })
            );
          }
          providers.svgFilesProvider.refresh();
          providers.builtIconsProvider.refresh();
          if (failed > 0 && deleteOption !== t("messages.deleteAll")) {
            vscode33.window.showWarningMessage(t("messages.builtWithErrors", { built, failed }));
          }
        }
      );
    })
  );
  disposables.push(
    vscode33.commands.registerCommand("sageboxIconStudio.buildIcons", async () => {
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;
      await vscode33.window.withProgress(
        {
          location: vscode33.ProgressLocation.Notification,
          title: t("ui.progress.buildingIconsLibrary"),
          cancellable: false
        },
        async (progress) => {
          progress.report({ message: t("ui.progress.scanningIcons") });
          await providers.workspaceSvgProvider.scanInlineSvgs();
          const icons = await providers.workspaceSvgProvider.getAllIcons();
          if (icons.length === 0) {
            vscode33.window.showWarningMessage(t("messages.noIconsFoundToBuild"));
            return;
          }
          progress.report({ message: t("ui.progress.generatingOutput") });
          const config2 = getConfig();
          const webComponentName = config2.webComponentName;
          const buildFormat = config2.buildFormat || "icons.ts";
          const MAX_COLORS_FOR_BUILD = 50;
          const iconList = [];
          const processedNames = /* @__PURE__ */ new Set();
          const skippedIcons = [];
          for (const icon of icons) {
            if (processedNames.has(icon.name)) continue;
            let svgContent = icon.svg;
            if (!svgContent && icon.path && fs25.existsSync(icon.path) && icon.path.toLowerCase().endsWith(".svg")) {
              try {
                svgContent = fs25.readFileSync(icon.path, "utf-8");
              } catch (readError) {
                console.error(`Failed to read SVG for ${icon.name}`, readError);
              }
            }
            if (!svgContent) continue;
            const colorCount = countSvgColors(svgContent);
            if (colorCount > MAX_COLORS_FOR_BUILD) {
              skippedIcons.push(`${icon.name} (${colorCount} colors)`);
              continue;
            }
            processedNames.add(icon.name);
            iconList.push({
              name: icon.name,
              svg: svgContent,
              animation: icon.animation
            });
          }
          if (buildFormat === "sprite.svg") {
            const generator = getSpriteGenerator();
            const spriteIcons = iconList.map((icon) => ({
              id: icon.name,
              name: icon.name,
              svg: icon.svg,
              viewBox: void 0
            }));
            const result = generator.generate(spriteIcons, {
              outputPath,
              generateHelper: true,
              helperFormat: "vanilla",
              webComponentName,
              generateTypes: true
            });
            if (result.sprite) {
              await writeFileWithVSCode(path31.join(outputPath, "sprite.svg"), result.sprite);
            }
            if (result.helperComponent) {
              await writeFileWithVSCode(path31.join(outputPath, "icons.js"), result.helperComponent);
            }
            if (result.typeDefinitions) {
              await writeFileWithVSCode(
                path31.join(outputPath, "icons.d.ts"),
                result.typeDefinitions
              );
            }
          } else {
            const iconsContent = buildIconsFileContent(iconList, svgTransformer);
            await writeFileWithVSCode(path31.join(outputPath, "icons.js"), iconsContent);
            const webComponent = await generateWebComponent(outputPath);
            await writeFileWithVSCode(webComponent.path, webComponent.content);
            const iconNames = iconList.map((i) => i.name);
            const typesContent = generateTypesFileContent(iconNames);
            await writeFileWithVSCode(path31.join(outputPath, "icons.d.ts"), typesContent);
          }
          if (skippedIcons.length > 0) {
            vscode33.window.showWarningMessage(
              t("messages.skippedRasterizedIcons", {
                count: skippedIcons.length,
                names: skippedIcons.slice(0, 3).join(", ") + (skippedIcons.length > 3 ? "..." : "")
              })
            );
          }
          providers.workspaceSvgProvider.refresh();
          await autoGenerateLicensesIfEnabled(outputPath);
        }
      );
      updateIconsJsContext();
      const config = getConfig();
      const formatName = config.buildFormat === "sprite.svg" ? "sprite.svg" : "icons.js";
      vscode33.window.showInformationMessage(
        t("messages.iconsLibraryBuilt", { format: formatName, path: outputPath })
      );
    })
  );
  return disposables;
}

// src/commands/navigationCommands.ts
var vscode34 = __toESM(require("vscode"));
init_i18n();
function registerNavigationCommands(_context) {
  const commands26 = [];
  commands26.push(
    vscode34.commands.registerCommand("sageboxIconStudio.goToUsage", async (item) => {
      if (item.resourceUri) {
        const document = await vscode34.workspace.openTextDocument(item.resourceUri);
        const editor = await vscode34.window.showTextDocument(document);
        if (item.contextValue === "iconUsage" && item.usage) {
          const line = item.usage.line - 1;
          const range = new vscode34.Range(line, 0, line, document.lineAt(line).text.length);
          editor.selection = new vscode34.Selection(range.start, range.end);
          editor.revealRange(range, vscode34.TextEditorRevealType.InCenter);
        }
      }
    })
  );
  commands26.push(
    vscode34.commands.registerCommand("sageboxIconStudio.goToInlineSvg", async (iconOrItem) => {
      const icon = iconOrItem?.icon || iconOrItem;
      if (icon && icon.filePath && icon.line !== void 0) {
        const document = await vscode34.workspace.openTextDocument(vscode34.Uri.file(icon.filePath));
        const editor = await vscode34.window.showTextDocument(document);
        if (icon.endLine !== void 0 && icon.endColumn !== void 0) {
          const startPos = new vscode34.Position(icon.line, icon.column || 0);
          const endPos = new vscode34.Position(icon.endLine, icon.endColumn);
          const range = new vscode34.Range(startPos, endPos);
          editor.selection = new vscode34.Selection(range.start, range.end);
          editor.revealRange(range, vscode34.TextEditorRevealType.InCenter);
        } else {
          const text = document.getText();
          const lines = text.split("\n");
          const startLine = icon.line;
          const isImgRef = icon.category === "img-ref";
          if (isImgRef) {
            let foundLine = -1;
            let imgTagIndex = -1;
            const iconName = icon.name;
            const searchPatterns = [
              new RegExp(`<img[^>]*${iconName}\\.svg`, "i"),
              /<img[^>]*\.svg/i
            ];
            for (let offset = 0; offset <= 2; offset++) {
              for (const lineOffset of [0, -offset, offset]) {
                if (lineOffset === 0 && offset !== 0) continue;
                const checkLine = startLine + lineOffset;
                if (checkLine < 0 || checkLine >= lines.length) continue;
                const lineText = lines[checkLine];
                for (const pattern of searchPatterns) {
                  const match = lineText.match(pattern);
                  if (match) {
                    foundLine = checkLine;
                    imgTagIndex = lineText.indexOf(match[0]);
                    break;
                  }
                }
                if (foundLine !== -1) break;
              }
              if (foundLine !== -1) break;
            }
            if (foundLine !== -1 && imgTagIndex !== -1) {
              const lineText = lines[foundLine];
              let endCol = lineText.indexOf(">", imgTagIndex);
              if (endCol !== -1) {
                endCol += 1;
              } else {
                endCol = lineText.length;
              }
              const startPos = new vscode34.Position(foundLine, imgTagIndex);
              const endPos = new vscode34.Position(foundLine, endCol);
              const range = new vscode34.Range(startPos, endPos);
              editor.selection = new vscode34.Selection(range.start, range.end);
              editor.revealRange(range, vscode34.TextEditorRevealType.InCenter);
            } else {
              const column = icon.column || 0;
              const position = new vscode34.Position(startLine, column);
              editor.selection = new vscode34.Selection(position, position);
              editor.revealRange(new vscode34.Range(position, position), vscode34.TextEditorRevealType.InCenter);
            }
          } else {
            const lineText = lines[startLine] || "";
            let svgStartCol = 0;
            let svgEndLine = startLine;
            let svgEndCol = lineText.length;
            const svgTagIndex = lineText.indexOf("<svg");
            if (svgTagIndex !== -1) {
              svgStartCol = svgTagIndex;
              let depth = 0;
              for (let i = startLine; i < lines.length; i++) {
                const currentLine = lines[i];
                const startIdx = i === startLine ? svgStartCol : 0;
                for (let j = startIdx; j < currentLine.length; j++) {
                  if (currentLine.substring(j, j + 4) === "<svg") {
                    depth++;
                  } else if (currentLine.substring(j, j + 6) === "</svg>") {
                    depth--;
                    if (depth === 0) {
                      svgEndLine = i;
                      svgEndCol = j + 6;
                      break;
                    }
                  }
                }
                if (depth === 0 && svgEndLine !== startLine) break;
              }
            }
            const startPos = new vscode34.Position(startLine, svgStartCol);
            const endPos = new vscode34.Position(svgEndLine, svgEndCol);
            const range = new vscode34.Range(startPos, endPos);
            editor.selection = new vscode34.Selection(range.start, range.end);
            editor.revealRange(range, vscode34.TextEditorRevealType.InCenter);
          }
        }
      }
    })
  );
  commands26.push(
    vscode34.commands.registerCommand("sageboxIconStudio.goToCode", async (iconOrItem) => {
      const icon = iconOrItem?.icon || iconOrItem;
      if (icon && icon.filePath && icon.line !== void 0) {
        const document = await vscode34.workspace.openTextDocument(vscode34.Uri.file(icon.filePath));
        const editor = await vscode34.window.showTextDocument(document);
        const line = icon.line;
        const column = icon.column || 0;
        const position = new vscode34.Position(line, column);
        editor.selection = new vscode34.Selection(position, position);
        editor.revealRange(
          new vscode34.Range(position, position),
          vscode34.TextEditorRevealType.InCenter
        );
      } else if (icon && icon.path) {
        const document = await vscode34.workspace.openTextDocument(vscode34.Uri.file(icon.path));
        await vscode34.window.showTextDocument(document);
      }
    })
  );
  commands26.push(
    vscode34.commands.registerCommand("sageboxIconStudio.openSvgFile", async (iconOrItem) => {
      const icon = iconOrItem?.icon || iconOrItem;
      if (icon && icon.path) {
        const uri = vscode34.Uri.file(icon.path);
        await vscode34.commands.executeCommand("vscode.open", uri);
      } else {
        vscode34.window.showWarningMessage(t("messages.noSvgPathAvailable"));
      }
    })
  );
  commands26.push(
    vscode34.commands.registerCommand("sageboxIconStudio.copyIconName", async (iconOrItem) => {
      const icon = iconOrItem?.icon || iconOrItem;
      if (icon && icon.name) {
        await vscode34.env.clipboard.writeText(icon.name);
        vscode34.window.showInformationMessage(t("messages.iconCopied", { name: icon.name }));
      }
    })
  );
  return commands26;
}

// src/commands/panelCommands.ts
var vscode36 = __toESM(require("vscode"));

// src/panels/IconStudioPanel.ts
var vscode35 = __toESM(require("vscode"));
var path32 = __toESM(require("path"));
var fs26 = __toESM(require("fs"));
init_config();
init_i18n();
var IconStudioPanel = class _IconStudioPanel {
  static currentPanel;
  static viewType = "sageboxIconStudio";
  _panel;
  _extensionUri;
  _context;
  _disposables = [];
  static createOrShow(extensionUri, context, searchQuery) {
    const column = vscode35.window.activeTextEditor ? vscode35.window.activeTextEditor.viewColumn : void 0;
    if (_IconStudioPanel.currentPanel) {
      _IconStudioPanel.currentPanel._panel.reveal(column);
      if (searchQuery) {
        _IconStudioPanel.currentPanel.postMessage({ type: "search", query: searchQuery });
      }
      return;
    }
    const panel = vscode35.window.createWebviewPanel(
      _IconStudioPanel.viewType,
      t("treeView.files"),
      column || vscode35.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true,
        localResourceRoots: [
          vscode35.Uri.joinPath(extensionUri, "media"),
          vscode35.Uri.joinPath(extensionUri, "webview")
        ]
      }
    );
    _IconStudioPanel.currentPanel = new _IconStudioPanel(panel, extensionUri, context);
    if (searchQuery) {
      _IconStudioPanel.currentPanel.postMessage({ type: "search", query: searchQuery });
    }
  }
  constructor(panel, extensionUri, context) {
    this._panel = panel;
    this._extensionUri = extensionUri;
    this._context = context;
    this._update();
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    this._panel.webview.onDidReceiveMessage(
      (message) => this._handleMessage(message),
      null,
      this._disposables
    );
    this._panel.onDidChangeViewState(
      () => {
        if (this._panel.visible) {
          this._update();
        }
      },
      null,
      this._disposables
    );
  }
  postMessage(message) {
    this._panel.webview.postMessage(message);
  }
  dispose() {
    _IconStudioPanel.currentPanel = void 0;
    this._panel.dispose();
    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) {
        x.dispose();
      }
    }
  }
  async _handleMessage(message) {
    switch (message.type) {
      case "insertIcon":
        await this._insertIcon(message.iconName, message.format);
        break;
      case "copyToClipboard":
        await vscode35.env.clipboard.writeText(message.text);
        vscode35.window.showInformationMessage(t("messages.copiedToClipboard"));
        break;
      case "getConfig": {
        const svgConfig = getFullSvgConfig();
        this.postMessage({
          type: "config",
          data: {
            componentName: svgConfig.componentName,
            componentImport: svgConfig.componentImport,
            outputFormat: svgConfig.outputFormat,
            iconNameAttribute: svgConfig.iconNameAttribute,
            autoImport: svgConfig.autoImport
          }
        });
        break;
      }
      case "getWorkspaceIcons":
        await this._sendWorkspaceIcons();
        break;
      case "getLibraryIcons":
        await this._sendLibraryIcons();
        break;
      case "openFile": {
        const doc = await vscode35.workspace.openTextDocument(message.path);
        await vscode35.window.showTextDocument(doc);
        break;
      }
      case "scanWorkspace":
        vscode35.commands.executeCommand("sageboxIconStudio.scanWorkspace");
        break;
      case "showError":
        vscode35.window.showErrorMessage(message.text);
        break;
      case "showInfo":
        vscode35.window.showInformationMessage(message.text);
        break;
    }
  }
  async _insertIcon(iconName, format) {
    const editor = vscode35.window.activeTextEditor;
    if (!editor) {
      vscode35.window.showErrorMessage(t("messages.noActiveEditor"));
      return;
    }
    const componentName = getSvgConfig("componentName", "Icon");
    const nameAttr = getSvgConfig("iconNameAttribute", "name");
    const outputFormat = format || getSvgConfig("outputFormat", "jsx");
    let snippet;
    switch (outputFormat) {
      case "html":
        snippet = `<iconify-icon icon="${iconName}"></iconify-icon>`;
        break;
      default:
        snippet = `<${componentName} ${nameAttr}="${iconName}" />`;
    }
    await editor.insertSnippet(new vscode35.SnippetString(snippet));
    vscode35.window.showTextDocument(editor.document);
  }
  async _sendWorkspaceIcons() {
    const workspaceFolders = vscode35.workspace.workspaceFolders;
    if (!workspaceFolders) {
      this.postMessage({ type: "workspaceIcons", icons: [] });
      return;
    }
    const svgFolders = getSvgConfig("svgFolders", []);
    const icons = [];
    for (const folder of workspaceFolders) {
      for (const svgFolder of svgFolders) {
        const fullPath = path32.join(folder.uri.fsPath, svgFolder);
        if (fs26.existsSync(fullPath)) {
          await this._scanSvgFolder(fullPath, icons, svgFolder);
        }
      }
    }
    this.postMessage({ type: "workspaceIcons", icons });
  }
  async _scanSvgFolder(folderPath, icons, category) {
    await ErrorHandler.wrapAsync(async () => {
      const entries = fs26.readdirSync(folderPath, { withFileTypes: true });
      for (const entry of entries) {
        const fullPath = path32.join(folderPath, entry.name);
        if (entry.isDirectory()) {
          await this._scanSvgFolder(fullPath, icons, `${category}/${entry.name}`);
        } else if (entry.isFile() && entry.name.endsWith(".svg")) {
          const name = path32.basename(entry.name, ".svg");
          const svg = fs26.readFileSync(fullPath, "utf-8");
          icons.push({
            name,
            svg,
            path: fullPath,
            category,
            source: "workspace"
          });
        }
      }
    }, `scanning folder ${folderPath}`);
  }
  async _sendLibraryIcons() {
    let libraryPath = getSvgConfig("libraryPath", "");
    if (!libraryPath) {
      const appDataPath = process.env.APPDATA || process.env.HOME || "";
      libraryPath = path32.join(appDataPath, "icon-manager", "icons.json");
    }
    if (!fs26.existsSync(libraryPath)) {
      this.postMessage({ type: "libraryIcons", icons: [] });
      return;
    }
    const result = await ErrorHandler.wrapAsync(async () => {
      const content = fs26.readFileSync(libraryPath, "utf-8");
      const icons = JSON.parse(content);
      this.postMessage({ type: "libraryIcons", icons });
      return true;
    }, "loading library icons");
    if (!result) {
      this.postMessage({ type: "libraryIcons", icons: [] });
    }
  }
  _update() {
    this._panel.title = "Icon Studio";
    this._panel.webview.html = this._getHtmlForWebview();
  }
  _getHtmlForWebview() {
    const webview = this._panel.webview;
    const nonce = getNonce();
    const templatesPath = path32.join(this._extensionUri.fsPath, "dist", "templates", "icon-manager");
    const css = fs26.readFileSync(path32.join(templatesPath, "IconStudio.css"), "utf8");
    const jsTemplate = fs26.readFileSync(path32.join(templatesPath, "IconStudio.js"), "utf8");
    let html = fs26.readFileSync(path32.join(templatesPath, "IconStudio.html"), "utf8");
    const i18nObject = {
      noIconsFound: t("webview.js.noIconsFound"),
      noIconsMatch: t("webview.js.noIconsMatch"),
      browseIconify: t("webview.js.browseIconify"),
      comingSoon: t("webview.js.comingSoon"),
      scanWorkspaceBtn: t("webview.js.scanWorkspaceBtn")
    };
    const js = jsTemplate.replace(/__I18N__/g, JSON.stringify(i18nObject));
    html = html.replace(/\${cspSource}/g, webview.cspSource).replace(/\${nonce}/g, nonce).replace(/\${css}/g, css).replace(/\${js}/g, js).replace(/\${i18n_title}/g, t("webview.tabs.title")).replace(/\${i18n_searchPlaceholder}/g, t("webview.tabs.searchPlaceholder")).replace(/\${i18n_workspace}/g, t("webview.tabs.workspace")).replace(/\${i18n_library}/g, t("webview.tabs.library")).replace(/\${i18n_online}/g, t("webview.tabs.online"));
    return html;
  }
};
function getNonce() {
  let text = "";
  const possible = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789";
  for (let i = 0; i < 32; i++) {
    text += possible.charAt(Math.floor(Math.random() * possible.length));
  }
  return text;
}

// src/commands/panelCommands.ts
init_i18n();
function registerPanelCommands(context, workspaceSvgProvider2) {
  const commands26 = [];
  commands26.push(
    vscode36.commands.registerCommand("sageboxIconStudio.openPanel", () => {
      IconStudioPanel.createOrShow(context.extensionUri, context);
    })
  );
  commands26.push(
    vscode36.commands.registerCommand("sageboxIconStudio.openWelcome", () => {
      WelcomePanel.createOrShow(context.extensionUri);
    })
  );
  commands26.push(
    vscode36.commands.registerCommand("sageboxIconStudio.showWelcome", () => {
      WelcomePanel.createOrShow(context.extensionUri);
    })
  );
  commands26.push(
    vscode36.commands.registerCommand("sageboxIconStudio.scanWorkspace", async (uri) => {
      const folder = uri?.fsPath || vscode36.workspace.workspaceFolders?.[0]?.uri.fsPath;
      if (folder) {
        await workspaceSvgProvider2.scanFolder(folder);
        await workspaceSvgProvider2.scanInlineSvgs();
        await workspaceSvgProvider2.scanIconUsages();
        vscode36.window.showInformationMessage(t("messages.svgScanComplete"));
      }
    })
  );
  commands26.push(
    vscode36.commands.registerCommand("sageboxIconStudio.scanUsages", async () => {
      await workspaceSvgProvider2.scanIconUsages();
      vscode36.window.showInformationMessage(t("messages.usageScanComplete"));
    })
  );
  return commands26;
}

// src/commands/referenceCommands.ts
var vscode38 = __toESM(require("vscode"));
var path33 = __toESM(require("path"));
var fs28 = __toESM(require("fs"));

// src/utils/iconifyService.ts
var https2 = __toESM(require("https"));
async function searchIconify(query, limit = 50) {
  return new Promise((resolve3, reject) => {
    const url = `https://api.iconify.design/search?query=${encodeURIComponent(query)}&limit=${limit}`;
    https2.get(url, (res) => {
      let data = "";
      res.on("data", (chunk) => data += chunk);
      res.on("end", () => {
        try {
          const result = JSON.parse(data);
          const icons = [];
          if (result.icons && Array.isArray(result.icons)) {
            for (const iconId of result.icons) {
              const [prefix, name] = iconId.split(":");
              if (prefix && name) {
                icons.push({ prefix, name });
              }
            }
          }
          resolve3(icons);
        } catch (parseError) {
          reject(parseError);
        }
      });
    }).on("error", reject);
  });
}
async function fetchIconSvg(prefix, name, color) {
  return new Promise((resolve3) => {
    let url = `https://api.iconify.design/${prefix}/${name}.svg`;
    if (color) {
      url += `?color=${encodeURIComponent(color)}`;
    }
    https2.get(url, (res) => {
      let data = "";
      res.on("data", (chunk) => data += chunk);
      res.on("end", () => {
        if (res.statusCode === 200 && data.includes("<svg")) {
          resolve3(data);
        } else {
          resolve3(null);
        }
      });
    }).on("error", () => resolve3(null));
  });
}

// src/commands/iconifyCommands.ts
var vscode37 = __toESM(require("vscode"));
var fs27 = __toESM(require("fs"));

// src/utils/iconPickerHtml.ts
var DEFAULT_COLOR_PRESETS = [
  { color: "#ffffff", title: "White" },
  { color: "#000000", title: "Black" },
  { color: "#3b82f6", title: "Blue" },
  { color: "#10b981", title: "Green" },
  { color: "#f59e0b", title: "Orange" },
  { color: "#ef4444", title: "Red" },
  { color: "#8b5cf6", title: "Purple" },
  { color: "#ec4899", title: "Pink" }
];
function escapeHtmlAttribute(str) {
  return str.replace(/&/g, "&amp;").replace(/"/g, "&quot;").replace(/'/g, "&#39;").replace(/</g, "&lt;").replace(/>/g, "&gt;");
}
function generateIconCard(icon, previewColor = "#ffffff") {
  const escapedName = escapeHtmlAttribute(icon.name);
  const escapedPrefix = escapeHtmlAttribute(icon.prefix);
  const encodedColor = encodeURIComponent(previewColor);
  return `
    <div class="icon-card" data-prefix="${escapedPrefix}" data-name="${escapedName}">
      <div class="icon-preview">
        <img src="https://api.iconify.design/${escapedPrefix}/${escapedName}.svg?color=${encodedColor}" alt="${escapedName}" />
      </div>
      <div class="icon-info">
        <span class="icon-name">${escapedName}</span>
        <span class="icon-prefix">${escapedPrefix}</span>
      </div>
      <button class="add-btn" onclick="addIcon('${escapedPrefix}', '${escapedName}')">
        + Add
      </button>
    </div>`;
}
function generateIconCards(icons, previewColor = "#ffffff") {
  return icons.map((icon) => generateIconCard(icon, previewColor)).join("");
}
function generateColorPresetButton(preset, isActive = false) {
  const activeClass = isActive ? " active" : "";
  return `<button class="color-preset${activeClass}" style="background: ${preset.color}" data-color="${preset.color}" title="${preset.title}"></button>`;
}
function generateColorPresets(presets = DEFAULT_COLOR_PRESETS, activeColor = "#ffffff") {
  return presets.map((preset) => generateColorPresetButton(preset, preset.color === activeColor)).join("\n      ");
}
function getIconPickerStyles() {
  return `
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--vscode-font-family);
      background: var(--vscode-editor-background);
      color: var(--vscode-foreground);
      padding: 20px;
    }
    h1 {
      font-size: 1.5rem;
      margin-bottom: 10px;
    }
    .toolbar {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 20px;
      padding: 12px;
      background: var(--vscode-input-background);
      border-radius: 8px;
    }
    .toolbar label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .color-picker {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
    }
    .color-presets {
      display: flex;
      gap: 6px;
    }
    .color-preset {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s;
    }
    .color-preset:hover {
      transform: scale(1.15);
    }
    .color-preset.active {
      border-color: var(--vscode-focusBorder);
    }
    .subtitle {
      color: var(--vscode-descriptionForeground);
      margin-bottom: 20px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
      gap: 16px;
    }
    .icon-card {
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: all 0.2s;
    }
    .icon-card:hover {
      border-color: var(--vscode-focusBorder);
      transform: translateY(-2px);
    }
    .icon-card.added {
      border-color: var(--vscode-charts-green);
      background: var(--vscode-diffEditor-insertedTextBackground);
    }
    .icon-preview {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    .icon-preview img {
      width: 100%;
      height: 100%;
    }
    .icon-info {
      text-align: center;
      margin-bottom: 8px;
    }
    .icon-name {
      display: block;
      font-size: 12px;
      font-weight: 500;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 120px;
    }
    .icon-prefix {
      display: block;
      font-size: 10px;
      color: var(--vscode-descriptionForeground);
    }
    .add-btn {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 4px 12px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }
    .add-btn:hover {
      background: var(--vscode-button-hoverBackground);
    }
    .add-btn.added {
      background: var(--vscode-charts-green);
      cursor: default;
    }`;
}
function getIconPickerScript() {
  return `
    const vscode = acquireVsCodeApi();
    let currentColor = '#ffffff';
    
    function updateIconColors(color) {
      currentColor = color;
      const encodedColor = encodeURIComponent(color);
      document.querySelectorAll('.icon-preview img').forEach(img => {
        const src = img.src;
        // Update color parameter in URL
        img.src = src.replace(/color=[^&]*/, 'color=' + encodedColor);
      });
      
      // Update active preset
      document.querySelectorAll('.color-preset').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === color);
      });
      
      document.getElementById('colorPicker').value = color;
    }
    
    // Color picker change
    document.getElementById('colorPicker').addEventListener('input', (e) => {
      updateIconColors(e.target.value);
    });
    
    // Color preset buttons
    document.querySelectorAll('.color-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        updateIconColors(btn.dataset.color);
      });
    });
    
    function addIcon(prefix, name) {
      vscode.postMessage({ command: 'addIcon', prefix, name, color: currentColor });
    }
    
    window.addEventListener('message', event => {
      const message = event.data;
      if (message.command === 'iconAdded') {
        const card = document.querySelector(\`.icon-card[data-prefix="\${message.prefix}"][data-name="\${message.name}"]\`);
        if (card) {
          card.classList.add('added');
          const btn = card.querySelector('.add-btn');
          btn.textContent = '\u2713 Added';
          btn.classList.add('added');
          btn.onclick = null;
        }
      }
    });`;
}
function generateToolbarHtml(activeColor = "#ffffff") {
  return `
  <div class="toolbar">
    <label>
      \u{1F3A8} Color:
      <input type="color" id="colorPicker" class="color-picker" value="${activeColor}" />
    </label>
    <div class="color-presets">
      ${generateColorPresets(DEFAULT_COLOR_PRESETS, activeColor)}
    </div>
    <span style="color: var(--vscode-descriptionForeground); font-size: 12px;">
      (Color for monochrome icons only)
    </span>
  </div>`;
}
function getIconPickerHtml(icons, query, previewColor = "#ffffff") {
  const escapedQuery = escapeHtmlAttribute(query);
  const iconCards = generateIconCards(icons, previewColor);
  const styles = getIconPickerStyles();
  const script = getIconPickerScript();
  const toolbar = generateToolbarHtml(previewColor);
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Icon Picker</title>
  <style>${styles}</style>
</head>
<body>
  <h1>\u{1F50D} Search Results for "${escapedQuery}"</h1>
  ${toolbar}
  <p class="subtitle">Found ${icons.length} icons. Click "Add" to add to your library.</p>
  <div class="grid">
    ${iconCards}
  </div>
  <script>${script}</script>
</body>
</html>`;
}

// src/commands/iconifyCommands.ts
init_i18n();
async function handleDuplicateIconName(iconName, workspaceSvgProvider2) {
  const existingIcon = workspaceSvgProvider2.getIcon(iconName);
  if (!existingIcon) {
    return iconName;
  }
  const choice = await vscode37.window.showQuickPick(
    [
      {
        label: t("ui.labels.renameIcon") || "Rename icon",
        description: t("ui.labels.enterNewName") || "Enter a different name",
        value: "rename"
      },
      {
        label: t("ui.labels.replaceIcon") || "Replace existing",
        description: t("ui.labels.overwriteExisting") || "Overwrite the existing icon",
        value: "replace"
      },
      {
        label: t("ui.labels.cancel") || "Cancel",
        description: "",
        value: "cancel"
      }
    ],
    {
      placeHolder: t("messages.iconAlreadyExists", { name: iconName }) || `Icon "${iconName}" already exists`,
      title: t("ui.titles.duplicateIcon") || "Duplicate Icon Name"
    }
  );
  if (!choice || choice.value === "cancel") {
    return void 0;
  }
  if (choice.value === "replace") {
    return iconName;
  }
  const suggestedName = generateUniqueName(iconName, workspaceSvgProvider2);
  const newName = await vscode37.window.showInputBox({
    prompt: t("ui.prompts.enterNewIconName") || "Enter a new name for the icon",
    value: suggestedName,
    placeHolder: t("ui.placeholders.iconName") || "icon-name",
    validateInput: (value) => {
      if (!value || value.trim() === "") {
        return t("validation.nameRequired") || "Name is required";
      }
      if (!/^[a-z0-9-]+$/.test(value)) {
        return t("validation.invalidCharacters") || "Use only lowercase letters, numbers, and hyphens";
      }
      return null;
    }
  });
  return newName || void 0;
}
function generateUniqueName(baseName, workspaceSvgProvider2) {
  let counter = 2;
  let newName = `${baseName}-${counter}`;
  while (workspaceSvgProvider2.getIcon(newName)) {
    counter++;
    newName = `${baseName}-${counter}`;
  }
  return newName;
}
function showIconifyReplacementPicker(context, icons, query, missingIconName) {
  return new Promise((resolve3) => {
    const panel = vscode37.window.createWebviewPanel(
      "iconifyReplacePicker",
      `Replace: ${missingIconName}`,
      vscode37.ViewColumn.One,
      {
        enableScripts: true,
        retainContextWhenHidden: true
      }
    );
    let resolved = false;
    panel.webview.html = getIconifyReplacePickerHtml(icons, query, missingIconName);
    panel.onDidDispose(() => {
      if (!resolved) {
        resolve3(void 0);
      }
    });
    panel.webview.onDidReceiveMessage(async (message) => {
      if (message.command === "selectIcon") {
        const { prefix, name, color } = message;
        try {
          const svg = await fetchIconSvg(prefix, name, color !== "#ffffff" ? color : void 0);
          if (!svg) {
            vscode37.window.showErrorMessage(t("messages.failedToFetchIcon"));
            return;
          }
          resolved = true;
          panel.dispose();
          resolve3({ prefix, name, svg });
        } catch (error) {
          vscode37.window.showErrorMessage(
            t("messages.failedToFetchIconError", { error: String(error) })
          );
        }
      } else if (message.command === "cancel") {
        resolved = true;
        panel.dispose();
        resolve3(void 0);
      } else if (message.command === "search") {
        const newQuery = message.query;
        const results = await searchIconify(newQuery);
        panel.webview.postMessage({ command: "updateResults", icons: results, query: newQuery });
      }
    });
  });
}
function showIconPickerPanel(context, results, query, svgTransformer, workspaceSvgProvider2) {
  const panel = vscode37.window.createWebviewPanel(
    "iconPicker",
    `Icons: ${query}`,
    vscode37.ViewColumn.One,
    { enableScripts: true, retainContextWhenHidden: true }
  );
  panel.webview.html = getIconPickerHtml(results, query);
  panel.webview.onDidReceiveMessage(async (message) => {
    if (message.command === "selectIcon") {
      const { prefix, name, color } = message;
      try {
        const svg = await fetchIconSvg(prefix, name, color !== "#ffffff" ? color : void 0);
        if (!svg) {
          vscode37.window.showErrorMessage(t("messages.failedToFetchIcon"));
          return;
        }
        const iconName = `${prefix}-${name}`;
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        const config = getConfig();
        const isSprite = config.buildFormat === "sprite.svg";
        if (isSprite) {
          await addToSpriteSvg(outputPath, iconName, svg, svgTransformer);
        } else {
          await addToIconsJs({
            outputPath,
            iconName,
            svgContent: svg,
            transformer: svgTransformer
          });
        }
        workspaceSvgProvider2.refresh();
        const formatName = isSprite ? "sprite" : "icons library";
        vscode37.window.showInformationMessage(
          t("messages.iconAddedToFormat", { name: iconName, format: formatName })
        );
      } catch (error) {
        vscode37.window.showErrorMessage(t("messages.failedToAddIcon", { error: String(error) }));
      }
    } else if (message.command === "search") {
      const newQuery = message.query;
      const newResults = await searchIconify(newQuery);
      panel.title = `Icons: ${newQuery}`;
      panel.webview.postMessage({ command: "updateResults", icons: newResults, query: newQuery });
    } else if (message.command === "close") {
      panel.dispose();
    }
  });
}
function getIconifyReplacePickerHtml(icons, query, missingIconName) {
  const escapedQuery = query.replace(/"/g, "&quot;");
  const escapedMissing = missingIconName.replace(/"/g, "&quot;");
  const iconCards = icons.map(
    (icon) => `
    <div class="icon-card" data-prefix="${icon.prefix}" data-name="${icon.name}">
      <div class="icon-preview">
        <img src="https://api.iconify.design/${icon.prefix}/${icon.name}.svg?color=%23ffffff" alt="${icon.name}" loading="lazy" />
      </div>
      <div class="icon-info">
        <span class="icon-name">${icon.name}</span>
        <span class="icon-prefix">${icon.prefix}</span>
      </div>
      <button class="select-btn" onclick="selectIcon('${icon.prefix}', '${icon.name}')">
        Build
      </button>
    </div>
  `
  ).join("");
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Replace Icon</title>
  <style>
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body {
      font-family: var(--vscode-font-family);
      background: var(--vscode-editor-background);
      color: var(--vscode-foreground);
      padding: 20px;
    }
    .header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-bottom: 16px;
    }
    h1 {
      font-size: 1.3rem;
    }
    .cancel-btn {
      background: var(--vscode-button-secondaryBackground);
      color: var(--vscode-button-secondaryForeground);
      border: none;
      padding: 8px 16px;
      border-radius: 4px;
      cursor: pointer;
    }
    .cancel-btn:hover {
      background: var(--vscode-button-secondaryHoverBackground);
    }
    .info-box {
      background: var(--vscode-inputValidation-infoBackground);
      border: 1px solid var(--vscode-inputValidation-infoBorder);
      border-radius: 6px;
      padding: 12px;
      margin-bottom: 16px;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    .info-box .icon { font-size: 20px; }
    .toolbar {
      display: flex;
      align-items: center;
      gap: 16px;
      margin-bottom: 20px;
      padding: 12px;
      background: var(--vscode-input-background);
      border-radius: 8px;
    }
    .toolbar label {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 13px;
    }
    .color-picker {
      width: 36px;
      height: 36px;
      border: none;
      border-radius: 6px;
      cursor: pointer;
      padding: 0;
    }
    .color-presets {
      display: flex;
      gap: 6px;
    }
    .color-preset {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid transparent;
      cursor: pointer;
      transition: transform 0.15s;
    }
    .color-preset:hover { transform: scale(1.15); }
    .color-preset.active { border-color: var(--vscode-focusBorder); }
    .subtitle {
      color: var(--vscode-descriptionForeground);
      margin-bottom: 20px;
    }
    .grid {
      display: grid;
      grid-template-columns: repeat(auto-fill, minmax(130px, 1fr));
      gap: 12px;
    }
    .icon-card {
      background: var(--vscode-input-background);
      border: 1px solid var(--vscode-input-border);
      border-radius: 8px;
      padding: 12px;
      display: flex;
      flex-direction: column;
      align-items: center;
      transition: all 0.2s;
    }
    .icon-card:hover {
      border-color: var(--vscode-focusBorder);
      transform: translateY(-2px);
    }
    .icon-preview {
      width: 48px;
      height: 48px;
      display: flex;
      align-items: center;
      justify-content: center;
      margin-bottom: 8px;
    }
    .icon-preview img {
      width: 100%;
      height: 100%;
    }
    .icon-info {
      text-align: center;
      margin-bottom: 8px;
    }
    .icon-name {
      display: block;
      font-size: 11px;
      font-weight: 500;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      max-width: 110px;
    }
    .icon-prefix {
      display: block;
      font-size: 10px;
      color: var(--vscode-descriptionForeground);
    }
    .select-btn {
      background: var(--vscode-button-background);
      color: var(--vscode-button-foreground);
      border: none;
      padding: 4px 14px;
      border-radius: 4px;
      cursor: pointer;
      font-size: 11px;
    }
    .select-btn:hover {
      background: var(--vscode-button-hoverBackground);
    }
  </style>
</head>
<body>
  <div class="header">
    <h1>\u{1F504} Replace Missing Icon</h1>
    <button class="cancel-btn" onclick="cancel()">Cancel</button>
  </div>

  <div class="info-box">
    <span class="icon">\u26A0\uFE0F</span>
    <span>Missing icon: <strong>${escapedMissing}</strong> \u2014 Select a replacement from Iconify</span>
  </div>

  <div class="toolbar">
    <label>
      \u{1F3A8} Color:
      <input type="color" id="colorPicker" class="color-picker" value="#ffffff" />
    </label>
    <div class="color-presets">
      <button class="color-preset active" style="background: #ffffff" data-color="#ffffff" title="White"></button>
      <button class="color-preset" style="background: #000000" data-color="#000000" title="Black"></button>
      <button class="color-preset" style="background: #3b82f6" data-color="#3b82f6" title="Blue"></button>
      <button class="color-preset" style="background: #10b981" data-color="#10b981" title="Green"></button>
      <button class="color-preset" style="background: #f59e0b" data-color="#f59e0b" title="Orange"></button>
      <button class="color-preset" style="background: #ef4444" data-color="#ef4444" title="Red"></button>
      <button class="color-preset" style="background: #8b5cf6" data-color="#8b5cf6" title="Purple"></button>
    </div>
  </div>

  <p class="subtitle">Results for "${escapedQuery}" \u2014 ${icons.length} icons found. Click to build.</p>

  <div class="grid">
    ${iconCards}
  </div>

  <script>
    const vscode = acquireVsCodeApi();
    let currentColor = '#ffffff';

    function updateIconColors(color) {
      currentColor = color;
      const encodedColor = encodeURIComponent(color);
      document.querySelectorAll('.icon-preview img').forEach(img => {
        const src = img.src;
        img.src = src.replace(/color=[^&]*/, 'color=' + encodedColor);
      });
      document.querySelectorAll('.color-preset').forEach(btn => {
        btn.classList.toggle('active', btn.dataset.color === color);
      });
      document.getElementById('colorPicker').value = color;
    }

    document.getElementById('colorPicker').addEventListener('input', (e) => {
      updateIconColors(e.target.value);
    });

    document.querySelectorAll('.color-preset').forEach(btn => {
      btn.addEventListener('click', () => {
        updateIconColors(btn.dataset.color);
      });
    });

    function selectIcon(prefix, name) {
      vscode.postMessage({ command: 'selectIcon', prefix, name, color: currentColor });
    }

    function cancel() {
      vscode.postMessage({ command: 'cancel' });
    }
  </script>
</body>
</html>`;
}
function registerIconifyCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2, svgTransformer } = providers;
  const searchIconsCmd = vscode37.commands.registerCommand("sageboxIconStudio.searchIcons", async () => {
    const query = await vscode37.window.showInputBox({
      prompt: t("ui.prompts.searchIconifyFull"),
      placeHolder: t("ui.placeholders.enterSearchTerm")
    });
    if (!query) return;
    const results = await searchIconify(query);
    if (results.length === 0) {
      vscode37.window.showInformationMessage(t("messages.noIconsFoundForQuery", { query }));
      return;
    }
    showIconPickerPanel(context, results, query, svgTransformer, workspaceSvgProvider2);
  });
  const searchIconifyCmd = vscode37.commands.registerCommand(
    "sageboxIconStudio.searchIconify",
    async (query) => {
      const searchTerm = query || await vscode37.window.showInputBox({
        prompt: t("ui.prompts.searchIconify"),
        placeHolder: t("ui.placeholders.enterSearchTerm")
      });
      if (!searchTerm) return;
      await vscode37.window.withProgress(
        {
          location: vscode37.ProgressLocation.Notification,
          title: `Searching "${searchTerm}" in Iconify...`,
          cancellable: false
        },
        async () => {
          const results = await searchIconify(searchTerm);
          if (results.length === 0) {
            vscode37.window.showInformationMessage(
              t("messages.noIconsFoundForQuery", { query: searchTerm })
            );
            return;
          }
          showIconPickerPanel(context, results, searchTerm, svgTransformer, workspaceSvgProvider2);
        }
      );
    }
  );
  const importIconCmd = vscode37.commands.registerCommand(
    "sageboxIconStudio.importIcon",
    async (iconName, sourceFile, line) => {
      const config = getConfig();
      const isSprite = config.buildFormat === "sprite.svg";
      const sourceChoice = await vscode37.window.showQuickPick(
        [
          {
            label: `$(cloud-download) ${t("ui.labels.searchInIconify")}`,
            description: t("ui.labels.findBuildIconify"),
            value: "iconify"
          },
          {
            label: `$(folder-opened) ${t("ui.labels.browseForSvgFile")}`,
            description: t("ui.labels.selectExistingSvg"),
            value: "file"
          }
        ],
        {
          placeHolder: `Import icon "${iconName}" - Select source`,
          title: `\u{1F4E5} Import: ${iconName}`
        }
      );
      if (!sourceChoice) return;
      let svgContent;
      let finalIconName = iconName;
      if (sourceChoice.value === "iconify") {
        const query = await vscode37.window.showInputBox({
          prompt: t("ui.prompts.searchIconify"),
          value: iconName,
          placeHolder: t("ui.placeholders.enterSearchTerm")
        });
        if (!query) return;
        const results = await searchIconify(query);
        if (results.length === 0) {
          vscode37.window.showInformationMessage(t("messages.noIconsFoundForQuery", { query }));
          return;
        }
        const selectedIcon = await showIconifyReplacementPicker(context, results, query, iconName);
        if (!selectedIcon) return;
        svgContent = selectedIcon.svg;
        finalIconName = `${selectedIcon.prefix}-${selectedIcon.name}`;
        const resolvedName = await handleDuplicateIconName(finalIconName, workspaceSvgProvider2);
        if (!resolvedName) return;
        finalIconName = resolvedName;
      } else if (sourceChoice.value === "file") {
        const fileUri = await vscode37.window.showOpenDialog({
          canSelectFiles: true,
          canSelectFolders: false,
          canSelectMany: false,
          filters: { "SVG Files": ["svg"] },
          title: `Select SVG file for "${iconName}"`
        });
        if (!fileUri?.[0]) return;
        svgContent = fs27.readFileSync(fileUri[0].fsPath, "utf-8");
        const resolvedName = await handleDuplicateIconName(finalIconName, workspaceSvgProvider2);
        if (!resolvedName) return;
        finalIconName = resolvedName;
      }
      if (!svgContent) return;
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;
      if (isSprite) {
        await addToSpriteSvg(outputPath, finalIconName, svgContent, svgTransformer);
      } else {
        await addToIconsJs({
          outputPath,
          iconName: finalIconName,
          svgContent,
          transformer: svgTransformer
        });
      }
      const builtIcon = {
        name: finalIconName,
        svg: svgContent,
        path: outputPath,
        source: "library",
        category: "built",
        isBuilt: true
      };
      workspaceSvgProvider2.addBuiltIcon(finalIconName, builtIcon);
      if (sourceFile && line !== void 0 && finalIconName !== iconName) {
        try {
          const document = await vscode37.workspace.openTextDocument(sourceFile);
          const lineText = document.lineAt(line).text;
          const newText = lineText.replace(
            new RegExp(`name=["']${iconName}["']`, "g"),
            `name="${finalIconName}"`
          );
          if (newText !== lineText) {
            const edit = new vscode37.WorkspaceEdit();
            edit.replace(document.uri, new vscode37.Range(line, 0, line, lineText.length), newText);
            await vscode37.workspace.applyEdit(edit);
          }
        } catch (updateError) {
          console.error("Failed to update icon reference:", updateError);
        }
      }
      workspaceSvgProvider2.softRefresh();
      builtIconsProvider2.refresh();
      const formatName = isSprite ? "sprite" : "icons library";
      vscode37.window.showInformationMessage(
        t("messages.iconImportedToFormat", { name: finalIconName, format: formatName })
      );
    }
  );
  const searchIconifyForComponentCmd = vscode37.commands.registerCommand(
    "sageboxIconStudio.searchIconifyForComponent",
    async (suggestedQuery, sourceFile, line) => {
      const config = getConfig();
      const isSprite = config.buildFormat === "sprite.svg";
      const componentName = config.webComponentName || "sg-icon";
      const query = await vscode37.window.showInputBox({
        prompt: t("ui.prompts.searchIconify"),
        value: suggestedQuery || "",
        placeHolder: t("ui.placeholders.enterSearchTerm")
      });
      if (!query) return;
      const results = await searchIconify(query);
      if (results.length === 0) {
        vscode37.window.showInformationMessage(t("messages.noIconsFoundForQuery", { query }));
        return;
      }
      const selectedIcon = await showIconifyReplacementPicker(
        context,
        results,
        query,
        suggestedQuery || query
      );
      if (!selectedIcon) return;
      let finalIconName = `${selectedIcon.prefix}-${selectedIcon.name}`;
      const resolvedName = await handleDuplicateIconName(finalIconName, workspaceSvgProvider2);
      if (!resolvedName) return;
      finalIconName = resolvedName;
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;
      if (isSprite) {
        await addToSpriteSvg(outputPath, finalIconName, selectedIcon.svg, svgTransformer);
      } else {
        await addToIconsJs({
          outputPath,
          iconName: finalIconName,
          svgContent: selectedIcon.svg,
          transformer: svgTransformer
        });
      }
      const builtIcon = {
        name: finalIconName,
        svg: selectedIcon.svg,
        path: outputPath,
        source: "library",
        category: "built",
        isBuilt: true
      };
      workspaceSvgProvider2.addBuiltIcon(finalIconName, builtIcon);
      if (sourceFile && line !== void 0) {
        try {
          const document = await vscode37.workspace.openTextDocument(sourceFile);
          const lineText = document.lineAt(line).text;
          const namePattern = new RegExp(`(<${componentName}[^>]*name=["'])([^"']*)(['"])`, "gi");
          let newText;
          if (namePattern.test(lineText)) {
            namePattern.lastIndex = 0;
            newText = lineText.replace(namePattern, `$1${finalIconName}$3`);
          } else {
            const tagPattern = new RegExp(String.raw`<${componentName}(\s*)`, "gi");
            newText = lineText.replace(tagPattern, `<${componentName}$1name="${finalIconName}" `);
          }
          if (newText !== lineText) {
            const edit = new vscode37.WorkspaceEdit();
            edit.replace(document.uri, new vscode37.Range(line, 0, line, lineText.length), newText);
            await vscode37.workspace.applyEdit(edit);
          }
        } catch (updateError) {
          console.error("Failed to update icon reference:", updateError);
        }
      }
      workspaceSvgProvider2.softRefresh();
      builtIconsProvider2.refresh();
      const formatName = isSprite ? "sprite" : "icons library";
      vscode37.window.showInformationMessage(
        t("messages.iconImportedToFormat", { name: finalIconName, format: formatName })
      );
    }
  );
  const browseWorkspaceIconsCmd = vscode37.commands.registerCommand(
    "sageboxIconStudio.browseWorkspaceIcons",
    async (suggestedName, sourceFile, line) => {
      const config = getConfig();
      const componentName = config.webComponentName || "sg-icon";
      const allIcons = await workspaceSvgProvider2.getAllIcons();
      if (allIcons.length === 0) {
        vscode37.window.showInformationMessage(
          t("messages.noIconsInWorkspace") || "No icons found in workspace. Try searching Iconify."
        );
        return;
      }
      const iconItems = allIcons.map((icon) => ({
        label: `$(symbol-misc) ${icon.name}`,
        description: icon.source === "library" ? t("ui.labels.library") : icon.source,
        iconName: icon.name
      }));
      const selected = await vscode37.window.showQuickPick(iconItems, {
        placeHolder: t("ui.placeholders.selectIcon") || "Select an icon",
        matchOnDescription: true,
        title: t("ui.titles.browseIcons") || "\u{1F4C1} Browse Workspace Icons"
      });
      if (!selected) return;
      if (sourceFile && line !== void 0) {
        try {
          const document = await vscode37.workspace.openTextDocument(sourceFile);
          const lineText = document.lineAt(line).text;
          const namePattern = new RegExp(`(<${componentName}[^>]*name=["'])([^"']*)(['"])`, "gi");
          let newText;
          if (namePattern.test(lineText)) {
            namePattern.lastIndex = 0;
            newText = lineText.replace(namePattern, `$1${selected.iconName}$3`);
          } else {
            const tagPattern = new RegExp(String.raw`<${componentName}(\s*)`, "gi");
            newText = lineText.replace(
              tagPattern,
              `<${componentName}$1name="${selected.iconName}" `
            );
          }
          if (newText !== lineText) {
            const edit = new vscode37.WorkspaceEdit();
            edit.replace(document.uri, new vscode37.Range(line, 0, line, lineText.length), newText);
            await vscode37.workspace.applyEdit(edit);
          }
        } catch (updateError) {
          console.error("Failed to update icon reference:", updateError);
        }
      }
      vscode37.window.showInformationMessage(
        t("messages.iconSelected", { name: selected.iconName }) || `Icon "${selected.iconName}" selected`
      );
    }
  );
  const importMissingIconCmd = vscode37.commands.registerCommand(
    "sageboxIconStudio.importMissingIcon",
    async (item) => {
      const iconName = item?.icon?.name || item?.label;
      if (!iconName) {
        vscode37.window.showWarningMessage(
          t("messages.noIconNameFound") || "No icon name found"
        );
        return;
      }
      await vscode37.window.withProgress(
        {
          location: vscode37.ProgressLocation.Notification,
          title: t("messages.searchingIconify", { name: iconName }) || `Searching "${iconName}" in Iconify...`,
          cancellable: false
        },
        async () => {
          const results = await searchIconify(iconName);
          if (results.length === 0) {
            vscode37.window.showInformationMessage(
              t("messages.noIconsFoundForQuery", { query: iconName })
            );
            return;
          }
          showIconPickerPanel(context, results, iconName, svgTransformer, workspaceSvgProvider2);
        }
      );
    }
  );
  context.subscriptions.push(
    searchIconsCmd,
    searchIconifyCmd,
    importIconCmd,
    searchIconifyForComponentCmd,
    browseWorkspaceIconsCmd,
    importMissingIconCmd
  );
}

// src/commands/referenceCommands.ts
init_i18n();
function registerReferenceCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, workspaceTreeView: workspaceTreeView2 } = providers;
  const removeReferenceCmd = vscode38.commands.registerCommand(
    "sageboxIconStudio.removeReference",
    async (item) => {
      if (!item?.icon?.filePath || item.icon.line === void 0) {
        vscode38.window.showWarningMessage(t("messages.cannotFindRefLocation"));
        return;
      }
      const confirm = await vscode38.window.showWarningMessage(
        `Remove reference to "${item.icon.name}.svg"?`,
        { modal: true },
        "Remove"
      );
      if (confirm !== "Remove") return;
      try {
        const document = await vscode38.workspace.openTextDocument(item.icon.filePath);
        const line = document.lineAt(item.icon.line);
        const text = line.text;
        const imgMatch = text.match(/<img\s+[^>]*src=["'][^"']*\.svg["'][^>]*>/i);
        if (imgMatch) {
          const edit = new vscode38.WorkspaceEdit();
          const startIndex = text.indexOf(imgMatch[0]);
          const startPos = new vscode38.Position(item.icon.line, startIndex);
          const endPos = new vscode38.Position(item.icon.line, startIndex + imgMatch[0].length);
          edit.delete(document.uri, new vscode38.Range(startPos, endPos));
          await vscode38.workspace.applyEdit(edit);
          await document.save();
          vscode38.window.showInformationMessage(
            t("messages.removedReference", { name: `${item.icon.name}.svg` })
          );
          workspaceSvgProvider2.refresh();
        }
      } catch (error) {
        vscode38.window.showErrorMessage(
          t("messages.errorRemovingReference", { error: String(error) })
        );
      }
    }
  );
  const findAndReplaceCmd = vscode38.commands.registerCommand(
    "sageboxIconStudio.findAndReplace",
    async (item) => {
      if (!item?.icon?.filePath || item.icon.line === void 0) {
        vscode38.window.showWarningMessage(t("messages.cannotFindRefLocation"));
        return;
      }
      const currentPath = item.icon.path;
      const currentName = item.icon.name;
      const choice = await vscode38.window.showQuickPick(
        [
          { label: `$(file-directory) ${t("ui.labels.browseForSvgFile")}`, value: "browse" },
          { label: `$(search) ${t("ui.labels.searchWorkspaceSvg")}`, value: "search" },
          { label: `$(cloud-download) ${t("ui.labels.searchInIconify")}`, value: "iconify" },
          { label: `$(edit) ${t("ui.labels.enterNewPathManually")}`, value: "manual" }
        ],
        {
          placeHolder: t("ui.placeholders.howToFindReplacement")
        }
      );
      if (!choice) return;
      let newPath;
      if (choice.value === "browse") {
        const fileUri = await vscode38.window.showOpenDialog({
          canSelectFiles: true,
          canSelectFolders: false,
          canSelectMany: false,
          filters: { "SVG Files": ["svg"] },
          title: t("ui.titles.selectSvgFile")
        });
        if (fileUri && fileUri[0]) {
          const refFileDir = path33.dirname(item.icon.filePath);
          newPath = "./" + path33.relative(refFileDir, fileUri[0].fsPath).replace(/\\/g, "/");
        }
      } else if (choice.value === "search") {
        const svgFiles = await vscode38.workspace.findFiles("**/*.svg", "**/node_modules/**", 100);
        if (svgFiles.length === 0) {
          vscode38.window.showWarningMessage(t("messages.noSvgFilesFound"));
          return;
        }
        const workspaceRoot = vscode38.workspace.workspaceFolders?.[0]?.uri.fsPath || "";
        const items = svgFiles.map((f) => {
          const relativePath = path33.relative(workspaceRoot, f.fsPath).replace(/\\/g, "/");
          return {
            label: path33.basename(f.fsPath),
            description: relativePath,
            fsPath: f.fsPath
          };
        });
        const selected = await vscode38.window.showQuickPick(items, {
          placeHolder: `Search for replacement SVG (current: ${currentName}.svg)`,
          matchOnDescription: true
        });
        if (selected) {
          const refFileDir = path33.dirname(item.icon.filePath);
          newPath = "./" + path33.relative(refFileDir, selected.fsPath).replace(/\\/g, "/");
        }
      } else if (choice.value === "iconify") {
        const query = await vscode38.window.showInputBox({
          prompt: t("ui.prompts.searchIconify"),
          value: currentName,
          placeHolder: t("ui.placeholders.enterSearchTerm")
        });
        if (!query) return;
        const results = await searchIconify(query);
        if (results.length === 0) {
          vscode38.window.showInformationMessage(t("messages.noIconsFoundForQuery", { query }));
          return;
        }
        const selectedIcon = await showIconifyReplacementPicker(
          context,
          results,
          query,
          currentName
        );
        if (!selectedIcon) return;
        const saveChoice = await vscode38.window.showQuickPick(
          [
            { label: `$(file-add) ${t("ui.labels.saveNextToFile")}`, value: "same-dir" },
            { label: `$(folder) ${t("ui.labels.chooseFolder")}`, value: "choose" }
          ],
          {
            placeHolder: t("ui.placeholders.whereToSaveSvg")
          }
        );
        if (!saveChoice) return;
        let savePath;
        const iconFileName = `${selectedIcon.prefix}-${selectedIcon.name}.svg`;
        const refFileDir = path33.dirname(item.icon.filePath);
        if (saveChoice.value === "same-dir") {
          savePath = path33.join(refFileDir, iconFileName);
        } else {
          const folderUri = await vscode38.window.showOpenDialog({
            canSelectFiles: false,
            canSelectFolders: true,
            canSelectMany: false,
            title: t("ui.titles.selectFolderToSave")
          });
          if (!folderUri || !folderUri[0]) return;
          savePath = path33.join(folderUri[0].fsPath, iconFileName);
        }
        fs28.writeFileSync(savePath, selectedIcon.svg);
        vscode38.window.showInformationMessage(
          t("messages.savedIconTo", { name: path33.basename(savePath) })
        );
        newPath = "./" + path33.relative(refFileDir, savePath).replace(/\\/g, "/");
      } else {
        newPath = await vscode38.window.showInputBox({
          prompt: t("ui.prompts.enterNewSvgPath"),
          value: currentPath,
          placeHolder: t("ui.placeholders.svgPathExample")
        });
      }
      if (!newPath) return;
      try {
        const document = await vscode38.workspace.openTextDocument(item.icon.filePath);
        const line = document.lineAt(item.icon.line);
        const text = line.text;
        const imgMatch = text.match(/<img\s+[^>]*src=["']([^"']*\.svg)["'][^>]*>/i);
        if (imgMatch) {
          const oldSrc = imgMatch[1];
          const newText = text.replace(oldSrc, newPath);
          const edit = new vscode38.WorkspaceEdit();
          edit.replace(document.uri, line.range, newText);
          await vscode38.workspace.applyEdit(edit);
          await document.save();
          vscode38.window.showInformationMessage(
            t("messages.updatedPath", { oldPath: oldSrc, newPath })
          );
          workspaceSvgProvider2.refresh();
        }
      } catch (error) {
        vscode38.window.showErrorMessage(t("messages.errorUpdatingPath", { error: String(error) }));
      }
    }
  );
  const revealInTreeCmd = vscode38.commands.registerCommand(
    "sageboxIconStudio.revealInTree",
    async (iconName, filePath, lineNumber) => {
      if (!iconName && !filePath) return;
      try {
        await workspaceSvgProvider2.ensureInitialized();
        let item = workspaceSvgProvider2.findItemByIconNameOrPath(iconName, filePath, lineNumber);
        if (!item) {
          let icon = workspaceSvgProvider2.getIconByName(iconName);
          if (!icon && filePath) {
            icon = workspaceSvgProvider2.getIconByPath(filePath);
          }
          if (icon) {
            item = workspaceSvgProvider2.createSvgItemFromIcon(icon);
          }
        }
        if (item && workspaceTreeView2) {
          try {
            await workspaceTreeView2.reveal(item, { select: true, focus: true, expand: true });
          } catch (revealError) {
          }
        }
      } catch (error) {
      }
    }
  );
  return [removeReferenceCmd, findAndReplaceCmd, revealInTreeCmd];
}

// src/commands/configCommands.ts
var vscode39 = __toESM(require("vscode"));
var path34 = __toESM(require("path"));
var fs29 = __toESM(require("fs"));
init_i18n();
function registerConfigCommands(_context) {
  const commands26 = [];
  commands26.push(
    vscode39.commands.registerCommand("sageboxIconStudio.configureProject", async () => {
      const config = vscode39.workspace.getConfiguration("sageboxIconStudio");
      const items = [
        {
          label: t("ui.labels.outputDirectory"),
          description: config.get("outputDirectory"),
          detail: t("ui.details.outputDirectoryDesc")
        },
        {
          label: t("ui.labels.svgFolders"),
          description: (config.get("svgFolders") || []).join(", "),
          detail: t("ui.details.svgFoldersDesc")
        },
        {
          label: t("ui.labels.componentName"),
          description: config.get("componentName"),
          detail: t("ui.details.componentNameDesc")
        },
        {
          label: t("ui.labels.outputFormat"),
          description: config.get("outputFormat"),
          detail: t("ui.details.outputFormatDesc")
        },
        {
          label: t("ui.labels.webComponentName"),
          description: config.get("webComponentName"),
          detail: t("ui.details.webComponentNameDesc")
        }
      ];
      const selection = await vscode39.window.showQuickPick(items, {
        placeHolder: t("ui.placeholders.selectSettingToConfigure")
      });
      if (!selection) {
        return;
      }
      if (selection.label === t("ui.labels.outputDirectory")) {
        const outputDir = await vscode39.window.showInputBox({
          prompt: t("ui.prompts.enterOutputDirectory"),
          value: config.get("outputDirectory") || "bezier-icons",
          placeHolder: t("ui.placeholders.outputDirectoryExample")
        });
        if (outputDir !== void 0) {
          await config.update("outputDirectory", outputDir, vscode39.ConfigurationTarget.Workspace);
          ensureOutputDirectory();
          vscode39.window.showInformationMessage(
            t("messages.outputDirectorySet", { path: outputDir })
          );
        }
      } else if (selection.label === t("ui.labels.svgFolders")) {
        const currentFolders = config.get("svgFolders") || [];
        const foldersStr = await vscode39.window.showInputBox({
          prompt: t("ui.prompts.enterSvgFolders"),
          value: currentFolders.join(", "),
          placeHolder: t("ui.placeholders.svgFoldersExample")
        });
        if (foldersStr !== void 0) {
          const folders = foldersStr.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
          await config.update("svgFolders", folders, vscode39.ConfigurationTarget.Workspace);
          vscode39.window.showInformationMessage(t("messages.svgFoldersUpdated"));
          vscode39.commands.executeCommand("sageboxIconStudio.refreshIcons");
        }
      } else if (selection.label === t("ui.labels.componentName")) {
        const name = await vscode39.window.showInputBox({
          prompt: t("ui.prompts.enterComponentName"),
          value: config.get("componentName") || "Icon"
        });
        if (name) {
          await config.update("componentName", name, vscode39.ConfigurationTarget.Workspace);
          vscode39.window.showInformationMessage(t("messages.componentNameSet", { name }));
        }
      } else if (selection.label === t("ui.labels.outputFormat")) {
        const format = await vscode39.window.showQuickPick(
          ["jsx", "vue", "svelte", "astro", "html"],
          {
            placeHolder: t("ui.placeholders.selectOutputFormat")
          }
        );
        if (format) {
          await config.update("outputFormat", format, vscode39.ConfigurationTarget.Workspace);
          vscode39.window.showInformationMessage(t("messages.outputFormatSet", { format }));
        }
      } else if (selection.label === t("ui.labels.webComponentName")) {
        const name = await vscode39.window.showInputBox({
          prompt: t("ui.prompts.enterWebComponentName"),
          value: config.get("webComponentName") || "bezier-icon"
        });
        if (name) {
          await config.update("webComponentName", name, vscode39.ConfigurationTarget.Workspace);
          vscode39.window.showInformationMessage(t("messages.componentNameSet", { name }));
        }
      }
    })
  );
  commands26.push(
    vscode39.commands.registerCommand("sageboxIconStudio.editIgnoreFile", async () => {
      const workspaceFolder = vscode39.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        vscode39.window.showWarningMessage(t("messages.noWorkspace"));
        return;
      }
      const ignoreFilePath = path34.join(workspaceFolder.uri.fsPath, ".bezierignore");
      if (!fs29.existsSync(ignoreFilePath)) {
        const template = `# Bezier - Ignore File
# This file works similar to .gitignore
# Patterns listed here will be excluded from scanning

# Examples:

# Ignore entire directories
# bak/
# temp/

# Ignore specific files
# svgs/old-icon.svg

# Ignore by pattern (** matches any path)
# **/backup/**
# **/*-old.svg

# Ignore files starting with underscore
# _*.svg

# Ignore node_modules (already ignored by default)
# node_modules/
`;
        fs29.writeFileSync(ignoreFilePath, template, "utf-8");
      }
      const doc = await vscode39.workspace.openTextDocument(ignoreFilePath);
      await vscode39.window.showTextDocument(doc);
    })
  );
  commands26.push(
    vscode39.commands.registerCommand("sageboxIconStudio.configureSvgFolder", async () => {
      const workspaceFolder = vscode39.workspace.workspaceFolders?.[0];
      if (!workspaceFolder) {
        vscode39.window.showWarningMessage(t("messages.noWorkspace"));
        return;
      }
      const config = vscode39.workspace.getConfiguration("sageboxIconStudio");
      const currentFolders = config.get("svgFolders") || [];
      const options = [
        {
          label: `$(folder-opened) ${t("ui.labels.browseForFolder")}`,
          description: t("ui.labels.selectFolderFromWorkspace"),
          alwaysShow: true
        },
        {
          label: `$(edit) ${t("ui.labels.enterPathManually")}`,
          description: t("ui.labels.typeRelativePath"),
          alwaysShow: true
        }
      ];
      if (currentFolders.length > 0) {
        options.push({ label: "", kind: vscode39.QuickPickItemKind.Separator });
        options.push({
          label: `$(list-unordered) ${t("ui.labels.currentFolders")}`,
          description: currentFolders.join(", "),
          alwaysShow: true
        });
        for (const folder of currentFolders) {
          options.push({
            label: `$(trash) ${t("ui.labels.removeFolder", { folder })}`,
            description: folder,
            // Store folder path in description for easy extraction
            alwaysShow: true
          });
        }
      }
      const selection = await vscode39.window.showQuickPick(options, {
        placeHolder: t("ui.placeholders.configureSvgFolders"),
        title: t("ui.titles.svgFoldersConfiguration")
      });
      if (!selection) return;
      if (selection.label.startsWith("$(folder-opened)")) {
        const folderUri = await vscode39.window.showOpenDialog({
          canSelectFiles: false,
          canSelectFolders: true,
          canSelectMany: false,
          defaultUri: workspaceFolder.uri,
          openLabel: t("ui.labels.selectSvgFolder")
        });
        if (folderUri && folderUri[0]) {
          const relativePath = path34.relative(workspaceFolder.uri.fsPath, folderUri[0].fsPath);
          if (relativePath && !relativePath.startsWith("..")) {
            const newFolders = [.../* @__PURE__ */ new Set([...currentFolders, relativePath])];
            await config.update("svgFolders", newFolders, vscode39.ConfigurationTarget.Workspace);
            vscode39.window.showInformationMessage(
              t("messages.addedSvgFolder", { path: relativePath })
            );
            vscode39.commands.executeCommand("sageboxIconStudio.refreshIcons");
          } else {
            vscode39.window.showWarningMessage(t("messages.selectFolderInsideWorkspace"));
          }
        }
      } else if (selection.label.startsWith("$(edit)")) {
        const foldersStr = await vscode39.window.showInputBox({
          prompt: t("ui.prompts.enterSvgFoldersRelative"),
          value: currentFolders.join(", "),
          placeHolder: t("ui.placeholders.svgFoldersExampleLong")
        });
        if (foldersStr !== void 0) {
          const folders = foldersStr.split(",").map((s) => s.trim()).filter((s) => s.length > 0);
          await config.update("svgFolders", folders, vscode39.ConfigurationTarget.Workspace);
          vscode39.window.showInformationMessage(
            folders.length > 0 ? t("messages.svgFoldersUpdatedList", { folders: folders.join(", ") }) : t("messages.svgFoldersUpdatedNone")
          );
          vscode39.commands.executeCommand("sageboxIconStudio.refreshIcons");
        }
      } else if (selection.label.startsWith("$(trash)")) {
        const folderToRemove = selection.description || "";
        const newFolders = currentFolders.filter((f) => f !== folderToRemove);
        await config.update("svgFolders", newFolders, vscode39.ConfigurationTarget.Workspace);
        vscode39.window.showInformationMessage(
          t("messages.removedSvgFolder", { folder: folderToRemove })
        );
        vscode39.commands.executeCommand("sageboxIconStudio.refreshIcons");
      }
    })
  );
  return commands26;
}

// src/commands/iconCommands.ts
var vscode40 = __toESM(require("vscode"));
var path35 = __toESM(require("path"));
var fs30 = __toESM(require("fs"));
init_VariantsService();
init_i18n();
function registerIconCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2, svgFilesProvider: svgFilesProvider2 } = providers;
  const commands26 = [];
  commands26.push(
    vscode40.commands.registerCommand(
      "sageboxIconStudio.deleteIcons",
      async (item, selectedItems) => {
        const itemsToDelete = selectedItems && selectedItems.length > 0 ? selectedItems : [item];
        if (itemsToDelete.length === 0) {
          vscode40.window.showWarningMessage(t("messages.noIconsSelectedForDeletion"));
          return;
        }
        const names = itemsToDelete.map((i) => typeof i.label === "string" ? i.label : "").filter(Boolean);
        const confirm = await vscode40.window.showWarningMessage(
          t("messages.confirmDeleteIcons", { count: names.length, names: names.join(", ") }),
          { modal: true },
          t("messages.deleteButton")
        );
        if (confirm !== t("messages.deleteButton")) return;
        const fullOutputPath = getFullOutputPath();
        let deletedCount = 0;
        const builtIconsToDelete = [];
        const svgFilesToRemove = [];
        for (const item2 of itemsToDelete) {
          if ((item2.contextValue === "svgIcon" || item2.contextValue === "svgIconBuilt" || item2.contextValue === "svgIconRasterized" || item2.contextValue === "svgIconRasterizedBuilt") && item2.resourceUri) {
            try {
              await vscode40.workspace.fs.delete(item2.resourceUri);
              deletedCount++;
              if (typeof item2.label === "string") {
                svgFilesToRemove.push({
                  name: item2.label,
                  path: item2.resourceUri.fsPath
                });
              }
            } catch (error) {
              vscode40.window.showErrorMessage(
                t("messages.failedToDelete", { name: item2.label, error: String(error) })
              );
            }
          } else if (item2.contextValue === "builtIcon" || item2.contextValue === "builtIconRasterized") {
            if (typeof item2.label === "string") {
              builtIconsToDelete.push(item2.label);
            }
          }
        }
        if (builtIconsToDelete.length > 0 && fullOutputPath) {
          const removed = removeFromIconsJs(fullOutputPath, builtIconsToDelete);
          if (removed) {
            deletedCount += builtIconsToDelete.length;
          }
        }
        for (const { path: filePath } of svgFilesToRemove) {
          svgFilesProvider2.removeItem(filePath);
        }
        if (builtIconsToDelete.length > 0) {
          builtIconsProvider2.refresh();
        }
        if (deletedCount > 0) {
          vscode40.window.showInformationMessage(t("messages.deletedCount", { count: deletedCount }));
        }
      }
    )
  );
  commands26.push(
    vscode40.commands.registerCommand(
      "sageboxIconStudio.removeFromBuilt",
      async (item, selectedItems) => {
        const items = selectedItems && selectedItems.length > 0 ? selectedItems : item ? [item] : [];
        if (items.length === 0 || !items[0]?.icon) {
          vscode40.window.showWarningMessage(t("messages.selectIconsToRemoveFromBuilt"));
          return;
        }
        const iconNames = items.filter((i) => i?.icon).map((i) => typeof i.label === "string" ? i.label : i.icon?.name).filter((name) => !!name);
        if (iconNames.length === 0) {
          vscode40.window.showWarningMessage(t("messages.couldNotDetermineIconNames"));
          return;
        }
        const fullOutputPath = getFullOutputPath();
        if (!fullOutputPath) {
          vscode40.window.showWarningMessage(t("messages.outputDirectoryNotConfigured"));
          return;
        }
        const message = iconNames.length === 1 ? t("messages.removeIconFromBuilt", { name: iconNames[0] }) : t("messages.removeIconsFromBuilt", { count: iconNames.length });
        const confirm = await vscode40.window.showWarningMessage(
          message,
          { modal: true },
          t("messages.removeButton")
        );
        if (confirm !== t("messages.removeButton")) {
          return;
        }
        const removed = removeFromIconsJs(fullOutputPath, iconNames);
        if (removed) {
          const variantsService = new VariantsService();
          for (const name of iconNames) {
            variantsService.removeIconData(name);
          }
          variantsService.persistToFile();
          updateIconsJsContext();
          builtIconsProvider2.refresh();
          workspaceSvgProvider2.refresh();
          svgFilesProvider2.refresh();
          const infoMsg = iconNames.length === 1 ? t("messages.removedIconFromBuilt", { name: iconNames[0] }) : t("messages.removedIconsFromBuilt", { count: iconNames.length });
          vscode40.window.showInformationMessage(infoMsg);
        } else {
          vscode40.window.showErrorMessage(t("messages.failedToRemoveFromBuilt"));
        }
      }
    )
  );
  commands26.push(
    vscode40.commands.registerCommand(
      "sageboxIconStudio.renameIcon",
      async (item, providedNewName) => {
        if (!item?.icon) {
          vscode40.window.showWarningMessage(t("messages.selectIconToRename"));
          return;
        }
        const icon = item.icon;
        const oldName = icon.name;
        const isBuiltIcon = item.contextValue === "builtIcon";
        const isSvgFile = item.contextValue === "svgIcon";
        let newName = providedNewName;
        if (!newName) {
          newName = await vscode40.window.showInputBox({
            prompt: t("ui.prompts.enterNewIconName"),
            value: oldName,
            placeHolder: t("ui.placeholders.iconName"),
            validateInput: (value) => {
              if (!value || value.trim() === "") {
                return t("editor.nameCannotBeEmpty");
              }
              if (value === oldName) {
                return t("editor.enterDifferentName");
              }
              if (!/^[a-zA-Z0-9_-]+$/.test(value)) {
                return t("editor.nameValidation");
              }
              return void 0;
            }
          });
        }
        if (!newName) return;
        try {
          let newPath;
          if (isSvgFile && icon.path) {
            const oldPath = icon.path;
            const dir = path35.dirname(oldPath);
            newPath = path35.join(dir, `${newName}.svg`);
            if (fs30.existsSync(newPath)) {
              vscode40.window.showErrorMessage(
                t("messages.fileAlreadyExists", { name: `${newName}.svg` })
              );
              return;
            }
            fs30.renameSync(oldPath, newPath);
            const oldFileName = `${oldName}.svg`;
            const newFileName = `${newName}.svg`;
            let referencesUpdated = 0;
            const workspaceFolder = vscode40.workspace.workspaceFolders?.[0];
            if (workspaceFolder) {
              const filesToSearch = await vscode40.workspace.findFiles(
                "**/*.{html,htm,jsx,tsx,js,ts,vue,svelte,css,scss,md}",
                "**/node_modules/**"
              );
              for (const fileUri of filesToSearch) {
                try {
                  const content = fs30.readFileSync(fileUri.fsPath, "utf-8");
                  const escapedOldFileName = oldFileName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
                  const srcPattern = new RegExp(
                    `(src\\s*=\\s*["'])([^"']*?)${escapedOldFileName}(["'])`,
                    "g"
                  );
                  const urlPattern = new RegExp(
                    `(url\\s*\\(\\s*["']?)([^)"']*?)${escapedOldFileName}(["']?\\s*\\))`,
                    "g"
                  );
                  const importFromPattern = new RegExp(
                    `(from\\s+["'])([^"']*?)${escapedOldFileName}(["'])`,
                    "g"
                  );
                  const importDirectPattern = new RegExp(
                    `(import\\s+["'])([^"']*?)${escapedOldFileName}(["'])`,
                    "g"
                  );
                  const requirePattern = new RegExp(
                    `(require\\s*\\(\\s*["'])([^"']*?)${escapedOldFileName}(["']\\s*\\))`,
                    "g"
                  );
                  const hrefPattern = new RegExp(
                    `(href\\s*=\\s*["'])([^"']*?)${escapedOldFileName}(["'])`,
                    "g"
                  );
                  let newContent = content;
                  let fileModified = false;
                  const patterns = [
                    srcPattern,
                    urlPattern,
                    importFromPattern,
                    importDirectPattern,
                    requirePattern,
                    hrefPattern
                  ];
                  for (const pattern of patterns) {
                    const matches = newContent.match(pattern);
                    if (matches && matches.length > 0) {
                      newContent = newContent.replace(pattern, `$1$2${newFileName}$3`);
                      fileModified = true;
                    }
                  }
                  if (fileModified) {
                    fs30.writeFileSync(fileUri.fsPath, newContent);
                    referencesUpdated++;
                  }
                } catch (err) {
                }
              }
            }
            if (referencesUpdated > 0) {
              vscode40.window.showInformationMessage(
                t("messages.renamedWithReferences", {
                  oldName: `${oldName}.svg`,
                  newName: `${newName}.svg`,
                  count: referencesUpdated
                })
              );
            } else {
              vscode40.window.showInformationMessage(
                t("messages.renamedTo", { name: `${newName}.svg` })
              );
            }
          } else if (isBuiltIcon) {
            const fullOutputPath = getFullOutputPath();
            if (!fullOutputPath) return;
            const iconsBzJsPath = path35.join(fullOutputPath, "icons.js");
            const iconsJsPath = path35.join(fullOutputPath, "icons.js");
            const iconsDtsPath = path35.join(fullOutputPath, "icons.d.ts");
            const spritePath = path35.join(fullOutputPath, "sprite.svg");
            const escapedOldName = oldName.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
            let foundInAnyFile = false;
            let filesUpdated = 0;
            if (fs30.existsSync(iconsBzJsPath)) {
              let content = fs30.readFileSync(iconsBzJsPath, "utf-8");
              const testPattern = new RegExp(`name:\\s*['"]${escapedOldName}['"]`);
              if (testPattern.test(content)) {
                foundInAnyFile = true;
                content = content.replace(
                  new RegExp(`(name:\\s*['"])${escapedOldName}(['"])`, "g"),
                  `$1${newName}$2`
                );
                fs30.writeFileSync(iconsBzJsPath, content);
                filesUpdated++;
              }
            }
            if (fs30.existsSync(iconsJsPath)) {
              let content = fs30.readFileSync(iconsJsPath, "utf-8");
              const testPattern = new RegExp(`(['"])${escapedOldName}\\1`);
              if (testPattern.test(content)) {
                foundInAnyFile = true;
                content = content.replace(
                  new RegExp(`(['"])${escapedOldName}\\1`, "g"),
                  `$1${newName}$1`
                );
                fs30.writeFileSync(iconsJsPath, content);
                filesUpdated++;
              }
            }
            if (fs30.existsSync(iconsDtsPath)) {
              let content = fs30.readFileSync(iconsDtsPath, "utf-8");
              const testPattern = new RegExp(`(['"])${escapedOldName}\\1`);
              if (testPattern.test(content)) {
                foundInAnyFile = true;
                content = content.replace(
                  new RegExp(`(['"])${escapedOldName}\\1`, "g"),
                  `$1${newName}$1`
                );
                fs30.writeFileSync(iconsDtsPath, content);
                filesUpdated++;
              }
            }
            if (fs30.existsSync(spritePath)) {
              let content = fs30.readFileSync(spritePath, "utf-8");
              const testPattern = new RegExp(`<symbol[^>]*id=["']${escapedOldName}["']`);
              if (testPattern.test(content)) {
                foundInAnyFile = true;
                content = content.replace(
                  new RegExp(`(<symbol[^>]*id=["'])${escapedOldName}(["'])`, "g"),
                  `$1${newName}$2`
                );
                fs30.writeFileSync(spritePath, content);
                filesUpdated++;
              }
            }
            if (!foundInAnyFile) {
              vscode40.window.showErrorMessage(
                t("messages.iconNotFoundInBuildFiles", { name: oldName })
              );
              return;
            }
            workspaceSvgProvider2.renameBuiltIcon(oldName, newName);
            builtIconsProvider2.refresh();
            vscode40.window.showInformationMessage(
              t("messages.renamedFilesUpdated", { oldName, newName, count: filesUpdated })
            );
          }
          if (isSvgFile && newPath) {
            workspaceSvgProvider2.renameSvgFile(oldName, newName, newPath);
            svgFilesProvider2.refresh();
          } else if (!isBuiltIcon) {
            workspaceSvgProvider2.refresh();
          }
          return { newName, newPath };
        } catch (error) {
          vscode40.window.showErrorMessage(t("messages.errorRenamingIcon", { error: String(error) }));
          return void 0;
        }
      }
    )
  );
  return commands26;
}

// src/commands/transformCommands.ts
var vscode41 = __toESM(require("vscode"));
init_i18n();
function registerTransformCommands(context, providers, svgTransformer) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2 } = providers;
  const commands26 = [];
  commands26.push(
    vscode41.commands.registerCommand("sageboxIconStudio.transformInlineSvg", async (item) => {
      if (item.icon && item.icon.filePath && item.icon.svg) {
        const document = await vscode41.workspace.openTextDocument(
          vscode41.Uri.file(item.icon.filePath)
        );
        const editor = await vscode41.window.showTextDocument(document);
        const text = document.getText();
        let svgStart = -1;
        let svgContent = item.icon.svg;
        const isImgReference = item.icon.category === "img-ref";
        let imgTagMatch = null;
        let imgTagText = "";
        if (isImgReference) {
          const iconName2 = item.icon.name;
          const escapedIconName = iconName2.replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
          const imgRegex = new RegExp(
            `<img\\s+[^>]*src=["'][^"']*${escapedIconName}\\.svg["'][^>]*>`,
            "gi"
          );
          if (item.icon.line !== void 0) {
            const searchRadius = 5;
            const startLine = Math.max(0, item.icon.line - searchRadius);
            const endLine = Math.min(document.lineCount - 1, item.icon.line + searchRadius);
            for (let i = startLine; i <= endLine; i++) {
              const line = document.lineAt(i);
              imgTagMatch = imgRegex.exec(line.text);
              if (imgTagMatch) {
                svgStart = document.offsetAt(line.range.start) + imgTagMatch.index;
                imgTagText = imgTagMatch[0];
                break;
              }
              imgRegex.lastIndex = 0;
            }
          }
          if (svgStart === -1) {
            imgRegex.lastIndex = 0;
            imgTagMatch = imgRegex.exec(text);
            if (imgTagMatch) {
              svgStart = imgTagMatch.index;
              imgTagText = imgTagMatch[0];
            }
          }
          if (svgStart === -1) {
            vscode41.window.showWarningMessage(
              t("messages.couldNotFindImgRef") + " " + t("messages.refreshIcons")
            );
            return;
          }
        } else {
          svgStart = text.indexOf(item.icon.svg);
          if (svgStart === -1 && item.icon.line !== void 0) {
            try {
              const searchRadius = 5;
              const startLine = Math.max(0, item.icon.line - searchRadius);
              const endLine = Math.min(document.lineCount - 1, item.icon.line + searchRadius);
              for (let i = startLine; i <= endLine; i++) {
                const line = document.lineAt(i);
                if (line.text.includes("<svg")) {
                  const textFromLine = text.substring(document.offsetAt(line.range.start));
                  const match = /<svg\s[^>]*>[\s\S]*?<\/svg>/i.exec(textFromLine);
                  if (match) {
                    svgStart = document.offsetAt(line.range.start) + match.index;
                    svgContent = match[0];
                    break;
                  }
                }
              }
            } catch (searchError) {
              console.error("Error searching for SVG fallback:", searchError);
            }
          }
          if (svgStart === -1) {
            vscode41.window.showWarningMessage(
              t("messages.couldNotFindSvgInDoc") + " " + t("messages.refreshIcons")
            );
            return;
          }
        }
        let range;
        if (isImgReference) {
          const startPos = document.positionAt(svgStart);
          const endPos = document.positionAt(svgStart + imgTagText.length);
          range = new vscode41.Range(startPos, endPos);
        } else {
          const startPos = document.positionAt(svgStart);
          const endPos = document.positionAt(svgStart + svgContent.length);
          range = new vscode41.Range(startPos, endPos);
        }
        const config = getConfig();
        const buildFormat = config.buildFormat || "icons.ts";
        const isSprite = buildFormat === "sprite.svg";
        const outputDir = config.outputDirectory;
        const webComponentName = config.webComponentName || "sg-icon";
        const iconName = item.label;
        let replacement;
        const fullOutputPath = getFullOutputPath();
        if (isSprite) {
          replacement = `<svg class="icon" aria-hidden="true"><use href="${outputDir}/sprite.svg#${iconName}"></use></svg>`;
          if (fullOutputPath) {
            await addToSpriteSvg(fullOutputPath, iconName, item.icon.svg, svgTransformer);
          }
        } else {
          replacement = `<${webComponentName} name="${iconName}"></${webComponentName}>`;
          if (fullOutputPath) {
            await addToIconsJs({
              outputPath: fullOutputPath,
              iconName,
              svgContent: item.icon.svg,
              transformer: svgTransformer
            });
          }
        }
        await editor.edit((editBuilder) => {
          editBuilder.replace(range, replacement);
        });
        workspaceSvgProvider2.refresh();
        builtIconsProvider2.refresh();
        const formatName = isSprite ? "Sprite" : "Web Component";
        vscode41.window.showInformationMessage(
          t("messages.transformedToFormat", { format: formatName })
        );
      }
    })
  );
  commands26.push(
    vscode41.commands.registerCommand("sageboxIconStudio.transformSvg", async () => {
      const editor = vscode41.window.activeTextEditor;
      if (!editor) return;
      const selection = editor.selection;
      const svgContent = editor.document.getText(selection);
      if (!svgContent.includes("<svg")) {
        vscode41.window.showWarningMessage(t("messages.pleaseSelectSvg"));
        return;
      }
      const format = await vscode41.window.showQuickPick(
        ["react", "vue", "svelte", "astro", "html"],
        { placeHolder: t("ui.placeholders.selectOutputFormat") }
      );
      if (!format) return;
      const componentName = await vscode41.window.showInputBox({
        prompt: t("ui.prompts.enterComponentName"),
        placeHolder: t("ui.placeholders.componentNameExample")
      });
      if (!componentName) return;
      const config = vscode41.workspace.getConfiguration("sageboxIconStudio");
      const nameAttr = config.get("nameAttribute", "name");
      const result = await svgTransformer.transformToComponent(svgContent, componentName, {
        componentName: config.get("componentName", "Icon"),
        nameAttribute: nameAttr,
        format
      });
      await editor.edit((editBuilder) => {
        editBuilder.replace(selection, result.component);
      });
      vscode41.window.showInformationMessage(t("messages.svgTransformedToComponent", { format }));
    })
  );
  commands26.push(
    vscode41.commands.registerCommand("sageboxIconStudio.optimizeSvg", async () => {
      const editor = vscode41.window.activeTextEditor;
      if (!editor) return;
      const selection = editor.selection;
      const svgContent = editor.document.getText(selection);
      if (!svgContent.includes("<svg")) {
        vscode41.window.showWarningMessage(t("messages.pleaseSelectSvg"));
        return;
      }
      const optimized = svgTransformer.cleanSvg(svgContent);
      await editor.edit((editBuilder) => {
        editBuilder.replace(selection, optimized);
      });
      vscode41.window.showInformationMessage(t("messages.svgOptimized"));
    })
  );
  commands26.push(
    vscode41.commands.registerCommand("sageboxIconStudio.insertIcon", async (item) => {
      const editor = vscode41.window.activeTextEditor;
      if (!editor) return;
      let iconName;
      if (item && typeof item.label === "string") {
        iconName = item.label;
      } else {
        const icons = await workspaceSvgProvider2.getAllIcons();
        const names = icons.map((i) => i.name);
        const selected = await vscode41.window.showQuickPick(names, {
          placeHolder: t("ui.placeholders.selectIconToInsert")
        });
        if (!selected) return;
        iconName = selected;
      }
      const config = getConfig();
      const snippet = `<${config.componentName} ${config.nameAttribute}="${iconName}" />`;
      await editor.edit((editBuilder) => {
        editBuilder.insert(editor.selection.active, snippet);
      });
    })
  );
  return commands26;
}

// src/commands/editorCommands.ts
var vscode48 = __toESM(require("vscode"));
var fs33 = __toESM(require("fs"));
var path38 = __toESM(require("path"));

// src/panels/IconEditorPanel.ts
var vscode47 = __toESM(require("vscode"));
var fs32 = __toESM(require("node:fs"));
var path37 = __toESM(require("node:path"));
init_SvgOptimizer();

// src/services/SvgManipulationService.ts
var import_xmldom = __toESM(require_lib8());

// src/services/AnimationService.ts
var ANIMATION_KEYFRAMES2 = {
  spin: "@keyframes spin { from { rotate: 0deg; } to { rotate: 360deg; } }",
  "spin-reverse": "@keyframes spin-reverse { from { rotate: 360deg; } to { rotate: 0deg; } }",
  pulse: "@keyframes pulse { 0%, 100% { scale: 1; opacity: 1; } 50% { scale: 1.1; opacity: 0.8; } }",
  "pulse-grow": "@keyframes pulse-grow { 0%, 100% { scale: 1; } 50% { scale: 1.3; } }",
  bounce: "@keyframes bounce { 0%, 100% { translate: 0 0; } 50% { translate: 0 -4px; } }",
  "bounce-horizontal": "@keyframes bounce-horizontal { 0%, 100% { translate: 0 0; } 50% { translate: 4px 0; } }",
  shake: "@keyframes shake { 0%, 100% { translate: 0 0; } 25% { translate: -2px 0; } 75% { translate: 2px 0; } }",
  "shake-vertical": "@keyframes shake-vertical { 0%, 100% { translate: 0 0; } 25% { translate: 0 -2px; } 75% { translate: 0 2px; } }",
  fade: "@keyframes fade { 0%, 100% { opacity: 1; } 50% { opacity: 0.3; } }",
  "fade-in": "@keyframes fade-in { from { opacity: 0; } to { opacity: 1; } }",
  "fade-out": "@keyframes fade-out { from { opacity: 1; } to { opacity: 0; } }",
  float: "@keyframes float { 0%, 100% { translate: 0 0; } 50% { translate: 0 -6px; } }",
  swing: "@keyframes swing { 0%, 100% { rotate: 0deg; } 20% { rotate: 15deg; } 40% { rotate: -10deg; } 60% { rotate: 5deg; } 80% { rotate: -5deg; } }",
  flip: "@keyframes flip { 0% { transform: perspective(400px) rotateY(0); } 100% { transform: perspective(400px) rotateY(360deg); } }",
  "flip-x": "@keyframes flip-x { 0% { transform: perspective(400px) rotateX(0); } 100% { transform: perspective(400px) rotateX(360deg); } }",
  heartbeat: "@keyframes heartbeat { 0%, 100% { scale: 1; } 14% { scale: 1.3; } 28% { scale: 1; } 42% { scale: 1.3; } 70% { scale: 1; } }",
  wiggle: "@keyframes wiggle { 0%, 100% { rotate: 0deg; } 25% { rotate: -10deg; } 75% { rotate: 10deg; } }",
  wobble: "@keyframes wobble { 0% { transform: translateX(0%); } 15% { transform: translateX(-25%) rotate(-5deg); } 30% { transform: translateX(20%) rotate(3deg); } 45% { transform: translateX(-15%) rotate(-3deg); } 60% { transform: translateX(10%) rotate(2deg); } 75% { transform: translateX(-5%) rotate(-1deg); } 100% { transform: translateX(0%); } }",
  "rubber-band": "@keyframes rubber-band { 0% { scale: 1 1; } 30% { scale: 1.25 0.75; } 40% { scale: 0.75 1.25; } 50% { scale: 1.15 0.85; } 65% { scale: 0.95 1.05; } 75% { scale: 1.05 0.95; } 100% { scale: 1 1; } }",
  jello: "@keyframes jello { 0%, 100% { transform: skewX(0deg) skewY(0deg); } 22% { transform: skewX(-12.5deg) skewY(-12.5deg); } 33% { transform: skewX(6.25deg) skewY(6.25deg); } 44% { transform: skewX(-3.125deg) skewY(-3.125deg); } 55% { transform: skewX(1.5625deg) skewY(1.5625deg); } 66% { transform: skewX(-0.78125deg) skewY(-0.78125deg); } 77% { transform: skewX(0.390625deg) skewY(0.390625deg); } 88% { transform: skewX(-0.1953125deg) skewY(-0.1953125deg); } }",
  tada: "@keyframes tada { 0% { scale: 1; rotate: 0deg; } 10%, 20% { scale: 0.9; rotate: -3deg; } 30%, 50%, 70%, 90% { scale: 1.1; rotate: 3deg; } 40%, 60%, 80% { scale: 1.1; rotate: -3deg; } 100% { scale: 1; rotate: 0deg; } }",
  blink: "@keyframes blink { 0%, 100% { opacity: 1; } 50% { opacity: 0; } }",
  glow: "@keyframes glow { 0%, 100% { filter: drop-shadow(0 0 2px currentColor); } 50% { filter: drop-shadow(0 0 8px currentColor); } }",
  "zoom-in": "@keyframes zoom-in { from { scale: 0; opacity: 0; } to { scale: 1; opacity: 1; } }",
  "zoom-out": "@keyframes zoom-out { from { scale: 1; opacity: 1; } to { scale: 0; opacity: 0; } }",
  "slide-in-up": "@keyframes slide-in-up { from { translate: 0 100%; opacity: 0; } to { translate: 0 0; opacity: 1; } }",
  "slide-in-down": "@keyframes slide-in-down { from { translate: 0 -100%; opacity: 0; } to { translate: 0 0; opacity: 1; } }",
  "slide-in-left": "@keyframes slide-in-left { from { translate: -100% 0; opacity: 0; } to { translate: 0 0; opacity: 1; } }",
  "slide-in-right": "@keyframes slide-in-right { from { translate: 100% 0; opacity: 0; } to { translate: 0 0; opacity: 1; } }",
  draw: "@keyframes draw { to { stroke-dashoffset: 0; } }",
  "draw-reverse": "@keyframes draw-reverse { to { stroke-dashoffset: var(--path-length); } }",
  "draw-loop": "@keyframes draw-loop { 0% { stroke-dashoffset: var(--path-length); } 50% { stroke-dashoffset: 0; } 100% { stroke-dashoffset: calc(var(--path-length) * -1); } }"
};
var AnimationService = class {
  /**
   * Get keyframe CSS for an animation
   */
  static getKeyframe(animationName) {
    return ANIMATION_KEYFRAMES2[animationName];
  }
  /**
   * Get all available animation names
   */
  static getAnimationNames() {
    return Object.keys(ANIMATION_KEYFRAMES2);
  }
};

// src/services/SvgManipulationService.ts
var SvgManipulationService = class {
  static ensureSvgNamespace(svg) {
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (hasError || parserError.length > 0) {
        return this.ensureSvgNamespaceRegex(svg);
      }
      const svgElement = doc.documentElement;
      if (!svgElement || svgElement.tagName !== "svg") {
        return this.ensureSvgNamespaceRegex(svg);
      }
      if (!svgElement.hasAttribute("xmlns")) {
        svgElement.setAttribute("xmlns", "http://www.w3.org/2000/svg");
        return new import_xmldom.XMLSerializer().serializeToString(doc);
      }
      return svg;
    } catch (_e) {
      return this.ensureSvgNamespaceRegex(svg);
    }
  }
  static ensureSvgNamespaceRegex(svg) {
    const nsPattern = /xmlns\s*=\s*["']http:\/\/www\.w3\.org\/2000\/svg["']/gi;
    const matches = svg.match(nsPattern);
    if (matches && matches.length > 1) {
      svg = svg.replace(nsPattern, "");
      return svg.replace(/<svg/i, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    if (!matches || matches.length === 0) {
      return svg.replace(/<svg/i, '<svg xmlns="http://www.w3.org/2000/svg"');
    }
    return svg;
  }
  static cleanAnimationFromSvg(svg) {
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (hasError || parserError.length > 0) return this.cleanAnimationFromSvgRegex(svg);
      let modified = false;
      const idsToRemove = ["icon-manager-animation", "icon-manager-script"];
      for (const id of idsToRemove) {
        const allStyles = doc.getElementsByTagName("style");
        const allScripts = doc.getElementsByTagName("script");
        for (let i = allStyles.length - 1; i >= 0; i--) {
          const el = allStyles[i];
          if (el.getAttribute("id") === id && el.parentNode) {
            el.parentNode.removeChild(el);
            modified = true;
          }
        }
        for (let i = allScripts.length - 1; i >= 0; i--) {
          const el = allScripts[i];
          if (el.getAttribute("id") === id && el.parentNode) {
            el.parentNode.removeChild(el);
            modified = true;
          }
        }
      }
      const svgElement = doc.documentElement;
      const groups = svgElement.getElementsByTagName("g");
      for (let i = groups.length - 1; i >= 0; i--) {
        const g = groups[i];
        const className = g.getAttribute("class") || "";
        if (className.startsWith("icon-anim-")) {
          const parent = g.parentNode;
          if (parent) {
            while (g.firstChild) {
              parent.insertBefore(g.firstChild, g);
            }
            parent.removeChild(g);
            modified = true;
          }
        }
      }
      const styles = doc.getElementsByTagName("style");
      for (let i = styles.length - 1; i >= 0; i--) {
        const style = styles[i];
        const content = style.textContent || "";
        if (content.includes(".icon-anim-") || content.includes("@keyframes") && content.includes("animation:")) {
          if (style.parentNode) {
            style.parentNode.removeChild(style);
            modified = true;
          }
        }
      }
      const scripts = doc.getElementsByTagName("script");
      for (let i = scripts.length - 1; i >= 0; i--) {
        const script = scripts[i];
        if (script.textContent && script.textContent.includes("document.currentScript.parentElement")) {
          if (script.parentNode) {
            script.parentNode.removeChild(script);
            modified = true;
          }
        }
      }
      if (modified) {
        return new import_xmldom.XMLSerializer().serializeToString(doc);
      }
      return svg;
    } catch (_e) {
      return this.cleanAnimationFromSvgRegex(svg);
    }
  }
  static cleanAnimationFromSvgRegex(svg) {
    svg = svg.replace(/<style id="icon-manager-animation">[\s\S]*?<\/style>/gi, "");
    svg = svg.replace(/<script id="icon-manager-script">[\s\S]*?<\/script>/gi, "");
    svg = svg.replace(/<g class="icon-anim-\d+">([\s\S]*?)<\/g>/gi, "$1");
    svg = svg.replace(
      /<style>@keyframes[\s\S]*?svg\s*\{\s*animation:[\s\S]*?\}[\s\S]*?<\/style>/gi,
      ""
    );
    svg = svg.replace(
      /<style>@keyframes[\s\S]*?\.icon-anim-\d+\s*\{[\s\S]*?\}[\s\S]*?<\/style>/gi,
      ""
    );
    svg = svg.replace(/<style[^>]*>[\s\S]*?\.icon-anim-\d+[\s\S]*?<\/style>/gi, "");
    svg = svg.replace(
      /<script>\s*\(function\(\)\s*\{\s*var svg = document\.currentScript\.parentElement;[\s\S]*?\}\)\(\);\s*<\/script>/gi,
      ""
    );
    return svg;
  }
  static embedAnimationInSvg(svg, animation, settings) {
    svg = this.cleanAnimationFromSvg(svg);
    svg = this.ensureSvgNamespace(svg);
    if (animation === "draw") {
      return this.embedDrawAnimation(svg, settings);
    }
    if (animation === "draw-reverse") {
      return this.embedDrawAnimation(svg, settings, true);
    }
    if (animation === "draw-loop") {
      return this.embedDrawLoopAnimation(svg, settings);
    }
    const keyframe = AnimationService.getKeyframe(animation);
    if (!keyframe) return svg;
    const duration = settings.duration || 1;
    const timing = settings.timing || "ease";
    const iteration = settings.iteration || "infinite";
    const direction = settings.direction || "normal";
    const delay = settings.delay || 0;
    const delayStr = delay > 0 ? ` ${delay}s` : "";
    const animClass = `icon-anim-${Date.now()}`;
    const cssContent = `${keyframe} .${animClass} { animation: ${animation} ${duration}s ${timing}${delayStr} ${iteration} ${direction}; transform-origin: center center; }`;
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (hasError || parserError.length > 0) throw new Error("XML Parse Error");
      const svgElement = doc.documentElement;
      const wrapper = doc.createElement("g");
      wrapper.setAttribute("class", animClass);
      while (svgElement.firstChild) {
        wrapper.appendChild(svgElement.firstChild);
      }
      const style = doc.createElement("style");
      style.setAttribute("id", "icon-manager-animation");
      style.textContent = cssContent;
      svgElement.appendChild(style);
      svgElement.appendChild(wrapper);
      return new import_xmldom.XMLSerializer().serializeToString(doc);
    } catch (_e) {
      const cssStyle = `<style id="icon-manager-animation">${cssContent}</style>`;
      const svgTagMatch = svg.match(/<svg[^>]*>/i);
      const svgCloseMatch = svg.match(/<\/svg>/i);
      if (svgTagMatch && svgCloseMatch) {
        const afterOpenTag = svgTagMatch.index + svgTagMatch[0].length;
        const beforeCloseTag = svgCloseMatch.index;
        const innerContent = svg.slice(afterOpenTag, beforeCloseTag);
        return svg.slice(0, afterOpenTag) + cssStyle + `<g class="${animClass}">` + innerContent + "</g>" + svg.slice(beforeCloseTag);
      }
      return svg;
    }
  }
  // Special animation: Draw paths as if being drawn
  static embedDrawAnimation(svg, settings, reverse = false) {
    const duration = settings.duration || 2;
    const timing = settings.timing || "ease-in-out";
    const delay = settings.delay || 0;
    const animName = reverse ? "undraw" : "draw";
    const drawKeyframes = reverse ? `@keyframes undraw { from { stroke-dashoffset: 0; } to { stroke-dashoffset: var(--path-length); } }` : `@keyframes draw { from { stroke-dashoffset: var(--path-length); } to { stroke-dashoffset: 0; } }`;
    const fillKeyframes = reverse ? `@keyframes fill-out { 0%, 80% { fill-opacity: 1; } 100% { fill-opacity: 0; } }` : `@keyframes fill-in { 0%, 80% { fill-opacity: 0; } 100% { fill-opacity: 1; } }`;
    const fillAnimName = reverse ? "fill-out" : "fill-in";
    const delayStr = delay > 0 ? ` ${delay}s` : "";
    const cssContent = `
      ${drawKeyframes}
      ${fillKeyframes}
      svg path, svg line, svg polyline, svg polygon, svg circle, svg ellipse, svg rect {
        stroke-dasharray: var(--path-length, 100);
        stroke-dashoffset: ${reverse ? "0" : "var(--path-length, 100)"};
        animation: ${animName} ${duration}s ${timing}${delayStr} forwards;
        fill-opacity: ${reverse ? "1" : "0"};
      }
      svg path[fill], svg circle[fill], svg ellipse[fill], svg rect[fill], svg polygon[fill] {
        animation: ${animName} ${duration}s ${timing}${delayStr} forwards, ${fillAnimName} ${duration * 1.2}s ${timing}${delayStr} forwards;
      }
    `;
    const scriptContent = `
      (function() {
        var svg = document.currentScript.parentElement;
        var elements = svg.querySelectorAll('path, line, polyline, polygon, circle, ellipse, rect');
        elements.forEach(function(el) {
          try {
            var len = el.getTotalLength ? el.getTotalLength() : 100;
            el.style.setProperty('--path-length', len);
          } catch(e) { el.style.setProperty('--path-length', '100'); }
        });
      })();
    `;
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (hasError || parserError.length > 0) throw new Error("XML Parse Error");
      const style = doc.createElement("style");
      style.setAttribute("id", "icon-manager-animation");
      style.textContent = cssContent;
      const script = doc.createElement("script");
      script.setAttribute("id", "icon-manager-script");
      script.textContent = scriptContent;
      const svgElement = doc.documentElement;
      if (svgElement.firstChild) {
        svgElement.insertBefore(script, svgElement.firstChild);
        svgElement.insertBefore(style, svgElement.firstChild);
      } else {
        svgElement.appendChild(style);
        svgElement.appendChild(script);
      }
      return new import_xmldom.XMLSerializer().serializeToString(doc);
    } catch (_e) {
      const cssStyle = `<style id="icon-manager-animation">${cssContent}</style>
    <script id="icon-manager-script">${scriptContent}</script>`;
      const svgTagMatch = svg.match(/<svg[^>]*>/i);
      if (svgTagMatch) {
        const insertPos = svgTagMatch.index + svgTagMatch[0].length;
        return svg.slice(0, insertPos) + cssStyle + svg.slice(insertPos);
      }
      return svg;
    }
  }
  // Special animation: Draw loop (draw then undraw)
  static embedDrawLoopAnimation(svg, settings) {
    const duration = settings.duration || 2;
    const timing = settings.timing || "ease-in-out";
    const iteration = settings.iteration || "infinite";
    const delay = settings.delay || 0;
    const drawKeyframes = `@keyframes draw-loop {
      0% { stroke-dashoffset: var(--path-length, 100); fill-opacity: 0; }
      45% { stroke-dashoffset: 0; fill-opacity: 1; }
      55% { stroke-dashoffset: 0; fill-opacity: 1; }
      100% { stroke-dashoffset: var(--path-length, 100); fill-opacity: 0; }
    }`;
    const delayStr = delay > 0 ? ` ${delay}s` : "";
    const cssContent = `
      ${drawKeyframes}
      svg path, svg line, svg polyline, svg polygon, svg circle, svg ellipse, svg rect {
        stroke-dasharray: var(--path-length, 100);
        stroke-dashoffset: var(--path-length, 100);
        fill-opacity: 0;
        animation: draw-loop ${duration}s ${timing}${delayStr} ${iteration};
      }
    `;
    const scriptContent = `
      (function() {
        var svg = document.currentScript.parentElement;
        var elements = svg.querySelectorAll('path, line, polyline, polygon, circle, ellipse, rect');
        elements.forEach(function(el) {
          try {
            var len = el.getTotalLength ? el.getTotalLength() : 100;
            el.style.setProperty('--path-length', len);
          } catch(e) { el.style.setProperty('--path-length', '100'); }
        });
      })();
    `;
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (hasError || parserError.length > 0) throw new Error("XML Parse Error");
      const style = doc.createElement("style");
      style.setAttribute("id", "icon-manager-animation");
      style.textContent = cssContent;
      const script = doc.createElement("script");
      script.setAttribute("id", "icon-manager-script");
      script.textContent = scriptContent;
      const svgElement = doc.documentElement;
      if (svgElement.firstChild) {
        svgElement.insertBefore(script, svgElement.firstChild);
        svgElement.insertBefore(style, svgElement.firstChild);
      } else {
        svgElement.appendChild(style);
        svgElement.appendChild(script);
      }
      return new import_xmldom.XMLSerializer().serializeToString(doc);
    } catch (_e) {
      const cssStyle = `<style id="icon-manager-animation">${cssContent}</style>
    <script id="icon-manager-script">${scriptContent}</script>`;
      const svgTagMatch = svg.match(/<svg[^>]*>/i);
      if (svgTagMatch) {
        const insertPos = svgTagMatch.index + svgTagMatch[0].length;
        return svg.slice(0, insertPos) + cssStyle + svg.slice(insertPos);
      }
      return svg;
    }
  }
  static detectAnimationFromSvg(svg) {
    try {
      let hasError = false;
      const parser = new import_xmldom.DOMParser({
        errorHandler: {
          warning: () => {
          },
          error: () => {
            hasError = true;
          },
          fatalError: () => {
            hasError = true;
          }
        }
      });
      const doc = parser.parseFromString(svg, "image/svg+xml");
      const parserError = doc.getElementsByTagName("parsererror");
      if (!hasError && parserError.length === 0) {
        const styles = doc.getElementsByTagName("style");
        for (let i = 0; i < styles.length; i++) {
          const content = styles[i].textContent || "";
          const result = this.analyzeCssContent(content);
          if (result) return result;
        }
      }
    } catch (_e) {
    }
    return this.analyzeCssContent(svg);
  }
  static analyzeCssContent(content) {
    if (content.includes("@keyframes draw-loop")) {
      return {
        type: "draw-loop",
        settings: {
          duration: 2,
          timing: "ease-in-out",
          iteration: "infinite",
          delay: 0,
          direction: "normal"
        }
      };
    }
    if (content.includes("@keyframes draw-reverse") || content.includes("@keyframes undraw")) {
      return {
        type: "draw-reverse",
        settings: {
          duration: 2,
          timing: "ease-in-out",
          iteration: "1",
          delay: 0,
          direction: "normal"
        }
      };
    }
    if (content.includes("@keyframes draw")) {
      return {
        type: "draw",
        settings: {
          duration: 2,
          timing: "ease-in-out",
          iteration: "1",
          delay: 0,
          direction: "normal"
        }
      };
    }
    const nameMatch = content.match(/animation:\s*([\w-]+)/);
    if (!nameMatch) return null;
    const type = nameMatch[1];
    const fullMatch = content.match(
      /(?:svg|\.icon-anim-\d+)\s*\{\s*animation:\s*([\w-]+)\s+([\d.]+)s\s+([^\s]+)(?:\s+([\d.]+)s)?\s+([^\s]+)\s+([^\s;}]+)/
    );
    if (fullMatch && fullMatch[1] === type) {
      return {
        type,
        settings: {
          duration: parseFloat(fullMatch[2]),
          timing: fullMatch[3],
          delay: fullMatch[4] ? parseFloat(fullMatch[4]) : 0,
          iteration: fullMatch[5],
          direction: fullMatch[6]
        }
      };
    }
    const durationMatch = content.match(/animation:.*?([\d.]+)s/);
    return {
      type,
      settings: {
        duration: durationMatch ? parseFloat(durationMatch[1]) : 1,
        timing: "ease",
        delay: 0,
        iteration: "infinite",
        direction: "normal"
      }
    };
  }
  static applyCssFilter(svg, filter) {
    if (svg.match(/<svg[^>]*style=["'][^"']*["']/i)) {
      return svg.replace(/(<svg[^>]*style=["')([^"']*)(["'])/i, (match, p1, p2, p3) => {
        let style = p2;
        style = style.replace(/filter:[^;]+;?/gi, "");
        if (style && !style.endsWith(";")) style += ";";
        return `${p1}${style} filter: ${filter};${p3}`;
      });
    } else {
      return svg.replace(/<svg/i, `<svg style="filter: ${filter};"`);
    }
  }
};

// src/panels/IconEditorPanel.ts
init_ColorService();
init_VariantsService();

// src/services/IconPersistenceService.ts
var vscode42 = __toESM(require("vscode"));
var fs31 = __toESM(require("node:fs"));
var path36 = __toESM(require("node:path"));
init_config();
init_i18n();
var IconPersistenceService = class _IconPersistenceService {
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!_IconPersistenceService._instance) {
      _IconPersistenceService._instance = new _IconPersistenceService();
    }
    return _IconPersistenceService._instance;
  }
  /**
   * Get the output path for icon files
   */
  getOutputPath() {
    const workspaceFolders = vscode42.workspace.workspaceFolders;
    const outputDir = getSvgConfig("outputDirectory", "bezier-icons");
    if (!workspaceFolders || !outputDir) return void 0;
    return path36.join(workspaceFolders[0].uri.fsPath, outputDir);
  }
  /**
   * Get the path to icons.js file
   */
  getIconsFilePath() {
    const outputPath = this.getOutputPath();
    if (!outputPath) return void 0;
    return path36.join(outputPath, "icons.js");
  }
  /**
   * Update icon in sprite.svg file
   */
  async updateSpriteFile(iconName, svg, spriteFile, viewBox) {
    if (!iconName || !spriteFile) {
      return false;
    }
    if (!fs31.existsSync(spriteFile)) {
      return false;
    }
    try {
      let spriteContent = fs31.readFileSync(spriteFile, "utf-8");
      const transformer = new SvgTransformer();
      const newContent = transformer.extractSvgBody(svg);
      const viewBoxMatch = svg.match(/viewBox=["']([^"']+)["']/i);
      const newViewBox = viewBoxMatch ? viewBoxMatch[1] : viewBox || "0 0 24 24";
      const symbolPattern = new RegExp(
        `(<symbol[^>]*id=["']${iconName}["'][^>]*viewBox=["'])([^"']+)(["'][^>]*>)[\\s\\S]*?(<\\/symbol>)`,
        "i"
      );
      const symbolMatch = spriteContent.match(symbolPattern);
      if (symbolMatch) {
        const newSymbol = `${symbolMatch[1]}${newViewBox}${symbolMatch[3]}${newContent}${symbolMatch[4]}`;
        spriteContent = spriteContent.replace(symbolPattern, newSymbol);
        fs31.writeFileSync(spriteFile, spriteContent, "utf-8");
        await this.regenerateTypesFromSprite(spriteFile, spriteContent);
        return true;
      }
      return false;
    } catch (error) {
      console.error("Error updating sprite file:", error);
      return false;
    }
  }
  /**
   * Update icon in icons.js file
   */
  async updateBuiltIconsFile(iconName, svg) {
    if (!iconName) {
      return false;
    }
    const workspaceFolders = vscode42.workspace.workspaceFolders;
    if (!workspaceFolders) {
      return false;
    }
    const outputDir = getSvgConfig("outputDirectory", "bezier-icons");
    const possiblePaths = outputDir ? [`${outputDir}/icons.js`, "svg/icons.js", "icons.js"] : [
      "bezier-icons/icons.js",
      "svg/icons.js",
      "dist/icons.js",
      "build/icons.js",
      "public/icons.js",
      "src/icons.js",
      "icons.js"
    ];
    for (const folder of workspaceFolders) {
      for (const relativePath of possiblePaths) {
        const iconsUri = vscode42.Uri.joinPath(folder.uri, relativePath);
        try {
          const document = await vscode42.workspace.openTextDocument(iconsUri);
          const result = await ErrorHandler.wrapAsync(async () => {
            const text = document.getText();
            const varName = toVariableName2(iconName);
            const transformer = new SvgTransformer();
            const body = transformer.extractSvgBody(svg);
            const iconStartPattern = new RegExp(`export\\s+const\\s+${varName}\\s*=\\s*\\{`);
            const match = iconStartPattern.exec(text);
            if (match) {
              const startIdx = match.index;
              const afterStart = text.substring(startIdx);
              const bodyStartMatch = afterStart.match(/body:\s*`/);
              if (bodyStartMatch?.index !== void 0) {
                const bodyContentStart = startIdx + bodyStartMatch.index + bodyStartMatch[0].length;
                let bodyContentEnd = bodyContentStart;
                let i = bodyContentStart;
                while (i < text.length) {
                  if (text[i] === "\\" && text[i + 1] === "`") {
                    i += 2;
                  } else if (text[i] === "`") {
                    bodyContentEnd = i;
                    break;
                  } else {
                    i++;
                  }
                }
                if (bodyContentEnd > bodyContentStart) {
                  const escapedBody = body.replace(/`/g, "\\`").replace(/\$/g, "\\$");
                  const newText = text.substring(0, bodyContentStart) + escapedBody + text.substring(bodyContentEnd);
                  const edit = new vscode42.WorkspaceEdit();
                  const fullRange = new vscode42.Range(
                    document.positionAt(0),
                    document.positionAt(text.length)
                  );
                  edit.replace(iconsUri, fullRange, newText);
                  await vscode42.workspace.applyEdit(edit);
                  await document.save();
                  vscode42.window.showInformationMessage(
                    t("messages.updatedFile", { path: relativePath })
                  );
                  return { success: true, path: iconsUri.fsPath, content: newText };
                }
              }
            }
            return { success: false, path: "", content: "" };
          }, `updating icons.js at ${relativePath}`);
          if (result?.success && result.path && result.content) {
            await this.regenerateTypesFromIconsFile(result.path, result.content);
            return true;
          }
        } catch {
          continue;
        }
      }
    }
    return false;
  }
  /**
   * Regenerate icons.d.ts based on icons in sprite.svg
   */
  async regenerateTypesFromSprite(spritePath, content) {
    const symbolPattern = /<symbol[^>]*id=["']([^"']+)["']/gi;
    const iconNames = [];
    let match;
    while ((match = symbolPattern.exec(content)) !== null) {
      iconNames.push(match[1]);
    }
    if (iconNames.length === 0) return;
    const outputDir = path36.dirname(spritePath);
    await this.writeTypesFile(outputDir, iconNames);
  }
  /**
   * Regenerate icons.d.ts based on icons in icons.js
   */
  async regenerateTypesFromIconsFile(iconsPath, content) {
    const exportPattern = /export\s+const\s+([a-zA-Z][a-zA-Z0-9]*)\s*=\s*\{/g;
    const iconNames = [];
    let match;
    while ((match = exportPattern.exec(content)) !== null) {
      const varName = match[1];
      const kebabName = varName.replace(/([a-z])([A-Z])/g, "$1-$2").toLowerCase();
      iconNames.push(kebabName);
    }
    if (iconNames.length === 0) return;
    const outputDir = path36.dirname(iconsPath);
    await this.writeTypesFile(outputDir, iconNames);
  }
  /**
   * Write icons.d.ts file with given icon names
   */
  async writeTypesFile(outputDir, iconNames) {
    const typesPath = path36.join(outputDir, "icons.d.ts");
    const sortedNames = [...iconNames].sort((a, b) => a.localeCompare(b));
    const content = `// Auto-generated by Icon Studio
// Do not edit manually

export type IconName = ${sortedNames.map((n) => `'${n}'`).join(" | ")};

export const iconNames = [
${sortedNames.map((n) => `  '${n}'`).join(",\n")}
] as const;

export type IconNameTuple = typeof iconNames;

/**
 * Check if a string is a valid icon name
 */
export function isValidIconName(name: string): name is IconName {
  return iconNames.includes(name as IconName);
}
`;
    const uri = vscode42.Uri.file(typesPath);
    const encoder = new TextEncoder();
    await vscode42.workspace.fs.writeFile(uri, encoder.encode(content));
  }
  /**
   * Ensure SVG has an ID attribute for animation/variation reference
   */
  ensureSvgId(svg, iconName) {
    const hasId = /<svg[^>]*\sid=["'][^"']+["']/i.test(svg);
    if (hasId) {
      return svg;
    }
    const id = `bz-${iconName.replace(/[^a-zA-Z0-9-]/g, "-")}`;
    return svg.replace(/<svg/, `<svg id="${id}"`);
  }
};
function getIconPersistenceService() {
  return IconPersistenceService.getInstance();
}

// src/services/SyntaxHighlighter.ts
var MARKERS = {
  AMP: "\u27E8AMP\u27E9",
  LT: "\u27E8LT\u27E9",
  GT: "\u27E8GT\u27E9",
  // Highlight markers
  B_OPEN: "\u2983b\u2984",
  // Brackets
  B_CLOSE: "\u2983/b\u2984",
  T_OPEN: "\u2983t\u2984",
  // Tags
  T_CLOSE: "\u2983/t\u2984",
  A_OPEN: "\u2983a\u2984",
  // Attributes/Props
  A_CLOSE: "\u2983/a\u2984",
  S_OPEN: "\u2983s\u2984",
  // Strings
  S_CLOSE: "\u2983/s\u2984",
  C_OPEN: "\u2983c\u2984",
  // Comments
  C_CLOSE: "\u2983/c\u2984",
  K_OPEN: "\u2983k\u2984",
  // CSS Keywords
  K_CLOSE: "\u2983/k\u2984",
  SEL_OPEN: "\u2983sel\u2984",
  // Selectors
  SEL_CLOSE: "\u2983/sel\u2984",
  V_OPEN: "\u2983v\u2984",
  // CSS Values
  V_CLOSE: "\u2983/v\u2984",
  BR_OPEN: "\u2983br\u2984",
  // Braces
  BR_CLOSE: "\u2983/br\u2984"
};
var SyntaxHighlighter = class {
  /**
   * Escape HTML special characters
   */
  escapeHtml(text) {
    return text.replace(/&/g, "&amp;").replace(/</g, "&lt;").replace(/>/g, "&gt;").replace(/"/g, "&quot;").replace(/'/g, "&#039;");
  }
  /**
   * Convert placeholder markers to HTML tags
   */
  _markersToHtml(text) {
    return text.replace(/AMP/g, "&amp;").replace(/LT/g, "&lt;").replace(/GT/g, "&gt;").replace(/b/g, '<span class="punctuation">').replace(/\/b/g, "</span>").replace(/t/g, '<span class="tag">').replace(/\/t/g, "</span>").replace(/a/g, '<span class="attr-name">').replace(/\/a/g, "</span>").replace(/s/g, '<span class="string">').replace(/\/s/g, "</span>").replace(/c/g, '<span class="comment">').replace(/\/c/g, "</span>").replace(/k/g, '<span class="keyword">').replace(/\/k/g, "</span>").replace(/sel/g, '<span class="variable">').replace(/\/sel/g, "</span>").replace(/v/g, '<span class="value">').replace(/\/v/g, "</span>").replace(/br/g, '<span class="punctuation">').replace(/\/br/g, "</span>");
  }
  /**
   * Apply CSS-specific highlighting
   */
  _highlightCss(line) {
    return line.replace(/(@[\w-]+)/g, "\u2983k\u2984$1\u2983/k\u2984").replace(/^(\s*)([^{]+)(\s*\{)/g, "$1\u2983sel\u2984$2\u2983/sel\u2984$3").replace(/([\w-]+)(\s*:)/g, "\u2983a\u2984$1\u2983/a\u2984$2").replace(/(:\s*)([^;{}]+)/g, "$1\u2983v\u2984$2\u2983/v\u2984").replace(/([{}])/g, "\u2983br\u2984$1\u2983/br\u2984");
  }
  /**
   * Apply SVG/XML-specific highlighting
   */
  _highlightXml(line) {
    return line.replace(/(LT!--.*?--GT)/g, "\u2983c\u2984$1\u2983/c\u2984").replace(/(LT\/?)([\w:-]+)/g, "\u2983b\u2984$1\u2983/b\u2984\u2983t\u2984$2\u2983/t\u2984").replace(/(\/?GT)/g, "\u2983b\u2984$1\u2983/b\u2984").replace(/(^|\s)([\w:-]+)(?==)/g, "$1\u2983a\u2984$2\u2983/a\u2984").replace(/"([^"]*)"/g, '\u2983s\u2984"$1"\u2983/s\u2984');
  }
  /**
   * Format CSS with proper indentation
   */
  formatCss(css) {
    if (!css) return "";
    const cleanCss = css.replace(/\s+/g, " ").replace(/\s*\{\s*/g, " {\n").replace(/\s*\}\s*/g, "\n}\n").replace(/;\s*/g, ";\n").trim();
    const lines = cleanCss.split("\n");
    const formatted = [];
    let indentLevel = 1;
    for (let line of lines) {
      line = line.trim();
      if (!line) continue;
      if (line.startsWith("}")) {
        indentLevel = Math.max(1, indentLevel - 1);
      }
      formatted.push("  ".repeat(indentLevel) + line);
      if (line.endsWith("{")) {
        indentLevel++;
      }
    }
    return formatted.join("\n") + "\n  ";
  }
  /**
   * Format SVG with proper indentation and line breaks
   */
  formatSvg(svg) {
    if (!svg) return "";
    const result = svg.trim().replace(/\s*style="[^"]*animation[^"]*"/gi, "");
    const formatted = [];
    let indent = 0;
    let pos = 0;
    while (pos < result.length) {
      while (pos < result.length && /\s/.test(result[pos])) pos++;
      if (pos >= result.length) break;
      if (result[pos] === "<") {
        let tagEnd = result.indexOf(">", pos);
        if (tagEnd === -1) tagEnd = result.length;
        const tag = result.substring(pos, tagEnd + 1).trim();
        const isClosing = tag.startsWith("</");
        const isSelfClosing = tag.endsWith("/>");
        const isComment = tag.startsWith("<!--");
        if (isClosing) indent = Math.max(0, indent - 1);
        if (!isComment && tag.length > 80) {
          const tagMatch = tag.match(/^<(\/?[\w:-]+)([\s\S]*?)(\/?>)$/);
          if (tagMatch) {
            const [, tagName, attrsStr, closing] = tagMatch;
            const attrs = [];
            const attrRegex = /([\w:-]+)(?:=("[^"]*"|'[^']*'|[^\s>]*))?/g;
            let attrMatch;
            while ((attrMatch = attrRegex.exec(attrsStr)) !== null) {
              if (attrMatch[2]) {
                attrs.push(`${attrMatch[1]}=${attrMatch[2]}`);
              } else if (attrMatch[1]) {
                attrs.push(attrMatch[1]);
              }
            }
            if (attrs.length > 0) {
              formatted.push("  ".repeat(indent) + `<${tagName}`);
              attrs.forEach((attr, i) => {
                const isLast = i === attrs.length - 1;
                formatted.push("  ".repeat(indent + 1) + attr + (isLast ? closing : ""));
              });
            } else {
              formatted.push("  ".repeat(indent) + tag);
            }
          } else {
            formatted.push("  ".repeat(indent) + tag);
          }
        } else {
          formatted.push("  ".repeat(indent) + tag);
        }
        if (!isClosing && !isSelfClosing && !isComment) {
          indent++;
        }
        pos = tagEnd + 1;
      } else {
        let textEnd = result.indexOf("<", pos);
        if (textEnd === -1) textEnd = result.length;
        const text = result.substring(pos, textEnd).trim();
        if (text) {
          formatted.push("  ".repeat(indent) + text);
        }
        pos = textEnd;
      }
    }
    let finalResult = formatted.join("\n");
    finalResult = finalResult.replace(/<style>([\s\S]*?)<\/style>/gi, (match, cssContent) => {
      return `<style>
${this.formatCss(cssContent)}</style>`;
    });
    return finalResult;
  }
  // Helper to create consistent HTML rows
  _createRowHtml(lineContent, lineNumber) {
    const content = lineContent.trim().length === 0 ? "&nbsp;" : this._markersToHtml(lineContent);
    return `<div class="code-row"><div class="ln">${lineNumber}</div><div class="cl">${content}</div></div>`;
  }
  /**
   * Highlight SVG code with syntax coloring
   */
  highlightSvg(svg) {
    const formatted = this.formatSvg(svg);
    const lines = formatted.split("\n");
    let insideStyle = false;
    const codeRows = lines.map((line, i) => {
      if (line.includes("<style")) insideStyle = true;
      const wasInsideStyle = insideStyle;
      if (line.includes("</style")) insideStyle = false;
      let highlighted = line.replace(/&/g, MARKERS.AMP).replace(/</g, MARKERS.LT).replace(/>/g, MARKERS.GT);
      if (wasInsideStyle && !line.trim().startsWith("<")) {
        highlighted = this._highlightCss(highlighted);
      } else {
        highlighted = this._highlightXml(highlighted);
      }
      return this._createRowHtml(highlighted, i + 1);
    }).join("");
    return `<div class="code-editor">${codeRows}</div>`;
  }
  /**
   * Highlight CSS code
   */
  highlightCssCode(css) {
    const lines = css.split("\n");
    const codeRows = lines.map((line, i) => {
      let highlighted = this.escapeHtml(line);
      if (line.trim().startsWith("/*")) {
        highlighted = `\u2983c\u2984${highlighted}\u2983/c\u2984`;
      } else if (line.includes("@keyframes")) {
        highlighted = highlighted.replace(/(@keyframes)\s+([\w-]+)/, "\u2983k\u2984$1\u2983/k\u2984 \u2983sel\u2984$2\u2983/sel\u2984");
      } else if (line.includes("{") || line.includes("}")) {
        highlighted = highlighted.replace(/([{}])/g, "\u2983br\u2984$1\u2983/br\u2984");
        highlighted = highlighted.replace(/\b(from|to|\d+%)\b/g, "\u2983sel\u2984$1\u2983/sel\u2984");
      } else if (line.includes(":")) {
        highlighted = highlighted.replace(/([\w-]+)(\s*:)/, "\u2983a\u2984$1\u2983/a\u2984$2");
        highlighted = highlighted.replace(/:\s*([^;]+)(;?)/, ": \u2983v\u2984$1\u2983/v\u2984$2");
      }
      return this._createRowHtml(highlighted, i + 1);
    }).join("");
    return `<div class="code-editor">${codeRows}</div>`;
  }
  /**
   * Highlight usage code (HTML/JS mixed)
   */
  highlightUsageCode(lines) {
    const codeRows = lines.map((line, i) => {
      let highlighted = this.escapeHtml(line);
      if (line.trim().startsWith("<!--")) {
        highlighted = `\u2983c\u2984${highlighted}\u2983/c\u2984`;
      } else if (line.includes("<")) {
        highlighted = highlighted.replace(/&lt;(\/?)([\w-]+)/g, "\u2983b\u2984&lt;$1\u2983/b\u2984\u2983t\u2984$2\u2983/t\u2984");
        highlighted = highlighted.replace(/(\s)([\w-]+)=/g, "$1\u2983a\u2984$2\u2983/a\u2984=");
        highlighted = highlighted.replace(/"([^"]*)"/g, '\u2983s\u2984"$1"\u2983/s\u2984');
        highlighted = highlighted.replace(/&gt;/g, "\u2983b\u2984&gt;\u2983/b\u2984");
      } else if (line.includes("import")) {
        highlighted = highlighted.replace(/(import|from)/g, "\u2983k\u2984$1\u2983/k\u2984");
        highlighted = highlighted.replace(/\{ ([^}]+) \}/, "{ \u2983sel\u2984$1\u2983/sel\u2984 }");
        highlighted = highlighted.replace(/'([^']+)'/g, "\u2983s\u2984'$1'\u2983/s\u2984");
      }
      return this._createRowHtml(highlighted, i + 1);
    }).join("");
    return `<div class="code-editor">${codeRows}</div>`;
  }
};
var syntaxHighlighterInstance;
function getSyntaxHighlighter() {
  if (!syntaxHighlighterInstance) {
    syntaxHighlighterInstance = new SyntaxHighlighter();
  }
  return syntaxHighlighterInstance;
}

// src/services/IconEditorTemplateService.ts
init_AnimationKeyframes();
init_i18n();
var ANIMATION_BUTTONS = {
  basic: [
    { type: "none", label: "None", icon: "circle-slash" },
    { type: "spin", label: "Spin", icon: "sync" },
    { type: "spin-reverse", label: "Spin \u21BA", icon: "sync" },
    { type: "pulse", label: "Pulse", icon: "pulse" },
    { type: "pulse-grow", label: "Grow", icon: "arrow-both" },
    { type: "bounce", label: "Bounce", icon: "triangle-up" },
    { type: "bounce-horizontal", label: "Bounce H", icon: "arrow-right" },
    { type: "shake", label: "Shake", icon: "arrow-swap" },
    { type: "shake-vertical", label: "Shake V", icon: "fold-up" },
    { type: "fade", label: "Fade", icon: "eye" },
    { type: "float", label: "Float", icon: "cloud" },
    { type: "blink", label: "Blink", icon: "lightbulb" },
    { type: "glow", label: "Glow", icon: "sparkle" }
  ],
  attention: [
    { type: "swing", label: "Swing", icon: "triangle-down" },
    { type: "wobble", label: "Wobble", icon: "symbol-event" },
    { type: "rubber-band", label: "Rubber", icon: "fold" },
    { type: "jello", label: "Jello", icon: "beaker" },
    { type: "heartbeat", label: "Heartbeat", icon: "heart" },
    { type: "tada", label: "Tada", icon: "megaphone" }
  ],
  entrance: [
    { type: "fade-in", label: "Fade In", icon: "eye" },
    { type: "fade-out", label: "Fade Out", icon: "eye-closed" },
    { type: "zoom-in", label: "Zoom In", icon: "zoom-in" },
    { type: "zoom-out", label: "Zoom Out", icon: "zoom-out" },
    { type: "slide-in-up", label: "Slide \u2191", icon: "arrow-up" },
    { type: "slide-in-down", label: "Slide \u2193", icon: "arrow-down" },
    { type: "slide-in-left", label: "Slide \u2190", icon: "arrow-left" },
    { type: "slide-in-right", label: "Slide \u2192", icon: "arrow-right" },
    { type: "flip", label: "Flip Y", icon: "refresh" },
    { type: "flip-x", label: "Flip X", icon: "fold-up" }
  ],
  draw: [
    { type: "draw", label: "Draw", icon: "edit" },
    { type: "draw-reverse", label: "Undraw", icon: "discard" },
    { type: "draw-loop", label: "Draw Loop", icon: "sync" }
  ]
};
var IconEditorTemplateService = class _IconEditorTemplateService {
  static _instance;
  constructor() {
  }
  static getInstance() {
    if (!_IconEditorTemplateService._instance) {
      _IconEditorTemplateService._instance = new _IconEditorTemplateService();
    }
    return _IconEditorTemplateService._instance;
  }
  /**
   * Generate HTML for a single animation button
   */
  generateAnimationButton(type, label, icon, currentType) {
    const isActive = type === currentType;
    return `
      <button class="animation-type-btn${isActive ? " active" : ""}" data-type="${type}" onclick="setAnimation('${type}')">
        <span class="codicon codicon-${icon}"></span>
        ${label}
      </button>
    `;
  }
  /**
   * Generate all animation buttons for a category
   */
  generateAnimationButtonsForCategory(category, currentType) {
    const buttons = ANIMATION_BUTTONS[category];
    if (!buttons) return "";
    return buttons.map((btn) => this.generateAnimationButton(btn.type, btn.label, btn.icon, currentType)).join("");
  }
  /**
   * Generate animation code HTML with syntax highlighting
   */
  generateAnimationCodeHtml(animationType, settings) {
    if (!animationType || animationType === "none") {
      return '<div class="code-editor"><div class="code-row"><div class="ln">1</div><div class="cl" style="color: var(--vscode-descriptionForeground); font-style: italic;">No animation selected</div></div></div>';
    }
    const duration = settings?.duration || 1;
    const timing = settings?.timing || "ease";
    const iteration = settings?.iteration || "infinite";
    const delay = settings?.delay || 0;
    const direction = settings?.direction || "normal";
    const keyframes = getKeyframesForAnimation(animationType);
    const animationRule = `.bz-anim-${animationType} {
  animation: ${animationType} ${duration}s ${timing} ${delay}s ${iteration} ${direction};
}`;
    const fullCss = `/* Animation: ${animationType} */
${keyframes}

${animationRule}`;
    return getSyntaxHighlighter().highlightCssCode(fullCss);
  }
  /**
   * Generate usage code HTML with syntax highlighting
   */
  generateUsageCodeHtml(iconName, animationType) {
    const config = getConfig();
    const tagName = config.webComponentName || "sg-icon";
    const lines = [
      `<!-- Web Component -->`,
      `<${tagName} name="${iconName}"${animationType && animationType !== "none" ? ` animation="${animationType}"` : ""}></${tagName}>`,
      ``,
      `<!-- SVG Use (Sprite) -->`,
      `<svg><use href="sprite.svg#${iconName}"></use></svg>`,
      ``,
      `<!-- JavaScript Import -->`,
      `import { ${toVariableName2(iconName)} } from './icons.js';`
    ];
    return getSyntaxHighlighter().highlightUsageCode(lines);
  }
  /**
   * Generate HTML body from template with substitutions
   */
  generateHtmlBody(template, data) {
    const hasAnimation = data.animationName && data.animationName !== "none";
    return template.replace(/\$\{name\}/g, data.name).replace(/\$\{displaySvg\}/g, data.displaySvg).replace(/\$\{fileSizeStr\}/g, data.fileSizeStr).replace(
      /\$\{isBuilt \? '<span class="badge badge-built">BUILT<\/span>' : ''\}/g,
      data.isBuilt ? '<span class="badge badge-built">BUILT</span>' : ""
    ).replace(
      'id="animBadge" style="display: none;"',
      hasAnimation ? 'id="animBadge" style="display: inline-flex;"' : 'id="animBadge" style="display: none;"'
    ).replace('<span id="animName"></span>', `<span id="animName">${data.animationName}</span>`).replace(/\$\{colorTabContent\}/g, data.colorTabContent).replace(/\$\{animationTabContent\}/g, data.animationTabContent).replace(/\$\{codeTabContent\}/g, data.codeTabContent).replace(/\$\{i18n_editorBadge\}/g, t("webview.editor.editorBadge")).replace(/\$\{i18n_optimizedBadge\}/g, t("webview.editor.optimizedBadge")).replace(/\$\{i18n_renameIcon\}/g, t("webview.editor.renameIcon")).replace(/\$\{i18n_zoomOut\}/g, t("webview.editor.zoomOut")).replace(/\$\{i18n_zoomIn\}/g, t("webview.editor.zoomIn")).replace(/\$\{i18n_resetZoom\}/g, t("webview.editor.resetZoom")).replace(/\$\{i18n_restartAnimation\}/g, t("webview.editor.restartAnimation")).replace(/\$\{i18n_buildIcons\}/g, t("webview.editor.buildIcons")).replace(/\$\{i18n_copySvg\}/g, t("webview.editor.copySvg")).replace(/\$\{i18n_optimizeSvg\}/g, t("webview.editor.optimizeSvg")).replace(/\$\{i18n_applyOnBuild\}/g, t("webview.editor.applyOnBuild")).replace(/\$\{i18n_discardOptimization\}/g, t("webview.editor.discardOptimization")).replace(/\$\{i18n_tabColor\}/g, t("webview.editor.tabColor")).replace(/\$\{i18n_tabAnimation\}/g, t("webview.editor.tabAnimation")).replace(/\$\{i18n_tabCode\}/g, t("webview.editor.tabCode"));
  }
  /**
   * Generate Animation Tab HTML from template
   */
  generateAnimationTabHtml(template, detectedAnimation) {
    const currentType = detectedAnimation?.type || "none";
    const settings = detectedAnimation?.settings || {
      duration: 1,
      timing: "ease",
      iteration: "infinite",
      delay: 0,
      direction: "normal"
    };
    const basicButtons = this.generateAnimationButtonsForCategory("basic", currentType);
    const attentionButtons = this.generateAnimationButtonsForCategory("attention", currentType);
    const entranceButtons = this.generateAnimationButtonsForCategory("entrance", currentType);
    const drawButtons = this.generateAnimationButtonsForCategory("draw", currentType);
    return template.replace(/\$\{basicAnimationButtons\}/g, basicButtons).replace(/\$\{attentionAnimationButtons\}/g, attentionButtons).replace(/\$\{entranceAnimationButtons\}/g, entranceButtons).replace(/\$\{drawAnimationButtons\}/g, drawButtons).replace(/\$\{duration\}/g, String(settings.duration)).replace(/\$\{delay\}/g, String(settings.delay || 0)).replace(/\$\{timingLinearSelected\}/g, settings.timing === "linear" ? "selected" : "").replace(/\$\{timingEaseSelected\}/g, settings.timing === "ease" ? "selected" : "").replace(/\$\{timingEaseInSelected\}/g, settings.timing === "ease-in" ? "selected" : "").replace(/\$\{timingEaseOutSelected\}/g, settings.timing === "ease-out" ? "selected" : "").replace(
      /\$\{timingEaseInOutSelected\}/g,
      settings.timing === "ease-in-out" ? "selected" : ""
    ).replace(/\$\{iteration1Selected\}/g, settings.iteration === "1" ? "selected" : "").replace(/\$\{iteration2Selected\}/g, settings.iteration === "2" ? "selected" : "").replace(/\$\{iteration3Selected\}/g, settings.iteration === "3" ? "selected" : "").replace(
      /\$\{iterationInfiniteSelected\}/g,
      settings.iteration === "infinite" ? "selected" : ""
    ).replace(
      /\$\{directionNormalSelected\}/g,
      settings.direction === "normal" ? "selected" : ""
    ).replace(
      /\$\{directionReverseSelected\}/g,
      settings.direction === "reverse" ? "selected" : ""
    ).replace(
      /\$\{directionAlternateSelected\}/g,
      settings.direction === "alternate" ? "selected" : ""
    ).replace(
      /\$\{directionAltReverseSelected\}/g,
      settings.direction === "alternate-reverse" ? "selected" : ""
    ).replace(/\$\{copyAnimBtnDisabled\}/g, currentType === "none" ? "disabled" : "").replace(/\$\{saveAnimBtnDisabled\}/g, "").replace(/\$\{i18n_animationType\}/g, t("webview.animation.animationType")).replace(/\$\{i18n_categoryBasic\}/g, t("webview.animation.categoryBasic")).replace(/\$\{i18n_categoryAttention\}/g, t("webview.animation.categoryAttention")).replace(/\$\{i18n_categoryEntrance\}/g, t("webview.animation.categoryEntrance")).replace(/\$\{i18n_categoryDraw\}/g, t("webview.animation.categoryDraw")).replace(/\$\{i18n_drawHint\}/g, t("webview.animation.drawHint")).replace(/\$\{i18n_settings\}/g, t("webview.animation.settings")).replace(/\$\{i18n_duration\}/g, t("webview.animation.duration")).replace(/\$\{i18n_delay\}/g, t("webview.animation.delay")).replace(/\$\{i18n_timing\}/g, t("webview.animation.timing")).replace(/\$\{i18n_iteration\}/g, t("webview.animation.iteration")).replace(/\$\{i18n_direction\}/g, t("webview.animation.direction")).replace(/\$\{i18n_timingLinear\}/g, t("webview.animation.timingLinear")).replace(/\$\{i18n_timingEase\}/g, t("webview.animation.timingEase")).replace(/\$\{i18n_timingEaseIn\}/g, t("webview.animation.timingEaseIn")).replace(/\$\{i18n_timingEaseOut\}/g, t("webview.animation.timingEaseOut")).replace(/\$\{i18n_timingEaseInOut\}/g, t("webview.animation.timingEaseInOut")).replace(/\$\{i18n_iterationOnce\}/g, t("webview.animation.iterationOnce")).replace(/\$\{i18n_iterationTwice\}/g, t("webview.animation.iterationTwice")).replace(/\$\{i18n_iteration3Times\}/g, t("webview.animation.iteration3Times")).replace(/\$\{i18n_iterationInfinite\}/g, t("webview.animation.iterationInfinite")).replace(/\$\{i18n_directionNormal\}/g, t("webview.animation.directionNormal")).replace(/\$\{i18n_directionReverse\}/g, t("webview.animation.directionReverse")).replace(/\$\{i18n_directionAlternate\}/g, t("webview.animation.directionAlternate")).replace(/\$\{i18n_directionAltReverse\}/g, t("webview.animation.directionAltReverse")).replace(/\$\{i18n_export\}/g, t("webview.animation.export")).replace(/\$\{i18n_saveAnimation\}/g, t("webview.animation.saveAnimation")).replace(/\$\{i18n_saveAnimationTooltip\}/g, t("webview.animation.saveAnimationTooltip")).replace(/\$\{i18n_copyWithAnimation\}/g, t("webview.animation.copyWithAnimation")).replace(/\$\{i18n_exportHint\}/g, t("webview.animation.exportHint"));
  }
  /**
   * Generate Code Tab HTML from template
   */
  generateCodeTabHtml(template, name, svg, detectedAnimation) {
    const animType = detectedAnimation?.type || "none";
    const hasAnimation = animType !== "none";
    return template.replace(/\$\{svgCodeHighlighted\}/g, getSyntaxHighlighter().highlightSvg(svg)).replace(/\$\{animationSectionStyle\}/g, hasAnimation ? "" : "display: none;").replace(/\$\{animationType\}/g, animType).replace(
      /\$\{animationCodeHtml\}/g,
      this.generateAnimationCodeHtml(animType, detectedAnimation?.settings)
    ).replace(
      /\$\{buildFormatBadge\}/g,
      getConfig().buildFormat === "sprite.svg" ? "Sprite" : "WebComponent"
    ).replace(/\$\{usageCodeHtml\}/g, this.generateUsageCodeHtml(name, animType)).replace(/\$\{i18n_svgSource\}/g, t("webview.code.svgSource")).replace(/\$\{i18n_animationCss\}/g, t("webview.code.animationCss")).replace(/\$\{i18n_usageExample\}/g, t("webview.code.usageExample")).replace(/\$\{i18n_copy\}/g, t("webview.code.copy")).replace(/\$\{i18n_copySvg\}/g, t("webview.code.copySvg")).replace(/\$\{i18n_copyAnimation\}/g, t("webview.code.copyAnimation")).replace(/\$\{i18n_copyUsage\}/g, t("webview.code.copyUsage"));
  }
  /**
   * Generate disabled colors section HTML for SVGs with too many colors
   */
  generateDisabledColorsHtml(totalColorCount) {
    return `
      <div class="section disabled-section">
        <div class="section-title">
          <span class="codicon codicon-paintcan"></span> Colors
        </div>
        <div class="colors-warning">
          <span class="codicon codicon-warning"></span>
          This SVG has ${totalColorCount} unique colors. Color editing is disabled for rasterized SVGs.
        </div>
      </div>
      <div class="section disabled-section">
        <div class="section-title">
          <span class="codicon codicon-symbol-color"></span> Variants
        </div>
        <div class="Variants-disabled-message">
          <span class="codicon codicon-info"></span> Variants disabled for SVGs with too many colors
        </div>
      </div>
    `;
  }
  /**
   * Generate color swatches HTML
   */
  generateColorSwatchesHtml(svgColors, colorService3) {
    return svgColors.map(
      (color, index) => `
      <div class="color-item">
        <div class="color-swatch" style="background-color: ${color}">
          <input type="color" value="${colorService3.toHexColor(color)}" 
            onchange="changeColor(${index}, this.value)"
            oninput="previewColor(${index}, this.value)" />
        </div>
        <span class="color-label">${color}</span>
      </div>
    `
    ).join("");
  }
  /**
   * Generate currentColor swatch HTML
   */
  generateCurrentColorHtml(hasCurrentColor) {
    if (!hasCurrentColor) return "";
    return `
      <div class="current-color-item">
        <div class="current-color-swatch" title="currentColor - inherits from CSS">
          <input type="color" value="#000000" 
            onchange="replaceCurrentColor(this.value)" />
          <span class="current-color-icon codicon codicon-paintcan"></span>
        </div>
        <span class="current-color-label">currentColor</span>
      </div>
    `;
  }
};
function getIconEditorTemplateService() {
  return IconEditorTemplateService.getInstance();
}

// src/panels/IconEditorPanel.ts
init_config();
init_i18n();

// src/handlers/IconEditorColorHandlers.ts
var vscode43 = __toESM(require("vscode"));
init_i18n();
function handlePreviewColor(ctx, message) {
  if (!ctx.iconData?.svg || !message.oldColor || !message.newColor) return;
  const updatedSvg = ctx.colorService.replaceColorInSvg(
    ctx.iconData.svg,
    message.oldColor,
    message.newColor
  );
  ctx.postMessage({
    command: "previewUpdated",
    svg: updatedSvg
  });
  const { colors } = ctx.colorService.extractColorsFromSvg(updatedSvg);
  vscode43.commands.executeCommand(
    "sageboxIconStudio.updateTreeViewPreview",
    ctx.iconData.name,
    updatedSvg,
    colors
  );
}
function handleChangeColor2(ctx, message) {
  if (!ctx.iconData?.svg || !message.oldColor || !message.newColor) return;
  const originalColor = message.originalColor || message.oldColor;
  ctx.variantsService.setColorMapping(ctx.iconData.name, originalColor, message.newColor);
  const updatedSvg = ctx.colorService.replaceColorInSvg(
    ctx.iconData.svg,
    message.oldColor,
    message.newColor
  );
  ctx.updateSvg(updatedSvg);
  const { colors } = ctx.colorService.extractColorsFromSvg(updatedSvg);
  vscode43.commands.executeCommand(
    "sageboxIconStudio.updateTreeViewPreview",
    ctx.iconData.name,
    updatedSvg,
    colors
  );
  let targetVariantIndex = ctx.selectedVariantIndex;
  if (ctx.selectedVariantIndex === -1) {
    const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
    const customIndex = variants.findIndex((v) => v.name === "custom");
    if (customIndex >= 0) {
      targetVariantIndex = customIndex;
      ctx.setSelectedVariantIndex(customIndex);
      ctx.variantsService.updateVariantColors(ctx.iconData.name, customIndex, colors);
    }
  } else {
    ctx.variantsService.updateVariantColors(ctx.iconData.name, ctx.selectedVariantIndex, colors);
  }
  ctx.postMessage({
    command: "variantColorsUpdated",
    variantIndex: targetVariantIndex,
    colors
  });
  ctx.refresh();
}
function handleReplaceCurrentColor(ctx, message) {
  if (!ctx.iconData?.svg || !message.newColor) return;
  const updatedSvg = ctx.colorService.replaceColorInSvg(
    ctx.iconData.svg,
    "currentColor",
    message.newColor
  );
  ctx.updateSvg(updatedSvg);
  const { colors } = ctx.colorService.extractColorsFromSvg(updatedSvg);
  let targetVariantIndex = ctx.selectedVariantIndex;
  if (ctx.selectedVariantIndex === -1) {
    const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
    const customIndex = variants.findIndex((v) => v.name === "custom");
    if (customIndex >= 0) {
      targetVariantIndex = customIndex;
      ctx.setSelectedVariantIndex(customIndex);
      ctx.variantsService.updateVariantColors(ctx.iconData.name, customIndex, colors);
    }
  } else {
    ctx.variantsService.updateVariantColors(ctx.iconData.name, ctx.selectedVariantIndex, colors);
  }
  ctx.postMessage({
    command: "variantColorsUpdated",
    variantIndex: targetVariantIndex,
    colors
  });
  ctx.refresh();
}
function handleAddFillColor(ctx, message) {
  if (!ctx.iconData?.svg || !message.color) return;
  let updatedSvg = ctx.iconData.svg;
  updatedSvg = updatedSvg.replace(
    /<path(?![^>]*fill=)([^>]*)\/?>/gi,
    `<path fill="${message.color}"$1/>`
  );
  updatedSvg = updatedSvg.replace(
    /<(circle|rect|ellipse|polygon|polyline)(?![^>]*fill=)([^>]*)\/?>/gi,
    `<$1 fill="${message.color}"$2/>`
  );
  ctx.updateSvg(updatedSvg);
  ctx.refresh();
}
function handleAddColor(ctx, message) {
  if (!ctx.iconData?.svg || !message.color) return;
  let updatedSvg = ctx.iconData.svg;
  if (updatedSvg.includes("fill=")) {
    updatedSvg = updatedSvg.replace(
      /<svg([^>]*)fill=["'][^"']*["']/,
      `<svg$1fill="${message.color}"`
    );
  } else {
    updatedSvg = updatedSvg.replace(/<svg/, `<svg fill="${message.color}"`);
  }
  ctx.updateSvg(updatedSvg);
  ctx.refresh();
}
function handleApplyFilters(ctx, message) {
  if (!ctx.iconData?.svg) return;
  const hue = parseInt(message.filters.hue) || 0;
  const saturation = parseInt(message.filters.saturation) || 100;
  const brightness = parseInt(message.filters.brightness) || 100;
  if (hue === 0 && saturation === 100 && brightness === 100) {
    vscode43.window.showInformationMessage(t("messages.noFiltersToApply"));
    return;
  }
  const { colors: currentColors } = ctx.colorService.extractColorsFromSvg(ctx.iconData.svg);
  let updatedSvg = ctx.iconData.svg;
  const newColors = [];
  for (const color of currentColors) {
    const filteredColor = applyColorFilters(color, hue, saturation, brightness);
    newColors.push(filteredColor);
    updatedSvg = ctx.colorService.replaceColorInSvg(updatedSvg, color, filteredColor);
  }
  updatedSvg = updatedSvg.replace(
    /filter:\s*hue-rotate\([^)]+\)\s*saturate\([^)]+\)\s*brightness\([^)]+\);?\s*/gi,
    ""
  );
  ctx.updateSvg(updatedSvg);
  vscode43.commands.executeCommand(
    "sageboxIconStudio.updateTreeViewPreview",
    ctx.iconData.name,
    updatedSvg,
    newColors
  );
  let targetVariantIndex = ctx.selectedVariantIndex;
  if (ctx.selectedVariantIndex === -1) {
    const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
    const customIndex = variants.findIndex((v) => v.name === "custom");
    if (customIndex >= 0) {
      targetVariantIndex = customIndex;
      ctx.setSelectedVariantIndex(customIndex);
      ctx.variantsService.updateVariantColors(ctx.iconData.name, customIndex, newColors);
    }
  } else {
    ctx.variantsService.updateVariantColors(ctx.iconData.name, ctx.selectedVariantIndex, newColors);
  }
  ctx.postMessage({
    command: "variantColorsUpdated",
    variantIndex: targetVariantIndex,
    colors: newColors
  });
  ctx.refresh();
  vscode43.window.showInformationMessage(t("messages.filtersApplied"));
}
function applyColorFilters(hexColor, hue, saturation, brightness) {
  let r, g, b;
  if (hexColor.startsWith("#")) {
    const hex = hexColor.slice(1);
    if (hex.length === 3) {
      r = parseInt(hex[0] + hex[0], 16);
      g = parseInt(hex[1] + hex[1], 16);
      b = parseInt(hex[2] + hex[2], 16);
    } else if (hex.length === 6) {
      r = parseInt(hex.slice(0, 2), 16);
      g = parseInt(hex.slice(2, 4), 16);
      b = parseInt(hex.slice(4, 6), 16);
    } else {
      return hexColor;
    }
  } else if (hexColor.startsWith("rgb")) {
    const match = hexColor.match(/rgba?\((\d+),\s*(\d+),\s*(\d+)/);
    if (match) {
      r = parseInt(match[1]);
      g = parseInt(match[2]);
      b = parseInt(match[3]);
    } else {
      return hexColor;
    }
  } else {
    return hexColor;
  }
  r /= 255;
  g /= 255;
  b /= 255;
  const max = Math.max(r, g, b), min = Math.min(r, g, b);
  let h = 0, s = 0;
  const l = (max + min) / 2;
  if (max !== min) {
    const d = max - min;
    s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
    switch (max) {
      case r:
        h = ((g - b) / d + (g < b ? 6 : 0)) / 6;
        break;
      case g:
        h = ((b - r) / d + 2) / 6;
        break;
      case b:
        h = ((r - g) / d + 4) / 6;
        break;
    }
  }
  let newH = (h + hue / 360) % 1;
  if (newH < 0) newH += 1;
  const newS = Math.min(1, Math.max(0, s * (saturation / 100)));
  const newL = Math.min(1, Math.max(0, l * (brightness / 100)));
  let r2, g2, b2;
  if (newS === 0) {
    r2 = g2 = b2 = newL;
  } else {
    const hue2rgb = (p2, q2, t2) => {
      if (t2 < 0) t2 += 1;
      if (t2 > 1) t2 -= 1;
      if (t2 < 1 / 6) return p2 + (q2 - p2) * 6 * t2;
      if (t2 < 1 / 2) return q2;
      if (t2 < 2 / 3) return p2 + (q2 - p2) * (2 / 3 - t2) * 6;
      return p2;
    };
    const q = newL < 0.5 ? newL * (1 + newS) : newL + newS - newL * newS;
    const p = 2 * newL - q;
    r2 = hue2rgb(p, q, newH + 1 / 3);
    g2 = hue2rgb(p, q, newH);
    b2 = hue2rgb(p, q, newH - 1 / 3);
  }
  const toHex = (x) => Math.round(x * 255).toString(16).padStart(2, "0");
  return `#${toHex(r2)}${toHex(g2)}${toHex(b2)}`;
}

// src/handlers/IconEditorVariantHandlers.ts
var vscode44 = __toESM(require("vscode"));
init_i18n();
async function handleSaveVariant2(ctx) {
  if (!ctx.iconData) {
    vscode44.window.showErrorMessage(t("messages.noIconData"));
    return;
  }
  const variantName = await vscode44.window.showInputBox({
    prompt: t("editor.enterVariantName"),
    placeHolder: t("editor.variantPlaceholder")
  });
  if (variantName) {
    const { colors } = ctx.colorService.extractColorsFromSvg(ctx.iconData.svg);
    ctx.variantsService.saveVariant(ctx.iconData.name, variantName, colors);
    ctx.refresh();
  }
}
function handleApplyVariant2(ctx, message) {
  if (!ctx.iconData || message.index === void 0) return;
  const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
  const variant = variants[message.index];
  if (variant) {
    const currentColors = ctx.colorService.extractColorsFromSvg(ctx.iconData.svg).colors;
    let newSvg = ctx.iconData.svg;
    for (let i = 0; i < Math.min(currentColors.length, variant.colors.length); i++) {
      newSvg = ctx.colorService.replaceColorInSvg(newSvg, currentColors[i], variant.colors[i]);
    }
    ctx.updateSvg(newSvg);
    ctx.setSelectedVariantIndex(message.index);
    ctx.refresh();
  }
}
function handleApplyDefaultVariant2(ctx) {
  if (!ctx.iconData) return;
  if (ctx.originalColors.length > 0) {
    const currentColors = ctx.colorService.extractColorsFromSvg(ctx.iconData.svg).colors;
    let newSvg = ctx.iconData.svg;
    for (let i = 0; i < Math.min(currentColors.length, ctx.originalColors.length); i++) {
      newSvg = ctx.colorService.replaceColorInSvg(newSvg, currentColors[i], ctx.originalColors[i]);
    }
    ctx.updateSvg(newSvg);
  }
  ctx.setSelectedVariantIndex(-1);
  ctx.refresh();
}
function handleGenerateAutoVariant(ctx, message) {
  if (!ctx.iconData || !message.type) return;
  ctx.generateAutoVariant(message.type);
}
function handleDeleteVariant2(ctx, message) {
  if (!ctx.iconData || message.index === void 0) return;
  ctx.variantsService.deleteVariant(ctx.iconData.name, message.index);
  const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
  const variantNames = variants.map((s) => s.name);
  const currentDefault = ctx.variantsService.getDefaultVariant(ctx.iconData.name);
  if (currentDefault && !variantNames.includes(currentDefault)) {
    ctx.variantsService.setDefaultVariant(ctx.iconData.name, null);
  }
  if (ctx.selectedVariantIndex === message.index) {
    ctx.setSelectedVariantIndex(-1);
  } else if (ctx.selectedVariantIndex > message.index) {
    ctx.setSelectedVariantIndex(ctx.selectedVariantIndex - 1);
  }
  ctx.refresh();
}
function handleSetDefaultVariant2(ctx, message) {
  if (!ctx.iconData) return;
  const variantName = message.variantName;
  ctx.variantsService.setDefaultVariant(ctx.iconData.name, variantName ?? null);
  ctx.refresh();
  if (variantName) {
    vscode44.window.showInformationMessage(
      t("messages.variantSetAsDefault", { name: variantName, icon: ctx.iconData.name })
    );
  } else {
    vscode44.window.showInformationMessage(
      t("messages.variantDefaultCleared", { icon: ctx.iconData.name })
    );
  }
}
async function handleEditVariant(ctx, message) {
  if (!ctx.iconData || message.index === void 0) return;
  const variants = ctx.variantsService.getSavedVariants(ctx.iconData.name);
  const variant = variants[message.index];
  if (variant) {
    const newName = await vscode44.window.showInputBox({
      prompt: t("editor.editVariantName"),
      value: variant.name,
      placeHolder: t("editor.variantPlaceholder")
    });
    if (newName !== void 0) {
      const { colors } = ctx.colorService.extractColorsFromSvg(ctx.iconData.svg);
      ctx.variantsService.updateVariant(ctx.iconData.name, message.index, newName, colors);
      ctx.refresh();
      vscode44.window.showInformationMessage(t("messages.variantUpdated", { name: newName }));
    }
  }
}

// src/handlers/IconEditorSvgHandlers.ts
var vscode45 = __toESM(require("vscode"));
init_SvgOptimizer();
init_i18n();
var svgOptimizer2 = new SvgOptimizer();
function handleOptimizeSvg2(ctx, message) {
  if (!ctx.iconData?.svg) return;
  const preset = message.preset || "safe";
  const presets = svgOptimizer2.getPresets();
  const result = svgOptimizer2.optimize(ctx.iconData.svg, presets[preset] || presets.safe);
  ctx.postMessage({
    command: "optimizeResult",
    ...result,
    originalSizeStr: svgOptimizer2.formatSize(result.originalSize),
    optimizedSizeStr: svgOptimizer2.formatSize(result.optimizedSize)
  });
}
async function handleApplyOptimizedSvg2(ctx, message) {
  if (!ctx.iconData || !message.svg) return;
  if (!ctx.getPreOptimizedSvg()) {
    ctx.setPreOptimizedSvg(ctx.iconData.svg);
  }
  await ctx.processAndSaveIcon({
    svg: message.svg,
    includeAnimationInFile: false,
    updateAnimationMetadata: false,
    triggerFullRebuild: false,
    skipPanelUpdate: true,
    successMessage: "Optimized SVG applied (session only)"
  });
  ctx.postMessage({
    command: "optimizedSvgApplied",
    svg: ctx.iconData.svg,
    code: getSyntaxHighlighter().highlightSvg(ctx.iconData.svg)
  });
}
async function handleRevertOptimization(ctx) {
  const preOptimizedSvg = ctx.getPreOptimizedSvg();
  if (!ctx.iconData || !preOptimizedSvg) return;
  await ctx.processAndSaveIcon({
    svg: preOptimizedSvg,
    includeAnimationInFile: false,
    updateAnimationMetadata: false,
    triggerFullRebuild: false,
    skipPanelUpdate: true,
    successMessage: "Optimization reverted"
  });
  ctx.setPreOptimizedSvg(void 0);
  ctx.postMessage({
    command: "optimizationReverted",
    svg: ctx.iconData.svg,
    code: getSyntaxHighlighter().highlightSvg(ctx.iconData.svg)
  });
}
function handleCopySvg2(ctx, message) {
  const svgToCopy = message.svg || ctx.iconData?.svg;
  if (svgToCopy) {
    vscode45.env.clipboard.writeText(svgToCopy);
    vscode45.window.showInformationMessage(t("messages.svgCopiedToClipboard"));
  }
}
function handleCopyWithAnimation(ctx, message) {
  if (!ctx.iconData?.svg || !message.animation || message.animation === "none") return;
  const defaultSettings = { duration: 1, timing: "ease", iteration: "infinite" };
  const settings = message.settings || defaultSettings;
  const animatedSvg = SvgManipulationService.embedAnimationInSvg(
    ctx.iconData.svg,
    message.animation,
    settings
  );
  vscode45.env.clipboard.writeText(animatedSvg);
  vscode45.window.showInformationMessage(t("messages.animatedSvgCopied"));
}
function handleFormatSvgCode(ctx) {
  if (!ctx.iconData?.svg) return;
  ctx.postMessage({
    command: "updateCodeTab",
    code: getSyntaxHighlighter().highlightSvg(ctx.iconData.svg)
  });
}
function handleUpdateCodeWithAnimation(ctx, message) {
  if (!ctx.iconData?.svg) return;
  ctx.postMessage({
    command: "updateCodeTab",
    code: getSyntaxHighlighter().highlightSvg(ctx.iconData.svg),
    size: Buffer.byteLength(ctx.iconData.svg, "utf8"),
    hasAnimation: message.animation && message.animation !== "none"
  });
}
function handleUpdateAnimationCode(ctx, message) {
  if (!message.animation) return;
  ctx.postMessage({
    command: "animationCodeUpdated",
    code: getIconEditorTemplateService().generateAnimationCodeHtml(
      message.animation,
      message.settings
    ),
    animationType: message.animation
  });
}
function handleShowMessage(message) {
  if (message.message) {
    vscode45.window.showInformationMessage(message.message);
  }
}
function handleInsertCodeAtCursor(message) {
  if (!message.code) return;
  const editor = vscode45.window.activeTextEditor;
  if (editor) {
    editor.edit((editBuilder) => {
      editBuilder.insert(editor.selection.active, message.code);
    }).then((success) => {
      if (success) {
        vscode45.window.showInformationMessage(t("messages.codeInsertedAtCursor"));
      }
    });
  } else {
    vscode45.env.clipboard.writeText(message.code);
    vscode45.window.showInformationMessage(t("messages.noActiveEditorCodeCopied"));
  }
}

// src/handlers/IconEditorIconHandlers.ts
var vscode46 = __toESM(require("vscode"));
init_i18n();
async function handleRequestRename(ctx, message) {
  if (!ctx.iconData || !message.currentName) return;
  const newName = await vscode46.window.showInputBox({
    prompt: t("editor.renamePrompt"),
    value: message.currentName,
    placeHolder: "icon-name",
    validateInput: (value) => {
      if (!value || value.trim() === "") {
        return t("editor.nameCannotBeEmpty");
      }
      if (value === message.currentName) {
        return t("editor.enterDifferentName");
      }
      if (!/^[a-zA-Z0-9_-]+$/.test(value)) {
        return t("editor.nameValidation");
      }
      return void 0;
    }
  });
  if (newName) {
    try {
      const result = await vscode46.commands.executeCommand(
        "sageboxIconStudio.renameIcon",
        {
          icon: {
            name: message.currentName,
            path: ctx.iconData.location?.file,
            svg: ctx.iconData.svg
          },
          contextValue: ctx.iconData.location ? "svgIcon" : "builtIcon"
        },
        newName
      );
      if (result) {
        ctx.updateIconName(result.newName);
        if (result.newPath && ctx.iconData.location) {
          ctx.updateIconLocation(result.newPath);
        }
        ctx.panel.title = `${t("editor.edit")}: ${result.newName}`;
        ctx.postMessage({ command: "nameUpdated", newName: result.newName });
        vscode46.window.showInformationMessage(t("messages.renamedTo", { name: result.newName }));
        vscode46.commands.executeCommand(
          "sageboxIconStudio.revealInTree",
          result.newName,
          result.newPath || ctx.iconData.location?.file,
          ctx.iconData.location?.line
        );
      }
    } catch (error) {
      vscode46.window.showErrorMessage(t("messages.errorRenaming", { error: String(error) }));
    }
  }
}
async function handleRenameIcon(ctx, message) {
  if (!ctx.iconData || !message.oldName || !message.newName) return;
  try {
    const result = await vscode46.commands.executeCommand(
      "sageboxIconStudio.renameIcon",
      {
        icon: {
          name: message.oldName,
          path: ctx.iconData.location?.file,
          svg: ctx.iconData.svg
        },
        contextValue: ctx.iconData.location ? "svgIcon" : "builtIcon"
      },
      message.newName
    );
    if (result) {
      ctx.updateIconName(result.newName);
      if (result.newPath && ctx.iconData.location) {
        ctx.updateIconLocation(result.newPath);
      }
      ctx.panel.title = `${t("editor.edit")}: ${result.newName}`;
      ctx.refresh();
      vscode46.window.showInformationMessage(t("messages.renamedTo", { name: result.newName }));
      vscode46.commands.executeCommand(
        "sageboxIconStudio.revealInTree",
        result.newName,
        result.newPath || ctx.iconData.location?.file,
        ctx.iconData.location?.line
      );
    }
  } catch (error) {
    vscode46.window.showErrorMessage(t("messages.errorRenaming", { error: String(error) }));
  }
}
async function handleRebuild(ctx, message) {
  if (!ctx.iconData?.svg) return;
  if (message.applyOptimization) {
    ctx.postMessage({ command: "applyOptimizationBeforeRebuild" });
  }
  await ctx.addToIconCollection(message.animation, message.animationSettings);
}
function handleSaveAnimation(ctx, message) {
  if (!ctx.iconData?.name) return;
  const animService = getAnimationService();
  const animationType = message.animation || "none";
  if (animationType === "none") {
    animService.removeAnimation(ctx.iconData.name);
    vscode46.window.showInformationMessage(
      t("messages.animationRemoved", { name: ctx.iconData.name })
    );
  } else {
    animService.setAnimation(ctx.iconData.name, {
      type: animationType,
      duration: message.settings?.duration,
      timing: message.settings?.timing,
      iteration: message.settings?.iteration,
      delay: message.settings?.delay,
      direction: message.settings?.direction
    });
    vscode46.window.showInformationMessage(
      t("messages.animationSaved", { name: ctx.iconData.name, animation: animationType })
    );
  }
}
function handleRefresh() {
  vscode46.commands.executeCommand("sageboxIconStudio.refreshIcons");
}

// src/panels/IconEditorPanel.ts
var IconEditorPanel = class _IconEditorPanel {
  static currentPanel;
  _panel;
  _extensionUri;
  _disposables = [];
  _iconData;
  _originalSvg = "";
  // Original SVG without color modifications
  _originalColors = [];
  _selectedVariantIndex = -1;
  _preOptimizedSvg;
  _colorService;
  _variantsService;
  static createOrShow(extensionUri, data) {
    const column = vscode47.window.activeTextEditor ? vscode47.window.activeTextEditor.viewColumn : void 0;
    if (_IconEditorPanel.currentPanel) {
      _IconEditorPanel.currentPanel._panel.reveal(column);
      if (data) {
        _IconEditorPanel.currentPanel._variantsService.resetCache();
        _IconEditorPanel.currentPanel._iconData = data;
        if (data.svg) {
          data.svg = SvgManipulationService.cleanAnimationFromSvg(data.svg);
          _IconEditorPanel.currentPanel._originalSvg = data.svg;
        }
        _IconEditorPanel.currentPanel._originalColors = _IconEditorPanel.currentPanel._colorService.extractColorsFromSvg(data.svg).colors;
        _IconEditorPanel.currentPanel._selectedVariantIndex = -1;
        _IconEditorPanel.currentPanel._ensureCustomVariant();
        _IconEditorPanel.currentPanel._update();
      }
      return;
    }
    const panel = vscode47.window.createWebviewPanel(
      "iconEditor",
      t("editor.title"),
      column || vscode47.ViewColumn.One,
      {
        enableScripts: true,
        localResourceRoots: [extensionUri],
        retainContextWhenHidden: true
      }
    );
    _IconEditorPanel.currentPanel = new _IconEditorPanel(panel, extensionUri, data);
  }
  constructor(panel, extensionUri, data) {
    this._panel = panel;
    this._extensionUri = extensionUri;
    this._iconData = data;
    this._colorService = getColorService();
    this._variantsService = getVariantsService();
    if (this._iconData?.svg) {
      this._iconData.svg = SvgManipulationService.cleanAnimationFromSvg(this._iconData.svg);
      this._originalSvg = this._iconData.svg;
      this._originalColors = this._colorService.extractColorsFromSvg(this._iconData.svg).colors;
      this._ensureCustomVariant();
    }
    this._update();
    this._panel.onDidDispose(() => this.dispose(), null, this._disposables);
    this._panel.onDidChangeViewState(
      (e) => {
        if (e.webviewPanel.visible && this._iconData) {
          vscode47.commands.executeCommand(
            "sageboxIconStudio.revealInTree",
            this._iconData.name,
            this._iconData.location?.file,
            this._iconData.location?.line
          );
        }
      },
      null,
      this._disposables
    );
    this._panel.webview.onDidReceiveMessage(
      async (message) => {
        await this._handleMessage(message);
      },
      null,
      this._disposables
    );
    if (this._iconData?.svg) {
      setTimeout(() => this._sendOptimizationStats(), 1e3);
    }
  }
  _sendOptimizationStats() {
    if (!this._iconData?.svg) return;
    const optimizer = new SvgOptimizer();
    const presets = optimizer.getPresets();
    const stats = {};
    for (const [key, options] of Object.entries(presets)) {
      const result = optimizer.optimize(this._iconData.svg, options);
      const savings = result.originalSize - result.optimizedSize;
      if (savings > 0) {
        stats[key] = `-${optimizer.formatSize(savings)}`;
      } else {
        stats[key] = "";
      }
    }
    this._panel.webview.postMessage({
      command: "optimizationStats",
      stats
    });
  }
  /**
   * Handle incoming webview messages by delegating to appropriate handlers
   */
  async _handleMessage(message) {
    if (message.command === "log") {
    }
    const colorCtx = this._createColorHandlerContext();
    const variantCtx = this._createVariantHandlerContext();
    const svgCtx = this._createSvgCodeHandlerContext();
    const iconCtx = this._createIconHandlerContext();
    switch (message.command) {
      // Color handlers
      case "previewColor":
        handlePreviewColor(colorCtx, message);
        break;
      case "changeColor":
        handleChangeColor2(colorCtx, message);
        break;
      case "replaceCurrentColor":
        handleReplaceCurrentColor(colorCtx, message);
        break;
      case "addFillColor":
        handleAddFillColor(colorCtx, message);
        break;
      case "addColor":
        handleAddColor(colorCtx, message);
        break;
      case "applyFilters":
        handleApplyFilters(
          colorCtx,
          message
        );
        if (message.thenRebuild) {
          const rebuildMsg = message;
          await handleRebuild(iconCtx, {
            animation: rebuildMsg.animation,
            animationSettings: rebuildMsg.animationSettings
          });
        }
        break;
      // Variant handlers
      case "saveVariant":
        await handleSaveVariant2(variantCtx);
        break;
      case "applyVariant":
        handleApplyVariant2(variantCtx, message);
        break;
      case "applyDefaultVariant":
        handleApplyDefaultVariant2(variantCtx);
        break;
      case "generateAutoVariant":
        handleGenerateAutoVariant(
          variantCtx,
          message
        );
        break;
      case "deleteVariant":
        handleDeleteVariant2(variantCtx, message);
        break;
      case "setDefaultVariant":
        handleSetDefaultVariant2(variantCtx, message);
        break;
      case "editVariant":
        await handleEditVariant(variantCtx, message);
        break;
      // SVG/Code handlers
      case "optimizeSvg":
        handleOptimizeSvg2(svgCtx, message);
        break;
      case "applyOptimizedSvg":
        await handleApplyOptimizedSvg2(svgCtx, message);
        break;
      case "revertOptimization":
        await handleRevertOptimization(svgCtx);
        break;
      case "copySvg":
        handleCopySvg2(svgCtx, message);
        break;
      case "copyWithAnimation":
        handleCopyWithAnimation(
          svgCtx,
          message
        );
        break;
      case "formatSvgCode":
        handleFormatSvgCode(svgCtx);
        break;
      case "updateCodeWithAnimation":
        handleUpdateCodeWithAnimation(svgCtx, message);
        break;
      case "updateAnimationCode":
        handleUpdateAnimationCode(
          svgCtx,
          message
        );
        break;
      case "showMessage":
        handleShowMessage(message);
        break;
      case "insertCodeAtCursor":
        handleInsertCodeAtCursor(message);
        break;
      // Icon handlers
      case "requestRename":
        await handleRequestRename(iconCtx, message);
        break;
      case "renameIcon":
        await handleRenameIcon(iconCtx, message);
        break;
      case "rebuild":
        await handleRebuild(
          iconCtx,
          message
        );
        break;
      case "saveAnimation":
        handleSaveAnimation(
          iconCtx,
          message
        );
        break;
      case "refresh":
        handleRefresh();
        break;
      case "log":
        break;
    }
  }
  /**
   * Create context for color handlers
   */
  _createColorHandlerContext() {
    return {
      iconData: this._iconData,
      selectedVariantIndex: this._selectedVariantIndex,
      colorService: this._colorService,
      variantsService: this._variantsService,
      postMessage: (msg) => this._panel.webview.postMessage(msg),
      updateSvg: (svg) => {
        if (this._iconData) this._iconData.svg = svg;
      },
      setSelectedVariantIndex: (index) => {
        this._selectedVariantIndex = index;
      },
      refresh: () => this._update()
    };
  }
  /**
   * Create context for variant handlers
   */
  _createVariantHandlerContext() {
    return {
      iconData: this._iconData,
      originalColors: this._originalColors,
      selectedVariantIndex: this._selectedVariantIndex,
      colorService: this._colorService,
      variantsService: this._variantsService,
      updateSvg: (svg) => {
        if (this._iconData) this._iconData.svg = svg;
      },
      setSelectedVariantIndex: (index) => {
        this._selectedVariantIndex = index;
      },
      refresh: () => this._update(),
      generateAutoVariant: (type) => this._generateAutoVariant(type)
    };
  }
  /**
   * Create context for SVG/code handlers
   */
  _createSvgCodeHandlerContext() {
    return {
      iconData: this._iconData,
      postMessage: (msg) => this._panel.webview.postMessage(msg),
      processAndSaveIcon: (options) => this._processAndSaveIcon(options),
      getPreOptimizedSvg: () => this._preOptimizedSvg,
      setPreOptimizedSvg: (svg) => {
        this._preOptimizedSvg = svg;
      }
    };
  }
  /**
   * Create context for icon handlers
   */
  _createIconHandlerContext() {
    return {
      iconData: this._iconData,
      panel: this._panel,
      postMessage: (msg) => this._panel.webview.postMessage(msg),
      updateIconName: (name) => {
        if (this._iconData) this._iconData.name = name;
      },
      updateIconLocation: (file) => {
        if (this._iconData?.location) this._iconData.location.file = file;
      },
      refresh: () => this._update(),
      addToIconCollection: (animation, settings) => this._addToIconCollection(animation, settings)
    };
  }
  /**
   * Generate HTML for the variants list
   */
  _generateVariantsHtml(iconName) {
    const variants = this._variantsService.getSavedVariants(iconName);
    const originalHtml = `
      <div class="variant-item default${this._selectedVariantIndex === -1 ? " selected" : ""}"
           onclick="applyDefaultVariant()"
           title="Original colors (read-only)">
        <div class="variant-colors">
          ${this._originalColors.slice(0, 4).map((c) => `<div class="variant-color-dot" style="background:${c}" title="${c}"></div>`).join("")}
        </div>
        <span class="variant-name">original</span>
        <span class="variant-badge readonly">read-only</span>
      </div>
    `;
    const variantsHtml = variants.map(
      (variant, index) => `
      <div class="variant-item${this._selectedVariantIndex === index ? " selected" : ""}"
           onclick="applyVariant(${index})"
           title="${variant.name} - Click to edit">
        <div class="variant-colors">
          ${variant.colors.slice(0, 4).map((c) => `<div class="variant-color-dot" style="background:${c}" title="${c}"></div>`).join("")}
        </div>
        <span class="variant-name">${variant.name}</span>
        <div class="variant-actions">
          <button class="variant-edit" onclick="event.stopPropagation(); editVariant(${index})" title="Edit variant name">
            <span class="codicon codicon-edit"></span>
          </button>
          <button class="variant-delete" onclick="event.stopPropagation(); deleteVariant(${index})" title="Delete variant">
            <span class="codicon codicon-trash"></span>
          </button>
        </div>
      </div>
    `
    ).join("");
    if (variants.length === 0) {
      return originalHtml + `<div class="no-Variants">No custom variants yet. Click + to save current colors.</div>`;
    }
    return originalHtml + variantsHtml;
  }
  // Ensure icon has stored original colors and a "custom" variant for editing
  _ensureCustomVariant() {
    if (!this._iconData) return;
    this._originalColors = this._variantsService.ensureCustomVariant(
      this._iconData.name,
      this._originalColors
    );
  }
  // ==================== Auto-generate Variants ====================
  _generateAutoVariant(type) {
    if (!this._iconData) return;
    const { colors } = this._colorService.extractColorsFromSvg(this._iconData.svg);
    if (colors.length === 0) return;
    const { colors: newColors, variantName } = this._colorService.generateAutoVariantColors(
      colors,
      type
    );
    if (!variantName) return;
    const existingVariants = this._variantsService.getSavedVariants(this._iconData.name);
    const existingNames = existingVariants.map((v) => v.name);
    let finalName = variantName;
    let counter = 2;
    while (existingNames.includes(finalName)) {
      finalName = `${variantName} ${counter}`;
      counter++;
    }
    this._variantsService.saveVariant(this._iconData.name, finalName, newColors);
    let newSvg = this._iconData.svg;
    for (let i = 0; i < colors.length; i++) {
      newSvg = this._colorService.replaceColorInSvg(newSvg, colors[i], newColors[i]);
    }
    this._iconData.svg = newSvg;
    this._selectedVariantIndex = this._variantsService.getSavedVariants(this._iconData.name).length - 1;
    this._update();
    vscode47.window.showInformationMessage(t("messages.variantGenerated", { name: finalName }));
  }
  // Animation storage methods - use animations.js in output directory
  _getOutputPath() {
    const workspaceFolders = vscode47.workspace.workspaceFolders;
    const outputDir = getSvgConfig("outputDirectory", "bezier-icons");
    if (!workspaceFolders || !outputDir) return void 0;
    return path37.join(workspaceFolders[0].uri.fsPath, outputDir);
  }
  _getIconsFilePath() {
    const outputPath = this._getOutputPath();
    if (!outputPath) return void 0;
    return path37.join(outputPath, "icons.js");
  }
  _readIconAnimation(iconName) {
    try {
      const animService = getAnimationService();
      const assigned = animService.getAnimation(iconName);
      if (assigned && assigned.type && assigned.type !== "none") {
        return {
          type: assigned.type,
          duration: assigned.duration || 1,
          timing: assigned.timing || "ease",
          iteration: assigned.iteration || "infinite",
          delay: assigned.delay,
          direction: assigned.direction
        };
      }
    } catch (err) {
      console.error("[Icon Studio] Error reading from AnimationAssignmentService:", err);
    }
    try {
      const filePath = this._getIconsFilePath();
      if (!filePath || !fs32.existsSync(filePath)) return void 0;
      const content = fs32.readFileSync(filePath, "utf-8");
      const varName = iconName.replace(/-([a-z0-9])/gi, (_, c) => c.toUpperCase());
      const iconStartPattern = new RegExp(String.raw`export\s+const\s+${varName}\s*=\s*\{`, "g");
      const startMatch = iconStartPattern.exec(content);
      if (!startMatch) return void 0;
      const startIndex = startMatch.index;
      const nextExportMatch = content.slice(startIndex + 1).match(/\nexport\s+const\s+/);
      const endIndex = nextExportMatch ? startIndex + 1 + nextExportMatch.index : content.length;
      const iconDefinition = content.slice(startIndex, endIndex);
      const animationMatch = iconDefinition.match(/animation:\s*(\{[^}]+\})/);
      if (!animationMatch) return void 0;
      return new Function(`return ${animationMatch[1]}`)();
    } catch {
      return void 0;
    }
  }
  async _saveAnimation(iconName, type, settings) {
    const outputPath = this._getOutputPath();
    if (!outputPath) return;
    const animation = {
      type,
      duration: settings.duration,
      timing: settings.timing,
      iteration: settings.iteration,
      delay: settings.delay,
      direction: settings.direction
    };
    await updateIconAnimation(outputPath, iconName, animation);
  }
  async _removeAnimation(iconName) {
    const outputPath = this._getOutputPath();
    if (!outputPath) return;
    await updateIconAnimation(outputPath, iconName, null);
  }
  _getIconAnimation(iconName) {
    return this._readIconAnimation(iconName);
  }
  async _processAndSaveIcon(options) {
    if (!this._iconData) {
      return;
    }
    let svgToSave = options.svg;
    svgToSave = SvgManipulationService.cleanAnimationFromSvg(svgToSave);
    svgToSave = SvgManipulationService.ensureSvgNamespace(svgToSave);
    if (options.includeAnimationInFile && options.animation && options.animation !== "none") {
      const settings = options.animationSettings || {
        duration: 2,
        timing: "linear",
        iteration: "infinite"
      };
      svgToSave = SvgManipulationService.embedAnimationInSvg(
        svgToSave,
        options.animation,
        settings
      );
    }
    this._iconData.svg = svgToSave;
    if (options.updateAnimationMetadata) {
      if (options.animation && options.animation !== "none") {
        const settings = options.animationSettings || {
          duration: 2,
          timing: "linear",
          iteration: "infinite"
        };
        await this._saveAnimation(this._iconData.name, options.animation, settings);
      } else {
        await this._removeAnimation(this._iconData.name);
      }
    }
    if (this._iconData.spriteFile) {
      const updated = await this._updateSpriteFile(svgToSave);
      if (!updated) {
        vscode47.window.showWarningMessage(t("messages.couldNotUpdateSprite"));
        return;
      }
      if (options.triggerFullRebuild) {
        vscode47.commands.executeCommand("sageboxIconStudio.buildIcons");
      }
    } else {
      const updated = await this._updateBuiltIconsFile(svgToSave);
      if (!updated) {
        vscode47.window.showWarningMessage(t("messages.couldNotFindIconsJs"));
        return;
      }
    }
    this._originalColors = this._colorService.extractColorsFromSvg(svgToSave).colors;
    if (!options.skipPanelUpdate) {
      this._update();
    }
    await vscode47.commands.executeCommand("sageboxIconStudio.refreshIconByName", this._iconData.name);
    if (options.successMessage) {
      vscode47.window.showInformationMessage(options.successMessage);
    }
  }
  /**
   * Add icon to the icon collection
   * Uses buildFormat from config: sprite.svg OR icons.js (not both)
   * Saves the ORIGINAL SVG (without color modifications) to icons.js
   * Color mappings are saved separately in variants.js
   */
  async _addToIconCollection(animation, animationSettings) {
    if (!this._iconData) {
      vscode47.window.showWarningMessage(t("messages.noIconData"));
      return;
    }
    const outputPath = getOutputPathOrWarn();
    if (!outputPath) return;
    try {
      const config = getConfig();
      const isSprite = config.buildFormat === "sprite.svg";
      let svgToAdd = this._originalSvg || this._iconData.svg;
      svgToAdd = SvgManipulationService.cleanAnimationFromSvg(svgToAdd);
      svgToAdd = SvgManipulationService.ensureSvgNamespace(svgToAdd);
      svgToAdd = getIconPersistenceService().ensureSvgId(svgToAdd, this._iconData.name);
      const transformer = new SvgTransformer();
      if (isSprite) {
        await addToSpriteSvg(outputPath, this._iconData.name, svgToAdd, transformer);
        this._iconData.svg = svgToAdd;
        this._iconData.spriteFile = path37.join(outputPath, "sprite.svg");
        vscode47.window.showInformationMessage(
          t("messages.iconAddedToSprite", { name: this._iconData.name })
        );
      } else {
        let animConfig;
        if (animation && animation !== "none") {
          const settings = animationSettings || {
            duration: 1,
            timing: "ease",
            iteration: "infinite"
          };
          animConfig = {
            type: animation,
            duration: settings.duration,
            timing: settings.timing,
            iteration: settings.iteration,
            delay: settings.delay,
            direction: settings.direction
          };
        }
        await addToIconsJs({
          outputPath,
          iconName: this._iconData.name,
          svgContent: svgToAdd,
          transformer,
          animation: animConfig
        });
        this._iconData.svg = svgToAdd;
        this._iconData.iconsFile = path37.join(outputPath, "icons.js");
        if (animConfig) {
          vscode47.window.showInformationMessage(
            t("messages.iconAddedWithAnimation", { name: this._iconData.name })
          );
        } else {
          vscode47.window.showInformationMessage(
            t("messages.iconAddedToIconsJs", { name: this._iconData.name })
          );
        }
        await vscode47.commands.executeCommand(
          "sageboxIconStudio.refreshFilesItemByName",
          this._iconData.name
        );
        await vscode47.commands.executeCommand(
          "sageboxIconStudio.addIconToBuiltAndRefresh",
          this._iconData.name,
          svgToAdd,
          this._iconData.iconsFile,
          animConfig
          // Pass animation config
        );
      }
      if (this._variantsService.hasUnsavedChanges) {
        this._variantsService.persistToFile();
      }
      this._update();
    } catch (error) {
      vscode47.window.showErrorMessage(t("messages.failedToAddIcon", { error: error.message }));
    }
  }
  /**
   * Update icon in sprite.svg file (delegates to persistence service)
   */
  async _updateSpriteFile(svg) {
    if (!this._iconData?.name || !this._iconData.spriteFile) {
      return false;
    }
    return getIconPersistenceService().updateSpriteFile(
      this._iconData.name,
      svg,
      this._iconData.spriteFile,
      this._iconData.viewBox
    );
  }
  /**
   * Update icon in icons.js file (delegates to persistence service)
   */
  async _updateBuiltIconsFile(svg) {
    if (!this._iconData?.name) {
      return false;
    }
    return getIconPersistenceService().updateBuiltIconsFile(this._iconData.name, svg);
  }
  dispose() {
    _IconEditorPanel.currentPanel = void 0;
    this._panel.dispose();
    while (this._disposables.length) {
      const x = this._disposables.pop();
      if (x) x.dispose();
    }
  }
  _update() {
    if (this._iconData) {
      this._panel.title = `Edit: ${this._iconData.name}`;
    }
    const html = this._getHtmlForWebview();
    this._panel.webview.html = html;
    if (this._iconData?.svg) {
      setTimeout(() => this._sendOptimizationStats(), 100);
    }
  }
  _getHtmlForWebview() {
    if (!this._iconData) {
      return "<html><body><p>No icon selected</p></body></html>";
    }
    const { name, svg, location: _location, isBuilt, animation } = this._iconData;
    const _defaultVariant = this._variantsService.getDefaultVariant(name);
    const savedAnimation = this._getIconAnimation(name);
    let detectedAnimation = SvgManipulationService.detectAnimationFromSvg(svg);
    if (!detectedAnimation && animation) {
      detectedAnimation = { type: animation.type, settings: animation };
    }
    if (!detectedAnimation && savedAnimation) {
      detectedAnimation = { type: savedAnimation.type, settings: savedAnimation };
    }
    const colorRegex = /(fill|stroke|stop-color)=["']([^"']+)["']/gi;
    const styleColorRegex = /(fill|stroke|stop-color)\s*:\s*([^;"'\s]+)/gi;
    const colorsSet = /* @__PURE__ */ new Set();
    const specialColors = /* @__PURE__ */ new Set();
    let colorMatch;
    while ((colorMatch = colorRegex.exec(svg)) !== null) {
      const color = colorMatch[2].toLowerCase();
      if (color === "currentcolor") {
        specialColors.add("currentColor");
      } else if (color !== "none" && color !== "transparent" && !color.startsWith("url(")) {
        colorsSet.add(color);
      }
    }
    while ((colorMatch = styleColorRegex.exec(svg)) !== null) {
      const color = colorMatch[2].toLowerCase();
      if (color === "currentcolor") {
        specialColors.add("currentColor");
      } else if (color !== "none" && color !== "transparent" && !color.startsWith("url(")) {
        colorsSet.add(color);
      }
    }
    const allColors = Array.from(colorsSet);
    const totalColorCount = allColors.length;
    const MAX_COLORS_TO_SHOW = 50;
    const svgColors = allColors.slice(0, MAX_COLORS_TO_SHOW);
    const hasMoreColors = totalColorCount > MAX_COLORS_TO_SHOW;
    const hasCurrentColor = specialColors.has("currentColor");
    let displaySvg = svg;
    if (!svg.includes("width=") && !svg.includes("style=")) {
      displaySvg = svg.replace("<svg", '<svg width="100%" height="100%"');
    }
    const fileSize = new Blob([svg]).size;
    const fileSizeStr = fileSize < 1024 ? `${fileSize} B` : `${(fileSize / 1024).toFixed(1)} KB`;
    const templatesDir = path37.join(this._extensionUri.fsPath, "dist", "templates", "icon-editor");
    const tabsDir = path37.join(templatesDir, "tabs");
    let cssContent, jsTemplate, bodyTemplate;
    let colorTabTemplate, animationTabTemplate, codeTabTemplate;
    try {
      const baseCss = fs32.readFileSync(path37.join(templatesDir, "IconEditor.css"), "utf-8");
      const colorCss = fs32.readFileSync(path37.join(tabsDir, "IconEditorColor.css"), "utf-8");
      const filtersCss = fs32.readFileSync(path37.join(tabsDir, "IconEditorFilters.css"), "utf-8");
      const animationCss = fs32.readFileSync(path37.join(tabsDir, "IconEditorAnimation.css"), "utf-8");
      const codeCss = fs32.readFileSync(path37.join(tabsDir, "IconEditorCode.css"), "utf-8");
      cssContent = baseCss + "\n" + colorCss + "\n" + filtersCss + "\n" + animationCss + "\n" + codeCss;
      jsTemplate = fs32.readFileSync(path37.join(templatesDir, "IconEditor.js"), "utf-8");
      bodyTemplate = fs32.readFileSync(path37.join(templatesDir, "IconEditorBody.html"), "utf-8");
      colorTabTemplate = fs32.readFileSync(path37.join(tabsDir, "IconEditorColorTab.html"), "utf-8");
      animationTabTemplate = fs32.readFileSync(
        path37.join(tabsDir, "IconEditorAnimationTab.html"),
        "utf-8"
      );
      codeTabTemplate = fs32.readFileSync(path37.join(tabsDir, "IconEditorCodeTab.html"), "utf-8");
    } catch (err) {
      console.error("[Icon Studio] IconEditorPanel template load error:", err);
      return "<html><body><p>Error loading templates</p></body></html>";
    }
    const i18nObject = {
      svgWillIncludeAnimation: t("webview.js.svgWillIncludeAnimation"),
      svgCodeCopied: t("webview.js.svgCodeCopied"),
      animationCssCopied: t("webview.js.animationCssCopied"),
      usageCodeCopied: t("webview.js.usageCodeCopied"),
      optimizeSvgo: t("webview.js.optimizeSvgo"),
      optimal: t("webview.js.optimal"),
      alreadyOptimized: t("webview.js.alreadyOptimized"),
      selectAnimationToEnable: t("webview.js.selectAnimationToEnable"),
      originalColor: t("webview.js.originalColor"),
      addFillColor: t("webview.js.addFillColor"),
      noColorsDetected: t("webview.js.noColorsDetected")
    };
    const jsContent = jsTemplate.replace(/__I18N__/g, JSON.stringify(i18nObject)).replace(/__ANIMATION_TYPE__/g, JSON.stringify(detectedAnimation?.type || "none")).replace(
      /__ANIMATION_DURATION__/g,
      JSON.stringify(detectedAnimation?.settings?.duration || 1)
    ).replace(
      /__ANIMATION_TIMING__/g,
      JSON.stringify(detectedAnimation?.settings?.timing || "ease")
    ).replace(
      /__ANIMATION_ITERATION__/g,
      JSON.stringify(detectedAnimation?.settings?.iteration || "infinite")
    ).replace(/__ANIMATION_DELAY__/g, JSON.stringify(detectedAnimation?.settings?.delay || 0)).replace(
      /__ANIMATION_DIRECTION__/g,
      JSON.stringify(detectedAnimation?.settings?.direction || "normal")
    ).replace(/__ORIGINAL_COLORS__/g, JSON.stringify(this._originalColors)).replace(/__CURRENT_COLORS__/g, JSON.stringify(svgColors));
    const templateService = getIconEditorTemplateService();
    const colorTabContent = this._generateColorTabHtml(
      colorTabTemplate,
      hasMoreColors,
      totalColorCount,
      svgColors,
      hasCurrentColor
    );
    const animationTabContent = templateService.generateAnimationTabHtml(
      animationTabTemplate,
      detectedAnimation
    );
    const codeTabContent = templateService.generateCodeTabHtml(
      codeTabTemplate,
      name,
      svg,
      detectedAnimation
    );
    const htmlBody = templateService.generateHtmlBody(bodyTemplate, {
      name,
      displaySvg,
      fileSizeStr,
      isBuilt,
      colorTabContent,
      animationTabContent,
      codeTabContent,
      animationName: detectedAnimation?.type
    });
    const cspSource = this._panel.webview.cspSource;
    return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta http-equiv="Content-Security-Policy" content="default-src 'none'; style-src ${cspSource} 'unsafe-inline' https://unpkg.com; script-src 'unsafe-inline' ${cspSource}; img-src ${cspSource} https: data:; font-src ${cspSource} https://unpkg.com;">
  <link rel="stylesheet" href="https://unpkg.com/@vscode/codicons/dist/codicon.css" />
  <style>
${cssContent}
  </style>
</head>
${htmlBody}
  <script>
${jsContent}
  </script>
</body>
</html>`;
  }
  /**
   * Generate Color Tab HTML from template
   */
  _generateColorTabHtml(template, hasMoreColors, totalColorCount, svgColors, hasCurrentColor) {
    if (hasMoreColors) {
      return `
        <div class="section disabled-section">
          <div class="section-title">
            <span class="codicon codicon-paintcan"></span> Colors
          </div>
          <div class="colors-warning">
            <span class="codicon codicon-warning"></span>
            This SVG has ${totalColorCount} unique colors. Color editing is disabled for rasterized SVGs.
          </div>
        </div>
        <div class="section disabled-section">
          <div class="section-title">
            <span class="codicon codicon-symbol-color"></span> Variants
          </div>
          <div class="Variants-disabled-message">
            <span class="codicon codicon-info"></span> Variants disabled for SVGs with too many colors
          </div>
        </div>
      `;
    }
    const colorSwatches = svgColors.map((color, _index) => {
      const escapedColor = color.replace(/'/g, "\\'").replace(/"/g, '\\"');
      return `
      <div class="color-item" title="Click to change color">
        <div class="color-swatch" style="background-color: ${color}">
          <input type="color" value="${this._colorService.toHexColor(color)}" 
            data-original-color="${escapedColor}"
            onchange="changeColor(this.dataset.originalColor, this.value)"
            oninput="previewColor(this.dataset.originalColor, this.value)" />
        </div>
        <span class="color-label" onclick="copyToClipboard('${escapedColor}')" title="Click to copy: ${color}">${color}</span>
      </div>
    `;
    }).join("");
    const currentColorHtml = hasCurrentColor ? `
      <div class="current-color-item">
        <div class="current-color-swatch" title="currentColor - inherits from CSS">
          <input type="color" value="#000000" 
            onchange="replaceCurrentColor(this.value)" />
          <span class="current-color-icon codicon codicon-paintcan"></span>
        </div>
        <span class="current-color-label">currentColor</span>
      </div>
    ` : "";
    const isOriginalSelected = this._selectedVariantIndex === -1;
    return template.replace(/\$\{colorsDisabledClass\}/g, isOriginalSelected ? " colors-disabled" : "").replace(
      /\$\{colorsHint\}/g,
      isOriginalSelected ? '<span class="colors-hint">(select custom to edit)</span>' : ""
    ).replace(/\$\{swatchesDisabledClass\}/g, isOriginalSelected ? " disabled" : "").replace(/\$\{filtersDisabledClass\}/g, isOriginalSelected ? " colors-disabled" : "").replace(
      /\$\{filtersHint\}/g,
      isOriginalSelected ? '<span class="colors-hint">(select custom)</span>' : ""
    ).replace(/\$\{filtersContainerDisabledClass\}/g, isOriginalSelected ? " disabled" : "").replace(/\$\{filtersDisabled\}/g, isOriginalSelected ? " disabled" : "").replace(/\$\{currentColorHtml\}/g, currentColorHtml).replace(/\$\{colorSwatches\}/g, colorSwatches).replace(/\$\{variantsHtml\}/g, this._generateVariantsHtml(this._iconData?.name || "")).replace(/\$\{i18n_colors\}/g, t("webview.color.colors")).replace(/\$\{i18n_globalFilters\}/g, t("webview.color.globalFilters")).replace(/\$\{i18n_hueRotate\}/g, t("webview.color.hueRotate")).replace(/\$\{i18n_saturation\}/g, t("webview.color.saturation")).replace(/\$\{i18n_brightness\}/g, t("webview.color.brightness")).replace(/\$\{i18n_reset\}/g, t("webview.color.reset")).replace(/\$\{i18n_resetFilters\}/g, t("webview.color.resetFilters")).replace(/\$\{i18n_variants\}/g, t("webview.color.variants")).replace(/\$\{i18n_saveVariant\}/g, t("webview.color.saveVariant"));
  }
};

// src/commands/editorCommands.ts
init_IconDetailsPanel();

// src/services/ComponentExporter.ts
var ComponentExporter = class {
  /**
   * Export SVG to component in specified format
   */
  export(options) {
    const { format, typescript: _typescript } = options;
    switch (format) {
      case "react":
      case "preact":
        return this.exportReact(options);
      case "react-native":
        return this.exportReactNative(options);
      case "vue":
        return this.exportVueComposition(options);
      case "vue-sfc":
        return this.exportVueSFC(options);
      case "svelte":
        return this.exportSvelte(options);
      case "angular":
        return this.exportAngular(options);
      case "solid":
        return this.exportSolid(options);
      case "qwik":
        return this.exportQwik(options);
      default:
        throw new Error(`Unsupported format: ${format}`);
    }
  }
  /**
   * Get all available formats
   */
  getFormats() {
    return [
      { id: "react", name: "React", description: "React functional component with props spread" },
      { id: "react-native", name: "React Native", description: "React Native SVG component" },
      { id: "vue", name: "Vue 3 (Composition)", description: "Vue 3 with script setup" },
      { id: "vue-sfc", name: "Vue SFC", description: "Vue Single File Component" },
      { id: "svelte", name: "Svelte", description: "Svelte component" },
      { id: "angular", name: "Angular", description: "Angular component with @Input" },
      { id: "solid", name: "SolidJS", description: "Solid component" },
      { id: "qwik", name: "Qwik", description: "Qwik component" },
      { id: "preact", name: "Preact", description: "Preact functional component" }
    ];
  }
  // ==================== React ====================
  exportReact(options) {
    const {
      iconName,
      svg,
      typescript,
      memo,
      forwardRef,
      exportType,
      defaultSize = 24,
      defaultColor = "currentColor"
    } = options;
    const componentName = this.toPascalCase(iconName);
    const ext = typescript ? "tsx" : "jsx";
    const { attributes, innerContent } = this.parseSvg(svg);
    const propsType = typescript ? `interface ${componentName}Props extends React.SVGProps<SVGSVGElement> {
  size?: number | string;
  color?: string;
}` : "";
    let code = "";
    if (typescript) {
      code += `import React from 'react';

`;
      code += propsType + "\n\n";
    } else {
      code += `import React from 'react';

`;
    }
    const propsArg = typescript ? `{ size = ${defaultSize}, color = '${defaultColor}', ...props }: ${componentName}Props` : `{ size = ${defaultSize}, color = '${defaultColor}', ...props }`;
    if (forwardRef) {
      const refType = typescript ? `React.Ref<SVGSVGElement>` : "";
      code += `const ${componentName} = React.forwardRef${typescript ? `<SVGSVGElement, ${componentName}Props>` : ""}((${propsArg}, ref${typescript ? `: ${refType}` : ""}) => (
`;
    } else {
      code += `const ${componentName} = (${propsArg}) => (
`;
    }
    code += `  <svg
`;
    code += `    ref={${forwardRef ? "ref" : "undefined"}}
`;
    code += `    width={size}
`;
    code += `    height={size}
`;
    code += `    viewBox="${attributes.viewBox || "0 0 24 24"}"
`;
    code += `    fill="${attributes.fill || "none"}"
`;
    code += `    stroke={color}
`;
    code += `    strokeWidth="${attributes["stroke-width"] || attributes.strokeWidth || "2"}"
`;
    code += `    strokeLinecap="${attributes["stroke-linecap"] || attributes.strokeLinecap || "round"}"
`;
    code += `    strokeLinejoin="${attributes["stroke-linejoin"] || attributes.strokeLinejoin || "round"}"
`;
    code += `    {...props}
`;
    code += `  >
`;
    code += `    ${this.convertToJSX(innerContent)}
`;
    code += `  </svg>
`;
    if (forwardRef) {
      code += `));

`;
      code += `${componentName}.displayName = '${componentName}';

`;
    } else {
      code += `);

`;
    }
    if (memo && !forwardRef) {
      code += `export ${exportType === "default" ? "default" : `const ${componentName}Memo =`} React.memo(${componentName});
`;
    } else {
      code += `export ${exportType === "default" ? "default" : ""} ${exportType === "named" ? `{ ${componentName} }` : componentName};
`;
    }
    return {
      code,
      filename: `${componentName}.${ext}`,
      language: typescript ? "typescriptreact" : "javascriptreact"
    };
  }
  // ==================== React Native ====================
  exportReactNative(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const ext = typescript ? "tsx" : "jsx";
    const { attributes, innerContent } = this.parseSvg(svg);
    let code = typescript ? `import React from 'react';
import Svg, { Path, Circle, Rect, Line, Polyline, Polygon, G } from 'react-native-svg';

interface ${componentName}Props {
  size?: number;
  color?: string;
}

const ${componentName}: React.FC<${componentName}Props> = ({ size = ${defaultSize}, color = '${defaultColor}' }) => (
` : `import React from 'react';
import Svg, { Path, Circle, Rect, Line, Polyline, Polygon, G } from 'react-native-svg';

const ${componentName} = ({ size = ${defaultSize}, color = '${defaultColor}' }) => (
`;
    code += `  <Svg width={size} height={size} viewBox="${attributes.viewBox || "0 0 24 24"}" fill="none">
`;
    code += `    ${this.convertToReactNative(innerContent, "color")}
`;
    code += `  </Svg>
`;
    code += `);

`;
    code += `export default ${componentName};
`;
    return {
      code,
      filename: `${componentName}.${ext}`,
      language: typescript ? "typescriptreact" : "javascriptreact"
    };
  }
  // ==================== Vue 3 Composition ====================
  exportVueComposition(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const { attributes, innerContent } = this.parseSvg(svg);
    const code = `<script setup${typescript ? ' lang="ts"' : ""}>
${typescript ? `interface Props {
  size?: number | string;
  color?: string;
}

` : ""}defineProps${typescript ? "<Props>" : ""}({
  size: { type: [Number, String], default: ${defaultSize} },
  color: { type: String, default: '${defaultColor}' }
});
</script>

<template>
  <svg
    :width="size"
    :height="size"
    viewBox="${attributes.viewBox || "0 0 24 24"}"
    fill="${attributes.fill || "none"}"
    :stroke="color"
    stroke-width="${attributes["stroke-width"] || "2"}"
    stroke-linecap="${attributes["stroke-linecap"] || "round"}"
    stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
  >
    ${innerContent.trim()}
  </svg>
</template>
`;
    return {
      code,
      filename: `${componentName}.vue`,
      language: "vue"
    };
  }
  // ==================== Vue SFC (Options API) ====================
  exportVueSFC(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const { attributes, innerContent } = this.parseSvg(svg);
    const code = `<template>
  <svg
    :width="size"
    :height="size"
    viewBox="${attributes.viewBox || "0 0 24 24"}"
    fill="${attributes.fill || "none"}"
    :stroke="color"
    stroke-width="${attributes["stroke-width"] || "2"}"
    stroke-linecap="${attributes["stroke-linecap"] || "round"}"
    stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
  >
    ${innerContent.trim()}
  </svg>
</template>

<script${typescript ? ' lang="ts"' : ""}>
${typescript ? `import { defineComponent, PropType } from 'vue';

` : ""}export default ${typescript ? "defineComponent(" : ""}{
  name: '${componentName}',
  props: {
    size: {
      type: ${typescript ? "[Number, String] as PropType<number | string>" : "[Number, String]"},
      default: ${defaultSize}
    },
    color: {
      type: String,
      default: '${defaultColor}'
    }
  }
}${typescript ? ")" : ""};
</script>
`;
    return {
      code,
      filename: `${componentName}.vue`,
      language: "vue"
    };
  }
  // ==================== Svelte ====================
  exportSvelte(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const { attributes, innerContent } = this.parseSvg(svg);
    const code = `<script${typescript ? ' lang="ts"' : ""}>
  export let size${typescript ? ": number | string" : ""} = ${defaultSize};
  export let color${typescript ? ": string" : ""} = '${defaultColor}';
</script>

<svg
  width={size}
  height={size}
  viewBox="${attributes.viewBox || "0 0 24 24"}"
  fill="${attributes.fill || "none"}"
  stroke={color}
  stroke-width="${attributes["stroke-width"] || "2"}"
  stroke-linecap="${attributes["stroke-linecap"] || "round"}"
  stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
  {...$$restProps}
>
  ${innerContent.trim()}
</svg>
`;
    return {
      code,
      filename: `${componentName}.svelte`,
      language: "svelte"
    };
  }
  // ==================== Angular ====================
  exportAngular(options) {
    const { iconName, svg, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const selector = this.toKebabCase(iconName);
    const { attributes, innerContent } = this.parseSvg(svg);
    const code = `import { Component, Input } from '@angular/core';

@Component({
  selector: '${selector}-icon',
  standalone: true,
  template: \`
    <svg
      [attr.width]="size"
      [attr.height]="size"
      viewBox="${attributes.viewBox || "0 0 24 24"}"
      fill="${attributes.fill || "none"}"
      [attr.stroke]="color"
      stroke-width="${attributes["stroke-width"] || "2"}"
      stroke-linecap="${attributes["stroke-linecap"] || "round"}"
      stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
    >
      ${innerContent.trim()}
    </svg>
  \`
})
export class ${componentName}IconComponent {
  @Input() size: number | string = ${defaultSize};
  @Input() color: string = '${defaultColor}';
}
`;
    return {
      code,
      filename: `${selector}-icon.component.ts`,
      language: "typescript"
    };
  }
  // ==================== SolidJS ====================
  exportSolid(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const ext = typescript ? "tsx" : "jsx";
    const { attributes, innerContent } = this.parseSvg(svg);
    let code = "";
    if (typescript) {
      code += `import { Component, JSX, splitProps, mergeProps } from 'solid-js';

interface ${componentName}Props extends JSX.SvgSVGAttributes<SVGSVGElement> {
  size?: number | string;
  color?: string;
}

const ${componentName}: Component<${componentName}Props> = (props) => {
  const merged = mergeProps({ size: ${defaultSize}, color: '${defaultColor}' }, props);
  const [local, others] = splitProps(merged, ['size', 'color']);

  return (
`;
    } else {
      code += `import { splitProps, mergeProps } from 'solid-js';

const ${componentName} = (props) => {
  const merged = mergeProps({ size: ${defaultSize}, color: '${defaultColor}' }, props);
  const [local, others] = splitProps(merged, ['size', 'color']);

  return (
`;
    }
    code += `    <svg
      width={local.size}
      height={local.size}
      viewBox="${attributes.viewBox || "0 0 24 24"}"
      fill="${attributes.fill || "none"}"
      stroke={local.color}
      stroke-width="${attributes["stroke-width"] || "2"}"
      stroke-linecap="${attributes["stroke-linecap"] || "round"}"
      stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
      {...others}
    >
      ${this.convertToJSX(innerContent)}
    </svg>
  );
};

export default ${componentName};
`;
    return {
      code,
      filename: `${componentName}.${ext}`,
      language: typescript ? "typescriptreact" : "javascriptreact"
    };
  }
  // ==================== Qwik ====================
  exportQwik(options) {
    const { iconName, svg, typescript, defaultSize = 24, defaultColor = "currentColor" } = options;
    const componentName = this.toPascalCase(iconName);
    const ext = typescript ? "tsx" : "jsx";
    const { attributes, innerContent } = this.parseSvg(svg);
    const code = `import { component$${typescript ? ", QwikIntrinsicElements" : ""} } from '@builder.io/qwik';

${typescript ? `interface ${componentName}Props {
  size?: number | string;
  color?: string;
}

` : ""}export const ${componentName} = component$${typescript ? `<${componentName}Props>` : ""}(({ size = ${defaultSize}, color = '${defaultColor}' }) => {
  return (
    <svg
      width={size}
      height={size}
      viewBox="${attributes.viewBox || "0 0 24 24"}"
      fill="${attributes.fill || "none"}"
      stroke={color}
      stroke-width="${attributes["stroke-width"] || "2"}"
      stroke-linecap="${attributes["stroke-linecap"] || "round"}"
      stroke-linejoin="${attributes["stroke-linejoin"] || "round"}"
    >
      ${this.convertToJSX(innerContent)}
    </svg>
  );
});
`;
    return {
      code,
      filename: `${componentName}.${ext}`,
      language: typescript ? "typescriptreact" : "javascriptreact"
    };
  }
  // ==================== Helpers ====================
  parseSvg(svg) {
    const attributes = {};
    const svgTagMatch = svg.match(/<svg([^>]*)>/i);
    if (svgTagMatch) {
      const attrStr = svgTagMatch[1];
      const attrRegex = /(\w+[-\w]*)=["']([^"']*)["']/g;
      let match;
      while ((match = attrRegex.exec(attrStr)) !== null) {
        attributes[match[1]] = match[2];
      }
    }
    const innerMatch = svg.match(/<svg[^>]*>([\s\S]*)<\/svg>/i);
    const innerContent = innerMatch ? innerMatch[1].trim() : "";
    return { attributes, innerContent };
  }
  convertToJSX(content) {
    return content.replace(/stroke-width=/g, "strokeWidth=").replace(/stroke-linecap=/g, "strokeLinecap=").replace(/stroke-linejoin=/g, "strokeLinejoin=").replace(/stroke-dasharray=/g, "strokeDasharray=").replace(/stroke-dashoffset=/g, "strokeDashoffset=").replace(/stroke-miterlimit=/g, "strokeMiterlimit=").replace(/stroke-opacity=/g, "strokeOpacity=").replace(/fill-opacity=/g, "fillOpacity=").replace(/fill-rule=/g, "fillRule=").replace(/clip-path=/g, "clipPath=").replace(/clip-rule=/g, "clipRule=").replace(/font-family=/g, "fontFamily=").replace(/font-size=/g, "fontSize=").replace(/text-anchor=/g, "textAnchor=").replace(/stop-color=/g, "stopColor=").replace(/stop-opacity=/g, "stopOpacity=").replace(/\sclass=/g, " className=");
  }
  convertToReactNative(content, colorVar) {
    return content.replace(/<path/g, "<Path").replace(/<\/path>/g, "</Path>").replace(/<circle/g, "<Circle").replace(/<\/circle>/g, "</Circle>").replace(/<rect/g, "<Rect").replace(/<\/rect>/g, "</Rect>").replace(/<line/g, "<Line").replace(/<\/line>/g, "</Line>").replace(/<polyline/g, "<Polyline").replace(/<\/polyline>/g, "</Polyline>").replace(/<polygon/g, "<Polygon").replace(/<\/polygon>/g, "</Polygon>").replace(/<g/g, "<G").replace(/<\/g>/g, "</G>").replace(/stroke="currentColor"/g, `stroke={${colorVar}}`).replace(/stroke="[^"]+"/g, `stroke={${colorVar}}`).replace(/stroke-width=/g, "strokeWidth=").replace(/stroke-linecap=/g, "strokeLinecap=").replace(/stroke-linejoin=/g, "strokeLinejoin=").replace(/fill-rule=/g, "fillRule=");
  }
  toPascalCase(str) {
    return str.split(/[-_\s]+/).map((word) => word.charAt(0).toUpperCase() + word.slice(1).toLowerCase()).join("");
  }
  toKebabCase(str) {
    return str.replace(/([a-z])([A-Z])/g, "$1-$2").replace(/[\s_]+/g, "-").toLowerCase();
  }
};
var exporterInstance;
function getComponentExporter() {
  if (!exporterInstance) {
    exporterInstance = new ComponentExporter();
  }
  return exporterInstance;
}

// src/commands/editorCommands.ts
init_i18n();
function registerEditorCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, iconPreviewProvider: iconPreviewProvider2 } = providers;
  const disposables = [];
  const previewIconCmd = vscode48.commands.registerCommand("sageboxIconStudio.previewIcon", (item) => {
    if (item?.icon?.svg) {
      const svgData = workspaceSvgProvider2.getSvgData(item);
      if (svgData) {
        iconPreviewProvider2.updatePreview(
          svgData.name,
          svgData.svg,
          svgData.location,
          item.contextValue === "builtIcon",
          svgData.animation
        );
      }
    }
  });
  disposables.push(previewIconCmd);
  const colorEditorCmd = vscode48.commands.registerCommand(
    "sageboxIconStudio.colorEditor",
    async (iconNameOrItem) => {
      let iconName;
      let svg;
      let filePath;
      let lineNumber;
      let isBuilt = false;
      let animation;
      if (iconNameOrItem instanceof vscode48.Uri) {
        filePath = iconNameOrItem.fsPath;
        if (filePath.toLowerCase().endsWith(".svg") && fs33.existsSync(filePath)) {
          svg = fs33.readFileSync(filePath, "utf-8");
          iconName = path38.basename(filePath, path38.extname(filePath));
          lineNumber = 1;
        } else {
          vscode48.window.showWarningMessage(t("messages.pleaseSelectValidSvgFile"));
          return;
        }
      } else if (typeof iconNameOrItem === "string") {
        iconName = iconNameOrItem;
      } else if (iconNameOrItem?.icon) {
        const svgData = workspaceSvgProvider2.getSvgData(iconNameOrItem);
        if (svgData) {
          iconName = svgData.name;
          svg = svgData.svg;
          filePath = svgData.location?.file;
          lineNumber = svgData.location?.line;
          animation = svgData.animation;
        } else {
          iconName = iconNameOrItem.icon.name;
          svg = iconNameOrItem.icon.svg;
          filePath = iconNameOrItem.icon.filePath || iconNameOrItem.icon.path;
          lineNumber = iconNameOrItem.icon.line;
          animation = iconNameOrItem.icon.animation;
        }
        isBuilt = iconNameOrItem.contextValue === "builtIcon";
      } else {
        const editor = vscode48.window.activeTextEditor;
        if (editor && !editor.selection.isEmpty) {
          const selectedText = editor.document.getText(editor.selection);
          if (selectedText.includes("<svg")) {
            svg = selectedText;
            iconName = "selected-svg";
            filePath = editor.document.uri.fsPath;
            lineNumber = editor.selection.start.line;
          }
        }
      }
      if (!iconName) {
        vscode48.window.showWarningMessage(t("messages.selectIconFromTreeOrEditor"));
        return;
      }
      if (!svg) {
        const icon = workspaceSvgProvider2.getIconByName(iconName);
        if (icon?.svg) {
          svg = icon.svg;
          filePath = icon.filePath || icon.path;
          lineNumber = icon.line;
        }
      }
      if (!svg) {
        vscode48.window.showWarningMessage(t("messages.couldNotFindSvgData", { name: iconName }));
        return;
      }
      const MAX_COLORS_FOR_EDIT = 50;
      const colorMatches = svg.match(
        /#[0-9a-fA-F]{3,8}\b|rgb\([^)]+\)|rgba\([^)]+\)|hsl\([^)]+\)|hsla\([^)]+\)/gi
      );
      const uniqueColors = colorMatches ? new Set(colorMatches.map((c) => c.toLowerCase())).size : 0;
      if (uniqueColors > MAX_COLORS_FOR_EDIT) {
        vscode48.window.showWarningMessage(
          t("messages.cannotEditRasterized", {
            name: iconName,
            colors: uniqueColors,
            maxColors: MAX_COLORS_FOR_EDIT
          })
        );
        return;
      }
      IconEditorPanel.createOrShow(context.extensionUri, {
        name: iconName,
        svg,
        location: filePath && lineNumber !== void 0 ? { file: filePath, line: lineNumber } : void 0,
        isBuilt,
        animation
      });
      vscode48.commands.executeCommand("sageboxIconStudio.revealInTree", iconName, filePath, lineNumber);
    }
  );
  disposables.push(colorEditorCmd);
  const showDetailsCmd = vscode48.commands.registerCommand(
    "sageboxIconStudio.showDetails",
    async (item) => {
      let iconName;
      let svg;
      let filePath;
      let lineNumber;
      let isBuilt = false;
      let animation;
      if (item instanceof vscode48.Uri) {
        filePath = item.fsPath;
        if (filePath.endsWith(".svg") && fs33.existsSync(filePath)) {
          svg = fs33.readFileSync(filePath, "utf-8");
          iconName = path38.basename(filePath, ".svg");
          lineNumber = 1;
        }
      } else if (item instanceof SvgItem) {
        const svgData = workspaceSvgProvider2.getSvgData(item);
        if (svgData) {
          iconName = svgData.name;
          svg = svgData.svg;
          filePath = svgData.location?.file;
          lineNumber = svgData.location?.line;
          isBuilt = item.contextValue === "builtIcon";
          animation = svgData.animation;
        }
      } else if (item) {
        iconName = item.name;
        svg = item.svg;
        filePath = item.filePath || item.path;
        lineNumber = item.line ?? 1;
        isBuilt = item.isBuilt ?? false;
        animation = item.animation;
        if (!svg && item.path && fs33.existsSync(item.path)) {
          try {
            svg = fs33.readFileSync(item.path, "utf-8");
          } catch {
          }
        }
      }
      if (!animation && item && item.icon) {
        animation = item.icon.animation;
      }
      if (iconName && svg) {
        IconDetailsPanel.createOrShow(context.extensionUri, {
          name: iconName,
          svg,
          location: filePath && lineNumber !== void 0 ? { file: filePath, line: lineNumber } : void 0,
          isBuilt,
          animation
        });
        vscode48.commands.executeCommand("sageboxIconStudio.revealInTree", iconName, filePath, lineNumber);
      }
    }
  );
  disposables.push(showDetailsCmd);
  const exportComponentCmd = vscode48.commands.registerCommand(
    "sageboxIconStudio.exportComponent",
    async (item) => {
      if (!item?.icon?.svg) {
        vscode48.window.showWarningMessage(t("messages.selectIconToExport"));
        return;
      }
      const format = await vscode48.window.showQuickPick(
        [
          { label: "React", value: "react" },
          { label: "Vue", value: "vue" },
          { label: "Svelte", value: "svelte" },
          { label: "Angular", value: "angular" },
          { label: "Web Component", value: "webcomponent" }
        ],
        { placeHolder: t("ui.placeholders.selectComponentFormat") }
      );
      if (!format) return;
      const iconName = typeof item.label === "string" ? item.label : "icon";
      const exporter = getComponentExporter();
      const componentCode = exporter.export(iconName);
      const doc = await vscode48.workspace.openTextDocument({
        content: componentCode.code,
        language: format.value === "vue" ? "vue" : format.value === "svelte" ? "svelte" : format.value === "angular" ? "typescript" : "typescriptreact"
      });
      await vscode48.window.showTextDocument(doc);
    }
  );
  disposables.push(exportComponentCmd);
  const updateTreeViewPreviewCmd = vscode48.commands.registerCommand(
    "sageboxIconStudio.updateTreeViewPreview",
    (name, svg, currentColors) => {
      iconPreviewProvider2.updateSvgContent(name, svg, currentColors);
    }
  );
  disposables.push(updateTreeViewPreviewCmd);
  return disposables;
}

// src/commands/spriteCommands.ts
var vscode50 = __toESM(require("vscode"));
var fs35 = __toESM(require("fs"));
var path40 = __toESM(require("path"));
init_i18n();

// src/commands/helpers/spritePreviewHelper.ts
var vscode49 = __toESM(require("vscode"));
var fs34 = __toESM(require("fs"));
var path39 = __toESM(require("path"));
init_IconDetailsPanel();
init_i18n();
var spritePreviewCss = null;
var spritePreviewJs = null;
var spritePreviewHtml = null;
function loadSpritePreviewTemplates() {
  if (!spritePreviewCss || !spritePreviewJs || !spritePreviewHtml) {
    const templatesDir = path39.join(__dirname, "..", "..", "templates", "sprite-preview");
    spritePreviewCss = fs34.readFileSync(path39.join(templatesDir, "SpritePreview.css"), "utf-8");
    spritePreviewJs = fs34.readFileSync(path39.join(templatesDir, "SpritePreview.js"), "utf-8");
    spritePreviewHtml = fs34.readFileSync(path39.join(templatesDir, "SpritePreview.html"), "utf-8");
  }
  return { css: spritePreviewCss, js: spritePreviewJs, html: spritePreviewHtml };
}
function getSpritePreviewHtml(icons, fileName) {
  const templates = loadSpritePreviewTemplates();
  const iconCards = icons.map((icon) => {
    const cleanContent = icon.content.replace(/<style[^>]*>[\s\S]*?<\/style>/gi, "").replace(/<script[^>]*>[\s\S]*?<\/script>/gi, "").replace(/<text[^>]*>[\s\S]*?<\/text>/gi, "").replace(/<title[^>]*>[\s\S]*?<\/title>/gi, "").replace(/<desc[^>]*>[\s\S]*?<\/desc>/gi, "");
    const svg = `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${icon.viewBox}" fill="currentColor">${cleanContent}</svg>`;
    return `
      <div class="icon-card" data-icon-id="${icon.id}" title="${icon.id}">
        <div class="icon-preview">${svg}</div>
        <div class="icon-name">${icon.id}</div>
      </div>
    `;
  }).join("");
  const htmlContent = templates.html.replace(/\$\{fileName\}/g, fileName).replace(/\$\{iconCount\}/g, String(icons.length)).replace(/\$\{iconCards\}/g, iconCards).replace(/\$\{i18n_icons\}/g, t("webview.spritePreview.icons")).replace(/\$\{i18n_openFile\}/g, t("webview.spritePreview.openFile")).replace(/\$\{i18n_refresh\}/g, t("webview.spritePreview.refresh")).replace(/\$\{i18n_copyName\}/g, t("webview.spritePreview.copyName")).replace(/\$\{i18n_copySvg\}/g, t("webview.spritePreview.copySvg")).replace(/\$\{i18n_editIcon\}/g, t("webview.spritePreview.editIcon")).replace(/\$\{i18n_showDetails\}/g, t("webview.spritePreview.showDetails")).replace(/\$\{i18n_exportComponent\}/g, t("webview.spritePreview.exportComponent")).replace(/\$\{i18n_rename\}/g, t("webview.spritePreview.rename")).replace(/\$\{i18n_delete\}/g, t("webview.spritePreview.delete"));
  return `<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>SVG Sprite Preview</title>
  <style>${templates.css}</style>
</head>
<body>
  ${htmlContent}
  <script>${templates.js}</script>
</body>
</html>`;
}
function buildFullSvg(iconData) {
  return `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${iconData.viewBox}" fill="currentColor">${iconData.content}</svg>`;
}
function createPreviewMessageHandler(config) {
  const {
    icons,
    filePath,
    panel,
    extensionUri,
    builtIconsProvider: builtIconsProvider2,
    isSprite,
    parseIconsFromContent
  } = config;
  return async (message) => {
    const iconData = icons.find((i) => i.id === message.iconId);
    if (!iconData && message.command !== "openFile" && message.command !== "refresh") return;
    switch (message.command) {
      case "copyName":
        await vscode49.env.clipboard.writeText(message.iconId);
        vscode49.window.showInformationMessage(t("messages.iconCopied", { name: message.iconId }));
        break;
      case "copySvg":
        await vscode49.env.clipboard.writeText(buildFullSvg(iconData));
        vscode49.window.showInformationMessage(t("messages.svgCopiedToClipboard"));
        break;
      case "editIcon":
        IconEditorPanel.createOrShow(extensionUri, {
          name: message.iconId,
          svg: buildFullSvg(iconData),
          ...isSprite ? { spriteFile: filePath, viewBox: iconData.viewBox } : { iconsFile: filePath, viewBox: iconData.viewBox }
        });
        break;
      case "showDetails":
        IconDetailsPanel.createOrShow(extensionUri, {
          name: message.iconId,
          svg: buildFullSvg(iconData),
          isBuilt: true
        });
        break;
      case "exportComponent":
        try {
          const componentExporter = getComponentExporter();
          const result = componentExporter.export({
            format: "react",
            typescript: true,
            iconName: message.iconId,
            svg: buildFullSvg(iconData)
          });
          const doc = await vscode49.workspace.openTextDocument({
            content: result.code,
            language: "typescriptreact"
          });
          await vscode49.window.showTextDocument(doc, vscode49.ViewColumn.Beside);
        } catch (err) {
          vscode49.window.showErrorMessage(
            t("messages.failedToExportComponent", { error: String(err) })
          );
        }
        break;
      case "renameIcon":
        await handleRenameIcon2(
          message.iconId,
          iconData,
          icons,
          filePath,
          panel,
          builtIconsProvider2,
          isSprite
        );
        break;
      case "openFile": {
        const doc = await vscode49.workspace.openTextDocument(filePath);
        await vscode49.window.showTextDocument(doc);
        break;
      }
      case "deleteIcon":
        await handleDeleteIcon(
          message.iconId,
          icons,
          filePath,
          panel,
          builtIconsProvider2,
          isSprite
        );
        break;
      case "refresh":
        handleRefresh2(icons, filePath, panel, parseIconsFromContent);
        break;
    }
  };
}
async function handleRenameIcon2(iconId, iconData, icons, filePath, panel, builtIconsProvider2, isSprite) {
  const newName = await vscode49.window.showInputBox({
    prompt: t("ui.prompts.enterNewIconName"),
    value: iconId,
    validateInput: (value) => {
      if (!value || value.trim() === "") return t("ui.validation.nameCannotBeEmpty");
      if (!/^[a-zA-Z][a-zA-Z0-9_-]*$/.test(value)) return t("ui.validation.invalidNameFormat");
      return null;
    }
  });
  if (newName && newName !== iconId) {
    let fileContent = fs34.readFileSync(filePath, "utf-8");
    if (isSprite) {
      const oldIdPattern = new RegExp(`id=["']${iconId}["']`, "g");
      fileContent = fileContent.replace(oldIdPattern, `id="${newName}"`);
    } else {
      const namePattern = new RegExp(
        `(export\\s+const\\s+\\w+\\s*=\\s*\\{[\\s\\S]*?name:\\s*['"])${iconId}(['"])`,
        "g"
      );
      fileContent = fileContent.replace(namePattern, `$1${newName}$2`);
      const oldVarName = iconId.replace(/-/g, "_");
      const newVarName = newName.replace(/-/g, "_");
      const varPattern = new RegExp(`export\\s+const\\s+${oldVarName}\\s*=`, "g");
      fileContent = fileContent.replace(varPattern, `export const ${newVarName} =`);
    }
    fs34.writeFileSync(filePath, fileContent, "utf-8");
    iconData.id = newName;
    panel.webview.html = getSpritePreviewHtml(icons, path39.basename(filePath));
    builtIconsProvider2.refresh();
    vscode49.window.showInformationMessage(t("messages.iconRenamedTo", { name: newName }));
  }
}
async function handleDeleteIcon(iconId, icons, filePath, panel, builtIconsProvider2, isSprite) {
  const messageKey = isSprite ? "messages.confirmDeleteIcon" : "messages.confirmDeleteIconFromFile";
  const confirm = await vscode49.window.showWarningMessage(
    t(messageKey, { name: iconId }),
    { modal: true },
    "Delete"
  );
  if (confirm === "Delete") {
    let fileContent = fs34.readFileSync(filePath, "utf-8");
    if (isSprite) {
      const symbolPattern = new RegExp(
        `<symbol[^>]*id=["']${iconId}["'][^>]*>[\\s\\S]*?<\\/symbol>\\s*`,
        "gi"
      );
      fileContent = fileContent.replace(symbolPattern, "");
    } else {
      const varName = iconId.replace(/-/g, "_");
      const iconPat = new RegExp(
        `export\\s+const\\s+${varName}\\s*=\\s*\\{[\\s\\S]*?\\};\\s*`,
        "g"
      );
      fileContent = fileContent.replace(iconPat, "");
    }
    fs34.writeFileSync(filePath, fileContent, "utf-8");
    const index = icons.findIndex((i) => i.id === iconId);
    if (index > -1) icons.splice(index, 1);
    panel.webview.html = getSpritePreviewHtml(icons, path39.basename(filePath));
    builtIconsProvider2.refresh();
    vscode49.window.showInformationMessage(t("messages.iconDeleted", { name: iconId }));
  }
}
function handleRefresh2(icons, filePath, panel, parseIconsFromContent) {
  const newContent = fs34.readFileSync(filePath, "utf-8");
  const newIcons = parseIconsFromContent(newContent);
  icons.length = 0;
  icons.push(...newIcons);
  panel.webview.postMessage({
    command: "refreshComplete",
    icons: icons.map((icon) => {
      const cleanContent = icon.content.replace(/<text[^>]*>[\s\S]*?<\/text>/gi, "").replace(/<title[^>]*>[\s\S]*?<\/title>/gi, "").replace(/<desc[^>]*>[\s\S]*?<\/desc>/gi, "");
      return {
        id: icon.id,
        viewBox: icon.viewBox,
        svg: `<svg xmlns="http://www.w3.org/2000/svg" viewBox="${icon.viewBox}" fill="currentColor">${cleanContent}</svg>`
      };
    }),
    count: icons.length
  });
}
function parseSpriteIcons(content) {
  const symbolRegex = /<symbol[^>]*id=['"]([^'"]+)['"][^>]*viewBox=['"]([^'"]+)['"][^>]*>([\s\S]*?)<\/symbol>/gi;
  const icons = [];
  let match;
  while ((match = symbolRegex.exec(content)) !== null) {
    icons.push({ id: match[1], viewBox: match[2], content: match[3] });
  }
  return icons;
}
function parseIconsJsIcons(content) {
  const iconPattern = /export\s+const\s+(\w+)\s*=\s*\{[\s\S]*?name:\s*['"]([^'"]+)['"][\s\S]*?body:\s*`([^`]*)`[\s\S]*?viewBox:\s*['"]([^'"]+)['"][\s\S]*?\};/g;
  const icons = [];
  let match;
  while ((match = iconPattern.exec(content)) !== null) {
    icons.push({ id: match[2], viewBox: match[4], content: match[3] });
  }
  return icons;
}

// src/commands/spriteCommands.ts
function registerSpriteCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2 } = providers;
  const disposables = [];
  const generateSpriteCmd = vscode50.commands.registerCommand(
    "sageboxIconStudio.generateSprite",
    async () => {
      const icons = await workspaceSvgProvider2.getAllIcons();
      if (icons.length === 0) {
        vscode50.window.showWarningMessage(t("messages.noIconsInLibrary"));
        return;
      }
      const formatChoice = await vscode50.window.showQuickPick(
        [
          { label: t("ui.labels.svgSprite"), value: "svg" },
          { label: t("ui.labels.webComponentJs"), value: "css" },
          { label: t("ui.labels.both"), value: "both" }
        ],
        { placeHolder: t("ui.placeholders.selectSpriteFormat") }
      );
      if (!formatChoice) return;
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;
      const config = getConfig();
      const webComponentName = config.webComponentName;
      const spriteIcons = [];
      for (const icon of icons) {
        let svgContent = icon.svg;
        if (!svgContent && icon.path && fs35.existsSync(icon.path) && icon.path.toLowerCase().endsWith(".svg")) {
          try {
            svgContent = fs35.readFileSync(icon.path, "utf-8");
          } catch (readError) {
            console.error(`Failed to read SVG for ${icon.name}`, readError);
          }
        }
        if (svgContent) {
          spriteIcons.push({
            id: icon.name,
            name: icon.name,
            svg: svgContent,
            viewBox: void 0
          });
        }
      }
      const generator = getSpriteGenerator();
      if (formatChoice.value === "svg" || formatChoice.value === "both") {
        const result = generator.generate(spriteIcons, { outputPath });
        fs35.writeFileSync(path40.join(outputPath, "sprite.svg"), result.sprite);
      }
      if (formatChoice.value === "css" || formatChoice.value === "both") {
        const result = generator.generate(spriteIcons, {
          outputPath,
          generateHelper: true,
          helperFormat: "vanilla",
          webComponentName
        });
        if (result.helperComponent) {
          fs35.writeFileSync(path40.join(outputPath, "icons.js"), result.helperComponent);
        }
      }
      vscode50.window.showInformationMessage(t("messages.spriteGenerated", { path: outputPath }));
    }
  );
  disposables.push(generateSpriteCmd);
  const viewSpriteCmd = vscode50.commands.registerCommand(
    "sageboxIconStudio.viewSprite",
    async (itemOrUri) => {
      let spritePath;
      if (itemOrUri instanceof vscode50.Uri) {
        spritePath = itemOrUri.fsPath;
      } else if (itemOrUri && "category" in itemOrUri && itemOrUri.category?.startsWith("built:")) {
        const fileName = itemOrUri.category.replace("built:", "");
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        spritePath = path40.join(outputPath, fileName);
      } else {
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        spritePath = path40.join(outputPath, "sprite.svg");
      }
      if (!fs35.existsSync(spritePath)) {
        vscode50.window.showWarningMessage(t("messages.spriteNotFound"));
        return;
      }
      const content = fs35.readFileSync(spritePath, "utf-8");
      const icons = parseSpriteIcons(content);
      if (icons.length === 0) {
        vscode50.window.showWarningMessage(t("messages.noIconsInSprite"));
        return;
      }
      const panel = vscode50.window.createWebviewPanel(
        "spritePreview",
        "SVG Sprite",
        vscode50.ViewColumn.One,
        { enableScripts: true }
      );
      panel.webview.html = getSpritePreviewHtml(icons, path40.basename(spritePath));
      panel.webview.onDidReceiveMessage(
        createPreviewMessageHandler({
          icons,
          filePath: spritePath,
          panel,
          extensionUri: context.extensionUri,
          builtIconsProvider: builtIconsProvider2,
          isSprite: true,
          parseIconsFromContent: parseSpriteIcons
        })
      );
    }
  );
  disposables.push(viewSpriteCmd);
  const cleanSpriteCmd = vscode50.commands.registerCommand("sageboxIconStudio.cleanSprite", async () => {
    const outputPath = getOutputPathOrWarn();
    if (!outputPath) return;
    const result = cleanSpriteSvg(outputPath);
    if (result.removed.length === 0) {
      vscode50.window.showInformationMessage(t("messages.spriteClean"));
    } else {
      vscode50.window.showInformationMessage(
        t("messages.spriteCleanedCount", { removed: result.removed.length, kept: result.kept })
      );
      builtIconsProvider2.refresh();
    }
  });
  disposables.push(cleanSpriteCmd);
  const viewIconsFileCmd = vscode50.commands.registerCommand(
    "sageboxIconStudio.viewIconsFile",
    async (item) => {
      let iconsFilePath;
      if (item?.category?.startsWith("built:")) {
        const fileName = item.category.replace("built:", "");
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        iconsFilePath = path40.join(outputPath, fileName);
      } else {
        const outputPath = getOutputPathOrWarn();
        if (!outputPath) return;
        for (const name of ["icons.js", "icons.ts"]) {
          const filePath = path40.join(outputPath, name);
          if (fs35.existsSync(filePath)) {
            iconsFilePath = filePath;
            break;
          }
        }
        if (!iconsFilePath) {
          vscode50.window.showWarningMessage(t("messages.noIconsFile"));
          return;
        }
      }
      if (!fs35.existsSync(iconsFilePath)) {
        vscode50.window.showWarningMessage(t("messages.iconsFileNotFound"));
        return;
      }
      const content = fs35.readFileSync(iconsFilePath, "utf-8");
      const icons = parseIconsJsIcons(content);
      if (icons.length === 0) {
        vscode50.window.showWarningMessage(t("messages.noIconsInFile"));
        return;
      }
      const panel = vscode50.window.createWebviewPanel(
        "iconsFilePreview",
        "Icons File",
        vscode50.ViewColumn.One,
        { enableScripts: true }
      );
      panel.webview.html = getSpritePreviewHtml(icons, path40.basename(iconsFilePath));
      panel.webview.onDidReceiveMessage(
        createPreviewMessageHandler({
          icons,
          filePath: iconsFilePath,
          panel,
          extensionUri: context.extensionUri,
          builtIconsProvider: builtIconsProvider2,
          isSprite: false,
          parseIconsFromContent: parseIconsJsIcons
        })
      );
    }
  );
  disposables.push(viewIconsFileCmd);
  const deleteBuiltFileCmd = vscode50.commands.registerCommand(
    "sageboxIconStudio.deleteBuiltFile",
    async (item) => {
      if (!item?.category?.startsWith("built:")) {
        vscode50.window.showWarningMessage(t("messages.noFileSelected"));
        return;
      }
      const fileName = item.category.replace("built:", "");
      const outputPath = getOutputPathOrWarn();
      if (!outputPath) return;
      const filePath = path40.join(outputPath, fileName);
      if (!fs35.existsSync(filePath)) {
        vscode50.window.showWarningMessage(t("messages.fileNotFound", { name: fileName }));
        return;
      }
      const confirm = await vscode50.window.showWarningMessage(
        t("messages.confirmDeleteFile", { name: fileName }),
        { modal: true },
        "Delete"
      );
      if (confirm === "Delete") {
        try {
          fs35.unlinkSync(filePath);
          builtIconsProvider2.refresh();
          vscode50.window.showInformationMessage(t("messages.fileDeleted", { name: fileName }));
        } catch (error) {
          vscode50.window.showErrorMessage(
            t("messages.failedToDeleteFile", { error: String(error) })
          );
        }
      }
    }
  );
  disposables.push(deleteBuiltFileCmd);
  return disposables;
}

// src/commands/miscCommands.ts
var vscode53 = __toESM(require("vscode"));
var path43 = __toESM(require("path"));
var fs37 = __toESM(require("fs"));

// src/utils/iconBuildHelpers.ts
var vscode51 = __toESM(require("vscode"));
var path41 = __toESM(require("path"));
init_i18n();
async function buildIcon(options) {
  const { iconName, svgContent, svgTransformer, outputPath: customPath } = options;
  const outputPath = customPath || getOutputPathOrWarn();
  if (!outputPath) {
    return {
      success: false,
      iconName,
      outputPath: "",
      format: "icons",
      error: "No output path configured"
    };
  }
  const config = getConfig();
  const isSprite = config.buildFormat === "sprite.svg";
  try {
    if (isSprite) {
      await addToSpriteSvg(outputPath, iconName, svgContent, svgTransformer);
    } else {
      await addToIconsJs({
        outputPath,
        iconName,
        svgContent,
        transformer: svgTransformer
      });
    }
    return {
      success: true,
      iconName,
      outputPath,
      format: isSprite ? "sprite" : "icons"
    };
  } catch (error) {
    return {
      success: false,
      iconName,
      outputPath,
      format: isSprite ? "sprite" : "icons",
      error: error.message
    };
  }
}
async function showDeleteOriginalPrompt(options) {
  const config = getConfig();
  const isSprite = config.buildFormat === "sprite.svg";
  const defaultDelete = vscode51.workspace.getConfiguration("iconStudio").get("deleteAfterBuild", false);
  const choice = await vscode51.window.showQuickPick(
    [
      {
        label: `$(trash) ${t("editor.deleteOriginalSvg")}`,
        description: t("editor.deleteOriginalSvgDesc"),
        value: true
      },
      {
        label: `$(file) ${t("editor.keepOriginalSvg")}`,
        description: t("editor.keepOriginalSvgDesc"),
        value: false
      }
    ],
    {
      placeHolder: t("editor.whatToDoWithOriginal"),
      title: options?.title || `${t("editor.addTo")} ${isSprite ? "Sprite" : t("editor.iconsLibrary")}`
    }
  );
  return choice?.value ?? options?.defaultValue ?? defaultDelete;
}
function generateReplacement(iconName, languageId) {
  const config = getConfig();
  const isSprite = config.buildFormat === "sprite.svg";
  const componentName = config.webComponentName || "sg-icon";
  if (isSprite) {
    return `<svg class="icon" aria-hidden="true"><use href="sprite.svg#${iconName}"></use></svg>`;
  }
  if (["javascriptreact", "typescriptreact", "vue", "svelte", "astro"].includes(languageId)) {
    return `<${componentName} name="${iconName}" />`;
  }
  return `<${componentName} name="${iconName}"></${componentName}>`;
}
async function checkScriptImport(document, documentUri) {
  const config = getConfig();
  const isSprite = config.buildFormat === "sprite.svg";
  if (isSprite) return;
  const ext = path41.extname(documentUri).slice(1).toLowerCase();
  if (!["html", "htm"].includes(ext)) return;
  const fullText = document.getText();
  const hasIconScript = fullText.includes("icon.js") || fullText.includes("icons.js");
  if (!hasIconScript) {
    const outputDir = config.outputDirectory || "icon-studio-icons";
    const addScript = await vscode51.window.showWarningMessage(
      `\u26A0\uFE0F ${t("messages.missingScriptImport", { outputDir })}`,
      t("messages.copyToClipboard"),
      t("messages.dismiss")
    );
    if (addScript === t("messages.copyToClipboard")) {
      const scriptTag = `<script type="module" src="./${outputDir}/icon.js"></script>`;
      await vscode51.env.clipboard.writeText(scriptTag);
      vscode51.window.showInformationMessage(t("messages.scriptCopiedToClipboard"));
    }
  }
}
function showBuildSuccess(result, extras) {
  const formatName = result.format === "sprite" ? "sprite" : t("editor.iconsLibrary");
  const targets = extras ? [formatName, ...extras].join(" & ") : formatName;
  vscode51.window.showInformationMessage(
    t("messages.iconImported", { name: result.iconName, targets })
  );
}

// src/commands/miscCommands.ts
init_i18n();

// src/commands/importCommands.ts
var vscode52 = __toESM(require("vscode"));
var path42 = __toESM(require("path"));
var fs36 = __toESM(require("fs"));
init_i18n();
function registerImportCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2, svgFilesProvider: svgFilesProvider2, svgTransformer } = providers;
  const importSvgToLibraryCmd = vscode52.commands.registerCommand(
    "sageboxIconStudio.importSvgToLibrary",
    async (item) => {
      let svgPath;
      let svgContent;
      let iconName;
      if (item?.resourceUri) {
        svgPath = item.resourceUri.fsPath;
        svgContent = fs36.readFileSync(svgPath, "utf-8");
        iconName = path42.basename(svgPath, ".svg");
      } else {
        const files = await vscode52.window.showOpenDialog({
          canSelectFiles: true,
          canSelectMany: false,
          filters: { "SVG Files": ["svg"] }
        });
        if (!files || files.length === 0) return;
        svgPath = files[0].fsPath;
        svgContent = fs36.readFileSync(svgPath, "utf-8");
        iconName = path42.basename(svgPath, ".svg");
      }
      if (!svgContent) return;
      const result = await buildIcon({
        iconName,
        svgContent,
        svgTransformer
      });
      if (result.success) {
        workspaceSvgProvider2.refresh();
        builtIconsProvider2.refresh();
        showBuildSuccess(result);
      } else {
        vscode52.window.showErrorMessage(
          t("messages.failedToImportIcon", { error: result.error || "" })
        );
      }
    }
  );
  const checkAndImportSvgCmd = vscode52.commands.registerCommand(
    "sageboxIconStudio.checkAndImportSvg",
    async () => {
      const editor = vscode52.window.activeTextEditor;
      if (!editor) return;
      const text = editor.document.getText();
      const svgRegex = /<svg[^>]*>[\s\S]*?<\/svg>/gi;
      const matches = [...text.matchAll(svgRegex)];
      if (matches.length === 0) {
        vscode52.window.showInformationMessage(t("messages.noInlineSvgsFound"));
        return;
      }
      const items = matches.map((match, index) => ({
        label: `SVG #${index + 1}`,
        description: match[0].substring(0, 50) + "...",
        svgContent: match[0],
        index: match.index
      }));
      const selected = await vscode52.window.showQuickPick(items, {
        placeHolder: t("editor.selectSvgToImport")
      });
      if (!selected) return;
      const iconName = await vscode52.window.showInputBox({
        prompt: t("editor.enterIconName"),
        placeHolder: t("ui.placeholders.iconName")
      });
      if (!iconName) return;
      const result = await buildIcon({
        iconName,
        svgContent: selected.svgContent,
        svgTransformer
      });
      if (result.success) {
        workspaceSvgProvider2.refresh();
        builtIconsProvider2.refresh();
        showBuildSuccess(result);
      } else {
        vscode52.window.showErrorMessage(
          t("messages.failedToImportIcon", { error: result.error || "" })
        );
      }
    }
  );
  const addSvgToCollectionCmd = vscode52.commands.registerCommand(
    "sageboxIconStudio.addSvgToCollection",
    async (item) => {
      const icon = item?.icon;
      if (!icon) {
        vscode52.window.showWarningMessage(t("messages.noIconSelected"));
        return;
      }
      const deleteOriginal = await showDeleteOriginalPrompt();
      try {
        let svgContent = icon.svg;
        if (!svgContent && icon.path) {
          svgContent = fs36.readFileSync(icon.path, "utf-8");
        }
        if (!svgContent) {
          vscode52.window.showErrorMessage(t("messages.couldNotReadSvg"));
          return;
        }
        const result = await buildIcon({ iconName: icon.name, svgContent, svgTransformer });
        if (!result.success) {
          vscode52.window.showErrorMessage(
            t("messages.failedToAddIcon", { error: result.error || "" })
          );
          return;
        }
        const extras = [];
        if (deleteOriginal && icon.path && fs36.existsSync(icon.path)) {
          fs36.unlinkSync(icon.path);
          extras.push("original deleted");
          svgFilesProvider2.removeItem(icon.path);
        }
        const outputPath = getFullOutputPath();
        const builtIcon = {
          name: icon.name,
          svg: svgContent,
          path: outputPath || icon.path,
          source: "library",
          isBuilt: true
        };
        workspaceSvgProvider2.addBuiltIcon(icon.name, builtIcon);
        builtIconsProvider2.refreshFile(path42.basename(builtIcon.path));
        if (!deleteOriginal) {
          svgFilesProvider2.refreshFile(icon.path);
        }
        vscode52.window.showInformationMessage(
          t("messages.iconImported", {
            name: icon.name,
            targets: result.format === "sprite" ? "sprite.svg" : "icons.js"
          })
        );
      } catch (error) {
        vscode52.window.showErrorMessage(t("messages.failedToAddIcon", { error: error.message }));
      }
    }
  );
  return [importSvgToLibraryCmd, checkAndImportSvgCmd, addSvgToCollectionCmd];
}

// src/commands/miscCommands.ts
function registerMiscCommands(context, providers) {
  const { workspaceSvgProvider: workspaceSvgProvider2, builtIconsProvider: builtIconsProvider2, svgTransformer } = providers;
  const transformSvgReferenceCmd = vscode53.commands.registerCommand(
    "sageboxIconStudio.transformSvgReference",
    async (options) => {
      const {
        originalPath,
        iconName,
        documentUri,
        line,
        originalHtml,
        isInlineSvg,
        svgContent: inlineSvgContent
      } = options;
      const docDir = path43.dirname(documentUri);
      const config = getConfig();
      const isSprite = config.buildFormat === "sprite.svg";
      const componentName = config.webComponentName || "sg-icon";
      const menuOptions = [
        {
          label: `$(cloud-download) ${t("ui.labels.searchInIconify")}`,
          description: t("ui.labels.findBuildIconify"),
          value: "iconify"
        }
      ];
      if (isInlineSvg) {
        menuOptions.push({
          label: `$(file-code) ${t("ui.labels.useInlineSvg") || "Use this inline SVG"}`,
          description: t("ui.labels.extractAndBuild") || "Extract and build as icon",
          value: "current"
        });
      } else {
        const fullSvgPath = path43.isAbsolute(originalPath) ? originalPath : path43.resolve(docDir, originalPath);
        const fileExists = fs37.existsSync(fullSvgPath);
        if (fileExists) {
          menuOptions.push({
            label: `$(file-media) ${t("ui.labels.useReferencedSvg")}`,
            description: `Build from: ${originalPath}`,
            value: "current"
          });
        } else {
          menuOptions.push({
            label: `$(warning) ${t("ui.labels.useReferencedSvg")}`,
            description: `\u26A0\uFE0F ${t("messages.fileNotFound", { path: originalPath }) || `File not found: ${originalPath}`}`,
            value: "file_not_found"
          });
        }
      }
      menuOptions.push({
        label: `$(library) ${t("ui.labels.browseBuiltIcons")}`,
        description: t("ui.labels.selectIconFromLibrary"),
        value: "built"
      });
      const sourceChoice = await vscode53.window.showQuickPick(menuOptions, {
        placeHolder: `Transform to ${isSprite ? "SVG Sprite" : "Web Component"} - Select icon source`,
        title: `\u{1F504} Transform: ${iconName}`
      });
      if (!sourceChoice) return;
      if (sourceChoice.value === "file_not_found") {
        vscode53.window.showWarningMessage(
          t("messages.svgFileNotFoundSuggestion", { path: originalPath }) || `File "${originalPath}" not found. Try "Search in Iconify" or "Browse built icons" instead.`
        );
        return;
      }
      let svgContent;
      let finalIconName = iconName;
      let skipBuild = false;
      if (sourceChoice.value === "iconify") {
        const query = await vscode53.window.showInputBox({
          prompt: t("ui.prompts.searchIconify"),
          value: iconName,
          placeHolder: t("ui.placeholders.enterSearchTerm")
        });
        if (!query) return;
        const results = await searchIconify(query);
        if (results.length === 0) {
          vscode53.window.showInformationMessage(t("messages.noIconsFoundForQuery", { query }));
          return;
        }
        const selectedIcon = await showIconifyReplacementPicker(context, results, query, iconName);
        if (!selectedIcon) return;
        svgContent = selectedIcon.svg;
        finalIconName = `${selectedIcon.prefix}-${selectedIcon.name}`;
        const resolvedName = await handleDuplicateIconName(finalIconName, workspaceSvgProvider2);
        if (!resolvedName) return;
        finalIconName = resolvedName;
      } else if (sourceChoice.value === "current") {
        if (isInlineSvg && inlineSvgContent) {
          svgContent = inlineSvgContent;
          const newName = await vscode53.window.showInputBox({
            prompt: t("ui.prompts.enterIconName") || "Enter a name for this icon",
            value: finalIconName,
            placeHolder: t("ui.placeholders.iconName") || "icon-name"
          });
          if (!newName) return;
          finalIconName = newName;
        } else {
          const fullSvgPath = path43.isAbsolute(originalPath) ? originalPath : path43.resolve(docDir, originalPath);
          if (!fs37.existsSync(fullSvgPath)) {
            vscode53.window.showErrorMessage(t("messages.svgFileNotFound", { path: originalPath }));
            return;
          }
          svgContent = fs37.readFileSync(fullSvgPath, "utf-8");
          const resolvedName = await handleDuplicateIconName(finalIconName, workspaceSvgProvider2);
          if (!resolvedName) return;
          finalIconName = resolvedName;
          const deleteOriginal = await showDeleteOriginalPrompt();
          if (deleteOriginal) {
            try {
              fs37.unlinkSync(fullSvgPath);
            } catch (deleteError) {
              console.error("Failed to delete:", deleteError);
            }
          }
        }
      } else if (sourceChoice.value === "built") {
        await builtIconsProvider2.ensureReady();
        const builtIcons = builtIconsProvider2.getBuiltIconsList();
        if (builtIcons.length === 0) {
          vscode53.window.showWarningMessage(t("messages.noBuiltIconsFound"));
          return;
        }
        const items = builtIcons.map((icon) => ({
          label: icon.name,
          description: icon.animation ? `\u{1F3AC} ${icon.animation.type}` : "",
          icon
        }));
        const selected = await vscode53.window.showQuickPick(items, {
          placeHolder: t("ui.placeholders.selectBuiltIcon"),
          matchOnDescription: true
        });
        if (!selected) return;
        finalIconName = selected.label;
        skipBuild = true;
      }
      if (!svgContent && !skipBuild) return;
      if (!skipBuild) {
        const result = await buildIcon({
          iconName: finalIconName,
          svgContent,
          svgTransformer
        });
        if (!result.success) {
          vscode53.window.showErrorMessage(
            t("messages.failedToBuildIcon", { error: result.error || "" })
          );
          return;
        }
        const config2 = getConfig();
        const outputPath = config2.outputDirectory || "src/icons";
        const builtIcon = {
          name: finalIconName,
          svg: svgContent,
          path: outputPath,
          source: "library",
          category: "built",
          isBuilt: true
        };
        workspaceSvgProvider2.addBuiltIcon(finalIconName, builtIcon);
      }
      try {
        const document = await vscode53.workspace.openTextDocument(documentUri);
        const replacement = generateReplacement(finalIconName, document.languageId);
        const edit = new vscode53.WorkspaceEdit();
        if (isInlineSvg && options.startOffset !== void 0 && options.endOffset !== void 0) {
          const startPos = document.positionAt(options.startOffset);
          const endPos = document.positionAt(options.endOffset);
          edit.replace(document.uri, new vscode53.Range(startPos, endPos), replacement);
        } else {
          const lineText = document.lineAt(line).text;
          const newText = lineText.replace(originalHtml, replacement);
          if (newText !== lineText) {
            edit.replace(document.uri, new vscode53.Range(line, 0, line, lineText.length), newText);
          }
        }
        await vscode53.workspace.applyEdit(edit);
        await checkScriptImport(document, documentUri);
      } catch (replaceError) {
        console.error("Failed to replace in document:", replaceError);
      }
      workspaceSvgProvider2.softRefresh();
      builtIconsProvider2.refresh();
      vscode53.window.showInformationMessage(
        t("messages.iconTransformed", { name: finalIconName, component: componentName })
      );
    }
  );
  return [transformSvgReferenceCmd];
}

// src/extension.ts
var SUPPORTED_LANGUAGES = [
  { language: "javascript" },
  { language: "typescript" },
  { language: "javascriptreact" },
  { language: "typescriptreact" },
  { language: "vue" },
  { language: "svelte" },
  { language: "html" }
];
var SUPPORTED_LANGUAGES_WITH_SCHEME = [
  { language: "javascript", scheme: "*" },
  { language: "typescript", scheme: "*" },
  { language: "javascriptreact", scheme: "*" },
  { language: "typescriptreact", scheme: "*" },
  { language: "vue", scheme: "*" },
  { language: "svelte", scheme: "*" },
  { language: "html", scheme: "*" }
];
var workspaceSvgProvider;
var builtIconsProvider;
var svgFilesProvider;
var iconPreviewProvider;
var workspaceTreeView;
var svgFilesTreeView;
var svgWatcher;
async function showOnboardingWizard(context) {
  const config = vscode54.workspace.getConfiguration("sageboxIconStudio");
  const outputDir = config.get("outputDirectory", "");
  if (outputDir) {
    return;
  }
  const workspaceFolder = vscode54.workspace.workspaceFolders?.[0];
  if (!workspaceFolder) {
    return;
  }
  WelcomePanel.createOrShow(context.extensionUri);
}
function activate(context) {
  showOnboardingWizard(context);
  initIgnoreFileWatcher(context);
  updateIconsJsContext();
  const svgTransformer = new SvgTransformer();
  workspaceSvgProvider = new WorkspaceSvgProvider(context);
  svgFilesProvider = new SvgFilesProvider(workspaceSvgProvider);
  svgFilesTreeView = vscode54.window.createTreeView("sageboxIconStudio.svgFiles", {
    treeDataProvider: svgFilesProvider,
    showCollapseAll: false
  });
  context.subscriptions.push(svgFilesTreeView);
  svgFilesTreeView.onDidChangeSelection((e) => {
    if (e.selection.length > 0) {
      const item = e.selection[0];
      if (item.icon) {
        const svgData = workspaceSvgProvider.getSvgData(item);
        if (svgData) {
          iconPreviewProvider.updatePreview(
            svgData.name,
            svgData.svg,
            svgData.location,
            false,
            svgData.animation
          );
        }
      }
    }
  });
  builtIconsProvider = new BuiltIconsProvider(workspaceSvgProvider);
  const builtIconsTreeView = vscode54.window.createTreeView("sageboxIconStudio.builtIcons", {
    treeDataProvider: builtIconsProvider,
    showCollapseAll: false,
    canSelectMany: true
  });
  context.subscriptions.push(builtIconsTreeView);
  svgFilesProvider.setBuiltIconsProvider(builtIconsProvider);
  builtIconsTreeView.onDidChangeSelection((e) => {
    if (e.selection.length > 0) {
      const item = e.selection[0];
      if (item.icon) {
        const svgData = workspaceSvgProvider.getSvgData(item);
        if (svgData) {
          iconPreviewProvider.updatePreview(
            svgData.name,
            svgData.svg,
            svgData.location,
            true,
            // isBuilt
            svgData.animation
          );
        }
      }
    }
  });
  iconPreviewProvider = new IconPreviewProvider(context.extensionUri);
  context.subscriptions.push(
    vscode54.window.registerWebviewViewProvider(IconPreviewProvider.viewType, iconPreviewProvider)
  );
  const treeView = vscode54.window.createTreeView("sageboxIconStudio.workspaceIcons", {
    treeDataProvider: workspaceSvgProvider,
    showCollapseAll: false,
    canSelectMany: true
  });
  workspaceTreeView = treeView;
  const treeViewCommands = registerTreeViewCommands(
    context,
    {
      workspace: treeView,
      builtIcons: builtIconsTreeView,
      svgFiles: svgFilesTreeView
    },
    {
      workspaceSvgProvider,
      builtIconsProvider,
      svgFilesProvider
    }
  );
  context.subscriptions.push(...treeViewCommands);
  treeView.onDidChangeSelection((e) => {
    if (e.selection.length > 0) {
      const item = e.selection[0];
      if (item.contextValue === "inlineSvg" || item.contextValue === "builtIcon" || item.contextValue === "svgIcon") {
        const svgData = workspaceSvgProvider.getSvgData(item);
        if (svgData) {
          iconPreviewProvider.updatePreview(
            svgData.name,
            svgData.svg,
            svgData.location,
            item.contextValue === "builtIcon",
            svgData.animation
          );
        }
      }
    }
  });
  context.subscriptions.push(treeView);
  const navigationCommands = registerNavigationCommands(context);
  context.subscriptions.push(...navigationCommands);
  const referenceCommands = registerReferenceCommands(context, { workspaceSvgProvider, workspaceTreeView });
  context.subscriptions.push(...referenceCommands);
  const panelCommands = registerPanelCommands(context, workspaceSvgProvider);
  context.subscriptions.push(...panelCommands);
  const configCommands = registerConfigCommands(context);
  context.subscriptions.push(...configCommands);
  const iconCommands = registerIconCommands(context, {
    workspaceSvgProvider,
    builtIconsProvider,
    svgFilesProvider
  });
  context.subscriptions.push(...iconCommands);
  const transformCommands = registerTransformCommands(
    context,
    { workspaceSvgProvider, builtIconsProvider },
    svgTransformer
  );
  context.subscriptions.push(...transformCommands);
  const refreshCommands = registerRefreshCommands({
    workspaceSvgProvider,
    builtIconsProvider,
    svgFilesProvider
  });
  context.subscriptions.push(...refreshCommands);
  const buildCommands = registerBuildCommands(
    context,
    {
      workspaceSvgProvider,
      builtIconsProvider,
      svgFilesProvider
    },
    svgTransformer
  );
  context.subscriptions.push(...buildCommands);
  registerIconifyCommands(context, {
    workspaceSvgProvider,
    builtIconsProvider,
    svgTransformer
  });
  const editorCommands = registerEditorCommands(context, {
    workspaceSvgProvider,
    iconPreviewProvider
  });
  context.subscriptions.push(...editorCommands);
  const spriteCommands = registerSpriteCommands(context, {
    workspaceSvgProvider,
    builtIconsProvider
  });
  context.subscriptions.push(...spriteCommands);
  const miscCommands = registerMiscCommands(context, {
    workspaceSvgProvider,
    builtIconsProvider,
    svgFilesProvider,
    svgTransformer,
    workspaceTreeView
  });
  context.subscriptions.push(...miscCommands);
  const importCommands = registerImportCommands(context, {
    workspaceSvgProvider,
    builtIconsProvider,
    svgFilesProvider,
    svgTransformer
  });
  context.subscriptions.push(...importCommands);
  const licenseCommands = registerLicenseCommands(context);
  context.subscriptions.push(...licenseCommands);
  const completionDisposable = vscode54.languages.registerCompletionItemProvider(
    SUPPORTED_LANGUAGES,
    new IconCompletionProvider(workspaceSvgProvider),
    "<",
    '"',
    "'"
  );
  const hoverDisposable = vscode54.languages.registerHoverProvider(
    SUPPORTED_LANGUAGES,
    new IconHoverProvider(workspaceSvgProvider)
  );
  svgWatcher = vscode54.workspace.createFileSystemWatcher("**/*.svg");
  svgWatcher.onDidCreate(() => svgFilesProvider.refresh());
  svgWatcher.onDidDelete(() => svgFilesProvider.refresh());
  svgWatcher.onDidChange(() => svgFilesProvider.refresh());
  const codeActionProvider = vscode54.languages.registerCodeActionsProvider(
    SUPPORTED_LANGUAGES_WITH_SCHEME,
    new SvgToIconCodeActionProvider(),
    {
      providedCodeActionKinds: SvgToIconCodeActionProvider.providedCodeActionKinds
    }
  );
  const missingIconCodeActionProvider = vscode54.languages.registerCodeActionsProvider(
    SUPPORTED_LANGUAGES,
    new MissingIconCodeActionProvider(workspaceSvgProvider),
    {
      providedCodeActionKinds: MissingIconCodeActionProvider.providedCodeActionKinds
    }
  );
  const diagnosticProvider = new SvgImgDiagnosticProvider();
  vscode54.workspace.onDidChangeTextDocument((e) => {
    diagnosticProvider.updateDiagnostics(e.document);
  });
  vscode54.workspace.onDidOpenTextDocument((doc) => {
    diagnosticProvider.updateDiagnostics(doc);
  });
  vscode54.window.visibleTextEditors.forEach((editor) => {
    diagnosticProvider.updateDiagnostics(editor.document);
  });
  context.subscriptions.push(
    // openPanelCmd, openWelcomeCmd, scanWorkspaceCmd, scanUsagesCmd
    // -> Now registered via registerPanelCommands
    // goToUsageCmd, goToInlineSvgCmd, goToCodeCmd, copyIconNameCmd
    // -> Now registered via registerNavigationCommands
    // configureProjectCmd, editIgnoreFileCmd
    // -> Now registered via registerConfigCommands
    // deleteIconsCmd, removeFromBuiltCmd, renameIconCmd
    // -> Now registered via registerIconCommands
    // transformInlineSvgCmd, transformSvgCmd, optimizeSvgCmd, insertIconCmd
    // -> Now registered via registerTransformCommands
    // refreshIconsCmd, buildAllReferencesCmd, buildAllFilesCmd, refreshFilesCmd,
    // refreshCodeCmd, refreshBuiltCmd, refreshSvgFileCmd, buildIconsCmd
    // -> Now registered via registerRefreshCommands and registerBuildCommands
    // previewIconCmd, colorEditorCmd, showDetailsCmd, exportComponentCmd
    // -> Now registered via registerEditorCommands
    // generateSpriteCmd, viewSpriteCmd, viewIconsFileCmd, deleteBuiltFileCmd, cleanSpriteCmd
    // -> Now registered via registerSpriteCommands
    // searchIconsCmd, searchIconifyCmd, importIconCmd
    // -> Now registered via registerIconifyCommands
    // importSvgToLibraryCmd, checkAndImportSvgCmd, transformSvgReferenceCmd,
    // addSvgToCollectionCmd, removeReferenceCmd, findAndReplaceCmd, revealInTreeCmd
    // -> Now registered via registerMiscCommands
    completionDisposable,
    hoverDisposable,
    svgWatcher,
    codeActionProvider,
    missingIconCodeActionProvider
    // expandAllCmd, expandBuiltCmd, collapseAllCmd, collapseBuiltCmd,
    // expandSvgFilesCmd, collapseSvgFilesCmd
    // -> Now registered via registerTreeViewCommands
  );
}
function deactivate() {
  if (svgWatcher) {
    svgWatcher.dispose();
    svgWatcher = void 0;
  }
  getAnimationService().resetCache();
  workspaceSvgProvider = void 0;
  builtIconsProvider = void 0;
  svgFilesProvider = void 0;
  iconPreviewProvider = void 0;
  workspaceTreeView = void 0;
  svgFilesTreeView = void 0;
}
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  activate,
  deactivate
});
//# sourceMappingURL=extension.js.map
